prompt,response,reasoning_content,api_usage
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_12_3
法律的最小可执行单元内容: {""subject"": ""上市公司控股股东 | 实际控制人 | 一致行动人"", ""condition"": ""计划通过集中竞价交易或大宗交易减持股份且首次披露减持计划, 且不存在已经按照本指引第四条披露减持计划，或者中国证监会另有规定的情况的"", ""constraint"": ""不得存在下列情形：上市公司最近一期经审计的财务报告的归属于上市公司股东的净利润为负"", ""contextual_info"": NaN}
必要的额外信息: 不考虑中国证监会另有规定的情况


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_12_3(df):
    '''
    检查MEU_12_3合规性：
    subject: 上市公司控股股东 | 实际控制人 | 一致行动人
    condition: 计划通过集中竞价或大宗交易减持股份且首次披露减持计划
    constraint: 最近一期经审计净利润不得为负
    '''
    df = df.copy()

    # 初始化标记列
    df['meu_12_3_subject'] = False
    df['meu_12_3_condition'] = False
    df['meu_12_3_constraint'] = None

    # 1. 标记valid的subject
    # 处理控股股东和实际控制人（数据中无一致行动人字段）
    valid_subject = df['股东身份'].isin(['控股股东', '实际控制人'])
    df.loc[valid_subject, 'meu_12_3_subject'] = True

    # 2. 标记valid的condition
    # 按公司和股东分组处理首次披露
    df_sorted = df.sort_values(['公司简称', '股东', '日期'])
    grouped = df_sorted.groupby(['公司简称', '股东'])
    # 计算历史减持计划累计次数（不含当前行）
    df_sorted['prev_plan_count'] = grouped['存在减持计划'].cumsum() - df_sorted['存在减持计划']
    df = df_sorted.sort_index()

    # 条件验证
    valid_condition = (
        df['减持方式'].isin(['竞价交易', '大宗交易']) &  # 交易方式验证
        df['存在减持计划'] &  # 存在减持计划
        (df['prev_plan_count'] == 0)  # 首次披露验证
    )
    df.loc[valid_condition, 'meu_12_3_condition'] = True

    # 3. 标记valid的constraint（独立检查）
    # 净利润>=0时满足约束
    df['meu_12_3_constraint'] = df['净利润'] >= 0

    # 清理临时列
    df.drop('prev_plan_count', axis=1, inplace=True, errors='ignore')

    return df
</CODE>","好的，我现在需要处理这个MEU_12_3的合规性检查。首先，我得仔细理解这个MEU的内容。MEU的subject是上市公司控股股东、实际控制人或其一致行动人。condition是计划通过集中竞价或大宗交易减持股份，并且是首次披露减持计划，且不存在已经按照第四条披露的情况，或者证监会另有规定的情况。但题目里说不需要考虑证监会的情况。constraint是不得存在最近一期经审计的财务报告的归属于上市公司股东的净利润为负的情况。

接下来，我需要根据提供的dataframe的列来编写函数。首先，处理subject部分。根据股东身份列，控股股东、实际控制人，或者一致行动人。但dataframe里有没有一致行动人的列呢？看附加信息中的股东身份选项，有控股股东、实际控制人，但没有一致行动人。可能需要通过其他方式判断，比如是否有其他列表明一致行动人？或者题目可能假设一致行动人已经被包含在控股股东或实际控制人中？或者可能需要根据其他条件来判断。这里可能需要进一步分析。

但根据附加信息中的股东身份列，可能没有直接的一致行动人标签。所以可能需要假设，题目中的一致行动人可能被归类到控股股东或实际控制人中，或者可能需要通过其他方式判断。或者可能题目中的一致行动人需要被忽略？或者可能题目中的一致行动人需要结合其他条件，比如是否属于同一控制下的股东？

这里可能需要用户澄清，但根据现有数据，可能无法直接判断一致行动人。因此，可能只能处理控股股东和实际控制人。或者，可能题目中的一致行动人需要被忽略，或者视为与控股股东或实际控制人等同？或者可能题目中的一致行动人需要根据其他条件，比如是否存在关联关系，但dataframe中没有相关列。因此，可能在这个任务中，暂时无法处理一致行动人，只能处理控股股东和实际控制人。或者可能题目中的一致行动人需要被忽略，因为数据中没有对应的列。因此，在代码中，可能只能标记subject为控股股东或实际控制人。

接下来，处理condition部分。条件是计划通过集中竞价或大宗交易减持，并且是首次披露减持计划，且没有已经按照第四条披露的情况。这里需要检查减持方式是否是集中竞价或大宗交易，并且存在减持计划，并且是首次披露。此外，还要排除已经按照第四条披露的情况。但第四条的情况可能没有数据，所以可能需要假设该条件是否满足。或者，题目中的必要额外信息指出不考虑证监会另有规定的情况，所以可能第四条的情况可能被忽略？

或者，可能第四条的情况需要检查是否存在已经披露的减持计划。例如，如果该股东之前已经披露过减持计划，那么当前的条件不满足。因此，需要判断是否是首次披露。这可能需要在数据中跟踪每个股东是否有过之前的减持计划披露。例如，对于每个股东，检查在之前的日期是否存在减持计划为True的情况。如果是第一次出现减持计划为True，则满足条件。否则，不满足。

因此，condition部分需要两个条件：减持方式是集中竞价或大宗交易，存在减持计划，并且是首次披露减持计划（即该股东之前没有减持计划）。此外，还要排除已经按照第四条的情况，但可能这里的数据中没有对应的信息，所以可能暂时不考虑。

然后，constraint部分是最近一期的经审计的财务报告的净利润是否为负。需要检查公司的最近一期经审计的净利润是否为负。这里的最近一期可能是指最近一个会计年度或季度？但dataframe中有净利润列，但不确定是否是经审计的。假设净利润列是经审计的，那么需要找到每个公司最近一期的净利润是否为负。例如，对于每个公司的每个日期，找到该日期前最近的经审计的财务报告的净利润是否为负。或者，可能净利润列是每个季度的数据？或者可能dataframe中的净利润是最近一期的经审计数据？

假设dataframe中的净利润列是每个日期对应的公司最近一期经审计的净利润。例如，每个日期对应的净利润是该公司的最近一期经审计的财务报告的数据。那么，在检查时，只需要检查该公司的净利润是否小于0即可。

现在，我需要将这些逻辑转化为代码。

首先，处理subject：

subject是控股股东、实际控制人。根据股东身份列，如果股东身份是'控股股东'或'实际控制人'，则标记为True。此外，可能一致行动人需要被考虑，但数据中没有对应的列，所以暂时忽略。因此，valid_subject = df['股东身份'].isin(['控股股东', '实际控制人'])。

接下来，处理condition：

条件包括减持方式是集中竞价或大宗交易，存在减持计划，并且是首次披露。此外，没有已经按照第四条的情况。但第四条的情况可能无法处理，所以暂时不考虑。因此，减持方式的条件是df['减持方式'].isin(['竞价交易', '大宗交易'])，并且存在减持计划为True。然后，需要判断是否是首次披露减持计划。这需要按公司和股东分组，检查当前行是否是第一次出现存在减持计划为True的情况。

例如，对于每个股东和公司，按日期排序，找到每个存在减持计划为True的行，并确定是否是第一次出现。如果是第一次，则满足条件。否则，不满足。因此，需要分组后，对每个组内的行，检查是否存在之前的减持计划。

这可以通过分组后的cumsum或shift来处理。例如，按['公司简称', '股东']分组，然后对'存在减持计划'列进行排序，并计算每个行的累计出现次数。如果当前行的存在减持计划为True，并且之前的累计次数为0，则满足首次披露的条件。

具体来说，可以创建一个分组后的累计标记。例如：

grouped = df.groupby(['公司简称', '股东'])
df['prev_plan_count'] = grouped['存在减持计划'].cumsum() - df['存在减持计划']  # 当前行之前的计划次数

然后，当存在减持计划为True时，且prev_plan_count为0，则满足首次披露的条件。

因此，valid_condition的条件是：

(df['减持方式'].isin(['竞价交易', '大宗交易'])) & (df['存在减持计划']) & (df['prev_plan_count'] == 0)

接下来，处理constraint：

constraint是最近一期经审计的净利润是否为负。假设净利润列是最近一期的经审计数据，那么只需要检查df['净利润'] < 0。如果净利润为负，则违反constraint，因此constraint的valid是当净利润 >=0时为True，否则False。或者，原constraint是“不得存在下列情形：净利润为负”，所以当净利润为负时，违反constraint，因此constraint的valid应为False。因此，valid_constraint = (df['净利润'] >= 0)

但需要注意，这里的净利润是否是最近一期的经审计数据。例如，假设每个日期对应的净利润是该公司的最近一期经审计的财务报告的数据。例如，每个季度结束后，公司会发布经审计的财务报告，那么每个日期对应的净利润是该季度报告的数据。或者，可能dataframe中的净利润是年度数据，但每个日期可能对应不同的报告期。例如，假设每个公司的净利润列是最近一次经审计的年度净利润，那么无论当前日期如何，净利润都是该年度的数据。或者，可能每个日期对应的净利润是该日期所在季度或年度的数据？

这可能需要更多的假设。例如，假设每个日期对应的净利润是该公司的最近一期经审计的年度净利润。因此，在检查时，只需要判断该行的净利润是否小于0。如果净利润小于0，则违反constraint，因此valid_constraint为False，否则为True。

现在，将这些逻辑转化为代码：

首先，初始化各列：

df['meu_12_3_subject'] = False
df['meu_12_3_condition'] = False
df['meu_12_3_constraint'] = None

处理subject：

valid_subject = df['股东身份'].isin(['控股股东', '实际控制人'])
df.loc[valid_subject, 'meu_12_3_subject'] = True

处理condition：

首先，计算每个股东和公司的减持计划首次披露：

# 按公司和股东分组，按日期排序，计算之前的减持计划次数
df_sorted = df.sort_values(by=['公司简称', '股东', '日期'])
grouped = df_sorted.groupby(['公司简称', '股东'])
df_sorted['prev_plan_count'] = grouped['存在减持计划'].cumsum() - df_sorted['存在减持计划']
# 恢复原来的顺序
df = df_sorted.sort_index()

然后，valid_condition的条件：

valid_condition = (
    df['减持方式'].isin(['竞价交易', '大宗交易']) &
    df['存在减持计划'] &
    (df['prev_plan_count'] == 0)
)
df.loc[valid_condition, 'meu_12_3_condition'] = True

处理constraint：

valid_constraint = df['净利润'] >= 0
df['meu_12_3_constraint'] = valid_constraint

但根据MEU的constraint描述，“不得存在下列情形：净利润为负”，所以当净利润为负时，违反constraint，因此valid_constraint应为False。所以：

df['meu_12_3_constraint'] = (df['净利润'] >= 0)

现在，将这三部分标记到对应的列中。

需要注意的是，constraint的标记是独立进行的，即不管subject和condition是否满足，都要检查。例如，即使某行不满足subject或condition，也要检查constraint是否满足。但根据用户的要求，对于简单操作dataframe可以处理的项目，三元组的检查是各自独立的，需要分别标记。因此，constraint的valid是独立标记的，不管subject和condition是否为True。

但根据MEU的约束条件，只有当subject和condition都满足时，才需要检查constraint是否满足？或者，根据用户的要求，对于不需要调用LLM的情况，三元组的检查是各自独立的，所以即使subject或condition不满足，也要检查constraint是否满足？

根据用户的要求中的“注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查.” 所以，三个条件各自独立检查，不管其他条件是否满足。因此，constraint的标记是独立进行的，不管subject和condition是否为True。

因此，在代码中，constraint的valid是独立计算的，不管其他条件。例如，即使某行的subject和condition都不满足，也要检查constraint是否满足，并标记在meu_12_3_constraint列中。

综上，最终的代码应该包括：

- 初始化各列
- 处理subject的条件
- 处理condition的条件，包括首次披露的判断
- 处理constraint的条件，即净利润是否非负

现在，将这些步骤整合到函数中。

可能的代码：

import pandas as pd

def check_meu_12_3(df):
    '''
    检查MEU_12_3的合规性：
    subject: 上市公司控股股东 | 实际控制人 | 一致行动人
    condition: 计划通过集中竞价或大宗交易减持股份且首次披露减持计划，且不存在已经按照本指引第四条披露减持计划的情况
    constraint: 不得存在最近一期经审计的净利润为负的情况
    '''
    df = df.copy()

    # 初始化列
    df['meu_12_3_subject'] = False
    df['meu_12_3_condition'] = False
    df['meu_12_3_constraint'] = None

    # 处理subject
    valid_subject = df['股东身份'].isin(['控股股东', '实际控制人'])
    df.loc[valid_subject, 'meu_12_3_subject'] = True

    # 处理condition
    # 按公司和股东分组，按日期排序，计算之前的减持计划次数
    df_sorted = df.sort_values(['公司简称', '股东', '日期'])
    grouped = df_sorted.groupby(['公司简称', '股东'])
    # 计算到当前行之前的累计减持计划次数（不包括当前行）
    df_sorted['prev_plan_count'] = grouped['存在减持计划'].cumsum() - df_sorted['存在减持计划']
    # 恢复原来的顺序
    df = df_sorted.sort_index()

    # 条件判断
    valid_condition = (
        df['减持方式'].isin(['竞价交易', '大宗交易']) &
        df['存在减持计划'] &
        (df['prev_plan_count'] == 0)
    )
    df.loc[valid_condition, 'meu_12_3_condition'] = True

    # 处理constraint
    # 净利润 >=0 时为True，否则False
    df['meu_12_3_constraint'] = df['净利润'] >= 0

    # 删除临时列
    df.drop('prev_plan_count', axis=1, inplace=True, errors='ignore')

    return df

需要注意的是，这里的一致行动人没有被处理，因为数据中没有对应的列。因此，可能subject的条件只覆盖了控股股东和实际控制人，而一致行动人无法判断。但根据题目给出的MEU内容，可能需要处理一致行动人，但数据中没有相关信息，所以可能无法处理。因此，在代码中，只能处理控股股东和实际控制人，而一致行动人可能被忽略。或者，可能题目中的一致行动人需要被包含在控股股东或实际控制人中，或者可能题目中的一致行动人需要其他条件，比如是否属于同一控制人，但数据中没有相关字段。因此，在现有数据下，只能处理控股股东和实际控制人。

另外，在condition部分，是否排除了已经按照第四条披露的情况？根据必要额外信息，不考虑中国证监会另有规定的情况，但第四条的情况可能仍然需要考虑。例如，如果股东之前已经按照第四条披露过减持计划，那么当前的条件不满足。但第四条的具体内容可能未知，但根据用户提供的示例，可能第四条涉及其他减持计划的披露。因此，在代码中，通过检查是否是首次披露减持计划，即prev_plan_count是否为0，来满足条件中的“首次披露”要求。这可能符合MEU中的条件要求。

综上，这个函数应该能够正确标记各条件的情况。
","CompletionUsage(completion_tokens=3516, prompt_tokens=1752, total_tokens=5268, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=3021, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_14_3
法律的最小可执行单元内容: {""subject"": ""上市公司董监高"", ""condition"": ""本人因涉嫌与该上市公司有关的证券期货违法犯罪，在被中国证监会及其派出机构立案调查或者被司法机关立案侦查期间"", ""constraint"": ""不得减持其所持有的本公司股份"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_14_3(df):
    '''
    验证MEU_14_3合规性：
    subject: 上市公司董监高
    condition: 因涉嫌证券期货违法犯罪被立案调查/侦查期间
    constraint: 不得减持股份
    '''
    df = df.copy()

    # 初始化合规性标记列
    df['meu_14_3_subject'] = False
    df['meu_14_3_condition'] = False
    df['meu_14_3_constraint'] = None

    # 1. 验证责任主体（当前在任的董监高）
    valid_subject = df['股东身份'] == '董监高'
    df.loc[valid_subject, 'meu_14_3_subject'] = True

    # 2. 验证触发条件（处于被立案调查/侦查状态）
    investigation_status = ['被中国证监会及其派出机构立案调查', '被司法机关立案侦查']
    valid_condition = df['股东涉嫌证券期货违法犯罪事件'].isin(investigation_status)
    df.loc[valid_condition, 'meu_14_3_condition'] = True

    # 3. 验证约束条件（当日未发生减持行为）
    # 注意：此处独立检查，不考虑subject和condition是否满足
    valid_constraint = (df['当日减持比例'] <= 0)
    df.loc[valid_constraint, 'meu_14_3_constraint'] = True
    df.loc[~valid_constraint, 'meu_14_3_constraint'] = False

    return df
</CODE>","好的，我现在需要处理这个任务，编写一个函数来检查MEU_14_3的合规性。首先，我得仔细理解这个MEU的内容。根据给定的信息，MEU_14_3的subject是“上市公司董监高”，condition是“本人因涉嫌与该上市公司有关的证券期货违法犯罪，在被中国证监会及其派出机构立案调查或者被司法机关立案侦查期间”，constraint是“不得减持其所持有的本公司股份”。

接下来，我需要确定如何将这些条件转化为代码中的逻辑。首先处理subject部分。根据附加信息中的股东身份列，可能的取值包括“董监高”和“离任董监高”等。但MEU中的subject是“上市公司董监高”，所以应该只包括当前在任的董监高，即股东身份列等于“董监高”的行。因此，valid_subject应该是df['股东身份'] == '董监高'。

然后是condition部分。condition的条件是股东本人因涉嫌与公司有关的证券期货违法犯罪，在被立案调查或侦查期间。对应的数据列是“股东涉嫌证券期货违法犯罪事件”，该列的可能值包括被立案调查、调查结束等。因此，需要检查该列是否包含“被中国证监会及其派出机构立案调查”或者“被司法机关立案侦查”。这时候，valid_condition的条件应该是该列的值属于这两个中的任意一个。例如，使用isin方法检查是否在对应的列表中。

接下来是constraint部分。constraint是不得减持股份。这里需要检查该股东在当天是否有减持行为。根据数据列中的信息，可能需要查看是否有减持的记录。例如，是否有减持比例大于0，或者是否存在减持计划。但根据数据列的描述，“存在减持计划”是一个布尔值，表示当天是否有减持计划。而“当日减持比例”可能表示当天实际减持的比例。但MEU中的constraint是“不得减持”，所以应该检查当日是否有减持行为，即“当日减持比例”是否大于0。或者，如果减持计划存在，是否在计划期间内。但根据MEU的约束，只要在立案期间，无论是否有减持计划，都不得减持。因此，constraint的检查应该是：在满足subject和condition的情况下，是否减持了股份。但根据用户的要求，对于三元组的检查是各自独立的，所以需要独立标记constraint的valid情况，而不管subject和condition是否满足。不过，根据附加说明中的“对于简单操作dataframe就可以处理的项目，对三元组的检查是各自独立的，需要分别标记三元组的True和False。并不是只对符合subject和condition进行检查。”所以，constraint的检查应该独立进行，即所有行都要检查是否满足constraint的条件，而不管subject和condition是否满足。但MEU中的constraint是“不得减持”，所以正确的逻辑是，当股东减持了股份（即当日减持比例>0）时，是否违反了约束。因此，valid_constraint应该是该行的“当日减持比例”等于0，或者不存在减持行为。但根据数据列，可能要看是否有实际的减持发生。例如，如果当日减持比例大于0，则违反约束，constraint为False；否则为True。或者，如果存在减持计划，但根据MEU的约束，只要在立案期间，无论是否计划，都不能减持。但这里需要独立检查constraint，所以可能直接检查是否有减持行为，即当日减持比例是否大于0。或者，是否在减持期间进行了减持。但可能数据中的“存在减持计划”可能表示计划的存在，而实际减持可能发生在其他时间。因此，正确的逻辑可能应该是：如果该股东在当天减持了股份（即当日减持比例>0），则constraint为False，否则为True。但需要根据数据列的情况来判断。

现在，我需要将这些逻辑转化为代码：

首先，处理subject：

df['meu_14_3_subject'] = (df['股东身份'] == '董监高')

然后，处理condition：

valid_condition = df['股东涉嫌证券期货违法犯罪事件'].isin(['被中国证监会及其派出机构立案调查', '被司法机关立案侦查'])

注意，这里需要检查该列的值是否是这两个中的任意一个。例如，如果该列的值是“被中国证监会及其派出机构立案调查”或者“被司法机关立案侦查”，则condition满足。

接下来，处理constraint：

valid_constraint = (df['当日减持比例'] <= 0)  # 即没有减持

或者，如果当日减持比例等于0，则满足约束。否则不满足。但需要注意，如果当日减持比例是NaN的话如何处理？可能需要填充为0或者根据实际情况处理。假设数据中，如果当日没有减持，该列的值是0，否则是正数。因此，valid_constraint可以简化为df['当日减持比例'] <= 0。

但根据MEU的约束，只要在立案期间，不得减持。所以，当股东在立案期间减持了股份，无论是否满足subject和condition，都违反约束。但根据任务要求，constraint的检查是独立的，所以所有行都要检查是否满足constraint的条件。即，不管该行是否属于董监高，或者是否处于被调查期间，只要该股东在当天减持了股份，则constraint为False。但MEU的约束是否仅适用于subject和condition同时满足的情况？或者，是否无论其他条件如何，只要减持了股份，就违反约束？

根据法律条文，约束是“不得减持”，但该约束仅在subject和condition满足的情况下适用。但根据用户的要求，对于简单操作，三元组的检查是各自独立的。因此，在代码中，constraint的检查是独立进行的，即不管subject和condition是否满足，只要该行存在减持行为，则constraint为False。或者，可能用户的意思是，对于constraint的检查，只有当subject和condition都满足时，才需要检查constraint是否满足。但根据用户给出的例子，比如在MEU_4_1的例子中，constraint的检查是独立进行的，例如：

在例子中，valid_constraint的计算是基于“交易日差”和“存在减持计划”，而不管subject和condition是否满足。因此，在用户的要求中，对于简单操作，三元组的检查是各自独立的。因此，在当前的MEU_14_3中，constraint的检查应该独立于subject和condition，即所有行都要检查是否满足constraint的条件。但根据法律条文，约束是“不得减持”仅在subject和condition满足的情况下适用。但用户可能希望在这种情况下，将constraint的检查独立处理，即不管是否满足subject和condition，只要减持了股份，就标记为违反约束。这可能与实际法律条文不符，但根据用户的要求，必须按照任务中的指示来处理。

或者，可能用户的意思是，对于constraint的检查，只有当subject和condition都满足时，才需要检查constraint是否满足。但根据用户给出的例子中的代码，例如MEU_4_1的代码中，constraint的检查是独立进行的，例如：

valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

这里，不管subject和condition是否满足，只要满足这两个条件，就认为constraint满足。这可能与法律条文不符，但根据用户的要求，必须按照示例中的方式处理。因此，在当前的MEU_14_3中，constraint的检查应该独立进行，即检查该股东是否减持了股份，而不管他们是否是董监高或者是否处于被调查期间。这可能不符合法律的实际应用，但根据任务要求，必须这样做。

但根据用户给出的附加说明中的“对于简单操作dataframe就可以处理的项目，对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查.” 所以，constraint的检查是独立的，不管subject和condition是否满足，都要检查是否满足constraint的条件。例如，在MEU_14_3中，constraint是“不得减持”，所以无论该股东是否是董监高，或者是否被调查，只要当天减持了股份，则constraint为False。这可能与实际法律条文中的约束条件不同，但根据任务要求，必须这样处理。

因此，在代码中，constraint的检查是：

valid_constraint = (df['当日减持比例'] <= 0)  # 没有减持

或者，如果当日减持比例等于0，则满足约束，否则不满足。例如：

df['meu_14_3_constraint'] = (df['当日减持比例'] <= 0)

但需要注意，如果当日减持比例是NaN的情况如何处理？例如，如果该股东当天没有减持，可能该列是0或者NaN？根据数据描述中的信息，可能该列的值是当日减持的比例，如果没有减持则为0。因此，可以安全地检查该列是否大于0。

综上，代码的大致结构如下：

初始化各列为False或None：

df['meu_14_3_subject'] = False
df['meu_14_3_condition'] = False
df['meu_14_3_constraint'] = None  # 或者初始化为True或False？

然后，标记subject：

valid_subject = df['股东身份'] == '董监高'
df.loc[valid_subject, 'meu_14_3_subject'] = True

标记condition：

valid_condition = df['股东涉嫌证券期货违法犯罪事件'].isin(['被中国证监会及其派出机构立案调查', '被司法机关立案侦查'])
df.loc[valid_condition, 'meu_14_3_condition'] = True

标记constraint：

valid_constraint = (df['当日减持比例'] <= 0)  # 没有减持
df.loc[valid_constraint, 'meu_14_3_constraint'] = True
df.loc[~valid_constraint, 'meu_14_3_constraint'] = False

但根据用户提供的例子中的处理方式，constraint的valid情况可能是一个布尔序列，然后直接赋值到对应的列。例如，在例子中：

valid_constraint = ... 

然后：

df.loc[valid_constraint, 'meu_4_1_constraint'] = True
df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

所以，这里同样处理。因此，constraint的valid情况是：如果当日减持比例<=0，则为True，否则False。

但根据法律条文，约束是“不得减持”，所以当减持发生时，违反约束。因此，当当日减持比例>0时，constraint为False，否则为True。因此，valid_constraint应为 (df['当日减持比例'] <= 0)。

现在，将这些逻辑整合到代码中：

函数名为check_meu_14_3，输入是df，返回处理后的df。

需要注意，在初始化时，各列的正确名称是meu_14_3_subject等。例如，在例子中，MEU_4_1的列名是meu_4_1_subject等。

现在，编写代码：

首先导入pandas：

import pandas as pd

然后定义函数：

def check_meu_14_3(df):
    # 复制df以避免修改原数据
    df = df.copy()
    
    # 初始化各列
    df['meu_14_3_subject'] = False
    df['meu_14_3_condition'] = False
    df['meu_14_3_constraint'] = None  # 初始化为None，之后用布尔值填充
    
    # 标记subject
    valid_subject = df['股东身份'] == '董监高'
    df.loc[valid_subject, 'meu_14_3_subject'] = True
    
    # 标记condition
    valid_condition = df['股东涉嫌证券期货违法犯罪事件'].isin(['被中国证监会及其派出机构立案调查', '被司法机关立案侦查'])
    df.loc[valid_condition, 'meu_14_3_condition'] = True
    
    # 标记constraint
    # 检查当日减持比例是否<=0，即没有减持
    valid_constraint = (df['当日减持比例'] <= 0)
    # 将结果转换为布尔值，因为可能存在NaN的情况，但假设数据中该列没有NaN
    df['meu_14_3_constraint'] = valid_constraint
    
    # 根据用户示例中的处理方式，可能需要将constraint列转换为True/False，而不是直接赋值布尔序列
    # 或者，使用loc来赋值：
    df.loc[valid_constraint, 'meu_14_3_constraint'] = True
    df.loc[~valid_constraint, 'meu_14_3_constraint'] = False
    
    return df

但需要注意，在初始化时，meu_14_3_constraint被设置为None，之后用valid_constraint的结果来填充。或者，可能应该初始化为False，然后根据条件设置为True或False。例如，在用户提供的例子中，初始化为None，然后根据条件赋值。或者，在例子中，初始化为None，然后通过loc来设置True和False。例如：

在例子中：

df['meu_4_2_constrain'] = None

然后：

df.loc[valid_constraint, 'meu_4_1_constraint'] = True
df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

所以，同样的处理方式在这里适用。因此，在代码中，初始化meu_14_3_constraint为None，然后根据valid_constraint的结果来设置True或False。

但需要注意，valid_constraint可能包含NaN的情况，例如如果当日减持比例是NaN。如何处理这种情况？根据数据描述中的信息，可能该列不会有NaN，而是0表示没有减持。因此，可以假设该列的值是数值型，且非空。因此，valid_constraint可以直接转换为布尔值。

综上，最终的代码应该如下：

import pandas as pd

def check_meu_14_3(df):
    df = df.copy()
    
    # 初始化列
    df['meu_14_3_subject'] = False
    df['meu_14_3_condition'] = False
    df['meu_14_3_constraint'] = None  # 初始化为None，之后填充布尔值
    
    # 检查subject是否为董监高
    valid_subject = df['股东身份'] == '董监高'
    df.loc[valid_subject, 'meu_14_3_subject'] = True
    
    # 检查condition是否为被立案调查或侦查
    valid_condition = df['股东涉嫌证券期货违法犯罪事件'].isin(['被中国证监会及其派出机构立案调查', '被司法机关立案侦查'])
    df.loc[valid_condition, 'meu_14_3_condition'] = True
    
    # 检查constraint：是否没有减持
    # 当日减持比例<=0视为未减持，满足约束
    valid_constraint = (df['当日减持比例'] <= 0)
    df.loc[valid_constraint, 'meu_14_3_constraint'] = True
    df.loc[~valid_constraint, 'meu_14_3_constraint'] = False
    
    return df

这样，每个条件都被独立检查，并分别标记在对应的列中。例如，即使某行的subject不是董监高，或者condition不满足，只要当日减持比例>0，则constraint标记为False。这可能与实际法律条文中的约束条件不同，但根据用户的要求，必须这样处理，因为三元组的检查是各自独立的。

最后，测试一下代码是否符合要求。例如，当股东身份是董监高，且被立案调查，并且当日减持比例>0时，subject和condition列为True，constraint列为False。而当股东身份不是董监高，但当日减持比例>0时，constraint列为False，但subject列为False。这符合用户的要求。
","CompletionUsage(completion_tokens=3719, prompt_tokens=1713, total_tokens=5432, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=3359, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_16_1
法律的最小可执行单元内容: {""subject"": ""上市公司董监高"", ""condition"": ""上市公司年度报告、半年度报告公告前15日内"", ""constraint"": ""不得买卖本公司股份"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_16_1(df):
    '''
    检查MEU_16_1合规性：
    - subject: 上市公司董监高
    - condition: 处于年报/半年报公告前15日内
    - constraint: 当日无股份买卖行为
    '''
    df = df.copy()
    
    # 初始化标记列
    df['meu_16_1_subject'] = False
    df['meu_16_1_condition'] = False
    df['meu_16_1_constraint'] = None

    # 1. 验证责任主体（独立检查）
    valid_subject = df['股东身份'] == '董监高'
    df.loc[valid_subject, 'meu_16_1_subject'] = True

    # 2. 验证触发条件（按公司分组检查）
    # 构建公司报告日期字典（年报/半年报）
    report_dates = df[df['公告类型'].isin(['年度报告', '半年度报告'])]
    company_report_dates = report_dates.groupby('公司简称')['公告日期'].apply(lambda x: x.unique().tolist()).to_dict()
    
    # 定义自然日窗口检查函数
    def check_report_window(row):
        company = row['公司简称']
        current_date = row['日期']
        for report_date in company_report_dates.get(company, []):
            if (report_date - pd.Timedelta(days=15)) <= current_date < report_date:
                return True
        return False
    
    valid_condition = df.apply(check_report_window, axis=1)
    df.loc[valid_condition, 'meu_16_1_condition'] = True

    # 3. 验证约束内容（独立检查）
    # 通过当日减持比例判断是否发生交易
    valid_constraint = df['当日减持比例'] == 0
    df.loc[valid_constraint, 'meu_16_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_16_1_constraint'] = False

    return df
</CODE>","好的，我现在需要处理MEU_16_1的合规性检查。首先，我得仔细理解这个MEU的内容。根据给定的信息，MEU_16_1的subject是“上市公司董监高”，condition是“上市公司年度报告、半年度报告公告前15日内”，constraint是“不得买卖本公司股份”。我的任务是为输入的DataFrame中的每一行标记这三个条件的满足情况。

首先，处理subject部分。根据附加信息中的列，股东身份有“董监高”这一项。所以，我需要检查每一行的股东身份是否是“董监高”。但可能还要注意，是否还有其他情况需要考虑？比如离任董监高？不过MEU中的subject明确是“上市公司董监高”，所以离任的可能不算。因此，valid_subject应该是股东身份等于“董监高”的行。

接下来是condition部分。条件是公司处于年报或半年报公告前15日内。这里需要确定每个公司的公告日期，然后检查当前行的日期是否在公告日期的前15天自然日内。例如，如果某公司的年报公告日期是2023-03-31，那么从2023-03-16到2023-03-30之间的日期都属于这个条件范围内。需要注意的是，这里的15天是自然日还是交易日？根据问题描述中的附加信息，MEU中的condition是自然日，所以应该用自然日计算。因此，我需要找到每个公司的年度报告和半年度报告的公告日期，然后对于每一行数据，判断该行的日期是否在公告日期的前15天内。

这里可能需要用到DataFrame中的公告类型和公告日期列。假设公告类型为“年度报告”或“半年度报告”时，对应的公告日期就是需要检查的日期。但如何将每个公司的年报和半年报的公告日期对应到每一行呢？可能需要按公司分组，找到每个公司最近的年报和半年报的公告日期，然后检查当前行的日期是否在这些日期的前15天内。

或者，可能每一行的公告类型列会标明该公告是否是年报或半年报，而公告日期是该公告的发布日期。例如，某行可能有公告类型为“年度报告”，公告日期为某个日期。但问题在于，每个公司的年报和半年报可能有多个记录，需要确定每个公司每个年度的报告对应的公告日期。或者，可能每一行的公告日期列指的是该行对应的报告公告日期。例如，当某行的公告类型是年度报告时，该行的公告日期就是该年报的公告日期。但可能同一公司会有多个年度报告，所以需要针对每个公司，找到所有年报和半年报的公告日期，然后对于每一行数据，检查该行的日期是否在这些公告日期的前15天内。

这可能需要按公司分组，然后对于每个公司，收集所有年报和半年报的公告日期，然后对于该公司的每一行数据，检查该行的日期是否在任何一个年报或半年报公告日期的前15天内。

但处理起来可能比较复杂。例如，假设DataFrame中的每一行代表某一天的情况，那么对于每个公司，需要知道在该行的日期之后是否有即将发布的年报或半年报，并且当前日期处于公告前15天的窗口期。

或者，可能每一行的公告类型和公告日期列表示的是该行对应的公告信息。例如，当某行的公告类型是年度报告时，该行的公告日期就是该年报的发布日期。此时，对于该行来说，该公司的年报公告日期是该行的公告日期，那么该行的日期是否在该公告日期的前15天内？

但这样的话，可能同一公司会有多个行对应不同的公告日期。例如，不同年份的年报。因此，对于每一行，如果该行的公告类型是年报或半年报，那么该行的日期是否在该公告日期的前15天内？

或者，可能公告日期列是该行对应的公告的日期，而公告类型列表示该公告的类型。例如，某行的公告日期是2023-03-31，公告类型是年度报告，那么该行的日期可能是在2023-03-31之前的某个时间。此时，该行的日期是否在2023-03-31的前15天内？

但MEU的条件是“上市公司年度报告、半年度报告公告前15日内”，所以需要确定，对于每个公司，当某一天处于该公司任何一次年报或半年报公告前15天时，该天的condition为真。

因此，处理步骤可能是：

1. 对于每个公司，收集所有年报和半年报的公告日期。
2. 对于每个公司的每个日期，检查该日期是否在任何一个年报或半年报公告日期的前15天内。
3. 如果是，则condition为真。

但如何从DataFrame中获取每个公司的年报和半年报的公告日期呢？

假设DataFrame中的每一行可能对应不同的公告类型。例如，当某行的公告类型是“年度报告”或“半年度报告”时，该行的公告日期就是对应的公告日期。因此，可以按公司分组，然后收集所有公告类型为年报或半年报的行的公告日期，形成一个列表。然后，对于该公司的每一行数据，检查该行的日期是否在任何一个公告日期的前15天内。

但如何实现这一点呢？可能需要先创建一个每个公司的所有年报和半年报公告日期的列表，然后对于每个公司的每一行日期，检查是否存在某个公告日期，使得该行的日期在公告日期的前15天内。

例如，假设对于公司A，有年报公告日期为2023-03-31和2022-03-30，那么对于公司A的某一行日期为2023-03-20，该日期在2023-03-31的前15天内（即从2023-03-16到2023-03-30），所以condition为真。

因此，处理步骤：

- 按公司简称分组。
- 对每个公司，提取所有公告类型为“年度报告”或“半年度报告”的行的公告日期。
- 对于每个公司的每一行，检查该行的日期是否在任何一个公告日期的前15天内（即公告日期 - 15天 <= 日期 < 公告日期）。
- 如果是，则condition为真。

现在，如何用pandas实现这一点？

可能的步骤：

1. 创建一个新的DataFrame，包含每个公司的所有年报和半年报的公告日期。例如：

report_dates = df[df['公告类型'].isin(['年度报告', '半年度报告'])][['公司简称', '公告日期']].drop_duplicates()

然后，对于每个公司，将这些日期收集到一个列表中。

2. 对原始df中的每一行，检查该行的日期是否在该公司对应的任何一个report_date的前15天内。

这可能需要使用groupby和transform，或者merge操作。

或者，可以使用apply函数，对每一行进行处理：

对于每一行，获取该公司的所有report_dates，然后检查该行的日期是否满足条件。

但这样可能效率较低，但数据量不大时可行。

具体来说：

- 首先，创建一个字典，键为公司简称，值为该公司所有年报和半年报的公告日期列表。

report_dates_dict = df[df['公告类型'].isin(['年度报告', '半年度报告'])].groupby('公司简称')['公告日期'].apply(lambda x: x.unique().tolist()).to_dict()

然后，对于df中的每一行，获取公司简称，然后遍历该公司的所有report_dates，检查当前行的日期是否在任何一个report_date的前15天内。

例如：

def check_condition(row):
    company = row['公司简称']
    current_date = row['日期']
    report_dates = report_dates_dict.get(company, [])
    for rd in report_dates:
        if (rd - pd.Timedelta(days=15)) <= current_date < rd:
            return True
    return False

然后，应用这个函数到每一行，生成valid_condition。

但需要注意，如果report_dates_dict中没有该公司的数据，则返回False。

这可能是一个可行的方法。

接下来是constraint部分，即“不得买卖本公司股份”。这里需要检查该股东在该日是否有买卖股份的行为。但DataFrame中的哪些列可以反映这一点？

根据提供的列，可能相关的列是“当日减持比例”或“减持方式”等。例如，如果当日减持比例大于0，或者减持方式不为空，则表示该股东在该日有减持行为，即买卖股份。但MEU中的constraint是“不得买卖”，所以如果当日减持比例>0，或者存在减持交易，则违反约束，因此constraint应为False。

但具体如何判断？例如，如果当日减持比例>0，或者存在减持记录，则视为买卖股份，此时constraint应为False（因为约束是不得买卖，所以当有买卖时，违反约束）。

因此，valid_constraint应为该行的当日减持比例等于0，或者没有减持行为。或者，可能要看是否有任何减持动作。例如，如果当日减持比例>0，则视为违反约束，此时constraint为False。

所以，valid_constraint = (df['当日减持比例'] == 0) 或者可能还有其他条件？

或者，可能要看该股东在该日是否有减持行为。例如，如果存在减持记录（如减持方式不为空，或者当日减持比例>0），则视为买卖股份，此时违反约束，因此constraint为False。否则为True。

因此，可能的判断条件是：

valid_constraint = (df['当日减持比例'] == 0) & (df['减持方式'].isna())

或者，可能更简单的方式是，只要当日减持比例等于0，就认为没有买卖，否则视为有买卖。或者，可能要看是否有任何减持动作，比如减持方式存在，或者当日减持比例>0。

例如：

valid_constraint = (df['当日减持比例'] == 0) & (df['减持方式'].isna())

但可能实际情况中，如果减持方式存在，但当日减持比例为0，这可能不成立。或者，可能当日减持比例>0时，减持方式才有值。这需要根据数据的具体情况判断。但根据问题描述中的列说明，“当日减持比例”可能直接反映是否有减持行为。因此，如果当日减持比例>0，则视为有买卖，此时违反约束，所以constraint为False。否则为True。

因此，valid_constraint = (df['当日减持比例'] == 0)

或者，可能还有其他情况，比如增持？但MEU中的constraint是“不得买卖”，所以无论是买入还是卖出都算？但问题中的描述是关于减持的，可能这里的“买卖”指的是减持。或者，可能该MEU中的constraint禁止任何形式的买卖，包括买入和卖出。但根据MEU的context，可能这里的“买卖”指的是减持，即卖出。但需要明确。

根据MEU的原文，“不得买卖本公司股份”，这里的买卖包括买入和卖出。但根据问题中的列，可能只有减持相关的信息。例如，可能没有买入的数据，只有减持的数据。因此，可能只能检查是否有减持行为。或者，可能该股东在该日如果有任何股份变动（如减持或增持），都视为买卖。但问题中的列可能没有增持的信息，所以可能只能检查减持情况。

因此，假设当日的减持比例>0时，视为卖出，违反约束。而买入的情况可能无法通过现有列判断，但可能问题中的场景只涉及减持。因此，valid_constraint的条件是当日减持比例等于0。

或者，可能“当日减持比例”为0时，表示没有减持，即没有卖出，但可能还有买入的情况。但根据问题中的列，可能无法判断买入，所以只能检查卖出情况。因此，在这种情况下，只要当日没有减持（即当日减持比例为0），则视为满足约束条件。否则，视为违反。

因此，valid_constraint = (df['当日减持比例'] == 0)

但需要确认这一点是否正确。例如，如果股东在该日买入股份，是否会被记录？可能问题中的数据集没有记录买入的情况，所以只能检查减持。因此，在这种情况下，假设只有减持会被视为“买卖”，所以当日的减持比例>0时，视为违反约束。

综上，处理步骤：

1. 标记subject：股东身份是“董监高”。
2. 标记condition：该日期处于该公司年报或半年报公告前15日内。
3. 标记constraint：当日减持比例为0。

现在，将这些步骤转化为代码。

首先，处理subject：

valid_subject = df['股东身份'] == '董监高'

然后，处理condition：

需要先构建每个公司的年报和半年报的公告日期列表。然后，对于每一行，检查日期是否在任何一个公告日期的前15天内。

代码步骤：

# 创建report_dates_dict
report_dates = df[df['公告类型'].isin(['年度报告', '半年度报告'])]
report_dates_dict = report_dates.groupby('公司简称')['公告日期'].apply(lambda x: x.unique().tolist()).to_dict()

# 对每一行应用检查
def check_condition(row):
    company = row['公司简称']
    current_date = row['日期']
    if company not in report_dates_dict:
        return False
    for rd in report_dates_dict[company]:
        if (rd - pd.Timedelta(days=15)) <= current_date < rd:
            return True
    return False

valid_condition = df.apply(check_condition, axis=1)

或者，可能更高效的方式是使用向量化操作，但可能比较复杂。例如，可以先将所有相关的公告日期与原始数据合并，然后计算日期差。

但考虑到时间和效率，可能使用apply函数更直接，尽管效率可能较低。

最后，处理constraint：

valid_constraint = df['当日减持比例'] == 0

但需要注意，如果当日减持比例是NaN的话，可能需要处理。但根据问题中的列描述，可能该列不会为NaN，而是0表示没有减持。或者，可能当存在减持时，该列有正数，否则为0。因此，假设该列的值是0或正数，没有NaN，所以可以直接比较。

综上，将这些条件应用到DataFrame中，并创建对应的列。

现在，编写代码：

首先，初始化各列：

df['meu_16_1_subject'] = False
df['meu_16_1_condition'] = False
df['meu_16_1_constraint'] = None  # 因为constraint需要标记True或False，所以初始化为None可能不太合适，应该初始化为False？

或者，根据示例中的代码，初始化为False，然后根据条件设置为True或False。例如：

df['meu_16_1_subject'] = False
df.loc[valid_subject, 'meu_16_1_subject'] = True

同样，condition和constraint也是如此。

但根据示例中的代码，constraint列初始化为None，然后根据条件设置为True或False。这可能是因为在示例中，constraint的检查可能比较复杂，但在这里，constraint的检查是独立的，所以应该初始化为False，然后符合条件的设为True，否则False。

但根据问题中的要求，三元组的检查是各自独立的，所以即使subject或condition不满足，也要检查constraint的条件。例如，不管subject和condition是否为真，只要constraint的条件满足，就标记为True。但根据MEU的逻辑，只有当subject和condition都满足时，constraint才需要被检查。但问题中的要求指出，对于简单操作dataframe的情况，三元组的检查是独立的，需要分别标记。因此，constraint的标记是独立于subject和condition的，即不管subject和condition是否为真，都要检查constraint的条件，并标记。

例如，在示例中，constraint的检查是独立进行的，而不是仅当subject和condition都为真时才检查。因此，在本题中，同样需要独立检查constraint的条件，并标记所有行的constraint是否符合。

因此，在代码中，constraint的标记是：

valid_constraint = (df['当日减持比例'] == 0)

然后，将valid_constraint的结果直接赋值给meu_16_1_constraint列。

但根据示例中的处理方式，constraint列初始化为None，然后根据条件设置为True或False。例如：

df.loc[valid_constraint, 'meu_16_1_constraint'] = True
df.loc[~valid_constraint, 'meu_16_1_constraint'] = False

或者，可以初始化为False，然后符合条件的设为True。例如：

df['meu_16_1_constraint'] = False
df.loc[valid_constraint, 'meu_16_1_constraint'] = True

两种方式都可以，但示例中的方式可能更清晰。

现在，整合所有步骤到代码中：

import pandas as pd

def check_meu_16_1(df):
    '''
    检查MEU_16_1的合规性：
    - subject: 上市公司董监高
    - condition: 上市公司年度报告、半年度报告公告前15日内
    - constraint: 不得买卖本公司股份
    '''
    df = df.copy()

    # 初始化列
    df['meu_16_1_subject'] = False
    df['meu_16_1_condition'] = False
    df['meu_16_1_constraint'] = None  # 初始化为None，后续填充True/False

    # 标记subject
    valid_subject = df['股东身份'] == '董监高'
    df.loc[valid_subject, 'meu_16_1_subject'] = True

    # 标记condition
    # 收集各公司的年报和半年报公告日期
    report_dates = df[df['公告类型'].isin(['年度报告', '半年度报告'])]
    report_dates_dict = report_dates.groupby('公司简称')['公告日期'].apply(lambda x: x.unique().tolist()).to_dict()

    # 定义检查condition的函数
    def check_condition(row):
        company = row['公司简称']
        current_date = row['日期']
        if company not in report_dates_dict:
            return False
        for rd in report_dates_dict[company]:
            if (rd - pd.Timedelta(days=15)) <= current_date < rd:
                return True
        return False

    valid_condition = df.apply(check_condition, axis=1)
    df.loc[valid_condition, 'meu_16_1_condition'] = True

    # 标记constraint
    # 检查当日是否有减持行为（当日减持比例为0）
    valid_constraint = df['当日减持比例'] == 0
    df.loc[valid_constraint, 'meu_16_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_16_1_constraint'] = False

    return df

需要注意的问题：

1. 在收集report_dates时，可能同一公司有多个年报和半年报的公告日期。例如，不同年份的。因此，在检查时，需要遍历所有可能的公告日期，判断当前日期是否在任何一个公告日期的前15天内。

2. 在检查condition时，使用的是自然日，而非交易日。因此，使用pd.Timedelta(days=15)是正确的。

3. 对于constraint的判断，假设当日减持比例为0表示没有买卖，否则视为有买卖，违反约束。因此，valid_constraint的条件是当日减持比例等于0。

可能的测试案例：

- 某行股东身份是董监高，处于年报公告前10天，当日减持比例为0：subject和condition为True，constraint为True → 合规？
但根据MEU的约束，当subject和condition都满足时，必须满足constraint。但根据问题中的要求，三元组的检查是独立的，所以即使subject和condition为False，只要constraint的条件满足，就标记为True。例如，某行股东身份不是董监高，但当日减持比例为0，那么该行的constraint标记为True。这可能与法律的实际要求无关，但根据任务要求，需要独立检查每个条件。

但根据MEU的逻辑，只有当subject和condition都满足时，才需要满足constraint。但在本任务中，对于简单操作，三元组的检查是独立的，因此需要分别标记。例如，不管subject和condition是否为真，只要constraint的条件满足，就标记为True。这可能与实际法律合规性无关，但根据用户的要求，需要这样处理。

因此，代码中的处理是正确的。

综上，以上代码应该能够正确标记各条件的情况。
","CompletionUsage(completion_tokens=4784, prompt_tokens=1698, total_tokens=6482, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=4314, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_14_2
法律的最小可执行单元内容: {""subject"": ""上市公司董监高"", ""condition"": ""上市公司因涉嫌证券期货违法犯罪被中国证监会及其派出机构立案调查或者被司法机关立案侦查，在行政处罚决定、刑事判决作出之后未满6个月"", ""constraint"": ""不得减持其所持有的本公司股份"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_14_2(df):
    '''
    合规性检查函数：MEU_14_2
    subject: 上市公司董监高
    condition: 公司因证券期货违法犯罪被立案调查/侦查且处罚决定/刑事判决未满6个月
    constraint: 不得减持股份
    '''
    df = df.copy()

    # 初始化标记列
    df['meu_14_2_subject'] = False
    df['meu_14_2_condition'] = False
    df['meu_14_2_constraint'] = None

    # 1. 标记责任主体 (上市公司董监高)
    subject_mask = df['股东身份'] == '董监高'
    df.loc[subject_mask, 'meu_14_2_subject'] = True

    # 2. 标记触发条件 (处罚后未满6个月)
    # 筛选处罚相关事件
    penalty_events = df[df['公司涉嫌证券期货违法犯罪事件'].isin(['行政处罚决定作出', '刑事判决作出'])]
    
    # 按公司获取最新处罚日期
    latest_penalty = penalty_events.groupby('公司简称')['公告日期'].max().reset_index()
    latest_penalty.rename(columns={'公告日期':'latest_penalty_date'}, inplace=True)
    
    # 合并处罚日期到主表
    df = df.merge(latest_penalty, on='公司简称', how='left')
    
    # 计算自然日间隔
    if 'latest_penalty_date' in df.columns:
        df['penalty_days'] = (df['日期'] - df['latest_penalty_date']).dt.days
        condition_mask = (df['penalty_days'] >= 0) & (df['penalty_days'] <= 180)
        df.loc[condition_mask, 'meu_14_2_condition'] = True

    # 3. 标记约束条件 (不得减持)
    df['meu_14_2_constraint'] = df['当日减持比例'] <= 0  # 无减持为合规
    
    # 清理辅助列
    df.drop(['latest_penalty_date', 'penalty_days'], axis=1, errors='ignore', inplace=True)
    
    return df
</CODE>","好的，我现在需要处理这个MEU_14_2的合规性检查。首先，我得仔细理解这个MEU的具体内容。MEU的subject是“上市公司董监高”，condition是公司因涉嫌证券期货违法犯罪被立案调查或侦查，且在行政处罚或刑事判决后未满6个月。constraint是这些董监高不得减持股份。

首先，我需要确定如何标记subject。根据用户提供的dataframe中的列，股东身份有“董监高”这一项。所以，只要股东身份是“董监高”的行，subject就有效。但要注意，用户提到股东身份的标签不会并列出现，所以直接检查该列是否为“董监高”即可。

接下来是condition部分。condition的条件是公司被立案调查或侦查，并且在处罚或判决后未满6个月。这里需要检查公司是否处于被调查或侦查的状态，并且行政处罚决定或刑事判决的日期是否在最近6个月内。dataframe中的列是“公司涉嫌证券期货违法犯罪事件”，可能包含事件类型，比如“被中国证监会及其派出机构立案调查”或者“被司法机关立案侦查”。同时，需要知道这些事件的结束时间，比如行政处罚决定作出的日期或者刑事判决的日期，然后计算到当前日期是否未满6个月。

但用户提供的列中，可能没有直接的日期信息。比如，假设dataframe中有事件发生的日期，比如“公告日期”或者其他相关日期列。或者可能需要根据事件类型的变化来判断。例如，当事件类型是“行政处罚决定作出”时，记录该日期，然后计算从该日期到当前行的日期是否在6个月内。但用户给出的可用列中有“公司涉嫌证券期货违法犯罪事件”列，可能包含多个状态，比如被立案调查、调查结束、处罚决定作出等。因此，可能需要跟踪每个公司的这些事件的时间线。

这里可能需要分组处理，按公司和日期来跟踪事件。例如，当公司被立案调查后，直到行政处罚决定作出，之后开始计算6个月的时间窗口。因此，对于每一行数据，需要确定公司是否处于处罚决定作出后的6个月内。

但具体如何操作呢？假设dataframe中的每一行代表某一天的情况，那么需要确定在该行的日期，公司是否处于处罚决定或刑事判决后的6个月期限内。例如，如果某公司有一个“行政处罚决定作出”的事件，其公告日期是某个日期，那么从该日期开始的6个月内，所有该公司的行都需要满足condition条件。

因此，可能需要为每个公司记录最近一次行政处罚决定或刑事判决的日期，然后检查当前行的日期是否在该日期之后的6个月内。

但用户提供的列中，可能没有直接的处罚决定日期。例如，“公司涉嫌证券期货违法犯罪事件”列可能包含事件类型，如“行政处罚决定作出”，而“公告日期”是该事件的日期。因此，可能需要遍历每个公司的事件，找到最近的处罚决定或判决的日期，然后计算时间差。

这可能需要按公司分组，然后对于每个公司，找到所有“行政处罚决定作出”或“刑事判决作出”的事件的日期，取最大的那个日期，然后判断当前行的日期是否在该日期之后的6个月内。

但具体如何实现呢？假设在dataframe中，当“公司涉嫌证券期货违法犯罪事件”列的值是“行政处罚决定作出”或“被司法机关立案侦查”的某种状态时，对应的公告日期是该事件的发生日期。例如，当事件类型是“行政处罚决定作出”时，该行的公告日期就是处罚决定的日期。因此，需要为每个公司收集这些事件的日期，并计算当前日期是否在处罚后的6个月内。

这可能比较复杂。例如，对于每一行，如果公司在该行日期之前有过行政处罚决定或刑事判决，并且该决定的日期到当前行的日期未满6个月，则condition为真。

因此，处理步骤可能如下：

1. 对于每个公司，收集所有“行政处罚决定作出”或“刑事判决作出”事件的日期。
2. 对于每个公司的每一行数据，检查是否存在这样的日期，并且当前行的日期是否在该日期之后的6个月内。
3. 如果是，则condition条件满足。

但如何具体实现呢？可能需要创建一个辅助列，记录每个公司最近的处罚或判决日期。例如，按公司分组，筛选出事件类型为“行政处罚决定作出”或“司法机关立案侦查结束”等（需要明确事件类型对应的条件），然后取最大的日期作为最近处罚日期。然后，对于每一行，如果该行的日期在最近处罚日期之后的6个月内，则condition为真。

但用户提供的列中，“公司涉嫌证券期货违法犯罪事件”可能包含多个事件类型，比如被立案调查、调查结束、处罚决定作出等。例如，当事件类型是“行政处罚决定作出”时，说明处罚已经作出。此时，该事件的公告日期即为处罚日期。因此，需要找到每个公司所有这样的处罚日期，并确定当前行日期是否在处罚后的6个月内。

因此，可能的步骤是：

- 筛选出公司的事件类型为“行政处罚决定作出”或“刑事判决作出”的行，获取这些行的公告日期。
- 对每个公司，找到最大的这样的日期，作为latest_penalty_date。
- 对于每一行，如果该行的日期在latest_penalty_date之后的6个月内，则condition条件满足。

但如何将这些信息合并到原始dataframe中呢？可能需要使用groupby和transform方法，为每个公司计算latest_penalty_date，然后比较当前行的日期是否在该日期之后且不超过6个月。

例如：

# 筛选出处罚或判决的事件
penalty_events = df[df['公司涉嫌证券期货违法犯罪事件'].isin(['行政处罚决定作出', '刑事判决作出'])]

# 按公司分组，找到每个公司的最新处罚日期
company_penalty_dates = penalty_events.groupby('公司简称')['公告日期'].max().reset_index()
company_penalty_dates.rename(columns={'公告日期': 'latest_penalty_date'}, inplace=True)

# 将latest_penalty_date合并到原df中
df = df.merge(company_penalty_dates, on='公司简称', how='left')

# 计算日期差
df['penalty_days'] = (df['日期'] - df['latest_penalty_date']).dt.days

# condition满足的条件是penalty_days在0到180天之间
valid_condition = (df['penalty_days'] >= 0) & (df['penalty_days'] <= 180)

但这里可能存在一个问题：如果公司没有被处罚过，那么latest_penalty_date是NaN，此时penalty_days会是NaN，所以valid_condition会是False。这符合条件，因为只有当公司被处罚后，才可能触发condition。

但用户提供的MEU中的condition是“上市公司因涉嫌证券期货违法犯罪被中国证监会及其派出机构立案调查或者被司法机关立案侦查，在行政处罚决定、刑事判决作出之后未满6个月”。也就是说，condition的条件是公司被立案调查或侦查，并且在处罚决定或判决后的6个月内。但这里的逻辑可能需要更精确的判断：是否在处罚决定作出后的6个月内？

或者，是否只要公司被立案调查或侦查，并且在处罚决定后的6个月内，不管是否调查已经结束？

根据MEU的描述，condition的条件是公司被立案调查或侦查，并且在处罚决定或刑事判决作出后的6个月内。所以，这里的触发条件是公司被立案调查或侦查，并且处罚决定或判决已经作出且在6个月内。

或者，可能MEU中的条件是指，公司被立案调查或侦查之后，在处罚决定作出后的6个月内，董监高不得减持。或者，是否处罚决定或判决是立案调查或侦查的结果？

可能原意是，当公司被立案调查或侦查，并且之后作出了行政处罚决定或刑事判决，且在作出后的6个月内，董监高不得减持。因此，condition的条件是处罚决定或判决作出后的6个月内，无论此时调查是否已经结束。

因此，正确的处理应该是，只要公司存在行政处罚决定或刑事判决的日期，并且当前日期在该日期后的6个月内，那么condition条件满足，无论之前的调查是否结束。

因此，上述方法可能是正确的，即找到每个公司最新的处罚决定或判决的日期，并检查当前行日期是否在该日期后的6个月内。

接下来是constraint部分，即董监高不得减持。在dataframe中，减持可能通过“当日减持比例”是否大于0来判断，或者是否有减持行为。例如，如果当日减持比例>0，则视为减持。或者，是否存在减持计划，或者实际减持行为。

根据MEU的constraint是“不得减持其所持有的本公司股份”，所以只要在condition满足的情况下，董监高减持了股份，就违反规定。因此，在constraint的检查中，需要判断该股东在该行日期是否有减持行为。例如，“当日减持比例”是否大于0，或者“累计减持比例”是否有增加。

但用户提供的列中有“当日减持比例”这一列，可能表示该股东在该交易日减持的比例。因此，如果当日减持比例>0，则视为减持行为。此时，constraint的条件是当日减持比例<=0，即不允许减持。因此，在满足subject和condition的情况下，如果当日减持比例>0，则违反constraint，否则符合。

但根据用户的要求，对于三元组的检查是各自独立的，所以constraint的检查是独立进行的，不需要考虑subject和condition是否满足。但根据附加要求中的说明：“对于简单操作dataframe就可以处理的项目，对三元组<subject, condition, constrain>的检查是各自独立的，你需要分别标记三元组的True和False。并不是只对符合subject和condition进行检查。” 所以，constraint的检查是独立进行的，即不管subject和condition是否满足，都要检查constraint是否满足。但MEU中的constraint是“不得减持”，所以无论subject和condition如何，只要减持了，是否都算违反？这显然不符合法律条文的本意。但根据用户的要求，这里需要将三个条件独立检查，所以可能constraint的检查是：无论subject和condition是否满足，只要该行存在减持，就标记constraint为False，否则为True？

但根据MEU的约束，只有当subject和condition都满足时，constraint才适用。但用户的任务说明中提到，对于简单操作，三个条件是独立检查的。所以，这里的constraint的检查可能需要独立判断，即不管subject和condition是否满足，只要该行存在减持，就认为违反constraint？这显然不符合法律的实际应用，但根据用户的要求，必须这样做。

但用户给出的例子中，比如MEU_4_1的示例中，constraint的检查是独立进行的，例如：

在示例代码中，valid_constraint是根据是否存在减持计划以及交易日差是否>=15。而不管subject和condition是否满足。所以，在示例中，constraint的检查是独立进行的，即不管subject和condition是否为真，只要满足条件，就标记为True或False。

但根据法律条文，只有当subject和condition都满足时，constraint才需要被检查。但用户的任务说明中，对于简单操作，三个条件是独立检查的。所以，这里的MEU_14_2的constraint检查，即“不得减持”，需要独立检查，即只要该行存在减持行为，无论是否是董监高，或者公司是否处于处罚后的6个月内，都认为constraint被违反？

这显然不符合法律的实际要求，但根据用户的要求，必须这样处理。或者，可能我误解了用户的要求？

用户的任务说明中的附加要求指出：“对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)”

所以，当前任务属于“简单操作dataframe就可以处理的项目”，因此三个条件需要独立检查。即，不管subject和condition是否为真，都要检查constraint是否满足。例如，对于MEU_14_2的constraint是“不得减持”，所以无论该行是否是董监高，或者公司是否处于处罚后的6个月内，只要该行存在减持行为，则constraint被标记为False，否则为True？

但这样显然不符合法律条文的本意，因为约束仅适用于特定情况下的主体。但根据用户的要求，必须独立检查。这可能是一个矛盾，但必须按照用户的要求处理。

或者，可能用户的意思是，对于constraint的检查，只有当subject和condition都满足时，才需要检查，否则标记为None或者不适用？但示例中的代码显示，在示例中，constraint的检查是独立进行的，例如：

在示例中，valid_constraint的计算是基于“存在减持计划”和“交易日差>=15”，而不管subject和condition是否满足。所以，在示例中，即使subject和condition不满足，只要满足constraint的条件，就标记为True。

这可能意味着，在用户的任务中，三个条件需要分别独立检查，不管其他条件是否满足。这可能与实际法律合规性检查的逻辑不符，但根据用户的要求，必须这样处理。

因此，回到当前任务，MEU_14_2的constraint是“不得减持”，所以无论该行是否属于董监高，或者公司是否处于处罚后的6个月内，只要该股东在该日减持了股份（即“当日减持比例”>0），则constraint被标记为False，否则为True。

但这样处理的话，constraint的检查结果可能大部分都是False，因为很多股东可能在减持，但只有当subject和condition都满足时，才需要遵守该约束。但根据用户的要求，必须独立检查三个条件。这可能是一个问题，但必须按照用户的要求处理。

现在，我需要根据这些分析来编写代码。

首先，处理subject：

subject是“上市公司董监高”，对应的dataframe中的“股东身份”列是否为“董监高”。所以，valid_subject = df['股东身份'] == '董监高'

接下来，处理condition：

condition是公司被立案调查或侦查，并且在处罚决定或刑事判决作出后的6个月内。需要找到每个公司最近的处罚决定或判决的日期，并检查当前日期是否在该日期后的6个月内。

步骤：

1. 筛选出公司的事件类型为“行政处罚决定作出”或“刑事判决作出”的行。假设这些事件对应的“公司涉嫌证券期货违法犯罪事件”列的值是这两个字符串之一。

2. 对每个公司，找到这些事件的最大日期，即最新的处罚日期。

3. 将每个公司的这个日期合并到原dataframe中，作为latest_penalty_date。

4. 计算当前行的日期与latest_penalty_date之间的天数差，如果在0到180天之间，则condition条件满足。

但需要注意，如果公司没有这样的处罚事件，则latest_penalty_date为NaN，此时条件不满足。

因此，代码可能如下：

# 筛选出处罚或判决的事件
penalty_mask = df['公司涉嫌证券期货违法犯罪事件'].isin(['行政处罚决定作出', '刑事判决作出'])
penalty_dates = df[penalty_mask][['公司简称', '公告日期']]

# 按公司分组，取最新的日期
latest_penalty = penalty_dates.groupby('公司简称')['公告日期'].max().reset_index()
latest_penalty.rename(columns={'公告日期': 'latest_penalty_date'}, inplace=True)

# 合并到原df
df = df.merge(latest_penalty, on='公司简称', how='left')

# 计算日期差
df['days_since_penalty'] = (df['日期'] - df['latest_penalty_date']).dt.days

# condition条件满足：处罚日期存在，且日期差在0到180天之间
valid_condition = (df['days_since_penalty'] >= 0) & (df['days_since_penalty'] <= 180)

但需要注意，如果latest_penalty_date是NaN，那么days_since_penalty也是NaN，此时条件为False。

接下来，处理constraint：

constraint是“不得减持”，即该股东在该日没有减持。根据dataframe中的“当日减持比例”列，如果该值大于0，则视为减持。因此，valid_constraint = df['当日减持比例'] <= 0

但需要注意，如果当日减持比例为0或负数（可能不可能），则视为没有减持。因此，只要当日减持比例>0，则constraint不满足，标记为False，否则为True。

但根据用户的要求，三个条件是独立检查的，所以不管subject和condition是否为真，都要检查constraint。因此，valid_constraint的计算是独立的。

现在，将这些条件应用到dataframe中，并创建对应的列：

初始化列：

df['meu_14_2_subject'] = False
df['meu_14_2_condition'] = False
df['meu_14_2_constraint'] = None  # 或者初始化为False？

然后，根据条件填充：

df.loc[valid_subject, 'meu_14_2_subject'] = True
df.loc[valid_condition, 'meu_14_2_condition'] = True
df.loc[:, 'meu_14_2_constraint'] = (df['当日减持比例'] <= 0)  # 这里可能有问题，因为如果减持比例是0或负数，则为True，否则False

但根据用户提供的示例，constraint的列初始化为None，然后根据条件设置为True或False。例如，在示例中：

df['meu_4_2_constrain'] = None
然后：
df.loc[valid_constraint, 'meu_4_1_constraint'] = True
df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

所以，正确的做法是：

valid_constraint = (df['当日减持比例'] <= 0)
df.loc[valid_constraint, 'meu_14_2_constraint'] = True
df.loc[~valid_constraint, 'meu_14_2_constraint'] = False

但需要注意，如果当日减持比例是NaN的话如何处理？假设该列不会有NaN，或者如果有NaN，则视为没有减持？

假设该列不会有NaN，或者当存在减持计划时，该列会被填充为0或其他值。因此，直接比较即可。

现在，将这些步骤整合到代码中：

编写函数：

def check_meu_14_2(df):
    # 复制df
    df = df.copy()

    # 初始化列
    df['meu_14_2_subject'] = False
    df['meu_14_2_condition'] = False
    df['meu_14_2_constraint'] = None  # 初始化为None，之后填充True/False

    # 标记subject
    valid_subject = df['股东身份'] == '董监高'
    df.loc[valid_subject, 'meu_14_2_subject'] = True

    # 处理condition
    # 筛选处罚或判决事件
    penalty_mask = df['公司涉嫌证券期货违法犯罪事件'].isin(['行政处罚决定作出', '刑事判决作出'])
    penalty_dates = df[penalty_mask][['公司简称', '公告日期']]
    # 按公司分组，取最新日期
    latest_penalty = penalty_dates.groupby('公司简称')['公告日期'].max().reset_index()
    latest_penalty.rename(columns={'公告日期': 'latest_penalty_date'}, inplace=True)
    # 合并到原df
    df = df.merge(latest_penalty, on='公司简称', how='left')
    # 计算日期差
    df['days_since_penalty'] = (df['日期'] - df['latest_penalty_date']).dt.days
    # 条件：日期差在0到180天之间
    valid_condition = (df['days_since_penalty'] >= 0) & (df['days_since_penalty'] <= 180)
    df.loc[valid_condition, 'meu_14_2_condition'] = True

    # 标记constraint
    # 检查当日减持比例是否<=0
    valid_constraint = df['当日减持比例'] <= 0
    df.loc[valid_constraint, 'meu_14_2_constraint'] = True
    df.loc[~valid_constraint, 'meu_14_2_constraint'] = False

    # 删除辅助列
    df.drop(['latest_penalty_date', 'days_since_penalty'], axis=1, inplace=True, errors='ignore')

    return df

但需要注意，合并后的latest_penalty_date可能引入新的列，处理完成后需要删除这些辅助列。

此外，在合并时，可能存在多个公司的情况，merge操作是否正确？

另外，当公司没有处罚记录时，latest_penalty_date为NaN，此时days_since_penalty也是NaN，valid_condition为False，这符合要求。

对于constraint的检查，假设“当日减持比例”列存在，且为数值类型。如果该列存在NaN，可能需要处理，但用户没有说明，所以假设该列不会有NaN，或者NaN视为0？

但根据用户提供的列说明，“当日减持比例”是一个比例，可能为0或正数。所以，如果该列存在NaN，可能表示没有减持，或者数据缺失。但根据用户的数据描述，可能该列不会有NaN，或者需要根据实际情况处理。但根据任务要求，假设数据是完整的，因此可以直接比较。

综上，上述代码应该能够正确标记三个条件的情况。
","CompletionUsage(completion_tokens=5117, prompt_tokens=1721, total_tokens=6838, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=4601, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_10_3
法律的最小可执行单元内容: {""subject"": ""上市公司大股东"", ""condition"": ""因涉及与本上市公司有关的违法违规，被本所公开谴责未满3个月"", ""constraint"": ""不得减持其所持有的本公司股份"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_10_3(df):
    '''
    检查MEU_10_3合规性：
    subject: 上市公司大股东
    condition: 因涉及违法违规被本所公开谴责未满3个月
    constraint: 不得减持股份
    '''
    df = df.copy()
    
    # 初始化合规标记列
    df['meu_10_3_subject'] = False
    df['meu_10_3_condition'] = False
    df['meu_10_3_constraint'] = None
    
    # 1. 验证责任主体
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    df.loc[is_major_shareholder, 'meu_10_3_subject'] = True
    
    # 2. 验证触发条件
    # 获取股东最近公开谴责日期
    condemn_df = df[df['股东涉嫌证券期货违法犯罪事件'] == '被本所公开谴责']
    if not condemn_df.empty:
        last_condemn = condemn_df.groupby(['公司简称', '股东'])['日期'].max().reset_index()
        last_condemn.rename(columns={'日期':'last_condemn_date'}, inplace=True)
        df = df.merge(last_condemn, how='left', on=['公司简称', '股东'])
        # 计算自然日间隔
        df['condemn_days'] = (df['日期'] - df['last_condemn_date']).dt.days
        valid_cond = (df['condemn_days'] <= 90) & df['last_condemn_date'].notna()
        df.loc[valid_cond, 'meu_10_3_condition'] = True
        df.drop(columns=['last_condemn_date', 'condemn_days'], inplace=True)
    else:
        df['meu_10_3_condition'] = False
    
    # 3. 验证约束条件（独立检查所有记录）
    df['meu_10_3_constraint'] = df['当日减持比例'] <= 0
    
    return df
</CODE>","好的，我现在需要处理这个MEU_10_3的合规性检查。首先，我得仔细理解这个MEU的内容。MEU_10_3的subject是“上市公司大股东”，condition是“因涉及与本上市公司有关的违法违规，被本所公开谴责未满3个月”，constraint是“不得减持其所持有的本公司股份”。所以，我需要编写一个函数，检查每个交易日中，每个公司的大股东是否在被公开谴责后的三个月内，如果有的话，他们是否减持了股份，从而判断是否违规。

首先，处理subject部分。根据附加信息中的股东身份列，可能的标签包括控股股东、实际控制人、持股5%以上股东等。但MEU中的subject是“上市公司大股东”，可能需要包括控股股东、实际控制人以及持股5%以上的股东。或者，可能需要根据持股比例来判断，比如持股5%以上的股东。这里可能需要结合股东身份列和持股比例列。例如，如果股东身份是控股股东、实际控制人或持股5%以上股东，或者持股比例大于等于5%，则视为大股东。但根据附加信息中的说明，股东身份列中的标签不会并列出现，所以可能需要同时检查股东身份和持股比例。例如，如果股东身份是控股股东、实际控制人、持股5%以上股东，或者持股比例>=5%，则视为符合subject条件。

接下来是condition部分。条件是股东因涉及与公司有关的违法违规，被本所公开谴责未满3个月。这里需要检查该股东是否有被公开谴责的记录，并且该记录的日期距离当前日期是否在三个月内。但数据中的相关列是“股东涉嫌证券期货违法犯罪事件”，可能包含“被本所公开谴责”的事件。需要确定每个股东被公开谴责的日期，并计算到当前行的日期是否在三个月内。例如，对于每个股东，找到最近一次被公开谴责的日期，然后检查当前行的日期是否在该日期之后的三个月内。

然后是constraint部分，即不得减持股份。需要检查该股东在当天的减持行为是否存在。例如，如果当日减持比例大于0，或者存在减持计划，或者有其他减持相关的指标。根据数据中的列，可能有“当日减持比例”或“存在减持计划”等字段。如果当日减持比例>0，则视为违反约束条件。或者，如果存在减持计划，则可能也需要检查。但MEU中的constraint是“不得减持”，所以实际减持行为才是违规。因此，可能需要检查当日是否有减持行为，即“当日减持比例”是否大于0。

现在，我需要将这些逻辑转化为代码。首先，处理subject：

valid_subject的条件是股东属于上市公司大股东。根据数据中的股东身份列，可能包括控股股东、实际控制人、持股5%以上股东，或者持股比例>=5%的股东。所以，我需要创建一个布尔条件，判断股东身份是否是这些之一，或者持股比例>=5%。例如：

is_major_shareholder = (
    df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
    (df['持股比例'] >= 0.05)
)

这样，valid_subject就是这个条件的结果。

接下来处理condition。需要检查该股东是否被本所公开谴责，并且在被谴责后的三个月内。这里的数据列是“股东涉嫌证券期货违法犯罪事件”，可能包含多个事件，比如“被本所公开谴责”。需要确定每个股东被公开谴责的日期，然后计算当前行的日期是否在该日期之后的三个月内。

但数据中的事件可能以列表形式存在，或者每个事件有对应的日期。但根据提供的列，可能有一个列记录事件类型，比如“股东涉嫌证券期货违法犯罪事件”可能包含事件类型，比如“被本所公开谴责”，但需要对应的日期。但根据提供的列，可能没有直接的日期。这里可能需要假设，当事件发生时，该行的日期即为事件发生的日期。例如，如果某行的“股东涉嫌证券期货违法犯罪事件”是“被本所公开谴责”，则该行的日期即为谴责日期。或者，是否有其他列记录事件发生的日期？

根据提供的列，可能没有直接的日期列。例如，可能有一个列“公告日期”或其他日期列，但需要看具体的数据结构。例如，可能每个事件的发生日期是该行的日期。例如，当某行的“股东涉嫌证券期货违法犯罪事件”为“被本所公开谴责”时，该行的日期即为该事件的发生日期。因此，需要为每个股东记录他们被公开谴责的最新日期，然后检查当前行的日期是否在该日期后的三个月内。

这可能需要按股东分组，找到每个股东最近一次被公开谴责的日期，然后在每个行中比较当前日期是否在该日期后的三个月内。例如：

对于每个股东，找出所有被公开谴责的日期，取最大的那个日期作为last_condemn_date。然后，对于当前行的日期，如果last_condemn_date存在，并且当前日期在last_condemn_date后的三个月内，则condition为True。

但如何实现这个呢？可能需要使用groupby和transform来为每个股东计算最新的谴责日期。

例如，首先筛选出所有被公开谴责的行：

condemn_events = df['股东涉嫌证券期货违法犯罪事件'] == '被本所公开谴责'

然后，对于每个股东，找到他们被公开谴责的日期的最大值：

df['last_condemn_date'] = df.groupby(['公司简称', '股东'])['日期'].transform(lambda x: x.where(condemn_events).max())

这样，每个行的last_condemn_date是该股东最近一次被公开谴责的日期。然后，计算当前日期与last_condemn_date之间的时间差：

df['days_since_condemn'] = (df['日期'] - df['last_condemn_date']).dt.days

然后，valid_condition的条件是days_since_condemn <= 90天（三个月），并且last_condemn_date不为空。

但需要注意，如果股东从未被公开谴责，则last_condemn_date是NaT，此时condition应为False。

所以，valid_condition = (df['days_since_condemn'] <= 90) & (df['last_condemn_date'].notna())

接下来处理constraint。constraint是不得减持股份。因此，需要检查该股东在当天是否有减持行为。根据数据中的列，可能有“当日减持比例”或“累计减持比例”等。如果当日减持比例>0，则视为减持，违反约束条件。因此，valid_constraint应为当日减持比例 <=0，即没有减持。或者，如果存在减持计划，但根据MEU的约束，只要减持就违规，所以需要检查当日是否有减持。

例如：

valid_constraint = df['当日减持比例'] <= 0

或者，如果当日减持比例等于0，则符合约束，否则不符合。但需要注意，如果当日减持比例是NaN的话如何处理？可能需要假设NaN表示没有减持，或者需要填充为0。根据数据描述，可能该列存在数值，所以可能直接判断是否大于0。

所以，valid_constraint = (df['当日减持比例'] <= 0) | (df['当日减持比例'].isna())

或者，假设如果当日减持比例不存在，则没有减持，所以valid_constraint为True。或者，可能该列不会为NaN，而是0。需要根据数据情况处理。这里假设该列存在数值，所以：

valid_constraint = df['当日减持比例'] <= 0

但根据MEU的约束，只要减持就违规，所以如果当日减持比例>0，则constraint为False，否则为True。

现在，将这些逻辑整合到代码中：

首先，初始化三个新列：

df['meu_10_3_subject'] = False
df['meu_10_3_condition'] = False
df['meu_10_3_constraint'] = None

然后，处理subject：

is_major_shareholder = (
    df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
    (df['持股比例'] >= 0.05)
)
df.loc[is_major_shareholder, 'meu_10_3_subject'] = True

处理condition：

首先，筛选出被公开谴责的事件：

condemn_mask = df['股东涉嫌证券期货违法犯罪事件'] == '被本所公开谴责'

然后，按公司和股东分组，找到每个股东的最新谴责日期：

df['last_condemn_date'] = df.groupby(['公司简称', '股东'])['日期'].transform(
    lambda x: x[condemn_mask].max()
)

计算当前日期与last_condemn_date之间的天数差：

df['days_since_condemn'] = (df['日期'] - df['last_condemn_date']).dt.days

valid_condition = (df['days_since_condemn'] <= 90) & (df['last_condemn_date'].notna())
df.loc[valid_condition, 'meu_10_3_condition'] = True

处理constraint：

valid_constraint = df['当日减持比例'] <= 0
df.loc[valid_constraint, 'meu_10_3_constraint'] = True
df.loc[~valid_constraint, 'meu_10_3_constraint'] = False

但需要注意，constraint的检查是独立进行的，即不管subject和condition是否满足，都要检查。例如，即使某个行不满足subject或condition，也要检查constraint是否满足。但根据任务要求中的说明，对于简单操作dataframe的情况，三元组的检查是各自独立的，需要分别标记。因此，constraint的检查是针对所有行的，而不仅仅是subject和condition同时满足的行。

但根据MEU的约束，只有当subject和condition都满足时，才需要遵守constraint。但根据任务要求中的说明，对于简单操作，三元组的检查是各自独立的。所以，这里需要将三个条件分别标记，不管其他条件是否满足。例如，即使某个行不满足subject或condition，也要检查constraint是否满足，并标记。但根据MEU的实际法律要求，只有当subject和condition都满足时，constraint才适用。但根据任务中的要求，这里需要将三个条件独立检查，所以可能constraint的检查是独立于其他条件的。这可能与实际法律逻辑不符，但根据任务要求，必须这样做。

但根据任务中的附加说明：“对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查。” 所以，constraint的检查是独立进行的，不管subject和condition是否满足。例如，即使某行不满足subject或condition，也要检查constraint是否满足，并标记。

但MEU的约束是当subject和condition满足时，才需要遵守constraint。但在这种情况下，任务要求将三个条件独立检查，所以可能constraint的标记是全局的，比如所有行的减持行为都会被检查，而不管是否属于大股东或被谴责的情况。这可能与实际法律逻辑不符，但根据任务要求，必须这样做。

因此，在代码中，constraint的检查是独立进行的，即检查所有行中的减持情况，不管subject和condition是否满足。例如，只要当日减持比例>0，则constraint为False，否则为True。

但根据MEU的约束，只有当subject和condition都满足时，才需要检查constraint。但根据任务要求，这里需要独立检查。这可能是一个矛盾。需要仔细看任务要求中的说明：

“对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)”

因此，当前任务属于简单操作dataframe的情况，所以三个条件独立检查。因此，constraint的检查是独立进行的，不管subject和condition是否满足。例如，所有行都会被检查是否满足constraint，即是否减持，而不管该行是否属于大股东或被谴责的情况。这可能与实际法律逻辑不符，但根据任务要求，必须这样处理。

但这样的话，constraint的标记可能大部分都是True，因为只有减持的才会被标记为False。但根据MEU的约束，只有当subject和condition满足时，减持才违规。但根据任务要求，这里需要将三个条件独立标记，所以必须这样做。

这可能是一个问题，但根据任务要求，必须按照这个方式处理。因此，在代码中，constraint的检查是独立进行的，即检查所有行中的减持情况，不管其他条件。

因此，代码中的constraint部分：

valid_constraint = df['当日减持比例'] <= 0
df['meu_10_3_constraint'] = valid_constraint

或者，如果当日减持比例是NaN的话，如何处理？例如，假设NaN表示没有减持，则valid_constraint为True。或者，如果该列存在NaN，可能需要填充为0。根据数据描述中的说明，可能该列不会有NaN，但需要处理可能的情况。例如：

valid_constraint = (df['当日减持比例'] <= 0) | df['当日减持比例'].isna()

但根据数据描述中的列信息，“当日减持比例”可能存在数值，所以可能不需要处理NaN。或者，可能该列在无减持时为0。因此，直接判断是否<=0即可。

综上，代码的大致结构如下：

首先，处理subject：

标记所有属于大股东的行。

然后，处理condition：

标记所有被公开谴责且在三个月内的行。

然后，处理constraint：

标记所有没有减持的行。

最后，将这三个条件分别标记到对应的列中。

现在，编写代码：

首先，导入必要的库：

import pandas as pd

然后，定义函数：

def check_meu_10_3(df):
    # 复制df，避免修改原数据
    df = df.copy()
    
    # 初始化各列
    df['meu_10_3_subject'] = False
    df['meu_10_3_condition'] = False
    df['meu_10_3_constraint'] = None  # 初始化为None，之后用布尔值填充
    
    # 处理subject：上市公司大股东
    # 判断是否是控股股东、实际控制人、持股5%以上股东，或持股比例>=5%
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    df.loc[is_major_shareholder, 'meu_10_3_subject'] = True
    
    # 处理condition：被本所公开谴责未满3个月
    # 筛选被公开谴责的事件
    condemn_events = df['股东涉嫌证券期货违法犯罪事件'] == '被本所公开谴责'
    # 按公司和股东分组，找到每个股东的最新谴责日期
    df['last_condemn_date'] = df.groupby(['公司简称', '股东'])['日期'].transform(
        lambda x: x[condemn_events.loc[x.index]].max()
    )
    # 计算当前日期与last_condemn_date的天数差
    df['days_since_condemn'] = (df['日期'] - df['last_condemn_date']).dt.days
    # 条件：日期差在90天内，并且last_condemn_date存在
    valid_condition = (df['days_since_condemn'] <= 90) & df['last_condemn_date'].notna()
    df.loc[valid_condition, 'meu_10_3_condition'] = True
    
    # 处理constraint：不得减持
    # 检查当日减持比例是否<=0
    valid_constraint = df['当日减持比例'] <= 0
    # 填充constraint列
    df.loc[valid_constraint, 'meu_10_3_constraint'] = True
    df.loc[~valid_constraint, 'meu_10_3_constraint'] = False
    
    # 删除临时列
    df.drop(columns=['last_condemn_date', 'days_since_condemn'], inplace=True)
    
    return df

但需要注意，groupby中的transform部分是否正确。例如，condemn_events.loc[x.index]是否正确获取了对应分组的条件？

或者，可能更好的方法是，在分组时，对每个分组的数据应用筛选条件。例如：

在分组时，对于每个分组的数据，筛选出被公开谴责的行，然后取最大的日期。例如：

df['last_condemn_date'] = df.groupby(['公司简称', '股东'])['日期'].transform(
    lambda s: s[df['股东涉嫌证券期货违法犯罪事件'] == '被本所公开谴责'].max()
)

但这样在lambda函数中，s是每个分组的日期列，而df['股东涉嫌证券期货违法犯罪事件']可能无法正确对应到分组中的索引。因此，正确的做法是在分组时，将整个DataFrame分组，然后在每个分组中筛选出被公开谴责的行，并取最大日期。

或者，更准确的方法是，在分组时，同时处理每个分组的行：

df_grouped = df.groupby(['公司简称', '股东'])
df['last_condemn_date'] = df_grouped.apply(
    lambda g: g.loc[g['股东涉嫌证券期货违法犯罪事件'] == '被本所公开谴责', '日期'].max()
).reset_index(level=[0,1], drop=True)

但这样可能会有索引对齐的问题。因此，可能更可靠的方法是使用transform，但需要确保在分组时正确筛选条件。

或者，可以创建一个临时列，标记是否被公开谴责，然后使用groupby和transform来获取每个组的最大日期：

df['is_condemn'] = (df['股东涉嫌证券期货违法犯罪事件'] == '被本所公开谴责')
df['last_condemn_date'] = df.groupby(['公司简称', '股东'])['日期'].transform(
    lambda x: x[df['is_condemn']].max()
)

但这样可能不正确，因为x是每个分组的日期列，而df['is_condemn']是整个DataFrame的布尔Series，索引可能不匹配。正确的做法是在每个分组内应用筛选条件：

正确的做法是，在groupby后，对每个分组应用函数，筛选出该分组中被公开谴责的行，然后取最大日期：

df['last_condemn_date'] = df.groupby(['公司简称', '股东']).apply(
    lambda g: g.loc[g['股东涉嫌证券期货违法犯罪事件'] == '被本所公开谴责', '日期'].max()
).reset_index(level=[0,1], drop=True)

但这样会导致索引对齐的问题，因为apply返回的Series的索引可能与原df的索引不一致。因此，使用transform可能更合适，但需要确保在分组内正确筛选。

另一种方法是，先为每个股东计算last_condemn_date：

condemn_dates = df[df['股东涉嫌证券期货违法犯罪事件'] == '被本所公开谴责'].groupby(['公司简称', '股东'])['日期'].max().reset_index()
condemn_dates.rename(columns={'日期': 'last_condemn_date'}, inplace=True)
df = df.merge(condemn_dates, on=['公司简称', '股东'], how='left')

这样，每个股东的last_condemn_date会被合并到df中，未发生谴责的则为NaN。然后计算days_since_condemn：

df['days_since_condemn'] = (df['日期'] - df['last_condemn_date']).dt.days

这可能更可靠，因为merge操作可以正确地将每个股东的last_condemn_date合并到对应的行中。

因此，修改代码中的condition处理部分：

# 处理condition：被本所公开谴责未满3个月
# 筛选出所有被公开谴责的事件
condemn_df = df[df['股东涉嫌证券期货违法犯罪事件'] == '被本所公开谴责']
# 按公司和股东分组，找到每个股东的最新谴责日期
condemn_dates = condemn_df.groupby(['公司简称', '股东'])['日期'].max().reset_index()
condemn_dates.rename(columns={'日期': 'last_condemn_date'}, inplace=True)
# 将last_condemn_date合并到原df中
df = df.merge(condemn_dates, on=['公司简称', '股东'], how='left')
# 计算天数差
df['days_since_condemn'] = (df['日期'] - df['last_condemn_date']).dt.days
# 条件：天数差<=90天，并且last_condemn_date存在
valid_condition = (df['days_since_condemn'] <= 90) & df['last_condemn_date'].notna()
df.loc[valid_condition, 'meu_10_3_condition'] = True
# 删除临时列
df.drop(columns=['last_condemn_date', 'days_since_condemn'], inplace=True)

这样处理可能更可靠，因为merge操作可以正确地将每个股东的最新谴责日期合并到原数据中。

综上，完整的代码如下：

import pandas as pd

def check_meu_10_3(df):
    '''
    检查MEU_10_3的合规性：
    subject: 上市公司大股东
    condition: 因涉及违法违规被本所公开谴责未满3个月
    constraint: 不得减持股份
    '''
    df = df.copy()
    
    # 初始化结果列
    df['meu_10_3_subject'] = False
    df['meu_10_3_condition'] = False
    df['meu_10_3_constraint'] = None
    
    # 处理subject：上市公司大股东
    # 判断是否是控股股东、实际控制人、持股5%以上股东，或持股比例>=5%
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    df.loc[is_major_shareholder, 'meu_10_3_subject'] = True
    
    # 处理condition：被公开谴责未满3个月
    # 筛选被公开谴责的事件
    condemn_mask = df['股东涉嫌证券期货违法犯罪事件'] == '被本所公开谴责'
    condemn_df = df[condemn_mask][['公司简称', '股东', '日期']]
    # 按公司和股东分组，获取最新谴责日期
    condemn_dates = condemn_df.groupby(['公司简称', '股东'])['日期'].max().reset_index()
    condemn_dates.rename(columns={'日期': 'last_condemn_date'}, inplace=True)
    # 合并到原df
    df = df.merge(condemn_dates, on=['公司简称', '股东'], how='left')
    # 计算天数差
    df['days_since_condemn'] = (df['日期'] - df['last_condemn_date']).dt.days
    # 条件：在三个月内且存在谴责日期
    valid_condition = (df['days_since_condemn'] <= 90) & df['last_condemn_date'].notna()
    df.loc[valid_condition, 'meu_10_3_condition'] = True
    
    # 处理constraint：不得减持
    # 检查当日减持比例是否<=0
    valid_constraint = df['当日减持比例'] <= 0
    df.loc[valid_constraint, 'meu_10_3_constraint'] = True
    df.loc[~valid_constraint, 'meu_10_3_constraint'] = False
    
    # 删除临时列
    df.drop(columns=['last_condemn_date', 'days_since_condemn'], inplace=True)
    
    return df

这样，代码应该能够正确标记各条件的情况。需要注意的是，在合并谴责日期时，使用how='left'，这样没有谴责记录的股东的last_condemn_date为NaN，从而在valid_condition中被排除。此外，对于减持比例的检查，假设该列的数值正确，且NaN的情况可能不存在，或者被处理为0。如果存在NaN，可能需要进一步处理，但根据任务描述中的列信息，可能该列不会有NaN。
","CompletionUsage(completion_tokens=5748, prompt_tokens=1704, total_tokens=7452, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=5246, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_16_2
法律的最小可执行单元内容: {""subject"": ""上市公司董监高"", ""condition"": ""上市公司季度报告、业绩预告、业绩快报公告前5日内"", ""constraint"": ""不得买卖本公司股份"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_16_2(df):
    '''
    检查MEU_16_2合规性：
    subject: 上市公司董监高
    condition: 处于季度报告/业绩预告/业绩快报公告前5日内
    constraint: 不得买卖本公司股份
    '''
    df = df.copy()
    
    # 初始化标记列
    df['meu_16_2_subject'] = False
    df['meu_16_2_condition'] = False
    df['meu_16_2_constraint'] = False
    
    # 标记valid的subject（董监高）
    valid_subject = df['股东身份'] == '董监高'
    df.loc[valid_subject, 'meu_16_2_subject'] = True
    
    # 标记valid的condition（公告前5日）
    # 获取有效公告日期
    relevant_ann = df[
        df['公告类型'].isin(['季度报告', '业绩预告', '业绩快报']) 
        & df['公告日期'].notna()
    ]
    ann_dates = relevant_ann[['公司简称', '公告日期']].drop_duplicates()
    
    # 生成所有前5日日期集合
    pre_dates_set = set()
    for _, row in ann_dates.iterrows():
        ann_date = row['公告日期']
        for days_back in range(5, 0, -1):
            pre_date = ann_date - pd.Timedelta(days=days_back)
            pre_dates_set.add((row['公司简称'], pre_date))
    
    # 标记符合条件的日期
    df['meu_16_2_condition'] = df.apply(
        lambda x: (x['公司简称'], x['日期']) in pre_dates_set,
        axis=1
    )
    
    # 标记valid的constraint（无减持）
    valid_constraint = df['当日减持比例'] == 0
    df.loc[valid_constraint, 'meu_16_2_constraint'] = True
    
    return df
</CODE>","好的，我现在需要处理这个MEU_16_2的合规性检查任务。首先，我得仔细理解这个MEU的内容。根据给定的信息，MEU_16_2的subject是“上市公司董监高”，condition是“上市公司季度报告、业绩预告、业绩快报公告前5日内”，constraint是“不得买卖本公司股份”。我的任务是根据这些条件，在输入的DataFrame中标记出各行的合规情况。

首先，我需要确定如何识别subject。根据附加信息中的说明，股东身份列有“董监高”这一项。所以，只要股东身份是“董监高”的行，subject条件就满足。这里需要注意的是，离任董监高可能不算，所以应该只检查股东身份等于“董监高”的情况。

接下来是condition部分。条件是公司在该交易日处于季度报告、业绩预告或业绩快报公告前5日内。这里需要找到每个公司的公告类型为这三种类型之一的记录，并确定该记录的日期是否在公告前5天的窗口期内。例如，如果某公司有一个公告日期是2023-01-10，那么在2023-01-05到2023-01-09之间的日期都属于这个条件范围内。

但这里有个问题：DataFrame中的每一行对应的是某个交易日，而公告日期可能在该行的某个列中。根据提供的列，有“公告类型”和“公告日期”列。因此，我需要检查每一行，如果该行的公司在该行的日期之后的5天内（自然日）有相关公告，那么该行就满足condition条件。或者，更准确地说，该行的日期是否在公告日期的前5个自然日内？

例如，假设某行的日期是D，而该公司在D+5天内（自然日）有一个季度报告、业绩预告或业绩快报的公告，那么D是否属于公告前5日？或者，是否该行的日期处于公告日期的前5个自然日？

根据法律条文的一般理解，这里的“前5日内”应该是指公告日期的前5个自然日，包括公告当天吗？通常，这种规定可能是指公告前的5个自然日，不包括公告日。例如，公告日是D，那么前5日是D-5到D-1。或者可能包括D？需要明确这一点。但根据常规解释，可能是指公告日之前的5个自然日内，即D-5到D-1。例如，如果公告日期是1月10日，那么前5天是1月5日到1月9日。

因此，对于每一行，我需要检查该行的日期是否属于任何该公司的季度报告、业绩预告或业绩快报公告日期的前5个自然日。也就是说，对于每个公司，遍历其所有相关公告日期，然后检查当前行的日期是否在某个公告日期的前5天内。

但如何操作呢？因为DataFrame中的每一行可能对应不同的公司和不同的日期，所以需要按公司分组，然后对于每个公司，找到所有符合条件的公告日期，然后检查该行的日期是否在这些公告日期的前5天内。

具体来说，对于每个公司，收集其所有公告类型为“季度报告”、“业绩预告”、“业绩快报”的公告日期。然后，对于该公司的每一行数据，检查该行的日期是否在任何一个公告日期的前5天（自然日）内。如果是，则condition条件满足。

这里需要注意的是，公告日期可能在该行的日期之后。例如，某行的日期是1月5日，而公告日期是1月10日。那么，1月5日是否在1月10日的前5天内？是的，因为1月10日的前5天是1月5日到1月9日。所以，如果该行的日期是1月5日，并且存在一个公告日期为1月10日，那么该行满足condition条件。

因此，处理步骤可能如下：

1. 按公司分组，收集所有符合条件的公告日期。
2. 对于每个公司的每一行，检查该行的日期是否在任何一个公告日期的前5天自然日内。
3. 如果是，则标记condition为True。

接下来是constraint部分，即“不得买卖本公司股份”。这里需要确定该股东在该交易日是否有买卖行为。但DataFrame中是否有相关的列？根据提供的列，有“当日减持比例”这一列。如果当日减持比例大于0，则表示该股东在该交易日减持了股份，即卖出了股份。因此，如果当日减持比例>0，则违反constraint，即constraint应为False。反之，如果当日减持比例为0，则符合constraint，即True。

但需要注意，这里的constraint是“不得买卖”，所以无论是买入还是卖出都是不允许的。但根据提供的列，可能只能通过减持来判断卖出。如果股东在该日买入股份，是否有对应的列？比如是否有“当日增持比例”这样的列？但提供的列中没有这个信息。因此，可能只能根据减持来判断卖出行为。因此，假设如果当日减持比例>0，则视为卖出，违反规定。如果当日减持比例为0，则视为没有买卖，符合规定。

因此，constraint的检查条件是：当日减持比例是否等于0。如果是，则满足constraint（即True），否则不满足（False）。

现在，将这三个条件分别处理：

Subject：股东身份是否为“董监高”；
Condition：该行日期是否处于该公司任何季度报告、业绩预告、业绩快报公告日期的前5个自然日内；
Constraint：当日减持比例是否为0。

需要注意的是，根据任务要求，这三个条件的检查是独立的，即每个条件都要单独标记，而不是仅在subject和condition都满足的情况下检查constraint。但根据问题中的附加说明：“对于简单操作dataframe就可以处理的项目，对三元组<subject, conditon, constrain>的检查是各自独立的，你需要分别标记三元组的True和False。并不是只对符合subject和condition进行检查。”因此，这三个条件需要分别标记，不管其他条件是否满足。

现在，如何实现这些条件？

首先，处理subject：

df['meu_16_2_subject'] = df['股东身份'] == '董监高'

然后处理condition：

需要按公司分组，找到每个公司的相关公告日期，然后对于每个日期，检查是否在任何一个公告日期的前5天内。

例如，对于每个公司，收集所有公告类型为“季度报告”、“业绩预告”、“业绩快报”的公告日期。然后，对于该公司的每一行，检查该行的日期是否在任何一个公告日期的前5天自然日内。

如何实现这一点？

首先，筛选出符合条件的公告：

公告类型列是“公告类型”，可能的值包括季度报告、业绩预告、业绩快报等。所以，先创建一个布尔掩码，选出这些公告类型：

relevant_announcements = df['公告类型'].isin(['季度报告', '业绩预告', '业绩快报'])

然后，按公司简称分组，收集每个公司的相关公告日期：

company_announcements = df[relevant_announcements].groupby('公司简称')['公告日期'].apply(lambda x: x.unique())

然后，对于每个公司的每一行，检查该行的日期是否在任何一个公告日期的前5天内。

这可能需要使用apply函数，或者更高效的方法。例如，对于每个公司，创建一个所有相关公告日期的列表，然后对于该公司的每一行日期，检查是否存在一个公告日期，使得该行日期 >= (公告日期 - 5天) 并且该行日期 < 公告日期。

但如何高效地实现这一点？

另一种方法是，对于每个公司，生成所有可能的日期范围（公告日期的前5天），然后检查该行的日期是否在这些日期范围内。

例如，对于每个公告日期，生成一个日期范围：start_date = 公告日期 - pd.Timedelta(days=5)，end_date = 公告日期 - pd.Timedelta(days=1)。然后，该行的日期如果在任何这样的区间内，则condition为True。

这可能需要为每个公司生成所有这样的区间，然后检查每个日期是否落在这些区间内。

但这个过程可能比较耗时，特别是当数据量大的时候。有没有更高效的方法？

或者，可以针对每个公司，将所有的公告日期转换为前5天的日期范围，然后对于该公司的每一行日期，检查是否在任何一个日期范围内。

例如，对于某公司，有一个公告日期是2023-01-10，那么对应的日期范围是2023-01-05到2023-01-09。如果该公司的某行日期是2023-01-06，则满足条件。

在代码中，可以这样做：

对于每个公司，获取所有相关的公告日期，然后对于每个公告日期，计算前5天的日期范围，然后检查该行的日期是否在任何一个范围内。

这可以通过以下步骤实现：

1. 创建一个新的DataFrame，包含所有符合条件的公告日期及其对应的公司简称。
2. 对每个公告日期，生成一个日期范围列表，即从公告日期-5天到公告日期-1天。
3. 对于每个公司，合并所有相关的日期范围。
4. 对于原始DataFrame中的每一行，检查该行的日期是否在该公司的任何日期范围内。

但这种方法可能比较复杂，因为需要处理日期范围。另一种方法是，对于每个公司的每个公告日期，计算该行的日期是否在公告日期的前5天内。

例如，对于某行的日期date_row，如果存在一个公告日期date_announce，使得 date_row >= (date_announce - 5 days) 并且 date_row < date_announce，则condition为True。

这可以通过对每个公司，遍历其所有相关公告日期，并检查该行的日期是否满足上述条件。

在代码中，可以这样做：

首先，筛选出所有符合条件的公告，按公司分组，得到每个公司的公告日期列表：

relevant_announcements = df[df['公告类型'].isin(['季度报告', '业绩预告', '业绩快报'])]
company_ann_dates = relevant_announcements.groupby('公司简称')['公告日期'].apply(lambda x: x.unique())

然后，对于原始DataFrame中的每一行，获取该公司对应的公告日期列表，并检查该行的日期是否在任何一个公告日期的前5天内。

这可以通过使用groupby和transform来实现吗？或者可能需要使用merge操作？

或者，可以创建一个辅助列，对于每一行，检查是否存在同一公司的公告日期，使得该行的日期在公告日期的前5天内。

例如：

df['meu_16_2_condition'] = False

for idx, row in df.iterrows():
    company = row['公司简称']
    current_date = row['日期']
    ann_dates = company_ann_dates.get(company, [])
    for ann_date in ann_dates:
        if (current_date >= (ann_date - pd.Timedelta(days=5))) and (current_date < ann_date):
            df.at[idx, 'meu_16_2_condition'] = True
            break

但这种方法在数据量大时效率很低，因为需要逐行遍历。有没有更高效的方法？

另一种思路是，对每个公告日期，生成对应的日期范围，然后将原始DataFrame与这些日期范围进行合并，从而标记出所有在范围内的日期。

例如，创建一个辅助DataFrame，其中每个公告日期对应5行，即公告日期前5天到前1天。然后，将原始DataFrame与这个辅助DataFrame合并，根据公司简称和日期匹配，来标记condition为True。

具体步骤如下：

1. 筛选出所有符合条件的公告，得到每个公司的公告日期。
2. 对每个公告日期，生成对应的前5天日期列表。
3. 将这些日期展开，形成一个新的DataFrame，其中每个公司简称对应的日期是公告前5天的日期。
4. 将原始DataFrame与这个新的DataFrame进行左合并，如果匹配到，则condition为True。

例如：

# 步骤1：筛选符合条件的公告
relevant_announcements = df[df['公告类型'].isin(['季度报告', '业绩预告', '业绩快报'])][['公司简称', '公告日期']].drop_duplicates()

# 步骤2：生成每个公告日期的前5天日期
def generate_pre_dates(row):
    ann_date = row['公告日期']
    pre_dates = [ann_date - pd.Timedelta(days=i) for i in range(5, 0, -1)]  # 前5天到前1天
    return pd.DataFrame({'公司简称': row['公司简称'], 'pre_date': pre_dates})

pre_dates_df = relevant_announcements.apply(generate_pre_dates, axis=1).reset_index(drop=True)

# 步骤3：展开pre_dates_df
pre_dates_df = pd.concat(pre_dates_df.tolist(), ignore_index=True)

# 步骤4：合并原始df和pre_dates_df，标记condition
df = df.merge(pre_dates_df, left_on=['公司简称', '日期'], right_on=['公司简称', 'pre_date'], how='left')
df['meu_16_2_condition'] = ~df['pre_date'].isna()
df.drop('pre_date', axis=1, inplace=True)

这种方法可能更高效，因为它利用向量化操作而不是逐行循环。但需要注意，当公告日期很多时，pre_dates_df可能会变得很大，但考虑到每个公告生成5行，这可能还是可行的。

现在，处理constraint：

constraint是“不得买卖本公司股份”，即当日减持比例是否为0。因此：

df['meu_16_2_constraint'] = df['当日减持比例'] == 0

但根据任务要求，constraint的检查是独立的，即不管subject和condition是否满足，都要标记。因此，所有行的constraint都会被检查，只要当日减持比例等于0，就标记为True，否则False。

最后，将这三个条件分别标记到对应的列中。

现在，将这些步骤整合到代码中：

首先，初始化三个列：

df['meu_16_2_subject'] = False
df['meu_16_2_condition'] = False
df['meu_16_2_constraint'] = None  # 或者初始化为False？

根据示例中的代码，初始化为False，然后根据条件设置为True。但根据任务要求，这三个条件需要分别标记各自的True或False，不管其他条件如何。因此，正确的做法是：

对于subject，初始化为False，然后符合条件的设为True；

对于condition，同样初始化为False，符合条件的设为True；

对于constraint，初始化为False，然后符合条件的设为True，否则False。

但示例中的代码将constraint初始化为None，然后根据条件设置为True或False。这可能是因为在示例中，constraint的检查可能比较复杂，需要先处理。但根据当前任务，constraint的条件比较简单，可以直接用布尔值。

现在，编写代码：

首先，处理subject：

df['meu_16_2_subject'] = (df['股东身份'] == '董监高')

然后处理condition：

需要生成每个公司的相关公告日期，并检查日期是否在公告前5天内。这里采用合并的方法：

# 筛选符合条件的公告
relevant_ann = df[df['公告类型'].isin(['季度报告', '业绩预告', '业绩快报'])]
# 提取公司简称和公告日期，去重
ann_dates = relevant_ann[['公司简称', '公告日期']].drop_duplicates()

# 生成每个公告日期的前5天日期
pre_dates_list = []
for _, row in ann_dates.iterrows():
    ann_date = row['公告日期']
    company = row['公司简称']
    for days in range(5, 0, -1):
        pre_date = ann_date - pd.Timedelta(days=days)
        pre_dates_list.append({'公司简称': company, 'pre_date': pre_date})

pre_dates_df = pd.DataFrame(pre_dates_list)

# 合并到原始df，标记condition
merged = df.merge(pre_dates_df, left_on=['公司简称', '日期'], right_on=['公司简称', 'pre_date'], how='left')
df['meu_16_2_condition'] = merged['pre_date'].notna()

或者，更高效的方式可能使用isin，但需要构造一个多索引：

# 创建公司简称和pre_date的集合
pre_dates_set = set(zip(pre_dates_df['公司简称'], pre_dates_df['pre_date']))

# 检查原始df中的每一行是否在该集合中
df['meu_16_2_condition'] = df.apply(lambda row: (row['公司简称'], row['日期']) in pre_dates_set, axis=1)

这种方法可能更高效，因为利用了集合的快速查找。

最后处理constraint：

df['meu_16_2_constraint'] = (df['当日减持比例'] == 0)

但需要注意，如果当日减持比例是NaN的话，如何处理？根据数据描述，可能该列不会有NaN，或者需要填充为0？假设该列中，没有减持的情况下，当日减持比例为0，否则为正值。因此，直接比较即可。

现在，将所有步骤整合到函数中：

import pandas as pd

def check_meu_16_2(df):
    '''
    检查MEU_16_2的合规性：
    subject: 上市公司董监高
    condition: 上市公司季度报告、业绩预告、业绩快报公告前5日内
    constraint: 不得买卖本公司股份
    '''
    df = df.copy()
    
    # 初始化标记列
    df['meu_16_2_subject'] = False
    df['meu_16_2_condition'] = False
    df['meu_16_2_constraint'] = False
    
    # 标记subject
    valid_subject = df['股东身份'] == '董监高'
    df.loc[valid_subject, 'meu_16_2_subject'] = True
    
    # 标记condition
    # 筛选符合条件的公告类型
    relevant_ann = df[df['公告类型'].isin(['季度报告', '业绩预告', '业绩快报'])]
    # 获取所有公司简称和对应的公告日期
    ann_dates = relevant_ann[['公司简称', '公告日期']].drop_duplicates()
    
    # 生成所有前5天的日期
    pre_dates_list = []
    for _, row in ann_dates.iterrows():
        ann_date = row['公告日期']
        company = row['公司简称']
        for days_back in range(1, 6):  # 前5天到前1天，共5天
            pre_date = ann_date - pd.Timedelta(days=days_back)
            pre_dates_list.append((company, pre_date))
    
    # 转换为集合以便快速查找
    pre_dates_set = set(pre_dates_list)
    
    # 检查每一行是否在pre_dates_set中
    df['meu_16_2_condition'] = df.apply(
        lambda row: (row['公司简称'], row['日期']) in pre_dates_set, 
        axis=1
    )
    
    # 标记constraint
    valid_constraint = df['当日减持比例'] == 0
    df.loc[valid_constraint, 'meu_16_2_constraint'] = True
    
    return df

但需要注意，生成pre_dates_list时，days_back应该是从5到1，因为前5天到前1天。例如，如果公告日期是D，那么前5天是D-5，D-4，D-3，D-2，D-1。因此，循环应该是days_back in range(5,0,-1)，即5,4,3,2,1。或者，使用range(1,6)的话，days_back是1到5，这样D - days_back会得到D-1到D-5，即前1天到前5天。但这样生成的日期是D-1到D-5，即前5天包括D-5到D-1？

例如，假设公告日期是2023-01-10：

当days_back=5时，pre_date = 2023-01-10 - 5 days = 2023-01-05

当days_back=4，pre_date=2023-01-06

依此类推，直到days_back=1，pre_date=2023-01-09.

这样，生成的pre_dates是D-5到 D-1，即前5天到前1天，共5天。因此，正确的循环应该是days_back从5到1：

for days_back in range(5, 0, -1):

或者，使用range(1,6)的话，days_back是1到5，那么pre_date是D-1到D-5，即前1天到前5天。这样，日期顺序是D-1, D-2, D-3, D-4, D-5。但不管顺序如何，只要日期正确即可。

因此，在代码中，正确的循环应该是：

for days_back in range(1,6):

这样，days_back是1到5，pre_date是D - days_back days，即从D-1到D-5，共5天。例如：

D = 2023-01-10

days_back=1 → 2023-01-09

days_back=2 → 2023-01-08

...

days_back=5 → 2023-01-05

这样，生成的pre_dates是公告日期的前1天到前5天，即公告前5日内（自然日）。因此，正确的日期范围是D-5到 D-1，共5天。

因此，在代码中，循环应该是：

for days_back in range(1,6):

或者，更直观的写法是：

for days_back in range(5, 0, -1):

但结果是一样的，因为days_back的值是5,4,3,2,1，所以pre_date是D-5, D-4, D-3, D-2, D-1。

因此，在代码中，正确的循环应该是：

for days_back in range(5, 0, -1):

或者，更简单的方式是：

for days_back in range(5):
    days_back += 1  # 1到5

或者，更直接的方式：

for days_back in [5,4,3,2,1]:

但这样写不够灵活。因此，正确的循环应该是：

for days_back in range(5, 0, -1):

这样，days_back从5到1，每次减1。

因此，在生成pre_dates_list时，应该这样写：

for days_back in range(5, 0, -1):

这样，pre_date = ann_date - pd.Timedelta(days=days_back)

例如，当days_back=5时，pre_date是ann_date -5天，即前5天。

这样，生成的pre_dates_list中的每个日期都是公告日期的前5天到前1天。

现在，修正代码中的循环部分：

在生成pre_dates_list时：

for days_back in range(5, 0, -1):

或者，更改为：

for days_back in range(5, 0, -1):

这样，每个公告日期会生成5个pre_date，即前5天到前1天。

因此，修正后的代码部分：

pre_dates_list = []
for _, row in ann_dates.iterrows():
    ann_date = row['公告日期']
    company = row['公司简称']
    for days_back in range(5, 0, -1):
        pre_date = ann_date - pd.Timedelta(days=days_back)
        pre_dates_list.append((company, pre_date))

或者，等价地：

for days_back in range(1,6):
    pre_date = ann_date - pd.Timedelta(days=6 - days_back)

但可能更简单的方式是直接循环5次，每次减去不同的天数。

现在，测试一下：

假设公告日期是2023-01-10，那么生成的pre_dates应该是：

2023-01-05 (10-5), 2023-01-06 (10-4), 2023-01-07 (10-3), 2023-01-08 (10-2), 2023-01-09 (10-1)

这样，每个pre_date都是公告日期的前5天到前1天。

因此，在代码中，循环days_back从5到1，每次减1，是正确的。

现在，回到代码中的循环部分：

for days_back in range(5, 0, -1):

这样，days_back依次是5,4,3,2,1，pre_date依次是ann_date -5, ann_date-4, ..., ann_date-1。

这样生成的pre_dates是正确的。

因此，代码中的循环部分应该这样写。

现在，整合到函数中：

def check_meu_16_2(df):
    df = df.copy()
    
    # 初始化标记列
    df['meu_16_2_subject'] = False
    df['meu_16_2_condition'] = False
    df['meu_16_2_constraint'] = False
    
    # 标记subject
    valid_subject = df['股东身份'] == '董监高'
    df.loc[valid_subject, 'meu_16_2_subject'] = True
    
    # 标记condition
    # 筛选符合条件的公告类型
    relevant_ann = df[df['公告类型'].isin(['季度报告', '业绩预告', '业绩快报'])]
    ann_dates = relevant_ann[['公司简称', '公告日期']].drop_duplicates()
    
    pre_dates_list = []
    for _, row in ann_dates.iterrows():
        ann_date = row['公告日期']
        company = row['公司简称']
        for days_back in range(5, 0, -1):
            pre_date = ann_date - pd.Timedelta(days=days_back)
            pre_dates_list.append((company, pre_date))
    
    pre_dates_set = set(pre_dates_list)
    
    df['meu_16_2_condition'] = df.apply(
        lambda row: (row['公司简称'], row['日期']) in pre_dates_set,
        axis=1
    )
    
    # 标记constraint
    valid_constraint = df['当日减持比例'] == 0
    df.loc[valid_constraint, 'meu_16_2_constraint'] = True
    
    return df

这样，代码应该可以正确标记各条件。

但需要注意，当公告日期为NaT时，如何处理？例如，如果某行的公告类型是符合条件的，但公告日期为空，这会导致错误。因此，在筛选relevant_ann时，应该排除公告日期为空的情况：

relevant_ann = df[df['公告类型'].isin(['季度报告', '业绩预告', '业绩快报']) & df['公告日期'].notna()]

因此，在代码中，应该添加这个条件：

relevant_ann = df[df['公告类型'].isin(['季度报告', '业绩预告', '业绩快报']) & df['公告日期'].notna()]

这样可以避免处理无效的日期。

另外，在生成pre_dates_list时，如果ann_date是NaT，会导致错误。因此，必须确保ann_dates中的公告日期都是有效的。

因此，修正后的代码：

# 筛选符合条件的公告类型，并排除公告日期为空的情况
relevant_ann = df[df['公告类型'].isin(['季度报告', '业绩预告', '业绩快报']) & df['公告日期'].notna()]
ann_dates = relevant_ann[['公司简称', '公告日期']].drop_duplicates()

这样，确保ann_dates中的每个公告日期都是有效的。

现在，代码应该能够正确处理这些情况。

最后，测试一下：

假设某公司有一个公告日期为2023-01-10，类型为季度报告。那么，该公司的股东在2023-01-05到2023-01-09期间的任何交易日的condition会被标记为True。例如，某行的日期是2023-01-05，公司简称匹配，则condition为True。

对于subject，只有当股东身份是董监高时，subject标记为True。

对于constraint，只要当日减持比例为0，就标记为True，否则False。

这样，代码应该满足要求。
","CompletionUsage(completion_tokens=6500, prompt_tokens=1701, total_tokens=8201, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=6042, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_12_2
法律的最小可执行单元内容: {""subject"": ""上市公司控股股东 | 实际控制人 | 一致行动人"", ""condition"": ""计划通过集中竞价交易或大宗交易减持股份且首次披露减持计划, 且不存在已经按照本指引第四条披露减持计划，或者中国证监会另有规定的情况的"", ""constraint"": ""不得存在下列情形：最近20个交易日内，上市公司任一交易日股票收盘价低于最近一个会计年度或者最近一期财务会计报告期末每股归属于上市公司股东的净资产"", ""contextual_info"": ""股票收盘价以最近一个会计年度或者最近一期财务会计报告资产负债表日为基准分别向后复权计算""}
必要的额外信息: 不考虑中国证监会另有规定的情况


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_12_2(df):
    '''
    验证MEU_12_2合规性：
    subject: 上市公司控股股东 | 实际控制人 | 一致行动人
    condition: 计划通过集中竞价或大宗交易减持且首次披露计划
    constraint: 最近20个交易日内收盘价不低于最近财务报告每股净资产
    
    处理逻辑：
    1. subject验证控股股东和实际控制人（一致行动人无数据支持）
    2. condition验证交易方式、减持计划及首次披露
    3. constraint验证复权后股价与净资产关系
    '''
    df = df.copy()
    
    # 初始化结果列
    df['meu_12_2_subject'] = False
    df['meu_12_2_condition'] = False
    df['meu_12_2_constraint'] = None
    
    # 1. SUBJECT验证（控股股东/实际控制人）
    valid_subject = df['股东身份'].isin(['控股股东', '实际控制人'])
    df.loc[valid_subject, 'meu_12_2_subject'] = True
    
    # 2. CONDITION验证
    # 交易方式验证
    valid_trade_type = df['减持方式'].isin(['竞价交易', '大宗交易'])
    # 首次披露验证（按股东维度）
    df_sorted = df.sort_values(by='日期')
    first_disclosure = (
        df_sorted.groupby(['公司简称', '股东'], group_keys=False)
        ['存在减持计划'].transform(lambda x: x & (x.cumsum() == 1))
    )
    valid_condition = valid_trade_type & df['存在减持计划'] & first_disclosure
    df.loc[valid_condition, 'meu_12_2_condition'] = True
    
    # 3. CONSTRAINT验证
    # 计算复权价格并判断
    df['复权收盘价'] = df['收盘价'] * df['复权因子']
    df['price_below_na'] = df['复权收盘价'] < df['每股净资产']
    
    # 按公司维度滚动检查20交易日
    df_sorted = df.sort_values(by='日期')
    window_check = (
        df_sorted.groupby('公司简称', group_keys=False)
        ['price_below_na'].rolling(window=20, min_periods=1)
        .apply(lambda x: x.any()).astype(bool)
    )
    df['constraint_violated'] = window_check.reset_index(level=0, drop=True)
    df['meu_12_2_constraint'] = ~df['constraint_violated']
    
    # 清理中间列
    df.drop(['复权收盘价', 'price_below_na', 'constraint_violated'], 
            axis=1, inplace=True)
    
    return df
</CODE>","好的，我现在需要处理这个任务，编写一个函数来检查MEU_12_2的合规性。首先，我得仔细理解这个MEU的内容和要求。

首先，MEU_12_2的subject是“上市公司控股股东 | 实际控制人 | 一致行动人”。所以，我需要确定在数据中哪些行对应的股东属于这三个类别之一。根据数据中的“股东身份”列，可能的值包括“控股股东”、“实际控制人”等。但可能没有直接标明“一致行动人”，所以可能需要根据其他条件来判断，比如是否有共同行动关系。不过，数据中可能没有直接的字段，这里可能需要假设“一致行动人”是否被包含在现有字段中，或者是否需要其他处理。但根据附加信息中的说明，股东身份的标签不会并列出现，所以可能无法直接判断一致行动人。这可能是个问题。但根据任务中的示例，比如MEU_4_1的处理，可能用户希望我们仅根据现有的“股东身份”列来判断，而一致行动人可能需要其他方式处理。或者可能用户希望我们暂时忽略一致行动人，或者是否有其他字段可用？比如，可能数据中没有相关字段，所以可能需要用户说明如何处理。但根据当前的信息，可能无法处理一致行动人，所以可能需要暂时忽略，或者假设一致行动人没有被单独标记，因此无法正确识别。这可能是一个问题，但根据任务要求，可能需要根据现有字段处理。因此，可能只能处理控股股东和实际控制人，而一致行动人可能无法识别。或者，可能用户希望我们通过其他方式，比如股东是否属于同一集团，但数据中没有相关信息。因此，可能需要暂时忽略一致行动人，或者假设该字段不存在，所以MEU的subject部分只能检查控股股东和实际控制人。或者，可能用户希望我们通过持股比例或其他条件来推断，但根据附加信息中的说明，股东身份的标签不会并列出现，所以可能无法。因此，可能在这个任务中，subject的条件只能检查股东身份是否为控股股东或实际控制人。这可能是一个限制，但根据现有数据，只能这样处理。

接下来是condition：“计划通过集中竞价交易或大宗交易减持股份且首次披露减持计划，且不存在已经按照本指引第四条披露减持计划，或者中国证监会另有规定的情况的”。这里需要满足两个条件：减持方式为集中竞价或大宗交易，并且是首次披露减持计划，同时没有已经按照第四条披露的情况，或者中国证监会另有规定的情况。但根据必要的额外信息，不考虑中国证监会另有规定的情况。因此，condition的条件可以简化为：减持方式为集中竞价或大宗交易，且存在减持计划（即首次披露），并且没有已经按照第四条披露的情况。但如何判断是否已经按照第四条披露过？可能数据中没有相关字段，或者需要根据其他列来判断。例如，可能“存在减持计划”列是否表示首次披露？或者是否有其他列如“计划披露日”等。例如，在示例中，检查是否存在减持计划可能用到了“存在减持计划”列。因此，可能这里的条件需要判断减持方式是否正确，并且存在减持计划，并且是首次披露。首次披露可能需要检查该股东是否之前没有披露过减持计划。这可能需要按公司和股东分组，检查在之前的日期中是否存在减持计划。例如，对于每个股东，在首次出现存在减持计划为True的行时，才视为首次披露。否则，如果之前已经有减持计划，则不符合条件。因此，condition的条件可能需要分组处理，判断该行是否是首次披露减持计划。

然后是constraint：“不得存在下列情形：最近20个交易日内，上市公司任一交易日股票收盘价低于最近一个会计年度或者最近一期财务会计报告期末每股归属于上市公司股东的净资产”。这里的约束条件是，在最近20个交易日内，任何一天的收盘价都不能低于每股净资产。这里的每股净资产可能需要根据contextual_info中的说明来计算，即股票收盘价以最近一个会计年度或最近一期财务报告的资产负债表日为基准向后复权计算。因此，需要确定每个交易日对应的最近一个会计年度或最近一期的每股净资产，然后复权后的收盘价是否低于该值。但数据中有“每股净资产”列，可能是否需要复权处理？例如，可能需要用复权因子来调整收盘价。例如，复权后的收盘价 = 收盘价 * 复权因子。然后比较复权后的收盘价是否低于每股净资产。或者，可能每股净资产已经根据复权调整过？这可能需要明确。根据contextual_info，可能需要将收盘价向后复权到最近一个会计年度或最近一期财务报告的资产负债表日。例如，假设资产负债表日对应的复权因子，那么当天的收盘价乘以复权因子得到复权后的价格，然后比较是否低于当时的每股净资产。或者，可能每股净资产是已经根据复权调整后的数值？这可能需要进一步分析数据中的列。例如，数据中有“复权因子”列，可能每个交易日的复权因子不同，因此需要计算每个交易日的复权收盘价，然后比较该价格是否低于对应的每股净资产。但如何确定每股净资产的值？例如，每个会计年度或每期财务报告后的每股净资产可能不同。例如，假设最近一个会计年度的每股净资产是最近一次年报中的数值，而最近一期的可能是季报中的数值。但数据中的“每股净资产”列可能是指当前交易日的每股净资产？或者可能每股净资产是静态的，根据最近的财务报告更新？这可能需要假设数据中的每股净资产列已经是最新的，即每个交易日对应的最近一个会计年度或最近一期的每股净资产。或者，可能需要根据财务报告的发布日期来更新每股净资产的值。例如，当公司发布新的财务报告时，每股净资产更新为新的数值。但数据中的处理可能比较复杂。例如，可能需要按公司分组，找到每个交易日对应的最近财务报告日的每股净资产。这可能比较复杂，但数据中是否有相关的列？例如，可能有“公告类型”列，其中包含财务报告的发布，如年报、季报等。但如果没有，可能需要假设每股净资产列已经正确反映了最近的数据。例如，数据中的“每股净资产”列在每个交易日都是最新的，即已经考虑了所有已发布的财务报告。因此，在计算时，可以直接使用该列的当前值。或者，可能需要根据财务报告的日期来确定。例如，每个财务报告发布后，每股净资产更新为新的数值。但如果没有相关的时间信息，可能需要简化处理，假设每股净资产是当前交易日的最新值。这可能是一个假设，但根据数据中的列，可能只能这样处理。

现在，我需要将这些逻辑转化为代码。

首先，处理subject部分。根据MEU的subject，需要标记股东是否为控股股东、实际控制人或一致行动人。但数据中的“股东身份”列可能只有“控股股东”和“实际控制人”，而一致行动人可能没有对应的标签。因此，可能无法正确识别一致行动人。因此，可能需要暂时忽略一致行动人，或者假设该情况不存在。或者，可能用户希望我们通过其他方式判断，比如是否存在一致行动人的关联股东，但数据中没有相关信息。因此，可能只能处理控股股东和实际控制人。因此，valid_subject的条件是股东身份为“控股股东”或“实际控制人”。

接下来是condition部分。条件包括减持方式为集中竞价或大宗交易，且首次披露减持计划，并且没有已经按照第四条披露的情况。根据必要信息，不考虑中国证监会的情况。因此，需要检查减持方式是否为竞价交易或大宗交易（数据中的“减持方式”列是否为这两个值之一），并且存在减持计划（“存在减持计划”列为True），并且是首次披露。首次披露需要按股东和公司分组，检查当前行的日期是否是该股东首次出现存在减持计划为True的情况。例如，对于每个（公司简称，股东）的组合，找到该组合中所有存在减持计划为True的日期，并判断当前行的日期是否是其中的第一个。如果是，则满足首次披露的条件。否则，不满足。此外，还需要排除已经按照第四条披露的情况，但数据中可能没有相关字段，因此可能无法处理这部分，但根据必要信息，可能第四条的情况可能不存在，或者用户希望我们忽略，因此可能暂时不考虑这部分。或者，可能第四条的情况对应其他MEU，但当前任务中不需要处理。因此，condition的条件是：减持方式为集中竞价或大宗交易，存在减持计划为True，并且是首次披露减持计划。

然后是constraint部分。需要检查最近20个交易日内，任何一天的收盘价（复权后）是否低于每股净资产。这里的每股净资产是最近一个会计年度或最近一期的数值，而收盘价需要复权计算。例如，复权后的收盘价 = 收盘价 * 复权因子。然后比较复权后的收盘价是否低于每股净资产。但数据中的“每股净资产”是否是已经复权后的数值？或者是否需要根据财务报告的时间点来计算？例如，假设每股净资产是最近一个会计年度的数值，那么需要找到该会计年度的资产负债表日，然后计算复权后的收盘价。这可能比较复杂。或者，可能每股净资产列已经是根据最近财务报告更新的，因此可以直接使用当前行的每股净资产值。例如，每个交易日的每股净资产是该日最新的财务报告中的数值。因此，复权后的收盘价是否低于该日的每股净资产？或者，是否需要比较当前行的复权收盘价与最近一个会计年度或最近一期的每股净资产？

根据contextual_info的说明，股票收盘价以最近一个会计年度或者最近一期财务会计报告资产负债表日为基准分别向后复权计算。因此，可能需要确定每个交易日对应的最近会计年度或最近一期的资产负债表日，然后获取该日的每股净资产，并将当前收盘价复权到该日，再进行比较。例如，对于每个交易日，找到最近的资产负债表日（比如年报的日期或季报的日期），然后获取该日的每股净资产，并将当前收盘价乘以复权因子（从当前交易日到该资产负债表日的复权因子）来计算复权后的价格，然后比较是否低于该日的每股净资产。这可能比较复杂，因为需要确定每个交易日对应的最近资产负债表日，并计算复权因子。但数据中是否有相关的信息？

例如，数据中有“复权因子”列，可能每个交易日都有一个复权因子，用于调整价格到某个基准日。例如，复权因子可能用于将当前价格调整到最新财务报告的基准日。因此，复权后的收盘价 = 收盘价 * 复权因子。然后，比较复权后的收盘价是否低于该基准日的每股净资产。例如，假设基准日是该财务报告的资产负债表日，那么该日的每股净资产即为该财务报告中的数值。因此，数据中的“每股净资产”列可能已经对应到该基准日的数值。因此，复权后的收盘价是否低于该基准日的每股净资产？

例如，假设当前行的复权因子是用于调整到最近一个会计年度的资产负债表日，那么复权后的收盘价即为该日的价格，而每股净资产是该日的数值。因此，比较复权后的收盘价是否低于该日的每股净资产。或者，可能每股净资产已经是复权后的数值？这可能需要明确。根据contextual_info，可能需要将收盘价复权到资产负债表日，然后比较是否低于该日的每股净资产。因此，复权后的收盘价 = 收盘价 * 复权因子。然后，该日的每股净资产即为资产负债表日的数值。因此，在数据中，可能需要将每个交易日的收盘价乘以复权因子，得到复权后的价格，然后比较是否低于该行的每股净资产。或者，可能复权因子已经将每股净资产调整到当前交易日？这可能需要进一步分析。

例如，假设复权因子是向后复权，即调整历史价格到当前交易日。例如，复权因子为1.0表示没有调整，如果股票发生分红或拆股，复权因子会调整历史价格。因此，复权后的收盘价是当前价格，而每股净资产可能需要根据复权进行调整。或者，可能每股净资产不需要复权，因为它是一个财务指标，而不是价格。这可能比较复杂，可能需要明确如何计算。

根据contextual_info的描述，收盘价需要向后复权到最近一个会计年度或最近一期的资产负债表日。例如，假设最近一个会计年度的资产负债表日是2022-12-31，而当前交易日是2023-05-01，那么复权后的收盘价是调整到2022-12-31的价格。此时，每股净资产是2022-12-31的数值。因此，复权后的收盘价是否低于该日的每股净资产？

因此，计算步骤可能如下：

1. 对于每个交易日，确定对应的最近一个会计年度或最近一期的资产负债表日。例如，找到最近的年报或季报的资产负债表日。
2. 获取该资产负债表日的每股净资产。
3. 计算当前交易日的复权因子，将收盘价复权到该资产负债表日。
4. 比较复权后的收盘价是否低于该资产负债表日的每股净资产。

但数据中是否有足够的信息来执行这些步骤？例如，是否有每个财务报告的发布日期和对应的每股净资产？或者，是否每个交易日的每股净资产列已经对应到最近的财务报告？

假设数据中的每股净资产列是每个交易日的最新值，即每当公司发布新的财务报告时，该列更新为最新的数值。例如，在2023年3月31日发布一季报后，每股净资产更新为一季度的数值，之后的所有交易日都使用该数值，直到下一个财务报告发布。因此，对于每个交易日，每股净资产是该日最新的财务报告中的数值。因此，在这种情况下，复权后的收盘价需要与该日的每股净资产比较。例如，复权后的收盘价 = 收盘价 * 复权因子，然后比较是否小于该行的每股净资产。

或者，可能复权因子已经将收盘价调整到最新的财务报告基准日，因此复权后的收盘价可以直接与当前行的每股净资产比较。例如，复权因子是调整到最近资产负债表日的因子，因此复权后的收盘价已经对应到该日的价格，而每股净资产也是该日的数值。因此，比较复权后的收盘价是否低于该行的每股净资产。

因此，在代码中，复权后的收盘价可以计算为：收盘价 * 复权因子。然后，比较该值是否小于每股净资产。如果存在任何一个交易日（在最近20个交易日内）满足这个条件，则constraint不满足，即不得存在这种情况。因此，需要检查最近20个交易日内是否有任何一天的复权收盘价低于当天的每股净资产。

但如何计算最近20个交易日？因为数据是按日频的，每个行对应一个交易日。对于每个交易日，需要检查该行之前的20个交易日内（包括该日）的所有行，是否存在复权收盘价低于每股净资产的情况。或者，是否是该行之前的20个交易日？例如，对于当前行，检查从当前日期往前推20个交易日（包括当前日期）的所有记录，是否存在收盘价复权后低于对应日期的每股净资产。

但这里可能有一个问题：每个交易日的每股净资产可能不同，因为财务报告发布后更新。因此，对于每个交易日，需要检查该交易日对应的每股净资产，以及当天的复权收盘价是否低于该值。然后，在最近20个交易日内，只要有一个交易日满足这个条件，则constraint不满足。

因此，对于每个行，需要检查该行所在公司的最近20个交易日内，是否存在任何一行的复权收盘价低于该行的每股净资产。或者，是检查该行所在公司的最近20个交易日内的所有行，每个行的复权收盘价是否低于该行对应的每股净资产？

例如，对于当前行，获取同一公司的前20个交易日的所有行（包括当前行），然后对于这些行中的每一行，计算复权收盘价是否小于该行的每股净资产。如果至少有一个行满足这个条件，则当前行的constraint不满足。

因此，这需要按公司分组，并对每个公司的每个交易日，检查其前20个交易日内是否存在这样的行。

这可能需要使用rolling窗口或者groupby.apply方法来实现。

但考虑到数据量可能较大，这样的操作可能会比较耗时。但根据任务要求，需要编写函数处理。

现在，总结各部分的处理步骤：

Subject部分：
- 检查股东身份是否为控股股东、实际控制人或一致行动人。但数据中没有一致行动人的标签，所以可能只能检查前两者。

Condition部分：
- 减持方式为集中竞价或大宗交易（即“减持方式”列的值是这两个之一）
- 存在减持计划（“存在减持计划”为True）
- 是首次披露减持计划（即该股东在该公司中首次出现存在减持计划为True的行）

Constraint部分：
- 最近20个交易日内，任何一天的复权收盘价（收盘价 * 复权因子）低于该天的每股净资产。

现在，编写代码：

首先，处理subject：

valid_subject = (df['股东身份'].isin(['控股股东', '实际控制人'])) | (一致行动人的条件)

但一致行动人无法判断，所以可能只能处理前两者。因此，valid_subject的条件是股东身份为控股股东或实际控制人。

接下来，处理condition：

valid_condition需要满足：
1. 减持方式为集中竞价或大宗交易：df['减持方式'].isin(['集中竞价', '大宗交易'])？但数据中的“减持方式”列可能使用的是不同的名称，比如示例中的“竞价交易”可能对应集中竞价。根据附加信息中的说明，交易方式有['竞价交易', '大宗交易', '融券卖出']，而集中竞价属于竞价交易。因此，这里的condition中的“集中竞价交易”对应数据中的“竞价交易”吗？是的。因此，减持方式是否为“竞价交易”或“大宗交易”。

因此，valid_condition_part1 = df['减持方式'].isin(['竞价交易', '大宗交易'])

2. 存在减持计划：df['存在减持计划'] == True

3. 首次披露减持计划：对于每个（公司简称，股东）组合，该行是否是第一个存在减持计划为True的行。这可以通过分组后，对每个组内的“存在减持计划”进行cumsum或rank来判断。例如，对于每个组，按日期排序，当存在减持计划为True时，标记是否为第一次出现。

例如，按公司简称和股东分组，然后对每个组内的行按日期排序，计算每个存在减持计划为True的行是否是组内的第一个。可以使用groupby和cumsum的方法：

df_sorted = df.sort_values(by=['日期'])
grouped = df_sorted.groupby(['公司简称', '股东'], group_keys=False)
first_occurrence = grouped['存在减持计划'].transform(lambda x: x & (x.cumsum() == 1))

这样，first_occurrence将为True当且仅当该行是组内首次出现存在减持计划为True的情况。

因此，valid_condition = valid_condition_part1 & df['存在减持计划'] & first_occurrence

但需要注意，可能存在多个减持计划的情况，但condition要求是首次披露。因此，只有首次出现减持计划的行才满足condition的条件。

因此，condition的valid_condition是减持方式正确，存在减持计划，并且是首次披露。

接下来处理constraint：

需要检查最近20个交易日内，任何一天的复权收盘价是否低于该天的每股净资产。因此，对于每个行，需要检查同一公司的最近20个交易日内（包括当前行）的所有行，是否存在复权收盘价 < 每股净资产的情况。

复权收盘价的计算是收盘价 * 复权因子。因此，复权收盘价 = df['收盘价'] * df['复权因子']

然后，对于每个公司的每个交易日，检查其前20个交易日内是否有任何行的复权收盘价 < 该行的每股净资产。

这可以通过按公司分组，然后对每个组内的每个行，使用rolling窗口来检查过去20个交易日内的最大值是否存在满足条件的情况。

但rolling窗口可能只能处理数值计算，而这里需要比较每个行的复权收盘价和每股净资产。因此，可能需要为每个行生成一个标志，表示该行的复权收盘价是否低于该行的每股净资产，然后检查该标志在最近20个交易日内是否有至少一个True。

具体步骤：

1. 计算复权收盘价是否低于每股净资产：

df['复权收盘价'] = df['收盘价'] * df['复权因子']
is_low = df['复权收盘价'] < df['每股净资产']

2. 按公司分组，对每个公司，计算每个交易日之前的20个交易日内是否有任何is_low为True：

这可以通过groupby和rolling窗口实现。例如，对于每个公司，按日期排序，然后对is_low列进行rolling(window=20, min_periods=1)的max()操作，因为只要有一个True，max()就会是True。

但需要注意，rolling窗口是向前看的，即包括当前行和之前的19行。因此，需要确保数据按日期升序排列。

例如：

df_sorted = df.sort_values(by=['日期'])
df_sorted['is_low'] = df_sorted['复权收盘价'] < df_sorted['每股净资产']
grouped = df_sorted.groupby('公司简称', group_keys=False)
df_sorted['any_low_in_20'] = grouped['is_low'].rolling(window=20, min_periods=1).max().reset_index(level=0, drop=True)

然后，any_low_in_20列将标记该行是否在最近20个交易日内存在复权收盘价低于每股净资产的情况。

但需要注意，rolling的窗口是包括当前行在内的前20行（如果存在的话）。例如，如果当前行是第25行，则窗口是第6到25行（假设按日期升序排列）。因此，对于每个行，any_low_in_20表示该行及其前19个交易日内的任何一天是否满足条件。

因此，constraint的条件是该行的any_low_in_20为False，即最近20个交易日内没有出现复权收盘价低于每股净资产的情况。因此，valid_constraint = ~any_low_in_20

但需要注意，在原始数据中，可能每个公司的数据是按日期排序的，因此需要先按公司分组并按日期排序，然后计算rolling窗口。

现在，将这些步骤整合到代码中：

函数的大致流程：

1. 初始化三个新列，初始化为False或None。
2. 处理subject：标记控股股东或实际控制人。
3. 处理condition：减持方式正确，存在减持计划，且是首次披露。
4. 处理constraint：计算复权收盘价，检查最近20个交易日内是否有低于每股净资产的情况。
5. 将结果标记到对应的列中。

现在，编写代码：

首先，导入必要的库：

import pandas as pd

然后，定义函数：

def check_meu_12_2(df):
    # 复制df，避免修改原始数据
    df = df.copy()
    
    # 初始化新列
    df['meu_12_2_subject'] = False
    df['meu_12_2_condition'] = False
    df['meu_12_2_constraint'] = None  # 初始化为None，之后填充True/False
    
    # 处理subject：控股股东、实际控制人
    valid_subject = df['股东身份'].isin(['控股股东', '实际控制人'])
    # 注意：一致行动人无法通过现有字段判断，因此暂时忽略
    
    # 处理condition
    # 减持方式为竞价交易或大宗交易
    valid_condition_part1 = df['减持方式'].isin(['竞价交易', '大宗交易'])
    # 存在减持计划
    valid_condition_part2 = df['存在减持计划']
    # 首次披露减持计划
    # 按公司和股东分组，找到每个组内首次出现存在减持计划的行
    df_sorted = df.sort_values(by=['日期'])
    grouped = df_sorted.groupby(['公司简称', '股东'], group_keys=False)
    # 计算每个组内是否存在减持计划的首次出现
    # 使用cumsum来标记首次出现
    first_occurrence = grouped['存在减持计划'].transform(lambda x: x & (x.cumsum() == 1))
    valid_condition = valid_condition_part1 & valid_condition_part2 & first_occurrence
    
    # 处理constraint
    # 计算复权收盘价
    df['复权收盘价'] = df['收盘价'] * df['复权因子']
    # 判断是否低于每股净资产
    df['is_low'] = df['复权收盘价'] < df['每股净资产']
    # 按公司分组，按日期排序，计算每个行的最近20个交易日内是否有任何is_low为True
    df_sorted_constraint = df.sort_values(by=['日期'])
    grouped_constraint = df_sorted_constraint.groupby('公司简称', group_keys=False)
    # 使用rolling window计算20个交易日内是否有任何True
    # 注意：rolling需要min_periods=1，否则可能返回NaN
    df_sorted_constraint['any_low_in_20'] = grouped_constraint['is_low'].rolling(
        window=20, min_periods=1
    ).apply(lambda x: x.max(), raw=True).reset_index(level=0, drop=True)
    # 合并回原始df，可能需要根据索引对齐
    # 由于排序可能改变索引，需要确保正确合并
    # 这里可能需要将排序后的结果合并回原df
    # 但为了简化，假设df_sorted_constraint的索引与原始df相同
    # 或者，使用merge或join，但需要保持顺序
    # 这里假设排序后的df_sorted_constraint的索引与原始df相同，或者使用相同的顺序
    # 因此，直接赋值
    df['any_low_in_20'] = df_sorted_constraint['any_low_in_20']
    # constraint的条件是any_low_in_20为False
    valid_constraint = ~df['any_low_in_20']
    
    # 标记各列
    df.loc[valid_subject, 'meu_12_2_subject'] = True
    df.loc[valid_condition, 'meu_12_2_condition'] = True
    # constraint是独立检查的，所有行都需要标记True或False
    df['meu_12_2_constraint'] = valid_constraint.astype(bool)
    
    # 清理临时列
    df.drop(columns=['复权收盘价', 'is_low', 'any_low_in_20'], inplace=True)
    
    return df

但需要注意，在计算any_low_in_20时，可能由于分组和排序的问题，导致索引错乱。因此，可能需要更谨慎地处理。例如，在排序后，保留索引，然后通过索引将结果合并回原df。

另外，在计算rolling时，需要确保每个公司的数据是按日期升序排列的，否则窗口可能不正确。

此外，在计算首次披露减持计划时，可能存在多个减持计划的情况，但只有首次的才满足condition的条件。因此，使用cumsum的方法是正确的。

现在，测试代码是否满足要求：

例如，对于subject部分，正确标记控股股东和实际控制人。

对于condition部分，只有当减持方式正确，存在减持计划，并且是首次披露时，才标记为True。

对于constraint部分，检查每个公司的最近20个交易日内是否有任何一天的复权收盘价低于每股净资产。如果存在，则constraint为False，否则为True。

最后，将这三个条件的结果分别记录到对应的列中。

可能的错误点：

1. 一致行动人未被处理：由于数据中没有相关字段，无法处理，但MEU的subject包括一致行动人。这可能导致部分情况未被正确标记。但根据现有数据，只能处理控股股东和实际控制人，因此可能需要用户注意这一点。

2. 首次披露减持计划的计算是否正确：使用cumsum的方法，当存在减持计划为True时，cumsum会累加，当等于1时即为首次出现。这可能正确。

3. 计算any_low_in_20时，是否正确地按公司分组，并按日期排序，然后计算rolling窗口。例如，如果数据中存在同一公司的多个行，但日期不是连续的，rolling窗口可能不会覆盖正确的20个交易日。但根据任务说明，数据中的日期列已经是交易日，因此每个公司的日期应该是连续的交易日，或者至少按顺序排列。因此，按日期排序并按公司分组后，rolling窗口应该正确计算每个公司的最近20个交易日。

4. 复权收盘价的计算是否正确：收盘价乘以复权因子，假设复权因子是正确的。

综上，代码应该能够正确标记各条件的情况。
","CompletionUsage(completion_tokens=6694, prompt_tokens=1787, total_tokens=8481, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=6056, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_17_1
法律的最小可执行单元内容: {""subject"": ""上市公司董监高"", ""condition"": ""在其就任时确定的任期内和任期届满后6个月内，每年通过集中竞价、大宗交易、协议转让等方式转让股份且不属于因司法强制执行、继承、遗赠、依法分割财产等导致股份变动"", ""constraint"": ""每年转让的股份不得超过其所持本公司股份总数的25%"", ""contextual_info"": NaN}
必要的额外信息: nan

你被分配的MEU coding任务存在refer_to关系, 你需要参考下面这个MEU的必要内容来完成你被安排的任务, 但你不需要直接执行下面的MEU: 
【MEU_18_1】
subject: 上市公司董监高
condition: nan
constrain: nan
contextual_info: 以上年末其所持股总数作为基数计算可转让股份数量








# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_17_1(df):
    '''
    验证MEU_17_1合规性：
    subject: 上市公司董监高
    condition: 在任期内及离任后6个月内通过指定方式转让股份且非特殊原因
    constraint: 年转让量不超过上年末持股的25%
    '''
    df = df.copy()

    # 初始化标记列
    df['meu_17_1_subject'] = False
    df['meu_17_1_condition'] = False
    df['meu_17_1_constraint'] = False

    # 标记subject
    valid_subject = df['股东身份'] == '董监高'
    df.loc[valid_subject, 'meu_17_1_subject'] = True

    # 标记condition
    # 时间条件（任期内或离任后6个月）
    time_cond = (
        df['离任日期'].isna() |  # 在任情况
        (df['日期'] <= df['离任日期'] + pd.DateOffset(months=6))  # 离任后6个月
    )
    # 减持方式条件
    method_cond = df['减持方式'].isin(['竞价交易', '大宗交易', '协议转让'])
    # 排除特殊原因
    reason_cond = ~df['拟减持原因'].isin(['司法强制执行', '继承', '遗赠', '依法分割财产'])
    valid_condition = time_cond & method_cond & reason_cond
    df.loc[valid_condition, 'meu_17_1_condition'] = True

    # 标记constraint（独立检查）
    # 计算每日减持数量
    df.sort_values(['公司简称', '股东', '日期'], inplace=True)
    df['prev_持股数量'] = df.groupby(['公司简称', '股东'])['持股数量'].shift(1)
    df['当日减持数量'] = (df['prev_持股数量'] - df['持股数量']).clip(lower=0)

    # 获取上年末持股基数
    df['year'] = df['日期'].dt.year
    # 生成年末基准数据
    year_end = df.groupby(['公司简称', '股东', 'year']).apply(lambda x: x.loc[x['日期'].idxmax()])
    base_df = year_end[['公司简称', '股东', 'year', '持股数量']].reset_index()
    base_df['base_year'] = base_df['year'] + 1
    # 合并基准数据
    df = df.merge(
        base_df[['公司简称', '股东', 'base_year', '持股数量']],
        left_on=['公司简称', '股东', 'year'],
        right_on=['公司简称', '股东', 'base_year'],
        how='left',
        suffixes=('', '_base')
    )
    # 计算年累计减持量
    df['年累计减持'] = df.groupby(['公司简称', '股东', 'year'])['当日减持数量'].cumsum()
    # 验证约束条件
    valid_constraint = (df['年累计减持'] <= df['持股数量_base'] * 0.25) & df['持股数量_base'].notna()
    df.loc[valid_constraint, 'meu_17_1_constraint'] = True

    # 清理中间列
    df.drop(['prev_持股数量', '当日减持数量', 'year', '持股数量_base', 'base_year', '年累计减持'], 
            axis=1, errors='ignore', inplace=True)

    return df
</CODE>","好的，我现在需要处理这个MEU_17_1的合规性检查。首先，我得仔细理解这个MEU的内容。MEU_17_1的主体是上市公司董监高，条件是在其任期内和任期届满后6个月内，每年通过集中竞价、大宗交易、协议转让等方式转让股份，且不属于司法强制执行等情况。约束是每年转让的股份不得超过其所持本公司股份总数的25%。此外，参考MEU_18_1，可能需要用上年末的持股总数作为基数来计算可转让数量。

接下来，我需要确定如何将这些条件转化为代码，应用到输入的DataFrame上。首先，处理subject部分。根据MEU_17_1的subject是“上市公司董监高”，所以需要检查股东身份是否为“董监高”。在给定的数据列中，有“股东身份”这一列，其中包含“董监高”这个选项。因此，valid_subject的条件应该是df['股东身份'] == '董监高'。不过，可能还需要考虑离任的情况吗？但MEU的条件里已经包括了任期届满后6个月内，所以离任的情况可能已经在condition部分处理了。所以subject部分只需要判断是否是董监高。

然后是condition部分。条件比较复杂：在任期内和任期届满后6个月内，每年通过特定方式转让股份，且不属于司法强制执行等情况。这里需要确定如何判断时间范围。假设数据中有“离任日期”这一列，那么任期结束后的6个月应该从离任日期开始计算。对于在任的情况，任期内的时间应该从就任日期开始到离任日期为止。但数据中是否有就任日期呢？可能没有，所以可能需要假设董监高的任期信息，或者是否有其他相关列？比如，可能“离任日期”存在的话，说明该股东已经离任，否则视为在任。或者可能需要根据其他列推断。例如，如果“股东身份”是“董监高”，则视为在任，如果是“离任董监高”，则视为离任。但MEU_17_1的subject是“上市公司董监高”，所以可能只处理在任的情况？或者是否包括离任后的情况？

根据MEU的条件描述，条件包括“在其就任时确定的任期内和任期届满后6个月内”，所以离任后的6个月也需要考虑。因此，需要确定每个股东在任的时间段和离任后的6个月时间段。例如，如果某个股东在某个日期离任，那么离任后的6个月内的日期都属于条件范围内。但数据中的每一行都是某个交易日的记录，所以需要判断该日期是否在任期内或离任后的6个月内。

这可能比较复杂。例如，对于每个股东，需要知道他们的任期开始和结束时间。但数据中可能没有任期开始时间，只有离任日期。假设数据中的“离任日期”列存在，那么对于在任的董监高，离任日期为空，而离任后的股东则有离任日期。因此，对于在任的股东，他们的任期结束时间未知，可能视为仍在任期内。或者，可能需要假设他们的任期结束时间，但数据中没有相关信息，这可能是个问题。或者，可能MEU的条件中的“任期”指的是该股东担任董监高的整个期间，而离任后的6个月则是从离任日期开始计算。

因此，对于condition的时间条件，需要判断该交易日是否处于该股东的任期内，或者离任后的6个月内。例如，如果该行的日期在离任日期之后的6个月内，则属于条件范围内。对于在任的股东（离任日期为空），则日期自然属于任期内。

此外，转让方式需要是集中竞价、大宗交易、协议转让等方式，所以需要检查减持方式是否属于这些类型。根据数据中的“减持方式”列，可能的值包括['竞价交易', '大宗交易', '协议转让']等。而排除的情况是司法强制执行、继承等，这可能对应数据中的某些列，比如是否存在这些情况。例如，可能有一个列标识减持的原因，如“拟减持原因”是否属于这些排除的情况。或者，可能需要假设这些情况不存在，或者通过其他列来判断。例如，如果“减持方式”是司法强制执行等，则不属于条件范围。但数据中的“减持方式”可能没有这些选项，所以可能需要其他列来判断，比如“拟减持原因”是否属于排除的情况。

假设数据中的“减持方式”列包含合法的转让方式，而排除的情况由其他列标识。例如，如果“拟减持原因”是“司法强制执行”等，则不属于条件范围。因此，在condition的条件中，需要同时满足减持方式属于指定类型，并且减持原因不属于排除的情况。

但根据MEU的描述，condition中的转让方式属于集中竞价、大宗交易、协议转让等方式，并且不属于因司法强制执行等情况。因此，需要检查两个条件：减持方式正确，且减持原因不在排除列表中。

现在，数据中的“减持方式”列可能有['竞价交易', '大宗交易', '协议转让', '融券卖出']等。根据MEU的条件，融券卖出可能不属于允许的方式，所以需要排除。因此，减持方式必须是这三种之一：集中竞价（即竞价交易）、大宗交易、协议转让。而“减持方式”列中的值可能对应的是“竞价交易”是否等于集中竞价？可能需要确认。根据之前的例子，MEU_4_1中的condition是“计划通过本所集中竞价或大宗交易减持股份”，对应的代码中检查的是减持方式是否为['竞价交易', '大宗交易']。所以可能“竞价交易”对应集中竞价。因此，在MEU_17_1的condition中，减持方式需要是这三种中的一种：竞价交易、大宗交易、协议转让。而融券卖出则不属于，所以需要排除。

此外，减持的原因是否属于排除的情况，比如司法强制执行、继承等。这可能对应“拟减持原因”列中的值。例如，如果“拟减持原因”是“司法强制执行”、“继承”等，则不符合条件。因此，需要检查“拟减持原因”是否不在这些排除的原因中。

因此，condition的条件包括：

1. 日期在任期内或离任后的6个月内；
2. 减持方式属于['竞价交易', '大宗交易', '协议转让']；
3. 减持原因不属于排除的情况（如司法强制执行、继承等）。

接下来，处理时间条件。对于每个股东，判断该交易日是否在任期内或离任后的6个月内。对于在任的董监高（离任日期为空），则所有日期都属于任期内。对于已离任的董监高（离任日期不为空），则日期需要小于等于离任日期后的6个月。

例如，假设某股东的离任日期是2023-01-01，那么离任后的6个月是到2023-07-01。该股东在2023-06-30的交易日属于条件范围内，而2023-07-02则不属于。

在代码中，如何计算这个时间差？可以使用pandas的日期处理功能。例如，对于每一行，如果该行的日期在离任日期之后的6个月内，则符合条件。对于离任日期为空的，视为在任期内，所以日期符合条件。

因此，时间条件可以表示为：

( (df['离任日期'].isna()) | (df['日期'] <= df['离任日期'] + pd.DateOffset(months=6)) )

但需要注意，离任日期可能为空，此时该股东仍在任，所以日期属于任期内。

接下来，减持方式的条件：

df['减持方式'].isin(['竞价交易', '大宗交易', '协议转让'])

减持原因的条件：

~df['拟减持原因'].isin(['司法强制执行', '继承', '遗赠', '依法分割财产'])

假设这些原因在数据中是存在的，并且“拟减持原因”列包含这些值。如果数据中没有这些原因，可能需要调整，但根据问题描述，用户提供的列中包含“拟减持原因”，所以可以这样处理。

综上，condition的valid条件是：

valid_condition = (
    ( (df['离任日期'].isna()) | (df['日期'] <= df['离任日期'] + pd.DateOffset(months=6)) ) &
    df['减持方式'].isin(['竞价交易', '大宗交易', '协议转让']) &
    ~df['拟减持原因'].isin(['司法强制执行', '继承', '遗赠', '依法分割财产'])
)

接下来是constraint部分：每年转让的股份不得超过其所持本公司股份总数的25%。这里需要计算每个股东每年转让的股份数量是否超过25%。根据MEU_18_1的参考，基数可能是上年末的持股总数。因此，每个自然年度的可转让数量是上年末持股数量的25%。

例如，对于2023年，可转让数量是2022年末的持股数量的25%。因此，需要按自然年分组，每个股东在每个自然年内的累计减持比例不能超过上年末持股数量的25%。

在数据中，每个交易日都有“当日减持比例”和“累计减持比例”等信息。但需要计算每个股东在每个自然年内的减持总量，并与上年末的持股数量的25%进行比较。

具体来说，对于每个股东和公司，每年的可减持数量是上年末持股数量的25%。例如，2023年的可减持量是2022年末的持股数量乘以0.25。因此，在2023年内的任何时间点，累计减持量不能超过这个值。

在代码中，如何实现这一点？可能需要按公司和股东分组，然后对于每个组，计算每个自然年的减持量，并比较是否超过上年末持股的25%。

但数据是按交易日记录的，所以需要先确定每个自然年的上年末持股数量。例如，对于某一行日期为2023-05-10，属于2023年，那么需要找到该股东在2022-12-31的持股数量作为基数。如果该股东在2022年末没有记录，可能需要处理缺失值，但根据问题描述，数据可能包含所有必要的信息。

可能的步骤：

1. 对每个股东和公司，按自然年分组。
2. 对于每个自然年，获取上年末的持股数量。
3. 计算该年内的累计减持量，并检查是否超过上年末持股的25%。

但如何在DataFrame中高效实现这一点呢？可能需要使用groupby和transform方法，或者使用shift操作来获取上一年的数据。

例如，首先为每个记录添加年份，然后按股东和公司分组，计算每个年份的上年末持股数量。例如，对于年份为Y的记录，上年末是Y-1年的年末。因此，需要找到该股东在Y-1年的最后一天的持股数量。

这可能比较复杂，因为数据是按交易日记录的的，不是每天都有记录。例如，股东可能在Y-1年的最后一天没有交易记录，因此需要找到该股东在Y-1年的最大日期（<= Y-1-12-31）的持股数量。

这可能需要为每个股东和公司，在每年的年末记录其持股数量，然后将其作为下一年的基数。

例如，可以创建一个辅助DataFrame，包含每个股东和公司在每个年份的年末持股数量。然后，将这一信息合并到原始DataFrame中，作为基数值。

具体步骤：

1. 提取每个股东和公司在每个自然年度的年末持股数量。例如，对于每个年份Y，找到该股东在该年的最后一天的记录中的持股数量。如果该年没有记录，可能需要向前填充或处理缺失值，但假设数据是完整的。

2. 将上年末的持股数量作为基数，合并到原始DataFrame中。例如，对于日期为Y年的记录，基数是Y-1年末的持股数量。

3. 计算该年内的累计减持量，并检查是否超过基数的25%。

但如何实现这一点呢？可能需要使用groupby和apply方法，或者使用shift操作。

另一种方法是，对于每个记录，计算其年份，然后找到该股东在该年份的上一年末的持股数量。例如，对于日期为2023-05-10的记录，年份是2023，需要找到该股东在2022-12-31的持股数量。如果该股东在2022-12-31没有记录，则可能需要找到最近的一个日期在2022年的记录中的持股数量，或者使用前一年的最后可用数据。

这可能比较复杂，但假设数据中存在每个自然年末的持股数量记录。例如，每个自然年的最后一个交易日的数据都存在。

假设数据中存在每个自然年末的记录，那么可以按以下步骤处理：

- 创建一个新的列'year'，表示该记录所属的自然年。
- 对每个股东和公司，按'year'分组，找到每个年份的最后一天的持股数量，作为下一年的基数。
- 将基数合并到原始DataFrame中，每个记录的基数是上一年的年末持股数量。

例如：

df['year'] = df['日期'].dt.year

# 获取每个股东和公司在每个年份的年末持股数量
year_end = df.groupby(['公司简称', '股东', 'year'])['日期'].idxmax()
base = df.loc[year_end, ['公司简称', '股东', 'year', '持股数量']].reset_index()
base['base_year'] = base['year'] + 1  # 下一年的基数是上一年的年末持股数量

# 将base合并到原始df中，根据公司简称、股东和年份匹配base_year
df = df.merge(base[['公司简称', '股东', 'base_year', '持股数量']], 
              left_on=['公司简称', '股东', 'year'], 
              right_on=['公司简称', '股东', 'base_year'], 
              how='left', suffixes=('', '_base'))

这样，每个记录的'持股数量_base'就是上一年末的持股数量。然后，计算该年的累计减持量是否超过25%的基数。

然后，对于每个记录，计算该年内的累计减持量，直到当前日期，是否超过基数 * 0.25。

这可能需要按股东、公司、年份分组，然后计算累计减持量。例如：

df['累计减持量'] = df.groupby(['公司简称', '股东', 'year'])['当日减持比例'].cumsum()

然后，检查累计减持量是否 <= (持股数量_base * 0.25)

但需要注意，这里的“当日减持比例”是否是减持的股份数量，或者是否是减持的比例。例如，如果“当日减持比例”是该股东当日减持的股份数量占公司总股本的比例，或者占其自身持股的比例？或者“当日减持比例”可能指的是减持的股份数量？

根据数据列的描述，可能“当日减持比例”是该股东当日减持的股份数量占其总持股的比例？或者可能“持股数量”是该股东当天的持股数量，而“当日减持比例”是减持的数量。例如，如果某股东当天减持了1000股，那么“当日减持比例”是1000股，而“持股数量”是减持后的数量。或者，可能“当日减持比例”是减持的股份数量占其原有持股数量的比例？

这个问题需要明确。假设“当日减持比例”是该股东当日减持的股份数量，那么累计减持量是该股东在该年内的总减持数量。而约束是，该年内的总减持量不能超过上年末持股数量的25%。

例如，上年末持股数量是10000股，那么当年最多可以减持2500股。因此，累计减持量超过2500股时，违反约束。

因此，在代码中，需要计算每个股东在每个自然年内的累计减持量，并与上年末持股数量的25%进行比较。

但如何计算累计减持量？假设数据中的“当日减持比例”是减持的绝对数量（股数），那么可以按年累计。例如：

df['年累计减持'] = df.groupby(['公司简称', '股东', 'year'])['当日减持比例'].cumsum()

然后，对于每一行，检查该行的年累计减持是否超过上年末持股数量的25%。如果超过，则约束不满足。

但需要注意，这里的“当日减持比例”是否是减持的股数。例如，如果“当日减持比例”是减持的股数，那么可以直接累加。如果“当日减持比例”是减持的比例（例如，减持了其持股的5%），则需要知道减持前的持股数量来计算实际减持的股数。这可能比较复杂。

根据问题描述中的列信息，数据列中有“持股数量”和“当日减持比例”。假设“当日减持比例”是该股东当日减持的股份数量，例如，减持了1000股，那么可以直接累加。或者，如果“当日减持比例”是减持的股数占公司总股本的比例，那么可能需要结合总股本来计算实际减持的股数。但根据问题描述中的列，可能“当日减持比例”是该股东当日减持的股份数量，或者该股东减持的股份数量占其总持股的比例？

这个问题需要明确。例如，假设“当日减持比例”是该股东当日减持的股份数量，那么可以直接累加。否则，可能需要其他计算方式。

根据问题描述中的列说明：

- ['当日减持比例']：可能指的是该股东当日减持的股份数量占其总持股的比例？或者减持的绝对数量？

假设问题中的“当日减持比例”是该股东当日减持的股份数量，那么可以直接累加。例如，某股东当天减持了1000股，那么该列的值为1000。这样，累计减持量就是各天减持量的总和。

但根据列名中的“比例”，可能该列是减持的股份数量占其总持股的比例，例如，减持了5%的股份。此时，需要知道该股东在减持前的持股数量，才能计算实际减持的股数。例如，如果减持前持股10000股，当日减持比例是0.05（即5%），则减持了500股。

但数据中的“持股数量”列可能指的是减持后的数量。例如，减持后的持股数量是9500股，那么减持量是500股。因此，当日减持比例可以通过（减持前的持股数量 - 减持后的持股数量）来计算。但数据中是否有减持前的持股数量？

这可能比较复杂。例如，如果数据中的“持股数量”是当天的持股数量，那么当天的减持量等于前一天的持股数量减去当天的持股数量。但如果没有前一天的记录，这可能难以计算。

在这种情况下，可能需要按股东和公司分组，计算每天的减持量。例如，对于每个分组，按日期排序，然后计算每天的减持量为前一天的持股数量减去当天的持股数量。但这种方法需要确保数据按日期排序，并且每个分组内的日期是连续的，否则可能会有缺失。

这可能比较复杂，特别是如果数据中存在缺失日期的情况。例如，某个股东在某个交易日没有减持，因此没有记录，或者记录中的持股数量没有变化。

因此，假设数据中的“当日减持比例”是该股东当日实际减持的股份数量，那么可以直接累加。否则，可能需要其他处理方式。

根据问题描述中的列说明，可能“当日减持比例”是该股东当日减持的股份数量占公司总股本的比例，或者占其自身持股的比例。但如果没有足够的信息，可能需要做出假设。

在这种情况下，可能需要假设“当日减持比例”是该股东当日减持的股份数量，或者该列存在其他列如“减持数量”来记录实际减持的股数。但根据提供的列列表，只有“当日减持比例”和“累计减持比例”可能与减持量有关。例如，“累计减持比例”可能指的是该股东累计减持的股份数量占其初始持股的比例。

这可能使得问题变得复杂。例如，假设“累计减持比例”是该股东从开始减持到当前日期累计减持的股份数量占其初始持股的比例。例如，初始持股10000股，累计减持比例为0.25，即累计减持了2500股。此时，约束条件是该累计减持比例不超过25%。但MEU_17_1的约束是每年不得超过25%，所以需要每年重新计算。

这可能意味着，每个自然年的累计减持比例不能超过25%。例如，每年可以减持上年末持股的25%。因此，需要每年重新计算基数。

例如，2023年的基数是2022年末的持股数量，2024年的基数是2023年末的持股数量，依此类推。

因此，对于每个自然年，计算该年内的累计减持量，并与上年末的持股数量的25%进行比较。

假设数据中的“累计减持比例”是该股东自减持开始以来的总减持比例，这可能无法直接使用，因为需要每年重新计算。因此，可能需要重新计算每年的累计减持量。

这可能比较复杂，但根据问题描述中的列，可能没有直接的减持数量，因此需要根据其他列推断。

或者，假设“持股数量”是该股东当天的持股数量，那么当天的减持量可以通过前一天的持股数量减去当天的持股数量来计算。例如，如果某股东在t-1天的持股数量是N，t天的持股数量是M，那么当天的减持量是N - M（假设没有增持的情况）。

因此，在代码中，可以按股东和公司分组，按日期排序，然后计算每天的减持量为前一天的持股数量减去当天的持股数量。这可能更准确，但需要确保数据按日期排序，并且每个分组内的日期是连续的。

例如：

df.sort_values(['公司简称', '股东', '日期'], inplace=True)
df['prev_持股数量'] = df.groupby(['公司简称', '股东'])['持股数量'].shift(1)
df['当日减持数量'] = df['prev_持股数量'] - df['持股数量']
df['当日减持数量'] = df['当日减持数量'].fillna(0)  # 第一天没有前一天数据，减持量为0

然后，每年的累计减持数量是该自然年内的所有“当日减持数量”的总和。例如，对于每个自然年Y，累计减持量是该年所有交易日的减持数量之和。

然后，需要比较该累计减持量是否超过上年末持股数量的25%。

因此，步骤大致如下：

1. 计算每个股东每天的减持数量（通过比较前一天的持股数量和当天的持股数量）。
2. 按自然年分组，计算每个自然年的累计减持数量。
3. 获取每个自然年的上年末的持股数量作为基数。
4. 检查累计减持数量是否超过基数的25%。

现在，如何在代码中实现这一点？

首先，计算每日的减持数量：

df = df.sort_values(['公司简称', '股东', '日期'])
df['prev_持股数量'] = df.groupby(['公司简称', '股东'])['持股数量'].shift(1)
df['当日减持数量'] = (df['prev_持股数量'] - df['持股数量']).clip(lower=0)  # 假设减持量非负，可能增持的情况不计入减持

这里使用clip(lower=0)是因为如果当天的持股数量增加，则减持量为0，因为只关心减持的情况。

然后，为每个记录添加年份：

df['year'] = df['日期'].dt.year

接下来，需要获取每个股东和公司在每个自然年末的持股数量，作为下一年的基数：

# 获取每个自然年末的持股数量
year_end_df = df.groupby(['公司简称', '股东', 'year']).apply(lambda x: x.nlargest(1, '日期')).reset_index(drop=True)
year_end_df = year_end_df[['公司简称', '股东', 'year', '持股数量']]
year_end_df.rename(columns={'持股数量': 'base_持股数量'}, inplace=True)
year_end_df['base_year'] = year_end_df['year'] + 1

# 将base_持股数量合并到原始df中，作为下一年的基数
df = df.merge(year_end_df[['公司简称', '股东', 'base_year', 'base_持股数量']], 
              left_on=['公司简称', '股东', 'year'], 
              right_on=['公司简称', '股东', 'base_year'], 
              how='left')

现在，df中的base_持股数量是上一年的年末持股数量，作为当前年的基数。

然后，按自然年计算累计减持数量：

df['年累计减持数量'] = df.groupby(['公司简称', '股东', 'year'])['当日减持数量'].cumsum()

然后，约束条件是：年累计减持数量 <= base_持股数量 * 0.25

因此，valid_constraint的条件是：

df['年累计减持数量'] <= df['base_持股数量'] * 0.25

但需要注意，base_持股数量可能为NaN，例如，对于某股东的第一年，没有上一年的数据。此时，可能需要忽略这些情况，或者认为没有基数，无法计算，因此约束不适用。但根据MEU的条件，约束是每年转让不得超过上年末的25%，所以如果上年末没有数据（例如，股东刚加入，没有上一年的数据），则可能无法满足约束条件，或者视为不适用？

这可能需要进一步处理。例如，如果base_持股数量为NaN，则约束条件无法满足，视为False？或者视为不适用？

根据问题描述，假设所有必要的数据都存在，因此可以忽略NaN的情况，或者填充为0？或者，可能在这种情况下，约束条件无法满足，因此标记为False。

例如，如果base_持股数量是NaN，则无法计算25%，因此约束条件不满足，标记为False。

综上，valid_constraint的条件是：

valid_constraint = (df['年累计减持数量'] <= df['base_持股数量'] * 0.25) & df['base_持股数量'].notna()

否则，如果base_持股数量为NaN，则条件不满足，标记为False。

现在，将这些条件组合起来，编写代码。

最后，将valid_subject、valid_condition、valid_constraint的结果分别标记到对应的列中。

总结代码步骤：

1. 初始化三个新列：meu_17_1_subject, meu_17_1_condition, meu_17_1_constraint，初始化为False或None。
2. 标记subject：股东身份是董监高。
3. 标记condition：日期在任期内或离任后6个月内，减持方式正确，且原因不属于排除情况。
4. 标记constraint：年累计减持数量不超过上年末持股的25%。
5. 将结果写入对应的列。

现在，编写代码：

首先，处理subject：

df['meu_17_1_subject'] = df['股东身份'] == '董监高'

然后，处理condition：

# 时间条件：在任期内或离任后6个月内
# 离任日期为空表示在任，日期自然在任期内
time_condition = (
    df['离任日期'].isna() | 
    (df['日期'] <= df['离任日期'] + pd.DateOffset(months=6))
)

# 减持方式条件
method_condition = df['减持方式'].isin(['竞价交易', '大宗交易', '协议转让'])

# 减持原因不属于排除情况
excluded_reasons = ['司法强制执行', '继承', '遗赠', '依法分割财产']
reason_condition = ~df['拟减持原因'].isin(excluded_reasons)

valid_condition = time_condition & method_condition & reason_condition

df['meu_17_1_condition'] = valid_condition

接下来，处理constraint：

# 计算每日减持数量
df = df.sort_values(['公司简称', '股东', '日期'])
df['prev_持股数量'] = df.groupby(['公司简称', '股东'])['持股数量'].shift(1)
df['当日减持数量'] = (df['prev_持股数量'] - df['持股数量']).clip(lower=0)

# 添加年份列
df['year'] = df['日期'].dt.year

# 获取每个自然年末的持股数量作为下一年的基数
year_end_df = df.groupby(['公司简称', '股东', 'year']).apply(lambda x: x.loc[x['日期'].idxmax()]).reset_index(drop=True)
year_end_df = year_end_df[['公司简称', '股东', 'year', '持股数量']]
year_end_df.rename(columns={'持股数量': 'base_持股数量', 'year': 'base_year'}, inplace=True)
year_end_df['base_year'] += 1  # 下一年的基数是上一年的年末持股数量

# 合并到原始df中
df = df.merge(year_end_df, 
              left_on=['公司简称', '股东', 'year'], 
              right_on=['公司简称', '股东', 'base_year'], 
              how='left')

# 计算年累计减持数量
df['年累计减持数量'] = df.groupby(['公司简称', '股东', 'year'])['当日减持数量'].cumsum()

# 约束条件
valid_constraint = (df['年累计减持数量'] <= df['base_持股数量'] * 0.25) & df['base_持股数量'].notna()

df['meu_17_1_constraint'] = valid_constraint

最后，将这三个条件的结果分别赋值到对应的列中。注意，根据问题要求，这三个条件的检查是独立的，所以即使subject或condition不满足，constraint的检查仍然进行。但根据附加信息中的说明，对于需要调用llm_content_check()的情况，只检查同时满足subject和condition的行的constraint。但在这个任务中，不需要调用该函数，因此constraint的检查是独立的，即无论subject和condition是否满足，都要检查constraint的条件。但根据MEU的约束，只有当subject和condition都满足时，constraint才需要被检查。但问题中的附加说明指出：“对于简单操作dataframe就可以处理的项目，对三元组<subject, conditon, constrain>的检查是各自独立的，你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查。” 因此，三个条件的检查是独立的，不管其他条件是否满足，都要分别标记。

因此，在代码中，三个条件的标记是独立的，不需要考虑其他条件是否满足。例如，即使subject是False，仍然要检查condition和constraint的条件，并标记它们是否为True或False。

但根据MEU的逻辑，约束条件仅适用于满足subject和condition的情况。但根据用户的要求，这三个条件的检查是独立的，所以需要分别标记。例如，即使股东不是董监高（subject为False），仍然要检查condition和constraint的条件，并标记它们是否满足。这可能与实际法律合规性检查不符，但根据用户的要求，必须这样做。

因此，在代码中，三个条件的标记是独立的，不需要考虑其他条件是否满足。

综上，最终的代码如下：
","CompletionUsage(completion_tokens=7230, prompt_tokens=1821, total_tokens=9051, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=6433, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_10_4
法律的最小可执行单元内容: {""subject"": ""上市公司大股东"", ""condition"": ""因涉及证券期货违法，被中国证监会行政处罚且罚没款尚未足额缴纳，且不存在法律、行政法规另有规定或减持资金用于缴纳罚没款的情形"", ""constraint"": ""不得减持其所持有的本公司股份"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_10_4(df):
    '''
    验证MEU_10_4合规性：
    subject: 上市公司大股东
    condition: 因证券期货违法被行政处罚且罚没款未缴，且不存在例外情形
    constraint: 不得减持股份
    '''
    df = df.copy()

    # 初始化合规性标记列
    df['meu_10_4_subject'] = False
    df['meu_10_4_condition'] = False
    df['meu_10_4_constraint'] = None

    # 1. 验证责任主体（上市公司大股东）
    major_shareholder_mask = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) | 
        (df['持股比例'] >= 0.05)
    )
    df.loc[major_shareholder_mask, 'meu_10_4_subject'] = True

    # 2. 验证触发条件（行政处罚+未足额缴纳+无例外情形）
    # 按时间顺序计算行政处罚持续状态
    sorted_df = df.sort_values(['公司简称', '股东', '日期'])
    sorted_df['行政处罚持续状态'] = (
        (sorted_df['股东涉嫌证券期货违法犯罪事件'] == '行政处罚决定作出')
        .groupby([sorted_df['公司简称'], sorted_df['股东']])
        .cummax()
    )
    df['行政处罚持续状态'] = sorted_df['行政处罚持续状态'].values  # 保持原始索引顺序
    
    # 检查例外情形（减持资金用于缴纳罚没款）
    exception_mask = df['拟减持原因'] == '缴纳罚没款'
    valid_condition = df['行政处罚持续状态'] & ~exception_mask
    df.loc[valid_condition, 'meu_10_4_condition'] = True

    # 3. 验证约束条件（当日无减持）
    df['meu_10_4_constraint'] = df['当日减持比例'].eq(0)

    # 清理临时字段
    df.drop('行政处罚持续状态', axis=1, inplace=True)
    
    return df
</CODE>","好的，我现在需要处理这个任务，编写一个函数来检查MEU_10_4的合规性。首先，我得仔细理解这个MEU的内容。根据提供的描述，MEU_10_4的subject是“上市公司大股东”，condition是“因涉及证券期货违法，被中国证监会行政处罚且罚没款尚未足额缴纳，且不存在法律、行政法规另有规定或减持资金用于缴纳罚没款的情形”，而constraint是“不得减持其所持有的本公司股份”。

首先，我需要确定如何标记这三个部分的有效性。根据任务要求，subject、condition和constraint需要分别独立检查，并各自标记在对应的列中。不过，对于constraint的检查，只有当subject和condition都满足时，才需要检查是否违反了constraint。但根据附加说明，这里不需要调用LLM函数，所以可能constraint的检查是独立进行的？或者可能只有当subject和condition都满足时，才需要检查constraint是否被违反？这点可能需要仔细看任务要求。

根据用户提供的更多要求中的说明：“对于简单操作dataframe就可以处理的项目，对三元组<subject, condition, constrain>的检查是各自独立的，你需要分别标记三元组的True和False。并不是只对符合subject和condition进行检查。” 所以这里的三个条件都是独立检查的，不管其他条件是否满足。例如，即使subject不满足，只要condition满足，condition对应的列也会标记为True。同样，constraint的检查也是独立进行的，不管subject和condition是否满足。不过，这可能与实际情况不符，但根据任务要求，必须这样处理。

不过，我需要再仔细看一下用户给的例子。在例子中，constraint的检查似乎也是独立进行的，比如在例子中的valid_constraint是根据交易日差和存在减持计划来判断的，而不管subject和condition是否满足。这可能意味着，每个条件都是独立判断的，不管其他条件是否满足。因此，在MEU_10_4的情况下，我需要分别判断subject、condition、constraint是否满足，并各自标记。

现在，我需要具体分析每个部分：

1. Subject：上市公司大股东。根据数据中的“股东身份”列，可能包括“控股股东”、“实际控制人”、“持股5%以上股东”等。但根据附加信息中的说明，股东身份列中的标签不会并列出现，所以需要检查股东身份是否是这些中的一种。或者，可能需要根据持股比例来判断是否是“大股东”。例如，如果股东身份是“控股股东”、“实际控制人”、“持股5%以上股东”，或者持股比例大于等于5%（可能？），则视为大股东。但根据MEU中的subject是“上市公司大股东”，可能需要明确哪些属于大股东。例如，控股股东、实际控制人、持股5%以上的股东都属于大股东。因此，判断subject的条件应该是股东身份属于这些类别之一，或者持股比例>=5%。或者，可能用户的数据中的“股东身份”列已经明确标注了是否是“大股东”，比如“控股股东”、“实际控制人”、“持股5%以上股东”都属于大股东。因此，在代码中，判断subject的条件是股东身份列是否属于这些值中的一种。或者，可能还需要考虑持股比例是否大于等于5%，因为可能存在股东身份是普通股东但持股比例超过5%的情况。例如，用户提供的附加信息中提到：“股东身份”有“董监高”、“离任董监高”、“控股股东”、“实际控制人”、“持股5%以上股东”、“普通股东”，并且这些标签不会并列出现。因此，如果某个股东的股东身份是“普通股东”，但持股比例>=5%，那么是否属于大股东？根据法律定义，可能持股5%以上的股东属于大股东，所以在这种情况下，即使股东身份是普通股东，只要持股比例>=5%，也应该被认定为大股东。因此，判断subject的条件应该是：股东身份是“控股股东”、“实际控制人”、“持股5%以上股东”中的一种，或者持股比例>=5%。或者，可能用户的数据中的“股东身份”列中的“持股5%以上股东”已经覆盖了这种情况，所以只需要检查股东身份是否为这三个中的一个。或者，可能用户的数据中的“股东身份”列可能没有正确标记，所以需要结合持股比例来判断。例如，如果股东身份是“董监高”，但持股比例>=5%，是否属于大股东？根据MEU的subject是“上市公司大股东”，可能大股东包括控股股东、实际控制人、持股5%以上的股东。因此，在代码中，判断subject的条件应该是：

valid_subject = (df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东'])) | (df['持股比例'] >= 0.05)

或者，可能用户的数据中的“股东身份”列中的“控股股东”等已经正确标记，所以不需要检查持股比例。但根据附加信息中的说明：“股东身份”列中的标签不会并列出现，例如董监高可能持股超过5%但未被标记为“持股5%以上股东”，所以需要手动从“持股比例”筛选。因此，正确的做法是，判断股东身份是否是“控股股东”、“实际控制人”、“持股5%以上股东”，或者持股比例>=5%。例如，在例子中的处理方式：

在例子中的subject是“上市公司大股东 | 董监高”，处理方式是：

is_major_shareholder = (
    df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
    (df['持股比例'] >= 0.05)
)
is_director = df['股东身份'].isin(['董监高'])
valid_subject = is_major_shareholder | is_director

所以，对于当前问题中的subject是“上市公司大股东”，应该同样处理，即：

valid_subject = df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) | (df['持股比例'] >= 0.05)

但需要注意，这里的“上市公司大股东”是否包括控股股东、实际控制人、持股5%以上的股东？根据通常的法律定义，是的。所以，这样处理是正确的。

接下来是condition部分：条件是被中国证监会行政处罚且罚没款尚未足额缴纳，并且不存在法律、行政法规另有规定或减持资金用于缴纳罚没款的情形。这需要检查该股东是否涉及证券期货违法，并且被行政处罚，且罚没款未足额缴纳，同时没有例外情况。

根据数据中的列，可能相关的列是“股东涉嫌证券期货违法犯罪事件”。该列的可能值包括：被中国证监会及其派出机构立案调查、立案调查结束、行政处罚决定作出等。例如，当该列的值是“行政处罚决定作出”时，表示该股东已经被行政处罚。但需要进一步的信息来判断是否罚没款已经缴纳。但数据中是否有相关的列？比如是否有“罚没款缴纳状态”这样的列？根据用户提供的可用列，可能没有直接的列。因此，可能需要假设，当“股东涉嫌证券期货违法犯罪事件”列中包含“行政处罚决定作出”，并且存在未缴纳的罚没款，那么条件成立。但数据中可能没有直接的字段，所以可能需要其他方式推断。

或者，可能用户的数据中的“股东涉嫌证券期货违法犯罪事件”列中的某些值可以表示是否被行政处罚，并且是否缴纳。例如，当该列的值是“行政处罚决定作出”时，可能意味着已经被处罚，但缴纳状态可能需要其他列的信息。但根据现有数据列，可能无法直接判断罚没款是否足额缴纳。这可能是一个问题，因为当前的数据可能没有足够的信息来判断condition中的部分条件。

这可能意味着，在现有数据的情况下，无法完全准确地判断condition是否满足。但根据任务要求，可能需要根据现有的列进行近似处理。例如，假设当“股东涉嫌证券期货违法犯罪事件”列中存在“行政处罚决定作出”，并且没有后续的缴纳记录，则视为罚没款未足额缴纳。或者，可能用户的数据中没有记录缴纳状态，所以只能根据是否有行政处罚决定作出，并假设此时罚没款尚未缴纳。这可能是一个假设，但可能需要根据现有数据来处理。

例如，在数据中，当股东的“股东涉嫌证券期货违法犯罪事件”列的值是“行政处罚决定作出”，并且没有其他事件（如缴纳完成），则视为罚没款未足额缴纳。但如何跟踪缴纳状态？可能需要按时间顺序处理每个股东的事件。

例如，对于每个股东，当出现“行政处罚决定作出”的事件后，在后续的日期中，如果没有其他事件表明罚没款已缴纳，则视为尚未缴纳。但数据中的“股东涉嫌证券期货违法犯罪事件”列可能只记录事件的发生，而没有后续的状态。因此，可能需要假设，一旦被行政处罚，则罚没款未缴纳，直到有另一个事件表明缴纳完成。但数据中可能没有这样的字段，所以这可能无法处理。

或者，可能用户的数据中的“股东涉嫌证券期货违法犯罪事件”列中的值可能包含多个状态，例如“行政处罚决定作出”表示已经被处罚，而其他值可能表示其他状态。但根据用户提供的可能值，该列的可能值包括：被中国证监会及其派出机构立案调查，中国证监会及其派出机构立案调查结束，行政处罚决定作出，被司法机关立案侦查，司法机关立案侦查结束，被本所公开谴责。因此，当该列的值是“行政处罚决定作出”时，表示该股东已经被行政处罚。但如何判断罚没款是否足额缴纳？这可能无法从现有数据中获取，因此可能需要假设，只要存在“行政处罚决定作出”的事件，并且没有其他条件，则视为罚没款未缴纳。或者，可能用户的数据中没有记录缴纳状态，所以无法判断，因此这个条件可能无法准确验证。但根据任务要求，可能需要根据现有数据进行近似处理。

在这种情况下，可能需要将condition的条件简化为：股东存在被中国证监会行政处罚的记录，并且没有其他例外情况。例如，当“股东涉嫌证券期货违法犯罪事件”列的值是“行政处罚决定作出”，并且没有其他条件（如减持资金用于缴纳罚没款的情形）。但如何判断是否存在例外情况？

例如，假设“拟减持原因”列中如果有“缴纳罚没款”的情况，则属于例外。因此，当“拟减持原因”是“缴纳罚没款”时，则存在例外，此时condition中的第二个条件（不存在法律、行政法规另有规定或减持资金用于缴纳罚没款的情形）不成立。因此，condition的成立需要同时满足：

1. 股东被行政处罚（即“股东涉嫌证券期货违法犯罪事件”列中存在“行政处罚决定作出”的记录）；
2. 罚没款未足额缴纳（假设只要存在行政处罚决定，且没有缴纳的记录，则视为未缴纳）；
3. 不存在减持资金用于缴纳罚没款的情形（即“拟减持原因”不是“缴纳罚没款”）；
4. 不存在法律、行政法规另有规定的情况（这可能无法从现有数据中判断，可能需要忽略，或者假设不存在）。

但根据现有数据列，可能只能处理部分条件。例如：

- 判断是否被行政处罚：检查“股东涉嫌证券期货违法犯罪事件”列是否包含“行政处罚决定作出”。
- 判断是否存在减持用于缴纳罚没款：检查“拟减持原因”是否为“缴纳罚没款”。
- 罚没款是否足额缴纳：可能无法判断，但假设只要存在行政处罚决定，则视为未缴纳，除非有缴纳的记录。但数据中没有缴纳记录，所以可能无法处理这部分，只能忽略，或者假设所有行政处罚都未缴纳。

这可能是一个挑战。因此，可能需要根据现有数据尽可能近似处理。

现在，我需要将这些条件转化为代码：

condition的条件是：

股东因涉及证券期货违法，被中国证监会行政处罚，且罚没款尚未足额缴纳，并且不存在法律、行政法规另有规定或减持资金用于缴纳罚没款的情形。

根据现有数据：

1. 涉及证券期货违法：可能对应“股东涉嫌证券期货违法犯罪事件”列中的“行政处罚决定作出”事件。
2. 被中国证监会行政处罚：同上。
3. 罚没款尚未足额缴纳：假设只要存在行政处罚决定，且没有缴纳的记录，则视为未缴纳。但数据中没有缴纳记录，所以可能无法判断，只能假设所有被行政处罚的股东都未缴纳。
4. 不存在法律、行政法规另有规定：可能无法判断，假设不存在。
5. 减持资金不用于缴纳罚没款：即“拟减持原因”列中的值不是“缴纳罚没款”。

因此，condition的valid条件可能为：

valid_condition = (
    (df['股东涉嫌证券期货违法犯罪事件'] == '行政处罚决定作出') &  # 被行政处罚
    (df['拟减持原因'] != '缴纳罚没款')  # 减持原因不是缴纳罚没款
)

但需要确认“拟减持原因”列的可能值是否包含“缴纳罚没款”。根据用户提供的列描述，“拟减持原因”列可能存在不同的原因，例如资金需求、投资等。假设其中有一个选项是“缴纳罚没款”，那么可以这样判断。否则，可能需要其他方式处理。

假设“拟减持原因”列中存在“缴纳罚没款”这一选项，那么当该列的值等于这个时，说明存在例外情况，此时condition的条件不成立。否则，如果被行政处罚且减持原因不是缴纳罚没款，则condition成立。

但还需要考虑时间因素。例如，行政处罚决定作出的日期是否在减持发生之前。例如，股东在某个日期被行政处罚，之后减持，此时condition才成立。因此，可能需要按时间顺序处理每个股东的事件，确保在减持发生之前已经存在行政处罚决定。

但根据当前的数据结构，每一行代表一个交易日的情况，可能需要按股东分组，并检查在该行日期之前是否发生过行政处罚决定作出的事件。

例如，对于每个股东，检查在该行的日期之前，是否有“股东涉嫌证券期货违法犯罪事件”为“行政处罚决定作出”的记录。如果有，则视为已经被行政处罚。同时，在该行的“拟减持原因”是否为缴纳罚没款。

这可能比较复杂，因为需要按股东分组，并检查历史记录。例如，对于每个股东，在每一行（日期）时，判断之前是否有过行政处罚决定作出的事件，并且在该行的减持原因不是缴纳罚没款。

因此，处理步骤可能如下：

1. 按股东分组。
2. 对每个股东的数据按日期排序。
3. 对于每个日期，检查该股东在此日期之前是否有“行政处罚决定作出”的事件。
4. 如果有，则标记为被行政处罚。
5. 同时，检查该行的“拟减持原因”是否为缴纳罚没款。
6. 如果被行政处罚且减持原因不是缴纳罚没款，则condition成立。

但如何实现这一点？例如，在pandas中，可以使用groupby和cummax来跟踪是否曾经发生过行政处罚决定作出的事件。

例如，对于每个股东，创建一个新的列，表示是否曾经被行政处罚。这可以通过对每个股东的数据按日期排序，然后检查“股东涉嫌证券期货违法犯罪事件”是否为“行政处罚决定作出”，并累积标记。

例如：

df['行政处罚标志'] = (df['股东涉嫌证券期货违法犯罪事件'] == '行政处罚决定作出').groupby([df['公司简称'], df['股东']]).cummax()

这样，对于每个股东，一旦出现“行政处罚决定作出”的事件，之后的所有行的“行政处罚标志”都为True。

然后，condition的条件可以简化为：

valid_condition = (
    df['行政处罚标志'] &  # 曾经被行政处罚
    (df['拟减持原因'] != '缴纳罚没款')  # 减持原因不是缴纳罚没款
)

但还需要考虑罚没款是否足额缴纳。但数据中没有缴纳的信息，所以可能无法处理这部分，只能假设只要被行政处罚，且减持原因不是缴纳罚没款，则condition成立。这可能是一个简化的处理方式，但根据现有数据，可能只能这样做。

接下来是constraint部分：不得减持其所持有的本公司股份。因此，需要检查该股东在当日是否有减持行为。例如，如果当日减持比例大于0，或者存在减持行为，则违反constraint。因此，constraint的valid条件是该股东当日没有减持。即，如果当日减持比例为0，则符合constraint（True），否则不符合（False）。

但根据任务要求，constraint的检查是独立进行的，即不管subject和condition是否满足，都要标记是否满足constraint。例如，即使subject和condition都不满足，只要当日没有减持，constraint的标记为True。这可能与实际法律要求不同，但根据任务要求，必须这样处理。

因此，constraint的valid条件为：

valid_constraint = (df['当日减持比例'] == 0)

或者，如果存在其他列表示减持行为，例如“当日减持比例”大于0，则视为减持。因此，当该列大于0时，constraint不满足，标记为False；否则为True。

现在，将这三个条件综合起来：

1. subject：股东是大股东（控股股东、实际控制人、持股5%以上股东，或持股比例>=5%）。
2. condition：股东被行政处罚，且减持原因不是缴纳罚没款。
3. constraint：当日没有减持。

然后，在代码中，需要分别标记这三个条件是否满足。

现在，编写代码的步骤：

首先，初始化三个新列，初始值为False或None：

df['meu_10_4_subject'] = False
df['meu_10_4_condition'] = False
df['meu_10_4_constraint'] = None  # 或者初始化为False？

根据例子中的处理，constraint列初始化为None，然后根据条件设置为True或False。例如：

df.loc[valid_constraint, 'meu_10_4_constraint'] = True
df.loc[~valid_constraint, 'meu_10_4_constraint'] = False

但可能更简单的方式是直接设置为布尔值。

现在，处理subject：

valid_subject = (
    df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
    (df['持股比例'] >= 0.05)
)

处理condition：

需要先创建“行政处罚标志”列，记录每个股东是否曾经被行政处罚。这可以通过groupby和cummax实现：

df.sort_values(['公司简称', '股东', '日期'], inplace=True)  # 确保按日期排序
df['行政处罚标志'] = (
    (df['股东涉嫌证券期货违法犯罪事件'] == '行政处罚决定作出')
    .groupby([df['公司简称'], df['股东']])
    .cummax()
)

然后，valid_condition的条件是：

valid_condition = (
    df['行政处罚标志'] & 
    (df['拟减持原因'] != '缴纳罚没款')
)

但还需要考虑是否存在法律、行政法规另有规定的情况。这部分可能无法从现有数据中判断，所以可能忽略，或者假设不存在。因此，暂时忽略这部分。

处理constraint：

valid_constraint = df['当日减持比例'] == 0

然后，将这三个条件分别标记到对应的列中。

综上，代码的大致结构如下：

import pandas as pd

def check_meu_10_4(df):
    df = df.copy()

    # 初始化列
    df['meu_10_4_subject'] = False
    df['meu_10_4_condition'] = False
    df['meu_10_4_constraint'] = None  # 初始化为None，之后填充布尔值

    # 处理subject
    valid_subject = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    df.loc[valid_subject, 'meu_10_4_subject'] = True

    # 处理condition
    # 按公司和股东分组，按日期排序，计算是否曾经被行政处罚
    df.sort_values(by=['公司简称', '股东', '日期'], inplace=True)
    df['行政处罚标志'] = (
        (df['股东涉嫌证券期货违法犯罪事件'] == '行政处罚决定作出')
        .groupby([df['公司简称'], df['股东']], group_keys=False)
        .cummax()
    )
    # 检查减持原因不是缴纳罚没款
    valid_condition = df['行政处罚标志'] & (df['拟减持原因'] != '缴纳罚没款')
    df.loc[valid_condition, 'meu_10_4_condition'] = True

    # 处理constraint
    valid_constraint = df['当日减持比例'] == 0
    df.loc[valid_constraint, 'meu_10_4_constraint'] = True
    df.loc[~valid_constraint, 'meu_10_4_constraint'] = False

    # 删除临时列
    df.drop('行政处罚标志', axis=1, inplace=True)

    return df

需要注意的问题：

1. 在groupby时，是否需要保持原来的顺序？因为排序可能会改变行的顺序。因此，在排序后，可能需要恢复原来的顺序。或者，在函数中，处理完condition后，将数据框恢复原来的顺序。例如，在排序前保存原始索引，处理后再恢复。

例如：

original_index = df.index
df.sort_values(..., inplace=True)
处理...
df = df.sort_index().reindex(original_index)

或者，在排序后处理完条件后，将数据框恢复原来的顺序。这可能比较复杂，但为了不影响其他处理，可能需要这样做。否则，后续的标记可能基于排序后的数据，导致错误。

例如，在排序后处理condition，但其他列（如subject和constraint）的标记可能基于排序后的数据，而用户传入的dataframe的顺序可能不同。因此，正确的做法是，在函数内部处理时，先保存原始顺序，处理完后再恢复。

这可能是一个问题。例如，在例子中的代码没有处理排序的问题，但在这个问题中，需要按日期排序来计算cummax。因此，正确的处理步骤应该是：

- 保存原始索引。
- 按公司和股东分组，并按日期排序，以确保cummax正确计算。
- 处理完condition后，恢复原始索引。

例如：

def check_meu_10_4(df):
    df = df.copy()

    # 保存原始索引以便恢复顺序
    original_index = df.index

    # 初始化列
    df['meu_10_4_subject'] = False
    df['meu_10_4_condition'] = False
    df['meu_10_4_constraint'] = None

    # 处理subject
    valid_subject = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    df.loc[valid_subject, 'meu_10_4_subject'] = True

    # 处理condition
    # 按公司和股东分组，按日期排序
    df_sorted = df.sort_values(by=['公司简称', '股东', '日期'])
    # 计算行政处罚标志
    df_sorted['行政处罚标志'] = (
        (df_sorted['股东涉嫌证券期货违法犯罪事件'] == '行政处罚决定作出')
        .groupby([df_sorted['公司简称'], df_sorted['股东']])
        .cummax()
    )
    # 将排序后的结果合并回原df
    df = df_sorted.sort_index().reindex(original_index)
    # 或者，可能更简单的方式是直接在原df上操作，但需要确保排序正确
    # 这里可能需要重新考虑方法，例如使用transform

    # 另一种方法：使用transform，不需要排序
    # 但cummax需要按时间顺序处理，所以必须排序
    # 因此，正确的做法是：

    # 按公司和股东分组，并按日期排序
    grouped = df.groupby(['公司简称', '股东'], group_keys=False)
    df_sorted = grouped.apply(lambda x: x.sort_values('日期'))
    # 在排序后的分组中计算cummax
    df_sorted['行政处罚标志'] = (
        (df_sorted['股东涉嫌证券期货违法犯罪事件'] == '行政处罚决定作出')
        .groupby([df_sorted['公司简称'], df_sorted['股东']])
        .cummax()
    )
    # 将结果合并回原df的顺序
    df = df_sorted.reset_index(drop=True).reindex(original_index)

    # 但这样可能比较复杂，可能需要更简单的方式

    # 另一种方法：在原始df中，按分组和日期排序，然后计算cummax
    df['行政处罚标志'] = (
        df.sort_values(['日期'])
        .groupby(['公司简称', '股东'])['股东涉嫌证券期货违法犯罪事件']
        .transform(lambda x: x.eq('行政处罚决定作出').cummax())
    )

    # 但这样可能无法正确按日期排序，因为transform可能不会保持顺序？

    # 正确的做法可能需要先按日期排序，然后分组计算cummax
    # 例如：

    df_sorted = df.sort_values(by=['公司简称', '股东', '日期'])
    df_sorted['行政处罚标志'] = (
        (df_sorted['股东涉嫌证券期货违法犯罪事件'] == '行政处罚决定作出')
        .groupby([df_sorted['公司简称'], df_sorted['股东']])
        .cummax()
    )
    # 然后，将排序后的数据合并回原索引顺序
    df = df_sorted.sort_index()

    # 现在，df中的'行政处罚标志'列是正确的，按每个股东的时间顺序累积是否被行政处罚

    # 然后，处理condition的条件
    valid_condition = (
        df['行政处罚标志'] & 
        (df['拟减持原因'] != '缴纳罚没款')
    )
    df.loc[valid_condition, 'meu_10_4_condition'] = True

    # 处理constraint
    valid_constraint = df['当日减持比例'] == 0
    df.loc[valid_constraint, 'meu_10_4_constraint'] = True
    df.loc[~valid_constraint, 'meu_10_4_constraint'] = False

    # 删除临时列
    df.drop('行政处罚标志', axis=1, inplace=True)

    return df

但这里可能存在排序的问题，因为原数据框的顺序可能被改变，导致后续处理错误。例如，如果原数据框的日期不是按顺序排列的，那么排序后的cummax可能不正确。因此，必须确保在计算cummax时，每个股东的数据是按日期升序排列的，这样才能正确累积行政处罚标志。

因此，正确的步骤应该是：

1. 按公司和股东分组，并按日期升序排列每个分组。
2. 在每个分组中，计算是否出现过“行政处罚决定作出”的事件，并累积到后续日期。
3. 将计算结果合并回原数据框的顺序。

这可以通过以下方式实现：

- 创建一个临时的排序后的数据框，计算行政处罚标志，然后将结果合并回原数据框。

例如：

# 保存原始索引
original_index = df.index

# 创建排序后的数据框
df_sorted = df.sort_values(by=['公司简称', '股东', '日期'])

# 计算行政处罚标志
df_sorted['行政处罚标志'] = (
    (df_sorted['股东涉嫌证券期货违法犯罪事件'] == '行政处罚决定作出')
    .groupby([df_sorted['公司简称'], df_sorted['股东']])
    .cummax()
)

# 将排序后的数据框的行政处罚标志合并回原数据框的顺序
df = df_sorted.reindex(original_index)

这样，原数据框的顺序被保留，但行政处罚标志是基于按日期排序后的分组计算的。这可能会有问题，因为当原数据框的顺序被打乱时，合并后的标志可能不正确。例如，原数据框中的行顺序可能不是按日期排列的，但计算标志时是按日期排序后的分组计算的。因此，正确的做法是，在计算标志时，确保每个分组内的数据是按日期排序的，然后将标志值赋给原数据框中的对应行。

例如，使用transform方法：

df['行政处罚标志'] = (
    df.groupby(['公司简称', '股东'])
    .apply(lambda x: x.sort_values('日期')['股东涉嫌证券期货违法犯罪事件'].eq('行政处罚决定作出').cummax())
    .reset_index(level=[0,1], drop=True)
)

但这种方法可能比较复杂，因为groupby后的apply返回的索引可能与原数据框不一致，导致赋值错误。因此，可能需要更稳妥的方式。

另一种方法是，在排序后的数据框中计算标志，然后将结果赋给原数据框：

# 创建排序后的数据框，并计算标志
df_sorted = df.sort_values(by=['公司简称', '股东', '日期']).copy()
df_sorted['行政处罚标志'] = (
    (df_sorted['股东涉嫌证券期货违法犯罪事件'] == '行政处罚决定作出')
    .groupby([df_sorted['公司简称'], df_sorted['股东']])
    .cummax()
)

# 将标志列合并回原数据框
df['行政处罚标志'] = df_sorted['行政处罚标志']

这样，原数据框中的顺序保持不变，但每个分组的标志是基于排序后的日期计算的。这可能有效，因为即使原数据框的顺序是乱的，排序后的数据框中的分组是按日期排序的，计算出的标志是正确的，然后通过索引对齐，将标志列赋给原数据框。这应该可以正确工作，因为即使数据框被排序，索引仍然对应原数据框的行。

因此，在代码中，可以这样处理：

# 处理condition
# 按公司和股东分组，并按日期排序，计算是否曾经被行政处罚
df_sorted = df.sort_values(by=['公司简称', '股东', '日期'])
df_sorted['行政处罚标志'] = (
    (df_sorted['股东涉嫌证券期货违法犯罪事件'] == '行政处罚决定作出')
    .groupby([df_sorted['公司简称'], df_sorted['股东']])
    .cummax()
)
# 将行政处罚标志合并回原df
df['行政处罚标志'] = df_sorted['行政处罚标志']

这样，df中的每一行都会获得正确的行政处罚标志，无论原数据框的顺序如何。

然后，处理condition的条件：

valid_condition = df['行政处罚标志'] & (df['拟减持原因'] != '缴纳罚没款')

但还需要考虑罚没款是否足额缴纳。由于数据中没有相关信息，可能无法处理，只能假设只要被行政处罚且未缴纳，则条件成立。因此，这部分条件可能无法完全满足，但根据现有数据，只能这样处理。

最后，处理constraint的条件：

valid_constraint = df['当日减持比例'] == 0

综上，最终的代码可能如下：

import pandas as pd

def check_meu_10_4(df):
    df = df.copy()

    # 初始化列
    df['meu_10_4_subject'] = False
    df['meu_10_4_condition'] = False
    df['meu_10_4_constraint'] = None

    # 处理subject
    valid_subject = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    df.loc[valid_subject, 'meu_10_4_subject'] = True

    # 处理condition
    # 按公司和股东分组，并按日期排序，计算是否曾经被行政处罚
    df_sorted = df.sort_values(by=['公司简称', '股东', '日期'])
    df_sorted['行政处罚标志'] = (
        (df_sorted['股东涉嫌证券期货违法犯罪事件'] == '行政处罚决定作出')
        .groupby([df_sorted['公司简称'], df_sorted['股东']])
        .cummax()
    )
    # 将行政处罚标志合并回原df
    df['行政处罚标志'] = df_sorted['行政处罚标志']

    # 检查减持原因是否为缴纳罚没款
    valid_condition = df['行政处罚标志'] & (df['拟减持原因'] != '缴纳罚没款')
    df.loc[valid_condition, 'meu_10_4_condition'] = True

    # 处理constraint
    valid_constraint = df['当日减持比例'] == 0
    df.loc[valid_constraint, 'meu_10_4_constraint'] = True
    df.loc[~valid_constraint, 'meu_10_4_constraint'] = False

    # 删除临时列
    df.drop('行政处罚标志', axis=1, inplace=True)

    return df

但需要测试这段代码是否正确处理了按时间顺序的行政处罚标志。例如，假设某个股东在某个日期被行政处罚，之后的所有日期的行政处罚标志都应为True。而之前的日期应为False。例如，在排序后的数据框中，cummax会确保一旦出现行政处罚决定作出，之后的所有行都标记为True。

此外，还需要确保“拟减持原因”列的处理正确。例如，如果减持原因是缴纳罚没款，则condition不成立。

最后，constraint的检查是独立进行的，不管subject和condition是否满足，只要当日没有减持，就标记为True。

综上，这段代码应该能够满足任务的要求。
","CompletionUsage(completion_tokens=7540, prompt_tokens=1723, total_tokens=9263, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=7060, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_4_8
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""拟在3个月内通过集中竞价交易减持股份的总数超过公司股份总数1%"", ""constraint"": ""应当在首次卖出的30个交易日前预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_4_8(df):
    '''
    检查MEU_4_8合规性：
    subject: 上市公司大股东 | 董监高
    condition: 拟在3个月内通过集中竞价交易减持股份总数超1%
    constraint: 需在首次卖出30个交易日前披露计划
    '''
    df = df.copy()

    # 初始化合规标记列
    df['meu_4_8_subject'] = False
    df['meu_4_8_condition'] = False
    df['meu_4_8_constraint'] = None  # 初始化为None以便区分未检查状态

    # 1. 验证责任主体 (subject)
    # 大股东标准：控股股东/实际控制人/持股5%以上股东或持股比例≥5%
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    # 董监高标准：直接身份标识
    is_director = df['股东身份'] == '董监高'
    valid_subject = is_major_shareholder | is_director
    df.loc[valid_subject, 'meu_4_8_subject'] = True

    # 2. 验证触发条件 (condition)
    # 集中竞价交易、存在减持计划、减持比例>1%、时间跨度≤90天
    valid_condition = (
        (df['减持方式'] == '竞价交易') &
        df['存在减持计划'] &
        (df['计划减持比例'] > 0.01) &
        ((df['计划结束日'] - df['计划开始日']).dt.days <= 90)
    )
    # 处理空值并标记
    valid_condition = valid_condition.fillna(False)
    df.loc[valid_condition, 'meu_4_8_condition'] = True

    # 3. 验证约束条件 (constraint)
    # 计算计划披露日与计划开始日的时间差
    days_diff = (df['计划开始日'] - df['计划披露日']).dt.days
    valid_constraint = days_diff >= 30
    # 空值处理并更新标记列
    valid_constraint = valid_constraint.fillna(False)
    df.loc[valid_constraint, 'meu_4_8_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_8_constraint'] = False

    return df
</CODE>","好的，我现在需要处理这个MEU_4_8的合规性检查。首先，我得仔细理解这个MEU的具体内容。MEU_4_8的subject是上市公司大股东或董监高，condition是计划在3个月内通过集中竞价交易减持股份超过公司总股本的1%，constraint是需要在首次卖出的30个交易日前预先披露减持计划。

首先，处理subject部分。根据附加信息中的股东身份列，可能的取值包括董监高、控股股东等。但还要注意，如果股东身份是董监高或离任董监高，但他们的持股比例超过5%，可能需要手动判断是否属于大股东。所以，我需要检查股东身份是否是“控股股东”、“实际控制人”、“持股5%以上股东”，或者是否是董监高（包括离任的？这里要看MEU是否包含离任的情况。MEU中的subject是“上市公司大股东 | 董监高”，可能离任的董监高是否算在内？原MEU中没有特别说明，可能只包括在任的。所以，股东身份列中的“董监高”才符合subject条件。或者，可能离任的董监高是否属于subject？需要看法律条文的具体规定。假设这里MEU中的董监高包括离任的，但可能需要进一步确认。不过根据附加信息中的说明，股东身份列中的“董监高”和“离任董监高”是分开的，所以MEU中的subject可能仅指在任的。因此，valid_subject应该是股东身份为“控股股东”、“实际控制人”、“持股5%以上股东”或者“董监高”，或者持股比例>=5%的情况？或者根据附加信息中的说明，股东身份列中的“董监高”可能已经包含了是否持股5%以上的情况？可能需要结合持股比例来判断。例如，如果股东身份是董监高，但持股比例是否达到5%？根据附加信息中的说明，股东身份列中的标签不会并列出现，所以即使董监高持股超过5%，他们的身份可能仍然是“董监高”而不是“持股5%以上股东”。所以，在判断subject时，除了检查股东身份是否是“控股股东”、“实际控制人”、“持股5%以上股东”或“董监高”之外，还需要检查持股比例是否>=5%的情况吗？根据MEU的subject是“上市公司大股东”，可能大股东指的是持股5%以上的股东，所以需要将股东身份为这些或者持股比例>=5%的视为有效subject。例如，可能有些股东虽然身份是普通股东，但持股比例超过5%，所以也属于大股东。因此，valid_subject的条件应该是：

股东身份属于['控股股东', '实际控制人', '持股5%以上股东', '董监高']，或者持股比例 >= 0.05？

或者，根据附加信息中的说明，“股东身份”列中的标签不会并列出现，所以如果某股东是董监高且持股超过5%，其身份可能只是“董监高”而没有“持股5%以上股东”的标签。因此，在判断subject时，需要同时考虑股东身份和持股比例。例如，如果股东身份是董监高，或者持股比例>=5%，则视为有效subject。或者，是否应该将股东身份为董监高，或者股东身份为其他大股东类型，或者持股比例>=5%的股东都算作subject？

根据MEU中的subject是“上市公司大股东 | 董监高”，所以大股东可能包括控股股东、实际控制人、持股5%以上的股东，或者任何持股超过5%的股东。因此，判断subject的条件应该是：

股东身份属于['控股股东', '实际控制人', '持股5%以上股东', '董监高']，或者持股比例 >= 0.05？

或者，可能原MEU中的“大股东”指的是控股股东、实际控制人、持股5%以上的股东，而董监高无论持股多少都属于subject。所以，valid_subject的条件是：

(股东身份属于['控股股东', '实际控制人', '持股5%以上股东']) | (股东身份属于['董监高']) | (持股比例 >= 0.05)

但根据附加信息中的说明，股东身份列中的标签不会并列出现，所以例如，一个股东可能同时是董监高且持股超过5%，但身份列可能只标记为“董监高”。因此，在判断时，需要将股东身份为董监高的视为有效，同时也要检查其他情况，如持股比例是否超过5%。例如：

is_major_shareholder = (df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东'])) | (df['持股比例'] >= 0.05)
is_director = df['股东身份'].isin(['董监高'])
valid_subject = is_major_shareholder | is_director

这样，无论是大股东还是董监高，都会被标记为有效subject。

接下来处理condition部分。condition是“拟在3个月内通过集中竞价交易减持股份的总数超过公司股份总数1%”。这里需要判断该股东是否有计划在接下来的3个月内通过集中竞价交易减持超过公司总股本的1%。

首先，减持方式必须是集中竞价交易，即“减持方式”列是否为“竞价交易”（根据附加信息中的说明，竞价交易包括集中竞价）。然后，计划减持的比例是否超过总股本的1%。总股本的数据在“总股本”列中，而计划减持的比例可能在“计划减持比例”列中。或者，可能需要计算计划减持的数量是否超过总股本的1%。例如，假设“计划减持比例”是该股东计划减持的股份占公司总股本的比例。或者，可能需要根据“计划减持比例”乘以总股本来计算是否超过1%。

例如，假设总股本是总股本列中的数值，那么计划减持的数量为计划减持比例 * 总股本。如果计划减持比例超过1%（即0.01），则满足条件。或者，如果“计划减持比例”是该股东自身持股的比例，那么需要转换为占公司总股本的比例。例如，如果股东持股5%，计划减持自身持股的20%，那么占公司总股本的比例是5% * 20% = 1%。这时候，如果计划减持比例是占自身持股的比例，那么需要计算是否超过总股本的1%。但根据附加信息中的列，是否有直接的“计划减持比例”列？根据提供的列，有“计划减持比例”列，但不确定其含义。假设“计划减持比例”是占公司总股本的比例，那么直接判断是否超过0.01即可。或者，如果“计划减持比例”是该股东减持自己持股的比例，那么需要乘以该股东的持股比例来计算占公司总股本的比例。例如，如果股东持股10%，计划减持自己持股的20%，则占公司总股本的2%（0.1 * 0.2 = 0.02），即超过1%。这时候，需要计算计划减持比例 * 持股比例是否超过0.01。但根据提供的列，是否有“计划减持比例”是占公司总股本的比例？或者是否有“计划减持数量”？

根据提供的列，有“计划减持比例”列，可能是指占公司总股本的比例。例如，如果计划减持比例是0.015（即1.5%），则超过1%。因此，condition的条件是：

减持方式为“竞价交易”，并且计划减持比例 > 0.01，并且该减持计划的时间范围在3个月内？

但如何判断时间范围是否在3个月内？例如，假设“计划开始日”和“计划结束日”之间的时间跨度是否在3个月（约90天）内。或者，是否计划减持的整个时间段在未来的3个月内？

或者，MEU中的condition是“拟在3个月内”减持超过1%，所以需要判断该减持计划的整个时间段是否在接下来的3个月内。例如，计划开始日到计划结束日之间的天数是否<=90天？

或者，可能该股东在某个交易日有减持计划，并且该计划的结束日距离当前日期（即该行的日期）是否在3个月内？

或者，是否该减持计划是在未来3个月内进行的？例如，计划开始日到计划结束日之间的时间跨度不超过3个月，并且减持方式为集中竞价交易，且减持比例超过1%。

这部分可能需要更详细的条件判断。例如，对于每一行数据（即某个交易日），如果该股东在该行日期存在减持计划（存在减持计划为True），并且减持方式为竞价交易，并且计划减持比例超过总股本的1%，并且计划结束日与计划开始日之间的天数不超过90天，则满足condition条件。

或者，是否只要该股东在未来的3个月内有减持超过1%的计划，就满足condition？例如，假设在某个交易日，该股东存在减持计划，且计划减持比例超过1%，并且减持方式为竞价交易，那么无论该计划的持续时间是否在3个月内，都视为满足condition？

这里可能需要仔细理解MEU中的条件。MEU中的condition是“拟在3个月内通过集中竞价交易减持股份的总数超过公司股份总数1%”，所以这里的“3个月内”可能指的是从计划开始到减持完成的时间不超过3个月，或者计划的时间跨度在3个月内。或者，可能指的是股东计划在未来3个月内进行减持，无论实际减持时间是否在3个月内完成。

例如，假设股东在某个交易日存在减持计划，该计划的开始日到结束日之间的时间跨度不超过3个月，并且减持方式为集中竞价，且总减持数量超过公司总股本的1%。这时候，该行的condition条件满足。

或者，可能只要股东在减持计划中计划的总减持数量超过1%，并且减持方式为集中竞价，则视为满足condition，而时间范围可能由其他条件决定？

这部分可能需要假设。例如，假设“计划减持比例”列代表该股东计划减持的股份占公司总股本的比例，并且减持方式为竞价交易，那么只要存在减持计划（存在减持计划为True），并且减持方式为竞价交易，并且计划减持比例>0.01，则满足condition。而时间范围可能由其他列决定，比如计划开始日和计划结束日之间的天数是否<=90天？

或者，可能MEU中的“3个月内”是指股东计划在未来的3个月内进行减持，即计划开始日距离当前日期（该行的日期）不超过3个月？

例如，对于某一行数据（日期为某一天），如果该股东在该日期存在减持计划，并且计划开始日在该日期之后的3个月内（即计划开始日 <= 该日期 + 90天），并且减持方式为竞价交易，计划减持比例超过1%，则满足condition。

或者，可能MEU中的“3个月内”是指整个减持过程在3个月内完成，即计划结束日 - 计划开始日 <= 90天？

这需要根据法律条文的理解。例如，法律条文可能要求股东在计划减持时，如果预计在3个月内减持超过1%，则需要提前披露。因此，这里的3个月可能是指股东预计的减持时间跨度，而不是从当前日期到减持开始的时间。

假设在这种情况下，我们需要检查该减持计划的持续时间是否在3个月内，并且减持比例超过1%。因此，condition的条件是：

减持方式为竞价交易，并且计划减持比例 > 0.01，并且 (计划结束日 - 计划开始日).dt.days <= 90。

但需要注意，计划开始日和计划结束日可能在某些行中为NaN，或者需要确保这些列存在。根据提供的列，存在“计划开始日”和“计划结束日”列，所以可以计算天数差。

因此，condition的条件包括：

1. 减持方式为“竞价交易”；
2. 存在减持计划（存在减持计划为True）；
3. 计划减持比例 > 0.01；
4. 计划结束日与计划开始日之间的天数差 <= 90。

或者，可能不需要检查时间跨度，只要股东在减持计划中计划的总减持比例超过1%，并且减持方式为集中竞价，则视为满足condition，而不管时间跨度。这可能取决于法律条文的具体要求。例如，法律条文中的“拟在3个月内”可能是指股东计划在接下来的3个月内进行减持，而不是已经开始的计划。这时候，可能需要检查该行的日期是否在计划开始日之前的某个时间范围内。

这部分可能需要更仔细的分析。例如，假设某股东在某个日期（行中的日期）存在减持计划，该计划的开始日是该日期之后的某一天，而结束日是该日期之后的90天内。这时候，该计划是否属于“拟在3个月内”减持？

或者，可能“拟在3个月内”指的是股东在计划中预计在未来的3个月内进行减持，因此，只要该计划的减持时间段在未来的3个月内，即计划开始日距离当前日期不超过3个月，并且减持比例超过1%。

例如，对于某一行数据中的日期，如果该行的存在减持计划为True，并且减持方式为竞价交易，计划减持比例超过1%，并且计划开始日 <= 该日期 + 90天，则满足condition。

或者，可能不需要考虑当前行的日期，而是只要该减持计划的整个时间段在3个月内，即计划结束日 - 计划开始日 <=90天，并且减持比例超过1%。

这可能需要更多的上下文信息，但根据问题描述，可能需要根据现有的列来判断。

假设在这种情况下，condition的条件是：

减持方式为竞价交易，并且存在减持计划为True，并且计划减持比例 > 0.01，并且 (计划结束日 - 计划开始日).dt.days <= 90。

但需要确认这些列是否存在。根据提供的列，确实有“减持方式”、“存在减持计划”、“计划减持比例”、“计划开始日”、“计划结束日”等列。

接下来处理constraint部分。constraint是“应当在首次卖出的30个交易日前预先披露减持计划”。这需要检查在首次卖出前30个交易日是否已经披露了减持计划。这里的首次卖出可能指的是减持计划中的首次卖出日，或者实际减持的首次日期？

根据附加信息中的列，可能有“计划披露日”列。假设“计划披露日”是披露减持计划的日期，而“计划开始日”是首次卖出的日期。因此，需要检查计划披露日是否在计划开始日的至少30个交易日前。

例如，对于每一行数据，如果该股东存在减持计划，并且计划披露日 <= 计划开始日 - 30个交易日。但如何计算30个交易日前的日期？

或者，可能需要计算计划开始日与计划披露日之间的交易日差是否 >=30。例如，假设该行的日期是某个交易日，但需要根据计划开始日和计划披露日来计算。例如，对于该股东的减持计划，计划披露日必须早于计划开始日至少30个交易日。

因此，constraint的条件是：

计划披露日 <= 计划开始日 - 30个交易日。

但如何计算两个日期之间的交易日差？根据附加信息中的说明，所有日期相关的列已经是pd.datetime格式，并且“日期”列本身就是交易日。但如何计算两个日期之间的交易日数量？

例如，假设有一个函数可以计算两个日期之间的交易日天数，比如使用pandas的日期功能，或者使用一个交易日历。但根据问题描述，可能需要假设“日期”列是连续的交易日，或者可能需要使用自然日来计算，但问题中说明自然日需要计算，而交易日已经处理过。

或者，根据附加信息中的说明，自然日需要计算，而交易日已经处理。因此，计划披露日和计划开始日之间的自然日天数是否 >=30个交易日？或者，是否应该计算这两个日期之间的实际交易日天数？

例如，如果计划开始日是2023-01-30，计划披露日是2023-01-01，那么两者之间的自然日天数是29天，但交易日天数可能更少（比如有周末和节假日）。但根据问题中的说明，用户可能无法提供交易日历，因此可能需要用自然日来近似，或者假设每个自然日都是交易日？

或者，根据附加信息中的说明，所有日期相关的列已经是pd.datetime格式，并且“日期”列本身就是交易日，但其他日期列如计划披露日、计划开始日可能不是交易日。例如，计划披露日可能是某个自然日，但可能不是交易日。这时候，如何计算两个日期之间的交易日差？

这可能比较复杂。但根据问题中的示例代码，例如在示例中，使用了 (df['计划开始日'] - df['计划披露日']).dt.days 来计算自然日的天数差，并检查是否 >=15。这可能意味着在示例中，法律要求的是自然日，而不是交易日。或者，可能法律条文中的“15日”指的是自然日，而示例中的处理方式是正确的。

回到当前问题，MEU_4_8的constraint是“应当在首次卖出的30个交易日前预先披露减持计划”。这里的“30个交易日”是交易日，而不是自然日。因此，需要计算计划披露日与计划开始日之间的交易日天数是否 >=30。

但如何计算两个日期之间的交易日天数？例如，如果有一个包含所有交易日的列表，可以计算两个日期之间的交易日数量。但根据问题中的dataframe结构，可能没有这样的列表。因此，可能需要假设“日期”列是连续的交易日，或者使用某种方法计算。

或者，问题中的示例可能忽略了这个复杂性，而直接使用自然日进行计算。例如，在示例中，MEU_4_1的constraint是“提前15日公告”，示例代码中计算的是自然日差。这可能意味着，在法律条文中，“15日”指的是自然日，而不是交易日。因此，在MEU_4_8中的“30个交易日”可能指的是自然日，或者需要明确处理。

但根据问题中的描述，用户提供的dataframe中的日期列已经是交易日，所以可能计划开始日和计划披露日也是交易日。因此，计算它们之间的差，直接相减得到的天数即为交易日天数。例如，如果计划开始日是某月的第30个交易日，计划披露日是同一月的第1个交易日，那么差为29天，不满足30个交易日的要求。

因此，在代码中，可以计算计划开始日与计划披露日之间的天数差是否 >=30。例如：

df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days

然后，valid_constraint = df['交易日差'] >=30

但需要注意，如果计划披露日为空，或者计划开始日为空，则可能返回False。此外，必须存在减持计划（存在减持计划为True）吗？

根据MEU的constraint，只有当subject和condition都满足时，才需要检查constraint吗？根据用户的要求中的说明：“对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查。” 因此，constraint的检查是独立的，不管subject和condition是否满足，都需要标记。但根据问题中的示例，在示例中，constraint的检查是独立的，例如：

valid_constraint = df['交易日差'] >=15 & df['存在减持计划']

所以，在示例中，只要存在减持计划，并且交易日差>=15，就视为满足constraint。这可能意味着，不管subject和condition是否满足，只要存在减持计划，并且满足交易日差条件，就标记constraint为True。

但根据MEU的约束，只有当subject和condition都满足时，才需要满足constraint。但根据用户的要求，对于简单操作dataframe的项目，三个条件的检查是独立的。因此，在编写代码时，需要分别标记subject、condition、constraint各自的满足情况，不管其他条件是否满足。

例如，对于constraint的检查，只要该行的计划披露日比计划开始日提前30个交易日，就标记为True，不管该行是否属于subject或condition。

但根据法律条文，只有当subject和condition都满足时，才需要遵守constraint。但用户的要求是，对于简单操作dataframe的项目，三个条件的检查是独立的。因此，在代码中，需要分别检查每个条件，而不管其他条件是否满足。例如，即使某行不满足subject或condition，只要constraint的条件满足，就标记为True。

这可能与实际情况不符，但根据用户的要求，必须这样做。因此，在编写代码时，需要分别处理三个条件，各自独立判断。

因此，对于constraint的检查，需要判断该股东是否在计划开始日的30个交易日前披露了减持计划。即，计划披露日 <= 计划开始日 - 30个交易日。或者，计划开始日 - 计划披露日 >=30个交易日。

因此，在代码中，可以计算交易日差：

df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days

然后，valid_constraint = df['交易日差'] >=30

但需要注意，如果计划开始日或计划披露日为空，则交易日差可能为NaN，此时应视为不满足条件。因此，在代码中可能需要处理这些情况，例如：

valid_constraint = (df['计划开始日'] - df['计划披露日']).dt.days >=30

但需要确保这两个日期列不为空。或者，可能只有当存在减持计划时，这两个日期才有值。因此，在存在减持计划的情况下，检查这两个日期是否满足条件。否则，constraint可能不适用。

但根据用户的要求，constraint的检查是独立的，不管subject和condition是否满足。因此，即使某行不存在减持计划，只要计划披露日和计划开始日满足条件，就标记为True。这可能不符合法律条文的要求，但根据用户的要求，必须这样处理。

综上，现在需要将各个条件独立判断：

1. subject的判断：股东身份属于大股东或董监高，或者持股比例>=5%。
2. condition的判断：减持方式为竞价交易，存在减持计划，计划减持比例>1%，并且计划时间段在3个月内（即计划结束日 - 计划开始日 <=90天？或者计划开始日到当前日期在3个月内？这部分可能需要进一步明确）。
3. constraint的判断：计划披露日比计划开始日早至少30个交易日。

现在，针对各个条件的具体处理：

对于subject：

valid_subject = (股东身份是控股股东、实际控制人、持股5%以上股东、董监高) 或者 持股比例 >=5%。

代码：

is_major_shareholder = df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) | (df['持股比例'] >= 0.05)
is_director = df['股东身份'].isin(['董监高'])
valid_subject = is_major_shareholder | is_director

对于condition：

需要满足：

- 减持方式为竞价交易；
- 存在减持计划为True；
- 计划减持比例 > 0.01；
- 计划的时间跨度在3个月内（即计划结束日 - 计划开始日 <=90天？或者计划开始日到当前日期在3个月内？）

这里可能需要明确时间跨度的判断。例如，假设股东在某个交易日存在减持计划，该计划的开始日和结束日之间的天数差 <=90天，并且减持比例超过1%。或者，可能该计划的整个减持时间段在未来的3个月内，即计划开始日距离当前日期（该行的日期）不超过3个月？

例如，假设该行的日期是某一天，计划开始日是该日期之后的某一天，而计划结束日是该日期之后的90天内。这时候，计划的时间跨度是否在3个月内？

或者，可能法律条文中的“拟在3个月内”指的是股东计划在未来的3个月内完成减持，因此，整个减持时间段（从开始到结束）不超过3个月。因此，计划结束日 - 计划开始日 <=90天。

因此，condition的条件是：

valid_condition = (
    (df['减持方式'] == '竞价交易') &
    (df['存在减持计划']) &
    (df['计划减持比例'] > 0.01) &
    ((df['计划结束日'] - df['计划开始日']).dt.days <= 90)
)

但需要注意，如果计划结束日或计划开始日为空，这部分条件会返回False。因此，只有当这些日期存在时，才会被考虑。

对于constraint：

需要满足计划披露日比计划开始日早至少30个交易日。因此：

valid_constraint = (df['计划开始日'] - df['计划披露日']).dt.days >=30

同样，如果这两个日期中的任何一个为空，则返回False。

现在，将这些条件应用到dataframe中，并分别标记各列。

最后，将valid_subject、valid_condition、valid_constraint的结果分别赋值给对应的列。

需要注意的是，在示例代码中，constraint的列初始化为None，然后根据条件设置为True或False。例如：

df['meu_4_2_constrain'] = None
...
df.loc[valid_constraint, 'meu_4_1_constraint'] = True
df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

但可能更有效的方式是直接使用布尔值，例如：

df['meu_4_8_constraint'] = valid_constraint.astype(bool)

但需要处理可能的NaN值。例如，如果计划开始日或计划披露日为空，则valid_constraint可能为NaN，此时应视为False。

因此，在代码中可能需要将NaN转换为False：

valid_constraint = ((df['计划开始日'] - df['计划披露日']).dt.days >=30).fillna(False)

或者，在计算时处理缺失值：

valid_constraint = (
    (df['计划开始日'] - df['计划披露日']).dt.days >=30
) & df['计划开始日'].notna() & df['计划披露日'].notna()

或者，使用fillna(False)：

valid_constraint = (
    (df['计划开始日'] - df['计划披露日']).dt.days >=30
).fillna(False)

这样，缺失的日期会被视为不满足条件。

综上，现在可以编写代码：

首先，初始化各列：

df['meu_4_8_subject'] = False
df['meu_4_8_condition'] = False
df['meu_4_8_constraint'] = False

然后，计算各条件：

valid_subject的条件：

is_major_shareholder = df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) | (df['持股比例'] >= 0.05)
is_director = df['股东身份'] == '董监高'
valid_subject = is_major_shareholder | is_director

valid_condition的条件：

valid_condition = (
    (df['减持方式'] == '竞价交易') &
    df['存在减持计划'] &
    (df['计划减持比例'] > 0.01) &
    ((df['计划结束日'] - df['计划开始日']).dt.days <= 90)
).fillna(False)

valid_constraint的条件：

valid_constraint = (
    (df['计划开始日'] - df['计划披露日']).dt.days >=30
).fillna(False)

然后，将结果赋值给对应的列：

df.loc[valid_subject, 'meu_4_8_subject'] = True
df.loc[valid_condition, 'meu_4_8_condition'] = True
df.loc[valid_constraint, 'meu_4_8_constraint'] = True

但需要注意，在示例代码中，constraint的列初始化为None，然后设置为True或False。但根据用户的要求，可能应该将constraint的列初始化为False，然后根据条件设置为True。或者，根据问题中的示例，可能初始化为None，然后根据条件设置True或False。例如：

在示例中：

df['meu_4_2_constrain'] = None  # constrain需要初始化为None
...
df.loc[valid_constraint, 'meu_4_1_constraint'] = True
df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

因此，在代码中，可能需要将constraint列初始化为None，然后根据条件设置True或False。例如：

df['meu_4_8_subject'] = False
df['meu_4_8_condition'] = False
df['meu_4_8_constraint'] = None  # 初始化为None

然后：

valid_constraint = ((df['计划开始日'] - df['计划披露日']).dt.days >=30).fillna(False)
df.loc[valid_constraint, 'meu_4_8_constraint'] = True
df.loc[~valid_constraint, 'meu_4_8_constraint'] = False

这样，constraint列中的值会是True或False，而不是NaN。

综上，现在将所有条件整合到代码中：

import pandas as pd

def check_meu_4_8(df):
    '''
    检查MEU_4_8的合规性：
    subject: 上市公司大股东 | 董监高
    condition: 拟在3个月内通过集中竞价交易减持股份的总数超过公司股份总数1%
    constraint: 应当在首次卖出的30个交易日前预先披露减持计划
    '''
    df = df.copy()

    # 初始化列
    df['meu_4_8_subject'] = False
    df['meu_4_8_condition'] = False
    df['meu_4_8_constraint'] = None  # 初始化为None，后续用布尔值填充

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'] == '董监高'
    valid_subject = is_major_shareholder | is_director
    df.loc[valid_subject, 'meu_4_8_subject'] = True

    # 标记valid的condition
    # 条件：减持方式为竞价交易，存在减持计划，计划减持比例>1%，且计划时间跨度<=90天
    valid_condition = (
        (df['减持方式'] == '竞价交易') &
        df['存在减持计划'] &
        (df['计划减持比例'] > 0.01) &
        ((df['计划结束日'] - df['计划开始日']).dt.days <= 90)
    )
    # 处理可能的NaN值
    valid_condition = valid_condition.fillna(False)
    df.loc[valid_condition, 'meu_4_8_condition'] = True

    # 标记valid的constraint
    # 条件：计划披露日早于计划开始日至少30个交易日
    # 计算交易日差，假设日期列是交易日
    days_diff = (df['计划开始日'] - df['计划披露日']).dt.days
    valid_constraint = days_diff >= 30
    # 处理可能的NaN值，例如计划开始日或计划披露日为空
    valid_constraint = valid_constraint.fillna(False)
    df.loc[valid_constraint, 'meu_4_8_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_8_constraint'] = False

    return df

需要注意的问题：

1. 在condition的判断中，计划减持比例是否指的是占公司总股本的比例？假设是的，因此直接比较是否大于0.01。

2. 在时间跨度的判断中，是否应该使用自然日还是交易日？根据问题中的示例，示例中使用的是自然日差，因此这里也使用自然日差。但法律条文中的“3个月内”可能指的是自然日，因此使用自然日差是合理的。

3. 对于减持计划的时间跨度，即计划结束日 - 计划开始日 <=90天，这可能与实际情况中的自然月不同（例如，3个月可能有92天），但法律条文中的“3个月”可能按自然月计算，例如，从计划开始日后的3个月。例如，如果计划开始日是1月15日，那么3个月后是4月15日，计划结束日必须<=4月15日。这种情况下，计算自然日差可能不准确。但根据问题中的示例，使用自然日差是可行的，因此这里也采用同样的方法。

4. 在constraint的判断中，是否应该使用交易日差？法律条文中的“30个交易日”可能指的是实际的交易日，而不是自然日。但根据问题中的示例，示例中的“15个交易日”被处理为自然日差。因此，这里可能存在矛盾。例如，在示例中，MEU_4_1的constraint是“提前15日公告”，示例代码中使用的是自然日差。因此，可能用户希望在这里也使用自然日差，即使法律条文中的“30个交易日”可能指的是交易日。但根据问题中的描述，用户可能希望用自然日差来近似，或者可能dataframe中的日期列已经是连续的交易日，因此自然日差等于交易日差。例如，如果dataframe中的日期列是连续的交易日，没有周末和节假日，那么自然日差等于交易日差。因此，在这种情况下，使用自然日差是正确的。

但根据附加信息中的说明，“日期”列本身就是交易日，但其他日期列（如计划开始日、计划披露日）可能不是交易日。例如，计划披露日可能是一个非交易日，比如周末，但法律要求披露必须在交易日进行。因此，可能需要调整这些日期到最近的交易日。但根据问题中的描述，用户可能没有提供这样的处理方式，因此假设计划披露日和计划开始日都是交易日，或者忽略非交易日的情况。

综上，代码中的处理方式是正确的，即使用自然日差来计算交易日差，这可能与实际情况存在差异，但根据示例和问题描述，这是可接受的处理方式。
","CompletionUsage(completion_tokens=7786, prompt_tokens=1717, total_tokens=9503, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=7204, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_17_2
法律的最小可执行单元内容: {""subject"": ""上市公司董监高"", ""condition"": ""所持股份不超过1000股"", ""constraint"": ""可一次全部转让且不受前款转让比例限制"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_17_2(df):
    '''
    检查MEU_17_2合规性：
    subject: 上市公司董监高
    condition: 所持股份不超过1000股
    constraint: 可一次全部转让且不受前款转让比例限制
    '''
    df = df.copy()
    
    # 初始化标记列
    df['meu_17_2_subject'] = False
    df['meu_17_2_condition'] = False
    df['meu_17_2_constraint'] = None  # 初始化为None便于布尔值填充
    
    # 1. 验证责任主体：上市公司董监高
    # 根据股东身份字段直接匹配
    valid_subject = df['股东身份'] == '董监高'
    df.loc[valid_subject, 'meu_17_2_subject'] = True
    
    # 2. 验证触发条件：持股数量≤1000股
    # 直接比较数值型字段
    valid_condition = df['持股数量'] <= 1000
    df.loc[valid_condition, 'meu_17_2_condition'] = True
    
    # 3. 验证约束条件：一次性全部转让
    # 通过当日/累计减持比例判断是否清仓
    valid_constraint = (
        (df['当日减持比例'] == 1.0) |  # 当日清仓
        (df['累计减持比例'] == 1.0)    # 累计清仓
    )
    df.loc[valid_constraint, 'meu_17_2_constraint'] = True
    df.loc[~valid_constraint, 'meu_17_2_constraint'] = False
    
    return df
</CODE>","好的，我现在需要处理这个MEU_17_2的合规性检查任务。首先，我得仔细理解这个MEU的具体内容。根据提供的资料，MEU_17_2的subject是“上市公司董监高”，condition是“所持股份不超过1000股”，constraint是“可一次全部转让且不受前款转让比例限制”。我的任务是为输入的DataFrame编写一个函数，检查每一行是否符合这三个条件，并分别标记出来。

首先，处理subject部分。根据附加信息中的股东身份列，合法的subject是“董监高”。所以，我需要检查每一行的股东身份是否为“董监高”。这里需要注意的是，附加信息中提到股东身份的可能值包括“董监高”和“离任董监高”等，所以必须严格匹配“董监高”这个值。因此，valid_subject的条件应该是df['股东身份'] == '董监高'。

接下来是condition部分，条件是所持股份不超过1000股。这里的数据列是“持股数量”，所以需要检查该列的值是否小于等于1000。需要注意的是，这里的单位是股，所以直接比较即可。valid_condition的条件是df['持股数量'] <= 1000。

然后是constraint部分，约束是允许一次全部转让且不受前款限制。但根据任务要求，对于constraint的检查是独立进行的，不需要依赖subject和condition是否满足。不过，这里可能需要明确，这里的约束是否涉及其他条件，比如是否实际进行了转让。但根据MEU的描述，constraint可能是指当满足subject和condition时，可以豁免某些限制。但根据用户的要求，这里需要独立检查constraint的条件，而不管subject和condition是否满足。不过，可能这里的constraint是否满足需要看是否一次全部转让，但数据中是否有相关字段呢？

不过，根据提供的DataFrame列，可能相关的列是“当日减持比例”或“累计减持比例”，或者是否存在减持计划。但MEU的constraint描述是允许一次转让，所以可能这里的约束是否被满足，需要看该股东是否在减持时一次性卖出了所有股份。但数据中是否有这样的信息呢？

例如，假设当该股东在减持时，如果当日减持比例等于其持股比例，或者累计减持比例等于100%，则视为满足。但根据现有的列，可能需要检查是否存在一次全部转让的情况。例如，如果某行的“当日减持比例”等于该股东的持股比例，或者累计减持比例达到了100%，则视为满足约束条件。但需要看数据中的具体列。

但根据提供的列，有“当日减持比例”和“累计减持比例”这两个列。假设“当日减持比例”是该股东当天减持的股份占其总持股的比例，而“累计减持比例”是到当天为止累计减持的比例。那么，如果某天该股东减持了全部股份（即当日减持比例为1，或者累计减持比例变为1），则视为满足约束条件。但需要确认这些列的数据类型是否为小数形式，比如1代表100%。

或者，可能“当日减持比例”是该股东当天减持的股份数量占其总持股的比例，而“累计减持比例”是到当天为止累计减持的比例。例如，如果某股东原本持有1000股，当天减持了1000股，那么当日减持比例就是1.0，累计减持比例也是1.0。这时候，该行的constraint条件会被满足。

因此，valid_constraint的条件可能是该行的“当日减持比例”等于1.0，或者“累计减持比例”等于1.0。或者，如果该股东在减持时一次性卖出了所有股份，那么当日的减持数量等于其当时的持股数量。但数据中是否有“减持数量”这样的列呢？根据提供的列，可能没有直接的减持数量，只有减持比例。因此，可能需要用减持比例来判断是否全部转让。

例如，假设某行的“当日减持比例”等于1.0，或者该行的“累计减持比例”等于1.0，则视为满足constraint条件。但需要确认这些列的定义。例如，“当日减持比例”可能是指当天减持的股份数量占该股东原本持股数量的比例。如果是这样的话，当该比例为1时，说明当天全部卖出。

因此，valid_constraint的条件可以是（df['当日减持比例'] == 1.0） | （df['累计减持比例'] == 1.0）。但需要看数据中的实际情况。或者，可能还有其他条件需要考虑，比如是否存在减持计划，或者减持是否已经完成。

但根据MEU的约束内容，只要满足subject和condition的情况下，可以一次全部转让，所以这里的constraint可能是指当subject和condition满足时，允许一次性转让。但根据任务要求，这里的constraint检查是独立的，不需要考虑subject和condition是否满足。因此，不管股东是否是董监高，或者是否持股不超过1000股，只要该股东在当天有一次全部转让的行为，就标记为满足constraint条件？

或者，可能这里的constraint条件是指该股东是否在减持时一次全部转让，而不管是否满足其他条件。例如，如果某股东当天减持了全部股份，则视为满足constraint条件。因此，valid_constraint的条件是当天的减持比例等于1.0，或者累计减持比例等于1.0。

但根据MEU的约束内容，这里的约束是“可一次全部转让且不受前款转让比例限制”，可能意味着当满足subject和condition时，可以不受其他转让比例的限制。但在这个任务中，用户要求对三元组的检查是各自独立的，所以constraint的检查不需要考虑subject和condition是否满足。因此，只要该股东在当天有一次全部转让的行为，就视为满足constraint条件。或者，这里的约束条件可能是指该股东是否被允许一次全部转让，而不管是否实际执行。但数据中可能没有直接的字段，所以可能需要根据是否存在减持计划，并且计划中的减持比例是否为100%。

例如，如果存在减持计划，并且计划减持比例等于1.0，则视为满足约束条件。或者，如果当天的减持行为是一次性全部转让，则视为满足。但根据现有的列，可能只能通过减持比例来判断。

综上，可能的处理步骤是：

1. 标记subject：股东身份是否为“董监高”。
2. 标记condition：持股数量是否<=1000。
3. 标记constraint：当日减持比例是否为1.0，或者累计减持比例是否为1.0。

但需要确认数据中的列是否支持这样的判断。例如，假设“当日减持比例”是该股东当天减持的股份占其原持股的比例，那么当该比例等于1时，说明当天全部卖出。同样，“累计减持比例”是该股东累计减持的比例，当等于1时，说明已经全部卖出。

因此，valid_constraint的条件是（df['当日减持比例'] == 1.0） | （df['累计减持比例'] == 1.0）。

但需要注意，如果某股东在当天减持了部分股份，但累计减持比例尚未达到1.0，那么该行不满足constraint条件。只有当某次减持导致全部股份被卖出时，才满足。

现在，将这些条件转化为代码：

首先，初始化三个新的列，meu_17_2_subject、meu_17_2_condition、meu_17_2_constraint，初始值为False或None。

对于subject：
valid_subject = df['股东身份'] == '董监高'

对于condition：
valid_condition = df['持股数量'] <= 1000

对于constraint：
valid_constraint = (df['当日减持比例'] == 1.0) | (df['累计减持比例'] == 1.0)

然后，将这些条件应用到对应的列上。

需要注意的是，在示例代码中，constraint列初始化为None，然后用布尔值填充。但根据用户的要求，对于constraint的检查是独立进行的，所以即使subject和condition不满足，只要constraint条件满足，就标记为True。

现在，将这些逻辑写入代码：

函数名为check_meu_17_2，参数是df。

初始化三个列：

df['meu_17_2_subject'] = False
df['meu_17_2_condition'] = False
df['meu_17_2_constraint'] = None  # 初始化为None，之后用布尔值填充？

或者，根据示例中的处理，初始化为False，然后根据条件设置为True？

在示例中，meu_4_1_constraint初始化为None，之后根据valid_constraint设置为True或False。例如：

df.loc[valid_constraint, 'meu_4_1_constraint'] = True
df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

所以，在代码中，应该将constraint列初始化为None，然后根据条件设置True或False。

现在，编写代码：

import pandas as pd

def check_meu_17_2(df):
    '''
    检查MEU_17_2的合规性：
    subject: 上市公司董监高
    condition: 所持股份不超过1000股
    constraint: 可一次全部转让且不受前款转让比例限制
    '''
    df = df.copy()

    # 初始化列
    df['meu_17_2_subject'] = False
    df['meu_17_2_condition'] = False
    df['meu_17_2_constraint'] = None  # 初始化为None，之后填充布尔值

    # 检查subject
    valid_subject = df['股东身份'] == '董监高'
    df.loc[valid_subject, 'meu_17_2_subject'] = True

    # 检查condition
    valid_condition = df['持股数量'] <= 1000
    df.loc[valid_condition, 'meu_17_2_condition'] = True

    # 检查constraint：是否一次全部转让
    # 假设当日减持比例等于1或累计减持比例等于1表示全部转让
    valid_constraint = (df['当日减持比例'] == 1.0) | (df['累计减持比例'] == 1.0)
    df.loc[valid_constraint, 'meu_17_2_constraint'] = True
    df.loc[~valid_constraint, 'meu_17_2_constraint'] = False

    return df

但需要确认“当日减持比例”和“累计减持比例”是否为小数形式，比如1.0代表100%。例如，如果某股东原本持有500股，当天减持了500股，那么当日减持比例是1.0。同样，累计减持比例达到1.0时，说明已经全部减持完毕。

此外，可能还需要考虑是否存在减持行为。例如，如果当天没有减持，那么即使减持比例为0，也不应该被标记为满足constraint条件。但根据MEU的约束内容，constraint是允许一次全部转让，所以只有当实际发生了一次性全部转让时，才满足约束条件。因此，在数据中，只有当减持行为发生且比例达到100%时，才视为满足。

因此，上述代码中的valid_constraint的条件是正确的。

但需要确保在数据中，当没有减持发生时，“当日减持比例”可能为0或NaN。例如，如果某行没有减持行为，那么“当日减持比例”可能为0，此时valid_constraint的条件会是False，因为0不等于1.0。因此，这部分处理是正确的。

综上，这个函数应该能正确标记各条件的情况。
","CompletionUsage(completion_tokens=2813, prompt_tokens=1701, total_tokens=4514, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=2419, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_11_1
法律的最小可执行单元内容: {""subject"": ""上市公司控股股东 | 实际控制人"", ""condition"": ""上市公司因涉嫌证券期货违法犯罪，在被中国证监会及其派出机构立案调查或者被司法机关立案侦查期间"", ""constraint"": ""不得减持其所持有的本公司股份"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_11_1(df):
    '''
    检查MEU_11_1合规性：
    subject: 上市公司控股股东 | 实际控制人
    condition: 公司因涉嫌证券期货违法犯罪被立案调查/侦查期间
    constraint: 不得减持股份
    
    实现逻辑：
    1. subject通过股东身份字段直接匹配
    2. condition通过公司涉嫌违法事件字段状态判断
    3. constraint通过当日减持比例字段数值验证
    '''
    df = df.copy()

    # 初始化合规标记列
    df['meu_11_1_subject'] = False
    df['meu_11_1_condition'] = False
    df['meu_11_1_constraint'] = None

    # 标记责任主体 (步骤1)
    subject_mask = df['股东身份'].isin(['控股股东', '实际控制人'])
    df.loc[subject_mask, 'meu_11_1_subject'] = True

    # 标记触发条件 (步骤2)
    condition_choices = ['被中国证监会及其派出机构立案调查', '被司法机关立案侦查']
    df['meu_11_1_condition'] = df['公司涉嫌证券期货违法犯罪事件'].isin(condition_choices)

    # 标记约束条件 (步骤3)
    # 当日减持比例>0视为违反约束，注意处理空值
    df['meu_11_1_constraint'] = (df['当日减持比例'].fillna(0) <= 0)
    
    # 将布尔值转换为True/False明确标记
    df['meu_11_1_constraint'] = df['meu_11_1_constraint'].map({True: True, False: False})

    return df
</CODE>","好的，我现在需要处理这个MEU_11_1的合规性检查。首先，我得仔细理解这个MEU的内容。根据给定的信息，责任主体是上市公司的控股股东或实际控制人。触发条件是当公司因涉嫌证券期货违法犯罪被中国证监会或其派出机构立案调查，或者被司法机关立案侦查期间。约束内容是他们不得减持所持有的本公司股份。

接下来，我需要考虑如何将这些条件转化为代码，操作提供的DataFrame。首先，处理subject部分。根据附加信息中的股东身份列，可能的取值包括控股股东、实际控制人等。所以，我需要检查每一行的股东身份是否是这两个中的一个。或者，可能有些情况下，股东身份列可能没有明确标明，但根据其他条件判断，比如是否属于控股股东或实际控制人。不过根据问题描述，股东身份列已经明确区分了这些标签，所以可以直接用该列来判断。因此，valid_subject的条件应该是股东身份列等于“控股股东”或“实际控制人”。

然后是condition部分。条件是公司正在被立案调查或侦查。在DataFrame中，公司涉嫌证券期货违法犯罪事件这一列的值可能包含“被中国证监会及其派出机构立案调查”或“被司法机关立案侦查”。所以，我需要检查该列是否处于这些状态中的一种。需要注意的是，这个条件是否在某个时间段内持续有效。例如，如果公司被立案调查的期间覆盖了该行的日期，那么该行的condition为真。但根据DataFrame的结构，每一行代表的是某个交易日的情况，所以可能该列的值会直接反映当天的状态。例如，如果当天公司处于被调查或侦查的状态，那么该行的condition为真。因此，valid_condition的条件是公司涉嫌证券期货违法犯罪事件列的值是“被中国证监会及其派出机构立案调查”或“被司法机关立案侦查”。

接下来是constraint部分。约束是不得减持股份。在DataFrame中，可能存在减持相关的列，比如存在减持计划、当日减持比例等。需要确定该股东在该交易日是否有减持行为。例如，如果当日减持比例大于0，或者存在减持计划在该日执行，那么违反约束。但根据提供的列，可能要看是否存在减持行为。例如，当日减持比例是否大于0，或者累计减持比例是否有增加。或者，是否存在减持计划在该日有效。但根据问题描述中的例子，可能使用存在减持计划列来判断。但需要明确的是，约束是不得减持，所以即使有计划，只要实际减持了，就违规。或者，只要存在减持计划，就视为违反约束？

这里可能需要更仔细的分析。MEU中的约束是“不得减持”，所以实际减持行为才是违反约束。但如何从DataFrame中判断是否有减持行为？例如，当日减持比例是否大于0。如果有，则视为减持，此时constraint应为False（即违反约束）。否则，如果当日没有减持，则符合约束。因此，valid_constraint的条件是当日减持比例等于0或者不存在减持行为。因此，在代码中，需要检查当日减持比例是否为0。如果该列的值大于0，则违反约束，否则满足。

现在，将这些逻辑转化为代码步骤：

1. 初始化三个新列：meu_11_1_subject、meu_11_1_condition、meu_11_1_constraint，初始值分别为False、False、None或False。

2. 标记subject：检查股东身份是否为控股股东或实际控制人。

3. 标记condition：检查公司涉嫌证券期货违法犯罪事件是否为被立案调查或侦查的状态。

4. 标记constraint：检查当日是否有减持行为，即当日减持比例是否大于0。如果大于0，则违反约束（False），否则符合（True）。注意，根据任务要求，constraint的检查是独立进行的，不需要依赖subject和condition是否满足。因此，无论subject和condition是否为真，都要对所有行的constraint进行检查。

但根据任务中的更多要求，对于三元组的检查是各自独立的，需要分别标记。因此，constraint的检查是针对所有行的，不管subject和condition是否满足。例如，即使某行不是控股股东，也要检查其是否减持，并标记在meu_11_1_constraint列中。但根据MEU的约束，只有当subject和condition都满足时，约束才适用。但根据任务中的说明，对于简单操作，constraint的检查是独立的，即不管subject和condition是否满足，都要检查。这可能与实际情况不符，但根据用户的要求，必须这样做。例如，在例子中，constraint的检查是独立进行的，比如检查是否存在减持计划，而不管subject和condition是否满足。这可能是因为用户希望分别记录每个条件的满足情况，而不管其他条件是否满足。因此，在MEU_11_1的情况下，constraint的检查应该独立进行，即检查所有行的减持情况，而不管该行是否属于subject或condition的情况。

但这样的话，可能不符合法律的实际应用，因为约束只有在subject和condition都满足时才生效。但根据用户的任务要求，这里需要将三个条件独立检查。这可能是一个需要注意的地方。但根据用户给出的例子，例如MEU_4_1的代码中，constraint的检查是独立进行的，例如检查是否存在减持计划，而不管subject和condition是否满足。因此，在MEU_11_1的情况下，同样需要独立检查constraint的条件，即是否减持，无论该行是否属于控股股东或公司是否被调查。

但这样的话，可能不符合实际法律条款的意图，因为约束只有在subject和condition都满足时才适用。但根据用户的任务要求，必须将三个条件独立标记。这可能是一个矛盾点。需要仔细确认用户的要求。

根据用户的任务说明中的“更多要求”部分：

- 对于简单操作dataframe就可以处理的项目，对三元组<subject, conditon, constrain>的检查是各自独立的，需要分别标记三元组的True和False。并不是只对符合subject和condition的行进行检查。对于需要调用llm_content_check()函数的项目，只对符合<subject, conditon>的constrain进行检查。而当前任务中没有需要调用该函数的项目。因此，在MEU_11_1的情况下，constraint的检查是独立进行的，即不管subject和condition是否满足，都要检查是否满足约束条件，并标记在对应的列中。

这可能与实际法律逻辑不符，但根据任务要求，必须这样做。例如，即使某行不是控股股东，或者公司没有被调查，只要该股东在该日减持了股份，那么meu_11_1_constraint列会被标记为False，因为约束条件是“不得减持”，而不管是否属于subject和condition的情况。这可能不符合法律条款的实际应用，但根据任务要求，必须独立检查每个条件。

但这里可能存在误解。例如，法律条款中的约束条件仅在subject和condition满足的情况下才适用。因此，正确的合规性检查应该是：只有当subject和condition都为真时，才需要检查constraint是否满足。否则，constraint是否满足无关紧要。但根据用户的任务要求，对于简单操作，三个条件需要独立检查，不管其他条件是否满足。这可能是一个矛盾，需要按照用户的要求来处理。

现在回到问题，用户给出的例子中的MEU_4_1的代码中，constraint的检查是独立进行的。例如，在例子中，constraint的条件是“提前15日公告”，代码中的检查是检查所有行的交易日差是否>=15，而不管该行是否属于subject或condition的情况。因此，在MEU_11_1的情况下，同样需要独立检查constraint的条件，即是否减持，不管subject和condition是否满足。

因此，在代码中，对于constraint的检查，应该检查所有行的当日减持比例是否为0。如果当日减持比例>0，则constraint为False，否则为True。但根据MEU的约束，只有当subject和condition都满足时，减持才被禁止。但根据用户的任务要求，必须独立检查三个条件，因此，不管其他条件如何，只要当日减持比例>0，则constraint标记为False，否则为True。这可能与实际法律条款不符，但必须按照用户的要求处理。

不过，这可能是一个错误的理解。需要再次仔细阅读任务说明中的“更多要求”部分：

“对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)”

哦，原来如此。对于简单操作，三个条件的检查是独立的，即每个条件是否满足，不管其他条件是否满足。例如，subject是否满足，condition是否满足，constraint是否满足，这三个都是独立判断的，并分别记录在各自的列中。而只有当需要调用llm_content_check()时，才会在subject和condition满足的情况下检查constraint。但当前任务属于简单操作，所以三个条件独立检查。

因此，在MEU_11_1的情况下：

- subject列标记的是该行股东是否是控股股东或实际控制人，不管其他条件。
- condition列标记的是公司是否处于被调查或侦查状态，不管其他条件。
- constraint列标记的是该股东在该日是否没有减持股份，不管其他条件。

因此，即使该股东不是控股股东，或者公司没有被调查，只要该股东在该日减持了股份，constraint列会被标记为False，因为约束条件是“不得减持”，而不管是否属于subject和condition的情况。这可能不符合法律条款的实际应用，但根据任务要求，必须这样处理。

现在，我需要根据这些逻辑编写代码。

首先，处理subject：

valid_subject = df['股东身份'].isin(['控股股东', '实际控制人'])

然后，处理condition：

valid_condition = df['公司涉嫌证券期货违法犯罪事件'].isin(['被中国证监会及其派出机构立案调查', '被司法机关立案侦查'])

接着，处理constraint：

valid_constraint = df['当日减持比例'] <= 0  # 或者等于0？需要看数据中的表示方式。假设减持比例是正数，所以当日减持比例>0表示减持了。

或者，可能要看是否有减持行为。例如，当日减持比例是否大于0。如果是，则违反约束，constraint为False。否则为True。

因此，valid_constraint = (df['当日减持比例'] == 0) | (df['当日减持比例'].isna()) ？或者，如果当日减持比例不存在，可能表示没有减持？

但根据数据列的描述，可能存在当日减持比例列，所以当该列的值大于0时，视为减持。因此，valid_constraint的条件是当日减持比例等于0或者不存在减持行为。但根据数据列的描述，可能该列的值在未减持时为0，减持时为正数。因此，valid_constraint = df['当日减持比例'] <= 0。或者，更准确的是，等于0时满足约束，否则不满足。例如：

valid_constraint = df['当日减持比例'] == 0

或者，如果该列可能为NaN，可能需要处理NaN的情况。例如，假设没有减持时该列为0，减持时为正数，那么：

valid_constraint = (df['当日减持比例'] == 0) | df['当日减持比例'].isna()

但根据问题描述中的列说明，可能该列在减持时会有数值，否则为0或NaN。需要明确如何处理。例如，如果某行的当日减持比例是NaN，可能表示没有减持，此时应视为满足约束。或者，如果该列在未减持时为0，减持时为正数，那么可以直接检查是否等于0。

假设该列在未减持时为0，减持时为正数，那么：

valid_constraint = df['当日减持比例'] == 0

这样，当减持比例为0时，constraint为True，否则为False。

现在，将这些条件应用到代码中：

初始化三个列：

df['meu_11_1_subject'] = False
df['meu_11_1_condition'] = False
df['meu_11_1_constraint'] = False  # 初始化为False，然后根据条件设置

或者，根据例子中的处理方式，初始化为False，然后符合条件的设置为True。例如：

df['meu_11_1_subject'] = False
df.loc[valid_subject, 'meu_11_1_subject'] = True

同样处理其他两个条件。

对于constraint列，初始化为False，然后满足条件的设为True：

df['meu_11_1_constraint'] = False
df.loc[valid_constraint, 'meu_11_1_constraint'] = True

或者，根据例子中的方式，初始化为None，然后填充True或False。但例子中的例子可能有些不同，比如：

在例子中，constraint列初始化为None，然后根据条件设置为True或False。例如：

df['meu_4_2_constrain'] = None
...
df.loc[valid_constraint, 'meu_4_1_constraint'] = True
df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

这可能更准确，因为初始值可能为None，然后根据条件设置True或False。但根据用户提供的例子中的代码，可能应该初始化为None，然后填充布尔值。例如：

在例子中，初始化为None：

df['meu_4_2_constrain'] = None

然后：

df.loc[valid_constraint, 'meu_4_1_constraint'] = True
df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

因此，在MEU_11_1的情况下，应该将constraint列初始化为None，然后根据条件设置True或False。但根据用户提供的例子中的代码，可能应该初始化为False，然后根据条件设置。或者，可能例子中的代码存在笔误？

例如，在例子中的代码：

df['meu_4_2_subject'] = False  # subject需要初始化为False
df['meu_4_2_condition'] = False  # condition需要初始化为False
df['meu_4_2_constrain'] = None  # constrain需要初始化为None

然后，在标记时：

df.loc[valid_subject, 'meu_4_1_subject'] = True
df.loc[valid_condition, 'meu_4_1_condition'] = True
df.loc[valid_constraint, 'meu_4_1_constraint'] = True
df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

因此，对于MEU_11_1，应该：

初始化三个列：

df['meu_11_1_subject'] = False
df['meu_11_1_condition'] = False
df['meu_11_1_constraint'] = None

然后，根据条件设置：

df.loc[valid_subject, 'meu_11_1_subject'] = True
df.loc[valid_condition, 'meu_11_1_condition'] = True
df.loc[valid_constraint, 'meu_11_1_constraint'] = True
df.loc[~valid_constraint, 'meu_11_1_constraint'] = False

现在，将这些逻辑整合到代码中。

总结：

- subject的条件是股东身份为控股股东或实际控制人。
- condition的条件是公司涉嫌证券期货违法犯罪事件列的值是“被中国证监会及其派出机构立案调查”或“被司法机关立案侦查”。
- constraint的条件是当日减持比例等于0。

现在，编写代码：

首先，复制df以避免修改原始数据：

df = df.copy()

初始化列：

df['meu_11_1_subject'] = False
df['meu_11_1_condition'] = False
df['meu_11_1_constraint'] = None

处理subject：

valid_subject = df['股东身份'].isin(['控股股东', '实际控制人'])
df.loc[valid_subject, 'meu_11_1_subject'] = True

处理condition：

valid_condition = df['公司涉嫌证券期货违法犯罪事件'].isin(['被中国证监会及其派出机构立案调查', '被司法机关立案侦查'])
df.loc[valid_condition, 'meu_11_1_condition'] = True

处理constraint：

valid_constraint = df['当日减持比例'] == 0
# 或者，如果存在NaN的情况，可能需要处理：
# valid_constraint = (df['当日减持比例'] == 0) | df['当日减持比例'].isna()
# 但根据问题描述中的列信息，可能该列在无减持时为0，减持时为正数。因此，直接检查是否等于0即可。
df.loc[valid_constraint, 'meu_11_1_constraint'] = True
df.loc[~valid_constraint, 'meu_11_1_constraint'] = False

但需要注意，如果当日减持比例是NaN，如何处理？例如，如果某行没有减持，可能该列是0，或者NaN？根据问题描述中的列信息，可能该列在无减持时为0，所以不需要处理NaN。但如果有NaN的情况，可能需要填充为0或者视为未减持。例如，假设NaN表示没有减持，那么：

valid_constraint = (df['当日减持比例'] == 0) | df['当日减持比例'].isna()

但根据用户提供的列描述，可能该列在无减持时为0，所以可以安全地检查是否等于0。

综上，代码大致如下：

import pandas as pd

def check_meu_11_1(df):
    '''
    检查MEU_11_1的合规性：
    subject: 上市公司控股股东 | 实际控制人
    condition: 公司因涉嫌证券期货违法犯罪被立案调查或侦查期间
    constraint: 不得减持股份
    '''
    df = df.copy()

    # 初始化列
    df['meu_11_1_subject'] = False
    df['meu_11_1_condition'] = False
    df['meu_11_1_constraint'] = None  # 初始化为None，之后填充True/False

    # 标记subject
    valid_subject = df['股东身份'].isin(['控股股东', '实际控制人'])
    df.loc[valid_subject, 'meu_11_1_subject'] = True

    # 标记condition
    valid_condition = df['公司涉嫌证券期货违法犯罪事件'].isin(['被中国证监会及其派出机构立案调查', '被司法机关立案侦查'])
    df.loc[valid_condition, 'meu_11_1_condition'] = True

    # 标记constraint
    # 当日减持比例为0表示没有减持，符合约束；否则不符合
    valid_constraint = df['当日减持比例'] == 0
    df.loc[valid_constraint, 'meu_11_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_11_1_constraint'] = False

    return df

但需要确认当日减持比例是否为0时表示没有减持。例如，如果某股东在当日减持了部分股份，那么当日减持比例应该大于0，此时constraint为False。如果当日没有减持，该列值为0，则constraint为True。

这样，代码中的valid_constraint就是正确的。

最后，返回处理后的df。
","CompletionUsage(completion_tokens=4512, prompt_tokens=1714, total_tokens=6226, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=4121, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_14_4
法律的最小可执行单元内容: {""subject"": ""上市公司董监高"", ""condition"": ""本人因涉嫌与该上市公司有关的证券期货违法犯罪被中国证监会及其派出机构立案调查或者被司法机关立案侦查，在行政处罚决定、刑事判决作出之后未满6个月"", ""constraint"": ""不得减持其所持有的本公司股份"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_14_4(df):
    '''
    检查MEU_14_4合规性：
    subject: 上市公司董监高
    condition: 因涉嫌证券期货违法犯罪被立案且处罚后未满6个月
    constraint: 不得减持股份
    '''
    df = df.copy()

    # 初始化标记列
    df['meu_14_4_subject'] = False
    df['meu_14_4_condition'] = False
    df['meu_14_4_constrain'] = True  # 默认未减持

    # 1.标记subject(上市公司董监高)
    df['meu_14_4_subject'] = df['股东身份'].isin(['董监高'])

    # 2.标记condition(被立案且处罚后未满6个月)
    # 按股东分组处理
    grouped = df.groupby(['公司简称', '股东'], group_keys=False)
    
    # 判断是否被立案调查/侦查过
    df['_investigated'] = grouped['股东涉嫌证券期货违法犯罪事件'].transform(
        lambda x: x.isin(['被中国证监会及其派出机构立案调查', '被司法机关立案侦查']).any()
    )
    
    # 获取最新行政处罚日期
    penalty_dates = df[df['股东涉嫌证券期货违法犯罪事件'] == '行政处罚决定作出']\
        .groupby(['公司简称', '股东'])['日期'].max().rename('penalty_date')
    df = df.merge(penalty_dates, how='left', on=['公司简称', '股东'])
    
    # 计算自然日间隔
    df['_penalty_days'] = (df['日期'] - df['penalty_date']).dt.days
    valid_penalty = (df['_penalty_days'] >= 0) & (df['_penalty_days'] <= 180)
    
    # 综合条件判断
    df['meu_14_4_condition'] = df['_investigated'] & valid_penalty & df['penalty_date'].notna()

    # 3.标记constraint(当日无减持)
    df['meu_14_4_constrain'] = (df['当日减持比例'] <= 0)

    # 清理中间列
    df.drop(['_investigated', 'penalty_date', '_penalty_days'], axis=1, inplace=True, errors='ignore')
    
    return df
</CODE>","好的，我现在需要处理这个MEU_14_4的合规性检查。首先，我得仔细理解这个MEU的内容。MEU的subject是“上市公司董监高”，condition是当本人因涉嫌与公司有关的证券期货违法犯罪被立案调查或侦查，且在行政处罚或刑事判决作出后未满6个月。constraint是不得减持股份。

首先，处理subject部分。根据附加信息中的股东身份列，可能的取值包括“董监高”和“离任董监高”等。所以，有效的subject应该是股东身份为“董监高”的行。这里需要注意，离任董监高可能不在此范围内，所以需要筛选出股东身份等于“董监高”的记录。

接下来是condition部分。条件有两个部分：被立案调查或侦查，以及处罚或判决后未满6个月。数据中的相关列是“股东涉嫌证券期货违法犯罪事件”。需要检查该列是否包含“被中国证监会及其派出机构立案调查”或者“被司法机关立案侦查”。然后，行政处罚决定或刑事判决作出的时间是否在6个月内。假设数据中有相关事件的日期，比如当事件是“行政处罚决定作出”时，对应的日期需要被记录。但这里可能需要处理时间序列的问题。例如，如果某行记录的日期是在行政处罚决定作出后的6个月内，那么condition满足。

但问题在于，如何确定行政处罚或刑事判决的日期。可能的数据结构是，当事件发生时，该行的日期即为事件发生日。例如，当某行的事件是“行政处罚决定作出”，那么该行的日期就是处罚决定的日期。之后，在后续的日期中，如果距离该日期未满6个月，则condition为真。因此，需要为每个股东跟踪他们最近的行政处罚或刑事判决的日期，并计算当前日期与该日期的差值是否小于6个月。

这可能涉及到分组处理，按公司和股东分组，找到每个股东最近一次的行政处罚或刑事判决日期。然后，在每一行中，检查当前日期是否在该日期之后的6个月内。同时，还需要确保该股东曾经被立案调查或侦查过。例如，如果股东被立案调查，之后被处罚，那么从处罚日期开始计算6个月。

但数据中的“股东涉嫌证券期货违法犯罪事件”列可能记录了不同的事件类型。例如，某行的事件是“被中国证监会及其派出机构立案调查”，另一行的事件是“行政处罚决定作出”。因此，需要先确定该股东是否有被立案调查或侦查的事件，并且之后是否有对应的处罚或判决事件。

这可能比较复杂。例如，需要先检查该股东是否有被立案调查或侦查的事件，然后是否有后续的行政处罚或刑事判决，并且当前日期是否在处罚后的6个月内。

或者，可能数据中的每一行如果该股东处于被处罚后的6个月内，那么该行的condition就满足。例如，假设当行政处罚决定作出后，该股东在接下来的6个月内所有日期都满足condition的条件。

因此，处理步骤可能是：

1. 对于每个股东，找到所有“行政处罚决定作出”或“刑事判决作出”的日期。
2. 对于每个这样的日期，计算该日期之后6个月的日期范围。
3. 在数据中，对于每个股东，如果当前行的日期处于任何一个这样的日期范围内，则condition满足。
4. 同时，该股东必须曾经被立案调查或侦查过。

但可能数据中没有直接的“刑事判决作出”事件，但可能有“被司法机关立案侦查”和“司法机关立案侦查结束”等事件。需要仔细看数据中的事件类型。

根据附加信息中的说明，“公司/股东涉嫌证券期货违法犯罪事件”的可能值包括“被中国证监会及其派出机构立案调查”、“中国证监会及其派出机构立案调查结束”、“行政处罚决定作出”、“被司法机关立案侦查”、“司法机关立案侦查结束”等。所以，行政处罚决定作出和刑事判决可能对应不同的条目。例如，当行政处罚决定作出时，该事件会被记录，而刑事判决可能没有直接的事件，但可能通过其他事件推断。

但根据MEU的条件，condition是“被立案调查或者被立案侦查，并且在行政处罚决定、刑事判决作出之后未满6个月”。所以，需要同时满足两个条件：被立案调查或侦查，并且处罚或判决之后未满6个月。

这可能意味着，只有当股东被立案调查或侦查，并且之后有对应的处罚或判决，且当前日期在处罚或判决后的6个月内，才满足condition。

因此，处理步骤可能如下：

对于每个股东，首先确定是否曾经被立案调查或侦查（事件类型为“被中国证监会及其派出机构立案调查”或“被司法机关立案侦查”）。然后，找到该股东最近的行政处罚决定或刑事判决的日期。如果存在这样的日期，并且当前行的日期在该日期之后的6个月内，则condition为真。

这可能需要按股东分组，记录每个股东的处罚或判决日期，然后计算每个行的日期是否在该日期后的6个月内。

但如何从数据中获取这些日期呢？例如，当事件是“行政处罚决定作出”时，该行的日期即为处罚日期。同样，刑事判决可能对应某个事件类型，但数据中可能没有明确的事件，可能需要假设刑事判决的日期是否存在。

假设数据中，当有“行政处罚决定作出”时，该行的日期即为处罚日期。同样，如果有刑事判决作出的事件，可能对应某个事件类型，但根据给定的可能值，可能没有直接的刑事判决事件。因此，可能需要假设，当事件是“被司法机关立案侦查”后，如果有“司法机关立案侦查结束”并且结果是有罪判决，那么该结束日期可能视为判决日期？或者可能数据中没有直接的刑事判决事件，所以无法处理这种情况？

这可能是一个问题。根据给定的数据列的可能值，可能无法直接获取刑事判决的日期。因此，可能只能处理行政处罚决定的情况，而无法处理刑事判决的情况，除非刑事判决的日期可以通过其他事件推断。

在这种情况下，可能需要假设，当股东有“被司法机关立案侦查”的事件，并且之后有“司法机关立案侦查结束”的事件，那么结束日期可能视为判决日期？或者这可能不正确，因为侦查结束可能只是调查结束，并不一定有判决。

因此，这可能存在数据不足的问题。但根据MEU的条件，必须同时满足被立案调查或侦查，并且在处罚或判决之后未满6个月。因此，在数据中，如果无法确定刑事判决的日期，可能无法正确判断condition的条件。这可能意味着，在代码中只能处理行政处罚决定的情况，而无法处理刑事判决的情况，除非有其他数据支持。

但根据用户提供的输入数据中的列，可能只能处理行政处罚的情况。例如，当事件是“行政处罚决定作出”时，记录该日期，并计算之后的6个月。

因此，处理步骤可能如下：

1. 对每个股东，检查是否有“被中国证监会及其派出机构立案调查”或“被司法机关立案侦查”的事件。
2. 同时，检查是否有后续的“行政处罚决定作出”事件。
3. 对于每个这样的行政处罚决定日期，计算该日期后的6个月。
4. 如果当前行的日期在该日期后的6个月内，则condition满足。

但如何将这些信息整合到数据中呢？可能需要为每个股东记录其最近的行政处罚决定的日期，然后在每一行中判断当前日期是否在该日期后的6个月内。

这可能需要分组操作。例如，按股东分组，找到该股东所有“行政处罚决定作出”的日期，取最大的那个日期，然后计算该日期后的6个月。如果当前行的日期在该区间内，则condition为真。

但如何实现这一点呢？可以使用groupby和transform来为每个股东生成一个最大处罚日期，然后计算每个行的日期是否在该日期后的6个月内。

例如：

对于每个股东，找到所有“行政处罚决定作出”事件的日期，取最大值作为latest_penalty_date。然后，对于每一行，如果该行的日期在latest_penalty_date之后，并且日期差小于6个月（约180天），则condition满足。

同时，还需要该股东曾经被立案调查或侦查过。例如，该股东是否有过“被中国证监会及其派出机构立案调查”或“被司法机关立案侦查”的事件。

这可能比较复杂。例如，股东可能被立案调查，但尚未有行政处罚决定，此时condition不满足。只有当行政处罚决定作出后，且在6个月内，才满足condition。

因此，步骤可能如下：

- 标记subject：股东身份是董监高。
- 标记condition：该股东被立案调查或侦查，并且当前日期在行政处罚决定或刑事判决后的6个月内。
- 对于condition部分，需要：
   a. 检查该股东是否有被立案调查或侦查的事件。
   b. 检查该股东是否有行政处罚决定或刑事判决的日期。
   c. 当前日期是否在该日期后的6个月内。

但如何从数据中提取这些信息呢？

例如，对于每个股东，找出所有“行政处罚决定作出”的日期，并取最近的一个。同样，如果有刑事判决的日期，也需要处理。但数据中没有明确的事件类型，所以可能只能处理行政处罚的情况。

假设数据中的“股东涉嫌证券期货违法犯罪事件”列中，当事件是“行政处罚决定作出”时，该行的日期即为处罚日期。同样，如果事件是“被司法机关立案侦查”，但之后是否有对应的判决日期，可能无法确定。

因此，可能只能处理行政处罚的情况，而无法处理刑事判决的情况，除非假设刑事判决的日期可以通过其他方式推断，但根据现有数据，这可能不可行。

因此，在代码中，可能只能处理行政处罚的情况。例如：

对于每个股东，找到最近的“行政处罚决定作出”的日期，然后判断当前日期是否在该日期后的6个月内，并且该股东曾经被立案调查或侦查过。

具体步骤：

1. 对每个股东，确定是否曾经被立案调查或侦查。这可以通过检查该股东的“股东涉嫌证券期货违法犯罪事件”列是否包含“被中国证监会及其派出机构立案调查”或“被司法机关立案侦查”。

2. 对每个股东，找到所有“行政处罚决定作出”的日期，取最大值作为latest_penalty_date。

3. 对于每一行，如果该行的日期在latest_penalty_date之后，并且日期差 <= 180天，则condition满足。

同时，必须满足该股东曾经被立案调查或侦查过。

这可能比较复杂，需要分组处理。

现在，如何将这些步骤转化为代码？

首先，处理subject部分：

df['meu_14_4_subject'] = (df['股东身份'] == '董监高')

然后，处理condition部分：

需要分组处理每个股东，确定他们是否被立案调查或侦查，并且是否有行政处罚决定，且在6个月内。

步骤：

a. 创建一个临时DataFrame，按股东分组，记录每个股东是否被立案调查或侦查过。

例如：

grouped = df.groupby(['公司简称', '股东'])

# 判断该股东是否有被立案调查或侦查的事件
has_investigation = grouped['股东涉嫌证券期货违法犯罪事件'].transform(lambda x: x.isin(['被中国证监会及其派出机构立案调查', '被司法机关立案侦查']).any())

b. 找到每个股东最近的行政处罚决定日期：

# 筛选出事件为“行政处罚决定作出”的行
penalty_dates = df[df['股东涉嫌证券期货违法犯罪事件'] == '行政处罚决定作出']

# 按股东分组，取最大的日期作为latest_penalty_date
latest_penalty = penalty_dates.groupby(['公司简称', '股东'])['日期'].max().reset_index()
latest_penalty.rename(columns={'日期': 'latest_penalty_date'}, inplace=True)

# 将latest_penalty_date合并回原df
df = df.merge(latest_penalty, on=['公司简称', '股东'], how='left')

# 计算当前日期与latest_penalty_date的差值
df['days_since_penalty'] = (df['日期'] - df['latest_penalty_date']).dt.days

# 判断是否在6个月内（假设6个月为180天）
within_6_months = (df['days_since_penalty'] >= 0) & (df['days_since_penalty'] <= 180)

# 同时，该股东必须被立案调查或侦查过，并且有行政处罚决定
valid_condition = has_investigation & within_6_months & df['latest_penalty_date'].notna()

但这里可能存在分组的问题，例如，merge操作可能会导致某些行的latest_penalty_date为NaN，如果该股东没有行政处罚决定的话。

此外，刑事判决的情况如何处理？由于数据中没有相关事件，可能无法处理，所以只能处理行政处罚的情况。

因此，condition的条件是：该股东被立案调查或侦查过，并且当前日期在行政处罚决定后的6个月内。

现在，处理constraint部分：不得减持股份。即，在满足subject和condition的情况下，该股东是否减持了股份？

但根据附加信息中的列，可能减持的信息在“当日减持比例”或“累计减持比例”中。例如，如果当日减持比例大于0，则表示该股东当天减持了股份。此时，constraint要求不得减持，因此如果当日减持比例>0，则违反约束。

因此，constraint的检查是：在满足subject和condition的行中，如果当日减持比例>0，则constraint为False，否则为True。或者，根据MEU的constraint是“不得减持”，所以只要当日减持比例>0，就违反约束。

但根据任务要求，对于constraint的检查是独立的，即不管subject和condition是否满足，都要检查。但根据用户的要求中的“更多要求”部分，对于不需要调用llm_content_check()的项目，三元组的检查是各自独立的，需要分别标记。但根据MEU的约束，只有当subject和condition都满足时，constraint才需要被检查。或者，用户的要求中提到：“对于简单操作dataframe就可以处理的项目，对三元组<subject, conditon, constrain>的检查是各自独立的，你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查.”

所以，在这个任务中，constraint的检查是独立的，不管subject和condition是否满足，都要检查。例如，不管股东是否是董监高，或者是否处于被处罚后的6个月内，只要该股东在当天减持了股份，那么constraint的标记为False？或者，constraint的检查是否应该仅在满足subject和condition的情况下进行？

根据用户给出的例子，比如在MEU_4_1的例子中，constraint的检查是独立进行的，例如，检查是否存在减持计划以及交易日差是否>=15。所以，不管subject和condition是否满足，只要存在减持计划且交易日差>=15，则constraint为True。这可能意味着，constraint的检查是独立的，不需要依赖subject和condition的条件。

但根据MEU_14_4的约束条件，“不得减持其所持有的本公司股份”，这应该仅在subject和condition都满足的情况下才需要检查。例如，只有当股东是董监高，并且处于被处罚后的6个月内，此时减持股份才违反约束。否则，如果股东不是董监高，或者不处于该期间，那么减持股份并不违反这个MEU的约束。

但根据用户的任务要求中的“更多要求”部分，对于不需要调用llm_content_check()的项目，三元组的检查是各自独立的。因此，constraint的检查是独立进行的，不管subject和condition是否满足。例如，不管股东是否是董监高，或者是否处于被处罚后的6个月内，只要该股东在当天减持了股份，那么constraint的标记为False？这显然不符合法律条文的本意，但根据用户的指示，必须按照这个方式处理。

这可能是一个矛盾。例如，MEU的约束条件仅在特定条件下适用，但根据任务要求，需要独立检查。这可能意味着，在代码中，constraint的检查不考虑subject和condition的条件，而是单独检查是否满足约束条件。例如，不管股东是谁，只要减持了股份，就标记constraint为False。但显然，这与MEU的实际要求不符。

这可能是一个需要澄清的问题。但根据用户给出的例子，例如MEU_4_1的代码中，constraint的检查是独立进行的，例如检查是否存在减持计划和交易日差是否>=15，而不管subject和condition是否满足。因此，在MEU_14_4的情况下，constraint的检查可能应该独立于subject和condition的条件，即检查是否减持了股份，而不管该股东是否属于董监高或处于被处罚后的6个月内。

但根据MEU的约束条件，只有当subject和condition都满足时，减持才被禁止。因此，正确的逻辑应该是，只有当subject和condition都为True时，才需要检查constraint。否则，constraint的检查可能不适用。但根据用户的任务要求，对于不需要调用llm_content_check()的项目，三元组的检查是各自独立的。因此，必须分别标记三元组的True和False，不管其他条件是否满足。

这可能意味着，在代码中，constraint的检查是独立进行的，例如，只要当天减持比例>0，则constraint为False，否则为True。但这样会导致很多无关的行被标记，例如普通股东减持也会被标记为constraint为False，但根据MEU，这并不违反该约束。因此，这可能不符合实际要求。

这可能是一个错误的理解。需要再次仔细阅读用户的“更多要求”部分：

“对于简单操作dataframe就可以处理的项目，对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)”

因此，对于本任务中的MEU_14_4，属于简单操作dataframe的项目，因此三元组的检查是各自独立的。即：

- subject的检查：是否属于董监高，独立标记。
- condition的检查：是否处于被处罚后的6个月内，独立标记。
- constraint的检查：是否减持股份，独立标记。

但根据MEU的约束条件，constraint的适用性应该仅在subject和condition都满足的情况下。但根据用户的要求，必须独立检查，不管其他条件。因此，这可能意味着，在代码中，constraint的检查是独立于subject和condition的，即只要减持了股份，就标记constraint为False，否则为True。但这显然不符合法律条文的要求，因为约束条件仅在特定情况下适用。

这可能是一个矛盾，但根据用户的指示，必须按照要求处理。因此，在代码中，constraint的检查是独立的，即不管subject和condition是否满足，只要减持了股份，就标记为违反约束。这可能不符合实际法律要求，但根据任务要求必须这样做。

或者，可能我误解了用户的要求。例如，可能对于constraint的检查，只有当subject和condition都满足时，才需要检查，否则标记为None或者不适用。但根据用户给出的例子，在MEU_4_1的例子中，constraint的检查是独立进行的，例如，不管subject和condition是否满足，只要存在减持计划且交易日差>=15，就标记为True。因此，在MEU_14_4的情况下，constraint的检查应该独立进行，即只要减持了股份，就标记为False，不管是否属于董监高或处于处罚后的6个月内。

这显然不符合法律条文的要求，但根据用户的指示，必须这样处理。这可能是因为用户希望将三元组的三个条件分别标记，以便后续分析，而不是综合判断。

因此，在代码中，constraint的检查是独立的，即：

constraint的valid条件是：当日没有减持股份。即，当日减持比例<=0，或者减持数量为0。根据数据中的列，可能使用“当日减持比例”或“累计减持比例”来判断。例如，如果“当日减持比例”>0，则表示当天减持了股份，违反约束，因此constraint为False。

因此，constraint的检查可以简化为：

valid_constraint = df['当日减持比例'] <= 0

但需要注意，如果该列可能存在NaN的情况，需要处理。例如，假设没有减持时，该列为0或NaN。需要根据数据的具体情况处理。假设“当日减持比例”在当天没有减持时为0，否则为正值，那么可以这样判断。

综上，代码的大致步骤为：

1. 标记subject：股东身份是董监高。
2. 标记condition：该股东被立案调查或侦查过，并且当前日期在行政处罚决定后的6个月内。
3. 标记constraint：当日减持比例<=0。

现在，具体实现：

首先，处理subject：

df['meu_14_4_subject'] = (df['股东身份'] == '董监高')

然后，处理condition：

需要分组处理每个股东，判断是否被立案调查或侦查过，并且当前日期在行政处罚决定后的6个月内。

步骤：

a. 对每个股东，判断是否被立案调查或侦查过：

# 创建分组对象
grouped = df.groupby(['公司简称', '股东'])

# 判断每个股东是否有被立案调查或侦查的事件
df['has_investigation'] = grouped['股东涉嫌证券期货违法犯罪事件'].transform(
    lambda x: x.isin(['被中国证监会及其派出机构立案调查', '被司法机关立案侦查']).any()
)

b. 找到每个股东的行政处罚决定日期：

# 筛选出行政处罚决定作出的行
penalty_mask = df['股东涉嫌证券期货违法犯罪事件'] == '行政处罚决定作出'
penalty_dates = df[penalty_mask][['公司简称', '股东', '日期']]

# 按股东分组，取最大的日期作为latest_penalty_date
latest_penalty = penalty_dates.groupby(['公司简称', '股东'])['日期'].max().reset_index()
latest_penalty.rename(columns={'日期': 'latest_penalty_date'}, inplace=True)

# 将latest_penalty_date合并回原df
df = df.merge(latest_penalty, on=['公司简称', '股东'], how='left')

# 计算当前日期与latest_penalty_date的差值
df['days_after_penalty'] = (df['日期'] - df['latest_penalty_date']).dt.days

# 判断是否在6个月内（假设180天）
within_6_months = (df['days_after_penalty'] >= 0) & (df['days_after_penalty'] <= 180)

# 同时，必须有行政处罚决定，即latest_penalty_date不为空
valid_condition = df['has_investigation'] & within_6_months & df['latest_penalty_date'].notna()

df['meu_14_4_condition'] = valid_condition

最后，处理constraint：

df['meu_14_4_constrain'] = (df['当日减持比例'] <= 0)

但需要注意，如果当日减持比例是NaN，可能需要处理。例如，假设没有减持时，该列为0，则可以直接判断。否则，可能需要填充NaN为0。

假设数据中，当日减持比例在无减持时为0，则：

df['meu_14_4_constrain'] = (df['当日减持比例'] <= 0)

但根据用户提供的列描述，“当日减持比例”可能是一个数值型列，当没有减持时为0。因此，可以直接使用该列。

综上，完整的代码可能如下：

import pandas as pd

def check_meu_14_4(df):
    '''
    检查MEU_14_4的合规性：
    subject: 上市公司董监高
    condition: 本人因涉嫌证券期货违法犯罪被立案调查或侦查，且在行政处罚决定或刑事判决后未满6个月
    constraint: 不得减持股份
    '''
    df = df.copy()

    # 初始化标记列
    df['meu_14_4_subject'] = False
    df['meu_14_4_condition'] = False
    df['meu_14_4_constrain'] = True  # 默认未减持

    # 标记subject
    valid_subject = df['股东身份'] == '董监高'
    df.loc[valid_subject, 'meu_14_4_subject'] = True

    # 标记condition
    # 判断是否被立案调查或侦查过
    grouped = df.groupby(['公司简称', '股东'])
    df['has_investigation'] = grouped['股东涉嫌证券期货违法犯罪事件'].transform(
        lambda x: x.isin(['被中国证监会及其派出机构立案调查', '被司法机关立案侦查']).any()
    )

    # 获取每个股东的最新行政处罚日期
    penalty_mask = df['股东涉嫌证券期货违法犯罪事件'] == '行政处罚决定作出'
    penalty_dates = df[penalty_mask][['公司简称', '股东', '日期']]
    latest_penalty = penalty_dates.groupby(['公司简称', '股东'])['日期'].max().reset_index()
    latest_penalty.rename(columns={'日期': 'latest_penalty_date'}, inplace=True)

    # 合并到原df
    df = df.merge(latest_penalty, on=['公司简称', '股东'], how='left')

    # 计算天数差
    df['days_after_penalty'] = (df['日期'] - df['latest_penalty_date']).dt.days

    # 判断是否在6个月内且日期有效
    within_6_months = (df['days_after_penalty'] >= 0) & (df['days_after_penalty'] <= 180)
    has_penalty = df['latest_penalty_date'].notna()

    valid_condition = df['has_investigation'] & within_6_months & has_penalty
    df.loc[valid_condition, 'meu_14_4_condition'] = True

    # 标记constraint：当日减持比例<=0
    df['meu_14_4_constrain'] = (df['当日减持比例'] <= 0)

    # 清理临时列
    df.drop(columns=['has_investigation', 'latest_penalty_date', 'days_after_penalty'], inplace=True, errors='ignore')

    return df

但需要注意，这里假设刑事判决的情况无法处理，因为数据中没有相关的事件类型。因此，condition部分只处理了行政处罚决定的情况，而无法处理刑事判决的情况。这可能与MEU的要求不符，但根据现有数据，只能如此处理。

此外，在代码中，对于每个股东，如果有多个行政处罚决定，取最新的那个日期，并计算6个月。这可能正确，因为MEU的条件是“行政处罚决定作出之后未满6个月”，所以每个处罚决定都会开启一个6个月的期间，只要当前日期在任何一个处罚决定的6个月内，就满足条件。但代码中取的是最新的处罚日期，这可能覆盖之前的处罚日期，因为最新的处罚的6个月期间可能包含之前的处罚的期间。例如，如果某股东在2023-01-01被处罚，之后在2023-03-01再次被处罚，那么第二个处罚的6个月期间到2023-09-01，而第一个的到2023-07-01。因此，在2023-04-01，两个处罚的期间都有效，但取最新的处罚日期，判断是否在6个月内是正确的。

此外，代码中使用了transform来为每个股东的所有行标记是否被调查过。这可能正确，因为只要该股东曾经有过被调查的事件，所有行的has_investigation都为True。

最后，constraint的检查是独立进行的，不管subject和condition是否满足，只要当日减持比例>0，则标记为False。这可能不符合法律要求，但根据用户的任务要求，必须如此处理。
","CompletionUsage(completion_tokens=6450, prompt_tokens=1724, total_tokens=8174, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=5902, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_4_7
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""披露减持计划"", ""constraint"": ""每次披露的减持计划中减持时间区间不得超过3个月"", ""contextual_info"": NaN}
必要的额外信息: 三个月按照90个自然日计算


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_4_7(df):
    '''
    验证MEU_4_7合规性：
    - subject: 上市公司大股东或董监高
    - condition: 披露减持计划
    - constraint: 减持时间区间不超过90自然日
    '''
    df = df.copy()

    # 初始化合规性标记列
    df['meu_4_7_subject'] = False
    df['meu_4_7_condition'] = False
    df['meu_4_7_constraint'] = None

    # 1. 验证责任主体
    # 判断大股东（含持股5%以上）或董监高
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'] == '董监高'
    valid_subject = is_major_shareholder | is_director

    # 2. 验证触发条件
    valid_condition = df['存在减持计划']

    # 3. 验证时间区间约束（独立检查）
    # 计算自然日差并判断有效性
    has_valid_dates = df['计划开始日'].notna() & df['计划结束日'].notna()
    end_after_start = df['计划结束日'] >= df['计划开始日']
    days_diff = (df['计划结束日'] - df['计划开始日']).dt.days
    valid_constraint = has_valid_dates & end_after_start & (days_diff <= 90)

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_7_subject'] = True
    df.loc[valid_condition, 'meu_4_7_condition'] = True
    df.loc[valid_constraint, 'meu_4_7_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_7_constraint'] = False

    return df
</CODE>","好的，我现在需要处理MEU_4_7的合规性检查。首先，我得仔细理解这个MEU的内容。MEU_4_7的subject是上市公司大股东或董监高，condition是披露减持计划，constraint是每次披露的减持计划的时间区间不超过3个月，也就是90个自然日。contextual_info没有额外信息，但必要的信息是三个月按90天算。

接下来，我需要根据提供的dataframe的列来设计检查逻辑。首先，处理subject部分。根据用户提供的列，股东身份包括董监高、控股股东等，但可能有些大股东的持股比例超过5%但没有明确标记，所以需要结合持股比例来判断。例如，如果股东身份是董监高，或者属于控股股东、实际控制人，或者持股比例>=5%，那么subject就符合条件。

然后是condition部分，条件是披露减持计划。根据数据中的列，存在减持计划是一个布尔值，所以当该列为True时，说明该股东当天有减持计划被披露，所以condition满足。

接下来是constraint部分，每次披露的减持计划的时间区间不得超过90天。这里需要检查每个减持计划的开始日和结束日之间的自然日差是否<=90。但要注意，每个减持计划可能有不同的披露日期，所以需要按公司和股东分组，然后检查每个计划的开始和结束日期是否符合要求。

不过，dataframe中的列有“计划披露日”、“计划开始日”、“计划结束日”这些日期字段。对于每个减持计划，应该有一个对应的计划披露日，以及计划的开始和结束日期。因此，在检查约束时，需要计算计划结束日与计划开始日之间的天数差是否超过90天。但如何将这些信息对应到dataframe的每一行呢？

因为dataframe的每一行代表的是某个交易日的情况，可能同一股东在不同日期有不同的减持计划。例如，某股东在某个日期披露了一个减持计划，计划开始日和结束日分别为某段时间。这时候，在数据中，该股东在该计划的时间区间内的行中，可能存在减持计划为True，并且对应的计划开始和结束日。因此，对于每一行，如果该行存在减持计划（即condition满足），那么需要检查该计划的开始和结束日之间的天数是否超过90天。

但需要注意的是，每个减持计划可能有不同的披露日期，所以需要按每个减持计划来检查。也就是说，对于每个股东和公司，每当有一个减持计划被披露时（即存在减持计划为True的行），该计划的开始和结束日必须满足时间差<=90天。因此，在dataframe中，可能同一股东有多个减持计划，每个计划对应不同的行，需要针对每个计划的开始和结束日进行检查。

但如何确定哪些行属于同一个减持计划呢？可能同一计划的计划披露日、计划开始日、计划结束日是一致的。例如，某个减持计划在某个日期被披露，计划开始日是之后的某天，结束日是开始日后的某天。因此，对于同一股东和公司，同一计划披露日、计划开始日、计划结束日的行，属于同一个减持计划。或者，可能每个减持计划在数据中对应多行，比如在计划的时间区间内的每个交易日都有记录，但计划的详细信息如开始和结束日可能在这些行中是相同的。

因此，在检查约束时，需要针对每个减持计划（即每个唯一的计划披露日、计划开始日、计划结束日的组合）来计算时间差。但如何将这些信息对应到每一行呢？

可能的解决方法是，对于每一行，如果存在减持计划（即condition满足），那么该行的计划开始日和计划结束日之间的自然日差是否超过90天。如果超过，则约束不满足。否则，满足。

因此，在代码中，对于每一行，当condition满足时（即存在减持计划为True），计算该行的计划结束日减去计划开始日的天数，如果超过90天，则约束不满足。否则满足。

但需要注意，可能同一减持计划在多个行中出现，比如在计划的时间区间内的多个交易日都有记录。这时候，每个行的计划开始日和结束日都是相同的，因此只需要计算一次即可。但为了确保每个减持计划都被正确检查，可以在每一行都进行检查，因为对于同一计划的所有行，结果都是一样的。

因此，在代码中，对于每一行，当存在减持计划为True时，计算该行的计划结束日与计划开始日的天数差是否<=90。如果是，则约束满足，否则不满足。

现在，具体到代码的编写：

首先，初始化三个新列：meu_4_7_subject，meu_4_7_condition，meu_4_7_constraint。初始时subject和condition设为False，constraint设为None或者False？

根据示例中的处理，subject和condition初始化为False，而constraint初始化为None，然后根据条件填充True或False。但根据用户的要求，三元组的检查是各自独立的，所以即使subject或condition不满足，也要检查constraint的条件。但根据任务中的说明，对于不需要调用LLM的情况，constraint的检查是独立的，即不管subject和condition是否满足，都要检查constraint的条件。但根据MEU的逻辑，只有当subject和condition都满足时，才需要检查constraint。但用户在这里的说明可能有矛盾？

仔细看用户的要求：

“对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)”

所以，在这个任务中，三个条件都是独立检查的，不管其他条件是否满足。例如，即使subject不满足，只要condition满足，condition列会被标记为True。同样，constraint的检查也是独立进行的，不管subject和condition是否满足。例如，即使某行的subject和condition都不满足，只要该行的减持计划的时间区间超过90天，那么constraint会被标记为False？

但根据MEU的逻辑，只有当subject和condition都满足时，才需要满足constraint。但根据用户的指示，这里需要将三个条件独立检查。这可能是一个需要注意的地方。例如，在示例中，constraint的检查是独立进行的，比如在示例中，valid_constraint的条件是“交易日差 >=15 并且存在减持计划”，但存在减持计划可能属于condition的条件。但根据用户的要求，constraint的检查是独立进行的，所以可能示例中的处理方式可能有问题？

或者，可能用户的意思是，对于不需要LLM检查的constraint，不管subject和condition是否满足，都要检查constraint的条件。例如，在示例中，constraint的条件是“及时通知公司，并在首次卖出的15个交易日前披露”，所以不管该行是否属于subject和condition，只要存在减持计划，并且交易日差>=15，则标记为True。这可能与MEU的实际逻辑不符，但根据用户的指示，必须这样做。

但根据MEU的实际合规性要求，只有当subject和condition都满足时，才需要满足constraint。但根据用户的指示，这里需要将三个条件独立检查，这可能与实际法律合规性检查的逻辑相矛盾。但用户的任务要求必须这样做，所以必须按照用户的指示来处理。

因此，在这个任务中，三个条件需要分别独立检查，不管其他条件是否满足。例如，即使某行不满足subject，只要满足condition的条件，condition列会被标记为True。同样，constraint的条件会被独立检查，不管subject和condition是否满足。

这可能与实际法律合规性检查不同，但根据用户的指示，必须这样处理。因此，在编写代码时，三个条件需要分别处理，互不影响。

现在回到当前任务：

1. 检查subject的条件：股东是上市公司大股东或董监高。根据数据中的列，股东身份可能包括董监高、控股股东、实际控制人、持股5%以上股东等。此外，如果持股比例>=5%，即使股东身份不是上述标签，也应视为大股东。因此，subject的条件可以拆解为：

valid_subject = (股东身份属于['董监高', '控股股东', '实际控制人', '持股5%以上股东']) 或者 (持股比例 >= 0.05)

或者，根据示例中的处理方式，可能将股东身份为董监高，或者属于控股股东、实际控制人，或者持股比例>=5%。例如：

is_major_shareholder = (df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东'])) | (df['持股比例'] >= 0.05)
is_director = df['股东身份'] == '董监高'
valid_subject = is_major_shareholder | is_director

这样处理是否正确？是的。因为即使股东身份不是上述标签，但持股比例>=5%，也属于大股东。

2. 检查condition的条件：披露减持计划。即存在减持计划为True的行。

valid_condition = df['存在减持计划'] == True

3. 检查constraint的条件：每次披露的减持计划的时间区间不超过90天。即计划结束日 - 计划开始日 <= 90天。这里需要注意，日期是自然日，所以用dt.days计算。

对于每一行，计算计划结束日与计划开始日的天数差：

df['时间区间天数'] = (df['计划结束日'] - df['计划开始日']).dt.days
valid_constraint = df['时间区间天数'] <= 90

但需要注意，如果计划结束日或计划开始日存在缺失值，可能会导致错误。因此，需要处理缺失值的情况。例如，如果这两个日期中的任何一个为NaT，则无法计算天数差，此时该行的constraint可能不满足，或者视为无效？

根据法律合规性要求，减持计划必须明确开始和结束日期，否则可能违规。因此，如果这两个日期中的任何一个缺失，则该行的constraint应标记为False。

因此，在代码中，可以这样处理：

has_valid_dates = df['计划开始日'].notna() & df['计划结束日'].notna()
days_diff = (df['计划结束日'] - df['计划开始日']).dt.days
valid_constraint = has_valid_dates & (days_diff <= 90)

这样，只有当开始和结束日期都存在，并且天数差<=90时，才视为满足约束条件。否则，视为不满足。

现在，将这些条件应用到dataframe的每一行，并分别标记subject、condition、constraint的满足情况。

现在，编写代码：

首先，复制dataframe以避免修改原始数据。

然后，初始化三个新列：

df['meu_4_7_subject'] = False
df['meu_4_7_condition'] = False
df['meu_4_7_constraint'] = False  # 或者初始化为None？根据示例中的处理，初始化为None，然后填充True或False。但示例中的示例代码将constraint初始化为None，然后根据条件设置为True或False。例如：

在示例中，初始化为None，然后：

df.loc[valid_constraint, 'meu_4_1_constraint'] = True
df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

这可能更合理，因为有些行可能无法确定约束条件（例如日期缺失），但根据前面的处理，如果日期缺失，则视为不满足约束条件，所以可以直接初始化为False，或者用布尔值处理。

但根据用户提供的示例，constraint列初始化为None，然后根据条件设置为True或False。这可能是因为在某些情况下，约束条件可能不适用，但根据当前任务，所有行都需要检查约束条件，不管是否满足subject和condition。因此，在代码中，应该将constraint列初始化为False，然后符合条件的设置为True。

或者，根据示例中的处理方式，初始化为None，然后填充。例如：

df['meu_4_7_constraint'] = None
然后，根据条件设置True或False。

但根据用户的要求，三个条件需要独立检查，所以即使某行的subject和condition都不满足，也要检查constraint的条件。例如，某行可能没有减持计划（condition为False），但该行的减持计划的时间区间是否满足约束条件，仍然需要检查。这可能不符合实际法律逻辑，但根据用户的要求，必须这样做。

但问题在于，如果某行不存在减持计划（condition为False），那么该行的计划开始日和计划结束日可能为NaT，或者没有值。此时，约束条件的检查可能无法进行，或者视为不满足。

例如，在数据中，当存在减持计划为False时，计划开始日和计划结束日可能为空。此时，计算天数差会得到NaT，导致has_valid_dates为False，因此valid_constraint为False。因此，对于这些行，约束条件会被标记为False。

这可能与实际无关，但根据用户的要求，必须对所有行进行三个条件的独立检查。因此，在代码中，无论是否存在减持计划，都要检查约束条件。例如，即使存在减持计划为False，也要检查该行的计划开始和结束日是否满足时间区间<=90天。这可能没有实际意义，但根据用户的要求，必须这样做。

因此，在代码中，约束条件的检查是独立进行的，不管condition是否为True。例如，某行的存在减持计划为False，但如果有计划开始和结束日，并且时间区间超过90天，那么该行的constraint会被标记为False。这可能不符合实际，但根据用户的要求，必须这样处理。

现在，回到代码：

处理subject：

valid_subject的条件是股东身份属于大股东或董监高。具体来说：

is_major_shareholder = (
    df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
    (df['持股比例'] >= 0.05)
)
is_director = df['股东身份'] == '董监高'
valid_subject = is_major_shareholder | is_director

处理condition：

valid_condition = df['存在减持计划'] == True

处理constraint：

has_valid_dates = df['计划开始日'].notna() & df['计划结束日'].notna()
days_diff = (df['计划结束日'] - df['计划开始日']).dt.days
valid_constraint = has_valid_dates & (days_diff <= 90)

然后，将这三个条件分别赋值到对应的列：

df.loc[valid_subject, 'meu_4_7_subject'] = True
df.loc[valid_condition, 'meu_4_7_condition'] = True
df.loc[valid_constraint, 'meu_4_7_constraint'] = True
# 对于不满足的情况，可能需要显式设置为False，但初始值已经是False，所以可能不需要？

但根据示例中的处理，初始时constraint列被设置为None，然后根据条件设置为True或False。例如：

在示例中，初始化为None，然后：

df.loc[valid_constraint, 'meu_4_1_constraint'] = True
df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

这可能更准确，因为初始值可能不是False，而是None。但根据用户提供的示例中的代码，初始化为None，然后显式设置True和False。因此，在当前任务中，应该遵循同样的方式。

因此，在代码中：

初始化：

df['meu_4_7_subject'] = False
df['meu_4_7_condition'] = False
df['meu_4_7_constraint'] = None  # 初始化为None

然后：

df.loc[valid_subject, 'meu_4_7_subject'] = True
df.loc[valid_condition, 'meu_4_7_condition'] = True
df.loc[valid_constraint, 'meu_4_7_constraint'] = True
df.loc[~valid_constraint, 'meu_4_7_constraint'] = False

这样处理是否正确？

是的。因为对于constraint列，初始化为None，然后根据条件设置为True或False。而subject和condition列初始化为False，然后符合条件的设置为True。

现在，将这些逻辑整合到代码中。

另外，需要注意，当计算天数差时，如果计划结束日早于计划开始日，会导致负数，这种情况下天数差会是负数，此时valid_constraint会被视为False，因为负数<=90是True？例如，如果结束日早于开始日，那么天数差是负数，此时是否视为有效？

根据法律要求，减持计划的开始日必须早于或等于结束日，否则该计划无效。因此，如果结束日早于开始日，视为无效，即约束条件不满足。因此，在代码中，需要确保结束日 >= 开始日。否则，即使天数差<=90，但结束日早于开始日，视为不满足。

因此，在计算valid_constraint时，需要添加条件：结束日 >= 开始日。

因此，valid_constraint的条件应该是：

has_valid_dates = df['计划开始日'].notna() & df['计划结束日'].notna()
end_after_start = df['计划结束日'] >= df['计划开始日']
days_diff = (df['计划结束日'] - df['计划开始日']).dt.days
valid_constraint = has_valid_dates & end_after_start & (days_diff <= 90)

这样，只有当开始和结束日都存在，结束日不早于开始日，并且天数差<=90时，才视为满足约束条件。

因此，在代码中需要添加end_after_start的条件。

现在，将这些条件整合到代码中。

总结：

代码步骤：

1. 复制df，避免修改原数据。

2. 初始化三个新列，meu_4_7_subject、meu_4_7_condition、meu_4_7_constraint。

3. 计算valid_subject：

   - 股东身份是董监高，或者属于控股股东、实际控制人、持股5%以上股东，或者持股比例>=5%。

4. 计算valid_condition：存在减持计划为True。

5. 计算valid_constraint：

   a. 检查计划开始日和结束日是否存在。

   b. 检查结束日是否>=开始日。

   c. 计算天数差是否<=90。

   d. 同时满足a、b、c则为True，否则False。

6. 将这三个条件的结果分别赋值到对应的列。

现在，编写代码：

例如：

def check_meu_4_7(df):
    # 复制df
    df = df.copy()
    
    # 初始化列
    df['meu_4_7_subject'] = False
    df['meu_4_7_condition'] = False
    df['meu_4_7_constraint'] = None
    
    # 处理subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'] == '董监高'
    valid_subject = is_major_shareholder | is_director
    
    # 处理condition
    valid_condition = df['存在减持计划'] == True
    
    # 处理constraint
    has_valid_dates = df['计划开始日'].notna() & df['计划结束日'].notna()
    end_after_start = df['计划结束日'] >= df['计划开始日']
    days_diff = (df['计划结束日'] - df['计划开始日']).dt.days
    valid_constraint = has_valid_dates & end_after_start & (days_diff <= 90)
    
    # 赋值到列
    df.loc[valid_subject, 'meu_4_7_subject'] = True
    df.loc[valid_condition, 'meu_4_7_condition'] = True
    df.loc[valid_constraint, 'meu_4_7_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_7_constraint'] = False
    
    return df

这样是否正确？

是的。但需要注意，在计算days_diff时，如果结束日等于开始日，则天数为0，符合条件。如果结束日比开始日晚90天，则天数差为90，符合条件。超过90天则不符合。

此外，对于存在减持计划为False的行，计划开始日和结束日可能为空，此时has_valid_dates为False，因此valid_constraint为False，所以这些行的constraint列会被标记为False。但根据用户的要求，不管condition是否满足，都要检查constraint。因此，即使某行不存在减持计划（condition为False），但只要计划开始和结束日存在，并且时间区间超过90天，该行的constraint会被标记为False。这可能与实际无关，但根据用户的要求，必须这样处理。

例如，某行存在减持计划为False，但计划开始日和结束日被填写了，并且时间超过90天，那么该行的constraint会被标记为False。这可能在实际中不会发生，但代码需要处理所有情况。

综上，这段代码应该能够满足用户的要求。
","CompletionUsage(completion_tokens=5009, prompt_tokens=1709, total_tokens=6718, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=4533, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_12_4
法律的最小可执行单元内容: {""subject"": ""控股股东 | 实际控制人（上市后不再具备相关主体身份的）"", ""condition"": ""计划通过集中竞价交易或大宗交易减持股份且首次披露减持计划, 且不存在已经按照本指引第四条披露减持计划，或者中国证监会另有规定的情况的"", ""constraint"": ""不得存在下列情形：最近20个交易日内任一交易日股票收盘价低于公开发行股票并上市的发行价格"", ""contextual_info"": ""股票收盘价以公开发行股票并上市之日为基准向后复权计算""}
必要的额外信息: 不考虑中国证监会另有规定的情况


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_12_4(df):
    '''
    验证MEU_12_4合规性：
    subject: 上市时是控股股东/实际控制人且当前已不具备该身份
    condition: 首次披露竞价/大宗减持计划
    constraint: 最近20交易日无复权收盘价低于发行价
    '''
    df = df.copy()
    
    # 初始化结果列
    df['meu_12_4_subject'] = False
    df['meu_12_4_condition'] = False
    df['meu_12_4_constraint'] = False
    
    # ================== SUBJECT验证 ==================
    # 构建公司上市时控股股东/实际控制人字典
    ipo_entities = (df.sort_values('日期')
                    .groupby('公司简称')
                    .apply(lambda g: set(g[g['日期'] == g['上市日期'].iloc[0]]
                                        .query(""股东身份 in ['控股股东','实际控制人']"")['股东'])))
    
    # 标记符合主体条件
    df['is_ipo_entity'] = df.apply(
        lambda x: x['股东'] in ipo_entities.get(x['公司简称'], set()), axis=1)
    valid_subject = df['is_ipo_entity'] & ~df['股东身份'].isin(['控股股东','实际控制人'])
    df.loc[valid_subject, 'meu_12_4_subject'] = True

    # ================== CONDITION验证 ==================
    # 计算首次计划披露日期
    first_plan = (df[df['存在减持计划']]
                 .sort_values('日期')
                 .groupby(['公司简称','股东'])['日期']
                 .first()
                 .reset_index(name='首披日'))
    
    # 合并首披日并验证条件
    df = df.merge(first_plan, how='left')
    valid_condition = (
        df['存在减持计划'] & 
        (df['日期'] == df['首披日']) & 
        df['减持方式'].isin(['竞价交易','大宗交易'])
    )
    df.loc[valid_condition, 'meu_12_4_condition'] = True

    # ================== CONSTRAINT验证 ==================
    # 计算复权价格
    df['复权价'] = df['收盘价'] * df['复权因子']
    
    # 按公司计算滚动窗口内最低价
    df_sorted = df.sort_values(['公司简称','日期'])
    df_sorted['发行价'] = df_sorted.groupby('公司简称')['发行价格'].transform('first')
    window_check = df_sorted.groupby('公司简称', group_keys=False).apply(
        lambda g: g['复权价'].rolling(20, min_periods=1).apply(
            lambda x: (x < g['发行价'].iloc[0]).any()))
    
    # 标记约束违规
    df_sorted['meu_12_4_constraint'] = ~(window_check > 0)
    df = df_sorted.sort_index().drop(columns=['复权价','发行价'])
    
    return df.drop(columns=['is_ipo_entity','首披日'], errors='ignore')
</CODE>","好的，我现在需要处理这个MEU_12_4的合规性检查。首先，我得仔细理解这个MEU的具体内容。根据提供的JSON结构，subject是控股股东或实际控制人，且在上市后不再具备相关主体身份。condition是计划通过集中竞价或大宗交易减持股份，并且是首次披露减持计划，同时不存在已经按照指引第四条披露的情况，或者证监会另有规定的情况。不过额外信息里说不考虑证监会的情况，所以可以忽略这部分。constraint是最近20个交易日内任一交易日的收盘价低于发行价，这里的收盘价需要复权计算，以上市日为基准。

接下来，我需要将这些条件转化为代码，对输入的DataFrame进行处理。根据任务要求，我需要分别标记subject、condition和constraint的合规情况，每个部分独立检查。

首先处理subject。根据MEU的subject，需要满足两个条件：一是股东身份是控股股东或实际控制人，二是上市后不再具备相关身份。这里可能需要判断该股东在上市时是否是控股股东或实际控制人，但现在不再是。但数据中的股东身份列可能只记录当前状态，所以可能需要比较当前身份是否已经不是控股股东或实际控制人。例如，如果股东身份列现在不是控股股东或实际控制人，但曾经是的话。但数据中的股东身份列可能只反映当前状态，所以可能需要其他方式判断。例如，假设如果当前股东身份不是控股股东或实际控制人，但曾经在上市时是的话，就符合条件。但如何确定他们上市时的身份呢？根据附加信息中的说明，假设公司上市时的控股股东和实际控制人是在上市日期对应的那一天的记录中的。所以，我需要为每个公司确定其上市时的控股股东和实际控制人，然后检查当前股东是否曾经是其中之一但现在不是。

这可能比较复杂。例如，对于每个公司，找到其上市日期（即上市日期列的值），然后在该日期对应的记录中，找出当时的控股股东和实际控制人。然后，对于当前行的股东，如果他们在上市时是控股股东或实际控制人，但现在（当前行的股东身份）不是，则符合subject条件。

但如何获取每个公司的上市时的控股股东和实际控制人？可能需要分组处理。例如，对每个公司，找到上市日期对应的记录，然后记录该公司的控股股东和实际控制人。然后，对于每个股东，检查他们是否在该公司的上市日期的记录中是控股股东或实际控制人，而当前行的股东身份是否已经不是。

这可能需要先为每个公司创建一个映射，记录其上市时的控股股东和实际控制人。例如，对于每个公司简称，找到上市日期（假设上市日期列是每个公司的最早日期？或者根据附加信息中的说明，上市发行价是第一个非空的收盘价对应的日期？可能需要根据上市日期列来确定。假设上市日期列是正确的，每个公司的上市日期是已知的。然后，对于每个公司，在上市日期当天，哪些股东是控股股东或实际控制人？

例如，对于公司A，上市日期是某一天，那么在该日期对应的行中，股东身份为控股股东或实际控制人的股东，就是上市时的相关主体。然后，当前行的股东是否是其中之一，但现在他们的身份已经不是控股股东或实际控制人？

所以，步骤可能是：

1. 对每个公司，确定其上市日期。
2. 对每个公司，在上市日期当天，找出所有股东身份为控股股东或实际控制人的股东列表。
3. 对于当前行的股东，如果他们在该公司的上市时的控股股东/实际控制人列表中，并且当前行的股东身份不是控股股东或实际控制人，则符合subject条件。

这需要分组处理，可能需要先为每个公司生成一个上市时的控股股东和实际控制人的列表。例如，使用groupby按公司分组，然后在每个组中找到上市日期对应的行，筛选出股东身份是控股股东或实际控制人的股东，保存这些股东的名字。然后，在后续处理中，检查当前行的股东是否在该列表中，并且当前行的股东身份是否已经不是控股股东或实际控制人。

这可能需要创建一个新的列或者字典来存储这些信息。例如，创建一个字典，键是公司简称，值是该公司的上市时的控股股东和实际控制人的集合。

接下来处理condition。condition是计划通过集中竞价或大宗交易减持股份，并且是首次披露减持计划，且没有已经按照第四条披露的情况。根据附加信息，不考虑证监会的情况，所以只需要检查是否是首次披露减持计划，并且减持方式是集中竞价或大宗交易。

首次披露减持计划可能需要检查该股东是否有之前的减持计划记录。例如，对于每个股东，在之前的日期中是否已经存在减持计划。如果当前行的存在减持计划为True，并且是该股东的首次披露，则符合条件。这需要按公司和股东分组，然后检查当前行的计划披露日是否是该股东的第一个计划披露日。

或者，可能更简单的是，假设存在减持计划列是布尔值，表示当天是否有减持计划。首次披露可能指的是该股东第一次出现存在减持计划为True的情况。例如，在分组中，对于每个公司和股东，找到他们第一次出现存在减持计划为True的日期，如果当前行的日期等于该日期，则符合条件。

这可能需要按公司和股东分组，然后计算每个组的累计出现减持计划的次数，或者标记是否为首次。

最后处理constraint。constraint是最近20个交易日内任一交易日的收盘价（复权后的）低于发行价。这里的复权计算需要以上市日为基准向后复权。发行价是公司的发行价格列的值。对于每个公司的每个交易日，需要计算复权后的收盘价，然后检查最近20个交易日内的收盘价是否低于发行价。

复权因子的处理可能需要用到复权因子列。例如，复权后的收盘价等于收盘价乘以复权因子。或者，可能根据上市日期后的复权因子调整。例如，假设复权因子是累积的，复权后的价格是收盘价 * 复权因子。例如，如果复权因子列是正确的，那么复权后的收盘价就是收盘价 * 复权因子。然后，发行价也需要复权吗？根据MEU的contextual_info，股票收盘价以公开发行股票并上市的发行价格向后复权计算。所以，发行价可能不需要复权，而收盘价需要复权到发行日后的价格。例如，发行价是当时的原始价格，而收盘价经过复权处理，比如考虑分红、拆股等因素后的价格，使得可以直接比较。

例如，复权后的收盘价 = 收盘价 * 复权因子。而发行价是固定的，不需要调整。因此，对于每个交易日，复权后的收盘价是否低于发行价？

所以，对于每个公司的每个交易日，复权后的收盘价是收盘价 * 复权因子。然后，检查该价格是否低于发行价格。如果最近20个交易日内的任何一个满足这个条件，则违反constraint，即constraint为False。

但如何计算最近20个交易日？对于每个日期，需要找到该日期之前的20个交易日（包括该日期本身？或者最近20个交易日包括当天？需要明确条件中的“最近20个交易日内任一交易日”是否包括当前日期。例如，假设当前日期是T，那么最近20个交易日是T-19到T的交易日。或者，可能是指过去20个交易日，包括当天？或者可能要看该行的日期是否是减持计划披露日，然后检查该日期之前的20个交易日内的收盘价情况？

或者，可能对于每一行，不管是否满足subject和condition，都要检查constraint的条件。但根据任务要求，对于简单操作，三元组的检查是独立的，所以constraint的检查是独立进行的，不需要依赖subject和condition是否满足。但根据MEU的约束条件，只有当subject和condition都满足时，constraint才需要被检查？或者根据任务中的说明，对于不需要调用LLM的情况，三个条件是独立检查的。所以，不管subject和condition是否满足，都要检查constraint的条件，并标记是否满足。

但根据MEU的约束条件，constraint是当subject和condition满足时，必须满足的条件。但根据任务中的要求，对于简单操作，三个条件是独立检查的。所以，可能在这个问题中，constraint的检查是独立进行的，即不管subject和condition是否满足，都要检查该行的constraint条件是否满足。例如，对于每一行，检查是否存在最近20个交易日内收盘价低于发行价的情况，不管该行是否属于控股股东减持的情况。

但根据MEU的约束条件，只有当subject和condition都满足时，才需要满足constraint。但根据任务中的要求，对于不需要调用LLM的情况，三个条件是独立检查的。所以，这里可能需要将三个条件分别独立检查，即每个条件是否满足，不管其他条件的情况。例如，subject列标记该行是否属于控股股东或实际控制人（上市后不再具备身份），condition列标记是否计划减持且首次披露，constraint列标记是否存在最近20个交易日收盘价低于发行价的情况。这三个条件各自独立标记。

但根据MEU的约束条件，只有当subject和condition都满足时，才需要满足constraint。但根据任务中的说明，对于简单操作，三个条件是独立检查的。所以，可能在这个问题中，三个条件各自独立检查，而最终的合规性可能需要综合这三个条件的结果。但根据任务中的示例，每个条件都被独立标记，所以这里需要分别处理。

现在，具体到每个条件的代码实现：

首先，处理subject：

subject的条件是：控股股东或实际控制人（上市后不再具备相关主体身份）。即，该股东在上市时是控股股东或实际控制人，但现在不再是。

如何确定这一点？

根据附加信息中的说明：“假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人.” 所以，每个公司的上市日期是当天的收盘价非空的最早日期。或者，可能上市日期列已经给出，所以每个公司的上市日期是已知的。然后，在该上市日期当天，该公司的控股股东和实际控制人是谁？

例如，对于每个公司简称，找到其上市日期（即上市日期列的值），然后在该日期对应的行中，筛选出股东身份为控股股东或实际控制人的股东。这些股东就是上市时的相关主体。然后，对于当前行的股东，如果他们属于该列表中的一员，并且当前行的股东身份不再是控股股东或实际控制人，则符合subject条件。

所以，步骤：

1. 对每个公司，确定其上市日期（即上市日期列的值）。
2. 对每个公司，在上市日期当天，找到所有股东身份为控股股东或实际控制人的股东，保存这些股东的名字。
3. 对于当前行的股东，如果他们属于该公司的上市时的控股股东或实际控制人列表，并且当前行的股东身份不是控股股东或实际控制人，则标记subject为True。

这需要先为每个公司生成一个上市时的控股股东和实际控制人的列表。例如，创建一个字典，键是公司简称，值是该公司的上市时的相关股东集合。

代码实现：

首先，获取每个公司的上市日期：

上市日期可能对于同一公司来说，所有行的上市日期列的值都是相同的。所以，可以按公司分组，取上市日期的第一个值即可。

然后，对于每个公司，在上市日期当天，找到所有股东身份为控股股东或实际控制人的股东：

例如，对于公司A，上市日期是date_A。筛选出公司A在date_A的行，且股东身份是控股股东或实际控制人的股东，收集这些股东的名字。

这可能需要创建一个字典，例如：

company_ipo_info = {}
for company in df['公司简称'].unique():
    ipo_date = df[df['公司简称'] == company]['上市日期'].iloc[0]
    ipo_shareholders = df[(df['公司简称'] == company) & (df['日期'] == ipo_date) & (df['股东身份'].isin(['控股股东', '实际控制人']))]['股东'].unique()
    company_ipo_info[company] = set(ipo_shareholders)

然后，对于当前行的股东，如果该股东属于company_ipo_info[公司简称]，并且当前行的股东身份不是控股股东或实际控制人，则subject为True。

所以，在代码中：

valid_subject = (
    df.apply(lambda row: row['股东'] in company_ipo_info.get(row['公司简称'], set()) 
             and row['股东身份'] not in ['控股股东', '实际控制人'], axis=1)
)

这可能比较耗时，因为apply是按行处理的。有没有更高效的方式？

或者，可以创建一个列，标记该股东是否是公司上市时的控股股东或实际控制人：

df['is_ipo_subject'] = df.apply(lambda row: row['股东'] in company_ipo_info.get(row['公司简称'], set()), axis=1)

然后，valid_subject = df['is_ipo_subject'] & ~df['股东身份'].isin(['控股股东', '实际控制人'])

这样可能更高效。

接下来处理condition：

condition是计划通过集中竞价或大宗交易减持股份，并且是首次披露减持计划，且没有已经按照指引第四条披露的情况。这里不考虑第四条的情况，所以只需要检查是否是首次披露减持计划，并且减持方式是集中竞价或大宗交易。

首先，减持方式是否是集中竞价或大宗交易：

valid_condition_part1 = df['减持方式'].isin(['集中竞价', '大宗交易'])  # 但数据中的减持方式列可能包含其他值，比如NaN？

但可能减持方式列在存在减持计划为True时才有效。所以，需要结合存在减持计划为True的情况。

另外，首次披露减持计划的条件需要判断该股东是否在之前没有披露过减持计划。例如，对于每个公司和股东，当前行的存在减持计划为True，并且是该股东的第一次出现存在减持计划为True的情况。

这可以通过按公司和股东分组，然后计算存在减持计划的累积次数，或者标记是否为首次。

例如：

df_sorted = df.sort_values(by=['公司简称', '股东', '日期'])
df['cumulative_plan'] = df_sorted.groupby(['公司简称', '股东'])['存在减持计划'].cumsum()
# 或者，更准确的是，检查该行是否是第一次出现存在减持计划为True的情况
# 使用groupby和transform来标记首次出现
df['is_first_plan'] = df_sorted.groupby(['公司简称', '股东'])['存在减持计划'].transform(lambda x: x & (x.cumsum() == 1))

或者，更准确的方式是，对于每个公司和股东，找到他们第一次存在减持计划为True的日期，然后判断当前行是否是那个日期。

例如：

grouped = df.groupby(['公司简称', '股东'])
df['first_plan_date'] = grouped['日期'].transform(lambda x: x[df['存在减持计划']].min())

然后，当前行的日期等于first_plan_date时，则为首次披露。

但可能存在多个减持计划的情况，但根据MEU的条件，只有首次披露的情况才符合条件。所以，只有当存在减持计划为True，并且该行的日期是该股东的首次披露日期时，才满足condition的条件。

所以，代码步骤：

1. 按公司和股东分组，找到每个股东首次存在减持计划为True的日期。
2. 判断当前行的日期是否等于该日期，并且存在减持计划为True。
3. 同时，减持方式是否是集中竞价或大宗交易。

所以，valid_condition = (存在减持计划为True) & (当前日期是首次披露日期) & (减持方式符合条件)

如何实现：

首先，按公司和股东分组，找到每个组的首次存在减持计划为True的日期：

df_sorted = df.sort_values(['公司简称', '股东', '日期'])
mask = df_sorted['存在减持计划']
first_plan_dates = df_sorted[mask].groupby(['公司简称', '股东'])['日期'].first().reset_index()
first_plan_dates.rename(columns={'日期': 'first_plan_date'}, inplace=True)

然后，将first_plan_dates合并回原df：

df = df.merge(first_plan_dates, on=['公司简称', '股东'], how='left')

然后，判断当前行的日期是否等于first_plan_date，并且存在减持计划为True：

is_first_plan = (df['日期'] == df['first_plan_date']) & df['存在减持计划']

同时，减持方式需要是集中竞价或大宗交易：

valid_condition = is_first_plan & df['减持方式'].isin(['竞价交易', '大宗交易'])

注意，数据中的减持方式列可能存储的是'竞价交易'，而MEU中的condition是“集中竞价交易或大宗交易”，所以需要确认数据中的值是否对应。根据附加信息中的说明，交易方式有['竞价交易', '大宗交易', '融券卖出']，而竞价交易包括集中竞价。所以，减持方式为'竞价交易'或'大宗交易'时，符合条件。

所以，减持方式的条件是：

df['减持方式'].isin(['竞价交易', '大宗交易'])

综上，valid_condition的条件是：

存在减持计划为True，且是首次披露，且减持方式正确。

现在处理constraint：

constraint是最近20个交易日内任一交易日的收盘价（复权后的）低于发行价格。这里的复权以上市日为基准向后复权。发行价格是公司的发行价格列的值。复权后的收盘价计算方式是收盘价乘以复权因子。

所以，对于每一行，需要检查该行的日期之前的20个交易日（包括该日期吗？或者最近20个交易日是否包括该日期？例如，假设当前日期是T，那么最近20个交易日是T-19到T的交易日。或者，可能是指过去20个交易日，即T的前20个交易日，不包括T？需要明确条件中的“最近20个交易日内任一交易日”是否包括当前日期。例如，假设当前行是某一天，那么需要检查该天之前的20个交易日（包括该天？或者不包括？）

根据常规理解，“最近20个交易日”通常包括当天。例如，如果今天是T，那么最近20个交易日是T-19到T的20天。所以，对于每一行，需要计算该行的日期往前20个交易日（包括该行日期）的窗口，然后检查其中是否有任何一天的复权收盘价低于发行价。

但如何计算每个日期的前20个交易日？这需要按公司分组，因为不同公司的交易日可能不同。例如，每个公司的交易日可能不同，但根据附加信息，日期列本身就是交易日，所以对于同一公司，日期是连续的交易日吗？可能不是，因为数据是日频的，可能包含非交易日的数据？或者日期列已经过滤了非交易日，所以每个日期都是该公司的实际交易日？

假设日期列已经是该公司的实际交易日，那么对于每个公司，每个日期，需要找到该日期之前的19个交易日（加上自己共20个）。例如，对于公司A的某一天，找到该公司的日期中小于等于该日期的前20个交易日，然后检查这些日期中的收盘价是否满足条件。

这可能需要按公司分组，然后对每个日期，计算滚动窗口。

例如，对于每个公司，按日期排序，然后对于每个日期，取前20个交易日（包括该日期），然后检查这些行中的收盘价是否满足条件。

但这样处理可能比较耗时，特别是对于大数据集。有没有更高效的方式？

或者，可以按公司分组，然后对每个公司的收盘价复权后的价格进行比较。

具体步骤：

1. 计算复权后的收盘价：复权收盘价 = 收盘价 * 复权因子。
2. 对于每个公司的每个交易日，检查该交易日及前19个交易日（共20个）内是否有复权收盘价 < 发行价格。
3. 如果存在至少一个这样的交易日，则constraint为False，否则为True？

但根据MEU的约束条件，constraint是“不得存在下列情形：最近20个交易日内任一交易日股票收盘价低于公开发行股票并上市的发行价格”，即如果存在任一交易日满足条件，则违反constraint，所以constraint的valid应为False。因此，在代码中，如果最近20个交易日内存在复权收盘价低于发行价，则constraint为False，否则为True。

所以，对于每一行，需要判断该行所在公司的最近20个交易日中是否有复权收盘价低于发行价。

如何实现：

首先，计算复权后的收盘价：

df['复权收盘价'] = df['收盘价'] * df['复权因子']

然后，发行价格是公司的发行价格列的值。每个公司的发行价格是固定的，所以可以按公司分组，取发行价格的值。

然后，对于每个公司的每个日期，检查该日期之前的20个交易日内是否有复权收盘价 < 发行价格。

这可以通过按公司分组，然后对每个公司的时间序列进行滚动窗口检查。

例如，按公司分组，对每个公司的复权收盘价列，使用rolling窗口，窗口大小为20，min_periods=1，然后检查每个窗口中是否有值小于发行价。

但滚动窗口是基于行数的，而不是时间范围。所以，如果数据中的日期是连续的，那么窗口大小20行对应20个交易日。否则，可能需要重新采样数据以确保每个公司的日期是连续的，但这样可能比较复杂。

另一种方法是，对于每个公司的每个日期，找到该日期之前的20个交易日（包括该日期），然后检查这些日期的复权收盘价是否小于发行价。

这可以通过按公司分组，然后对每个日期，找到该日期之前的20个交易日的记录，并检查条件。

例如，对于公司A的某一行，日期为date，发行价为price。我们需要找到公司A的所有日期中，在[date - 19 days, date]之间的日期，最多20个交易日，然后检查这些日期的复权收盘价是否小于price。

但如何高效地实现这一点？

可能需要使用rolling窗口，但需要确保数据按日期排序，并且每个公司的数据是连续的。

假设数据已经按公司简称和日期排序，那么可以按公司分组，然后对每个公司的复权收盘价列进行滚动窗口，计算每个窗口内的最小值，并与发行价比较。

例如：

df_sorted = df.sort_values(['公司简称', '日期'])
grouped = df_sorted.groupby('公司简称')

# 计算每个公司的发行价
company_issue_price = df_sorted.groupby('公司简称')['发行价格'].first()

# 对每个公司，计算复权收盘价是否小于发行价的布尔序列
df_sorted['复权收盘价_低于发行价'] = df_sorted['复权收盘价'] < df_sorted['公司简称'].map(company_issue_price)

# 然后，按公司分组，对每个公司的该布尔列进行滚动窗口，窗口大小为20，检查是否有True存在
df_sorted['最近20日存在低于发行价'] = grouped['复权收盘价_低于发行价'].transform(lambda s: s.rolling(20, min_periods=1).max().astype(bool))

这样，'最近20日存在低于发行价'列将为True，如果在过去20个交易日中存在至少一个交易日复权收盘价低于发行价。

但滚动窗口的起始点是否正确？例如，窗口是前20行（即前20个交易日），包括当前行。例如，对于第20行，窗口是前20行，即从第1行到第20行。这样，每个窗口代表当前行及前19行的数据？或者，窗口的大小为20，表示包括当前行在内的20行？

需要明确rolling的参数。例如，rolling(window=20)会包括当前行和前19行，共20行。所以，对于每个行，窗口是当前行及前19行，共20行。因此，如果在这20行中，至少有一个行的复权收盘价低于发行价，则标记为True。

这样，'最近20日存在低于发行价'列将标记该行所在公司的最近20个交易日是否存在该情况。

然后，constraint的valid是当该列为False时，即最近20个交易日中没有出现复权收盘价低于发行价的情况，才满足constraint的条件。因为MEU的constraint是“不得存在下列情形”，即如果存在，则违反，所以constraint的valid应为False。

因此，valid_constraint = ~df['最近20日存在低于发行价']

综上，将这三个条件分别标记到对应的列中。

现在，将这些步骤整合到代码中：

首先，处理subject：

创建company_ipo_info字典，记录每个公司上市时的控股股东和实际控制人。

然后，标记valid_subject的条件。

接着，处理condition：

找到每个公司和股东的首次减持计划披露日期，并判断当前行是否为该日期，且减持方式正确。

最后，处理constraint：

计算复权收盘价，并检查最近20个交易日内是否有低于发行价的情况。

现在，编写代码：

首先，导入必要的库：

import pandas as pd

然后，定义函数：

def check_meu_12_4(df):
    # 复制df，避免修改原数据
    df = df.copy()
    
    # 初始化标记列
    df['meu_12_4_subject'] = False
    df['meu_12_4_condition'] = False
    df['meu_12_4_constraint'] = None  # 初始化为None，后续填充True/False
    
    # 处理subject
    # 步骤1：确定每个公司上市时的控股股东和实际控制人
    # 按公司分组，找到上市日期对应的行中的股东身份为控股股东或实际控制人的股东
    company_ipo_info = {}
    for company in df['公司简称'].unique():
        # 获取该公司的上市日期
        ipo_date = df[df['公司简称'] == company]['上市日期'].iloc[0]
        # 筛选上市日期当天的行，且股东身份为控股股东或实际控制人
        ipo_shareholders = df[(df['公司简称'] == company) & 
                              (df['日期'] == ipo_date) & 
                              (df['股东身份'].isin(['控股股东', '实际控制人']))]['股东'].unique()
        company_ipo_info[company] = set(ipo_shareholders)
    
    # 标记subject条件：股东是上市时的控股股东/实际控制人，且当前身份不再是
    df['is_ipo_subject'] = df.apply(
        lambda row: row['股东'] in company_ipo_info.get(row['公司简称'], set()), 
        axis=1
    )
    valid_subject = df['is_ipo_subject'] & ~df['股东身份'].isin(['控股股东', '实际控制人'])
    df.loc[valid_subject, 'meu_12_4_subject'] = True
    
    # 处理condition
    # 步骤：找到每个公司和股东的首次减持计划披露日期，并判断减持方式
    # 按公司和股东分组，找到首次存在减持计划为True的日期
    df_sorted = df.sort_values(['公司简称', '股东', '日期'])
    mask = df_sorted['存在减持计划']
    first_plan_dates = df_sorted[mask].groupby(['公司简称', '股东'])['日期'].first().reset_index()
    first_plan_dates.rename(columns={'日期': 'first_plan_date'}, inplace=True)
    
    # 合并回原df
    df = df.merge(first_plan_dates, on=['公司简称', '股东'], how='left')
    
    # 判断当前行是否为首次披露且减持方式正确
    is_first_plan = (df['日期'] == df['first_plan_date']) & df['存在减持计划']
    valid_condition = is_first_plan & df['减持方式'].isin(['竞价交易', '大宗交易'])
    df.loc[valid_condition, 'meu_12_4_condition'] = True
    
    # 处理constraint
    # 计算复权收盘价
    df['复权收盘价'] = df['收盘价'] * df['复权因子']
    
    # 获取每个公司的发行价格
    company_issue_price = df.groupby('公司简称')['发行价格'].first().to_dict()
    df['发行价格'] = df['公司简称'].map(company_issue_price)
    
    # 判断复权收盘价是否低于发行价
    df['复权收盘价_低于发行价'] = df['复权收盘价'] < df['发行价格']
    
    # 按公司分组，计算最近20个交易日内是否有低于发行价的情况
    df_sorted = df.sort_values(['公司简称', '日期'])
    grouped = df_sorted.groupby('公司简称')
    
    # 使用rolling窗口计算每个公司最近20个交易日的情况
    df_sorted['最近20日存在低于发行价'] = grouped['复权收盘价_低于发行价'].transform(
        lambda s: s.rolling(20, min_periods=1).max().astype(bool)
    )
    
    # 将结果合并回原df的顺序
    df = df_sorted.sort_index()
    
    # constraint的valid是最近20日没有出现低于发行价的情况
    valid_constraint = ~df['最近20日存在低于发行价']
    df['meu_12_4_constraint'] = valid_constraint
    
    # 清理中间列
    df.drop(columns=['is_ipo_subject', 'first_plan_date', '复权收盘价', '发行价格', 
                     '复权收盘价_低于发行价', '最近20日存在低于发行价'], inplace=True, errors='ignore')
    
    return df

但需要注意，在合并first_plan_dates时，可能有些行没有首次计划日期，所以需要处理NaN的情况。例如，在判断is_first_plan时，如果first_plan_date是NaN，则条件为False。

此外，在计算复权收盘价时，复权因子是否正确？假设复权因子列已经正确，所以直接相乘即可。

另外，在计算每个公司的发行价格时，可能每个公司的发行价格是固定的，所以用groupby后取第一个即可。但需要确保每个公司的发行价格列的值是相同的，否则可能需要更准确的处理。

最后，在rolling窗口处理时，需要确保数据按日期排序，并且每个公司的数据是连续的。如果数据中存在缺失的交易日，则rolling窗口可能不准确。但根据附加信息，日期列已经是交易日，所以假设每个公司的日期是连续的，或者至少按顺序排列。

综上，这段代码应该能够处理MEU_12_4的合规性检查，分别标记subject、condition和constraint的满足情况。
","CompletionUsage(completion_tokens=7249, prompt_tokens=1775, total_tokens=9024, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=6528, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_14_5
法律的最小可执行单元内容: {""subject"": ""上市公司董监高"", ""condition"": ""本人因涉及证券期货违法，被中国证监会行政处罚，罚没款尚未足额缴纳，且不存在法律、行政法规另有规定或减持资金用于缴纳罚没款的情况"", ""constraint"": ""不得减持其所持有的本公司股份"", ""contextual_info"": NaN}
必要的额外信息: 不考虑法律、行政法规另有规定或减持资金用于缴纳罚没款的情况


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_14_5(df):
    '''
    检查MEU_14_5合规性：
    ""subject"": ""上市公司董监高"",
    ""condition"": ""被证监会行政处罚且罚没款未缴"",
    ""constraint"": ""不得减持股份"",
    实现逻辑：
    1. subject检查：股东身份为董监高
    2. condition检查：存在行政处罚决定且未缴款（通过事件字段判断）
    3. constraint检查：当日无减持行为（通过减持比例判断）
    '''
    df = df.copy()

    # 初始化合规标记列
    df['meu_14_5_subject'] = False
    df['meu_14_5_condition'] = False
    df['meu_14_5_constraint'] = None

    # 1. 验证责任主体（上市公司董监高）
    subject_mask = df['股东身份'] == '董监高'
    df.loc[subject_mask, 'meu_14_5_subject'] = True

    # 2. 验证触发条件（存在未缴款的行政处罚）
    # 根据数据字段直接匹配行政处罚决定状态
    condition_mask = df['股东涉嫌证券期货违法犯罪事件'] == '行政处罚决定作出'
    df.loc[condition_mask, 'meu_14_5_condition'] = True

    # 3. 验证约束条件（未发生减持行为）
    # 通过当日减持比例判断，0表示无减持
    constraint_mask = df['当日减持比例'] == 0
    df.loc[constraint_mask, 'meu_14_5_constraint'] = True
    df.loc[~constraint_mask, 'meu_14_5_constraint'] = False

    return df
</CODE>","好的，我现在需要处理这个MEU_14_5的合规性检查任务。首先，我得仔细理解这个MEU的具体内容。根据提供的法律单元，责任主体是上市公司的董监高，触发条件是这些人因涉及证券期货违法被证监会行政处罚，且罚没款未足额缴纳，同时不考虑其他例外情况。约束内容是他们不得减持所持有的公司股份。

接下来，我需要确定如何将这些条件转化为代码，检查数据框中的每一行是否符合。首先，处理subject部分。根据数据中的股东身份列，我需要筛选出身份是“董监高”的股东。因为股东身份列中的选项包括“董监高”和“离任董监高”，但MEU中的subject是现任的董监高，所以应该只检查股东身份为“董监高”的行。

然后是condition部分。条件有两个主要部分：一是被证监会行政处罚且罚没款未缴纳，二是没有例外情况。根据附加信息，这里不考虑例外情况，所以只需要关注是否被行政处罚且未缴纳。数据中的相关列是“股东涉嫌证券期货违法犯罪事件”，其中可能包含“行政处罚决定作出”的状态。但需要确认是否有对应的字段来记录罚没款是否缴纳。不过，根据给定的数据列，可能没有直接的字段，所以可能需要假设，如果存在行政处罚决定，并且没有后续的缴纳完成记录，则视为未缴纳。但当前数据列可能没有这样的信息，可能需要根据其他字段推断。例如，假设一旦有“行政处罚决定作出”，则罚没款未缴纳，直到有另一个事件表明缴纳完成。但根据问题描述中的必要额外信息，这里不考虑例外情况，所以只要存在行政处罚决定，并且没有缴纳，就满足条件。但数据中的列可能只能判断是否有行政处罚决定作出，而无法直接判断缴纳状态。因此，可能需要假设只要存在“行政处罚决定作出”的事件，就视为满足条件中的被处罚且未缴纳。这可能是一个简化处理，但根据现有数据字段，可能需要这样处理。

接下来是constraint部分，即是否减持。需要检查在满足subject和condition的情况下，是否有减持行为。减持可能通过“减持方式”列来判断，或者是否有减持记录。例如，如果当天的减持比例大于0，或者存在减持计划，或者当日的减持操作。但根据数据列中的字段，可能需要检查是否存在减持行为，比如“当日减持比例”是否大于0，或者“存在减持计划”是否为True。但MEU的约束是“不得减持”，所以需要确保在这些情况下，股东没有进行任何减持。

现在，我需要将这些逻辑转化为代码。首先，标记subject是否有效。有效的subject是股东身份为“董监高”的行。因此，可以用df['股东身份'] == '董监高'来标记meu_14_5_subject列为True。

然后是condition的条件。需要检查该股东是否被行政处罚，且罚没款未缴纳。根据数据中的“股东涉嫌证券期货违法犯罪事件”列，如果该列包含“行政处罚决定作出”，则视为满足被处罚的条件。同时，假设只要存在该事件，且没有缴纳，就满足条件。因此，valid_condition的条件是df['股东涉嫌证券期货违法犯罪事件'] == '行政处罚决定作出'。但需要确认该列的可能值是否包含这个字符串。根据附加信息中的说明，该列的可能值包括“行政处罚决定作出”，所以可以这样判断。此外，根据必要额外信息，不考虑例外情况，所以无需检查其他条件。

接下来是constraint的检查。约束是不得减持，因此需要检查该股东在该交易日是否有减持行为。这可能涉及多个字段，比如“当日减持比例”是否大于0，或者“存在减持计划”是否为True。但根据MEU的约束，只要存在减持行为就违规。例如，如果当日减持比例>0，或者减持方式不为空，或者存在减持计划，那么constraint的条件不满足。但需要明确如何判断是否减持。例如，如果“存在减持计划”为True，或者“当日减持比例”>0，则视为违反约束。或者，可能要看是否有实际的减持操作，比如当日减持比例>0。或者，如果存在减持计划，不管是否执行，都视为违反约束？这需要仔细分析法律条文。

根据MEU的约束内容，“不得减持其所持有的本公司股份”，所以只要在满足subject和condition的情况下，存在减持行为，就违反约束。因此，在代码中，需要检查在满足subject和condition的行中，是否有减持发生。例如，如果“当日减持比例”>0，或者“减持方式”不为空，或者“存在减持计划”为True。但根据数据列的描述，“存在减持计划”是一个布尔值，表示该股东当天是否有减持计划。而约束是不得减持，所以即使有计划，也属于违反约束吗？或者，是否只有在实际减持时才违反？

这里可能存在不同的情况。例如，如果股东有计划但尚未执行，是否属于违反？根据法律条文中的约束内容，“不得减持”，所以可能包括计划中的减持，但需要看具体的法律解释。例如，在例子中的MEU_4_1，约束是提前披露减持计划，所以存在减持计划但未披露的情况会被标记。但当前MEU的约束是“不得减持”，所以可能只要存在减持行为（如实际减持或计划减持）就违反。但需要根据法律条文的具体要求来判断。

根据MEU的约束内容，是“不得减持”，所以实际减持行为才违反。因此，可能需要检查“当日减持比例”是否大于0，或者是否有减持交易发生。例如，如果“减持方式”列不为空，或者“当日减持比例”>0，则视为减持。因此，在代码中，valid_constraint的条件应为该股东在当日的减持行为是否存在。例如，如果当日减持比例>0，则constraint为False（违反），否则为True（遵守）。

但根据问题描述中的要求，对于三元组的检查是各自独立的，所以constraint的检查是独立于subject和condition的。也就是说，不管subject和condition是否满足，都要检查constraint是否满足。但根据MEU的约束，只有当subject和condition都满足时，才需要遵守constraint。但根据用户的要求，对于不需要调用llm_content_check()的情况，三元组的检查是各自独立的，需要分别标记。这可能意味着，即使subject或condition不满足，也要检查constraint是否满足，这可能与法律逻辑不符。但根据用户的要求，必须按照这个框架处理。

但根据用户给出的示例，比如MEU_4_1的例子，constraint的检查是独立进行的，例如，检查是否存在减持计划并提前披露。在示例中，valid_constraint的条件是计划开始日和披露日之间的天数是否足够，而不管subject和condition是否满足。这可能意味着，在示例中，所有行都会被检查constraint的条件，而不仅仅是subject和condition都满足的行。但根据用户的要求，对于不需要调用llm_content_check()的情况，三元组的检查是各自独立的，需要分别标记。因此，在MEU_14_5的情况下，constraint的检查应该独立进行，即检查所有行是否满足“不得减持”，而不管subject和condition是否满足。这可能不符合法律逻辑，但根据任务要求必须这样做。

不过，这可能存在矛盾。例如，约束条件“不得减持”只有在subject和condition都满足时才适用。但根据用户的要求，对于不需要调用llm_content_check()的情况，需要分别检查三元组中的每个条件，而不管其他条件是否满足。因此，在MEU_14_5的情况下，constraint的检查是独立进行的，即所有行都会被检查是否减持，而不管该行是否属于董监高或被处罚。这可能不符合实际法律应用，但根据任务要求必须这样处理。

因此，在代码中，需要分别处理三个条件：

1. subject是否为董监高。
2. condition是否被处罚且未缴纳。
3. constraint是否没有减持。

每个条件的检查都是独立的，所以即使某行不满足subject或condition，也要检查constraint是否满足。例如，对于非董监高的股东，是否减持都会被检查是否满足constraint（即不得减持），这可能不正确，但根据任务要求必须如此。

但根据MEU的约束内容，约束条件仅适用于满足subject和condition的情况。因此，正确的做法应该是，只有当subject和condition都满足时，才需要检查constraint。但根据用户的要求，对于不需要调用llm_content_check()的情况，三元组的检查是各自独立的。这可能存在矛盾，需要仔细确认用户的要求。

用户提到：“对于简单操作dataframe就可以处理的项目，对三元组<subject, conditon, constrain>的检查是各自独立的，你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查。” 因此，三个条件的检查是独立的，不管其他条件是否满足，都要分别标记每个条件的满足情况。例如，即使某行不满足subject，也要检查condition和constraint是否满足。这可能与实际法律应用不同，但任务要求如此。

因此，在代码中，三个条件的检查是独立的：

- subject：股东身份是否为董监高。
- condition：是否被行政处罚且未缴纳（根据必要信息，不考虑例外）。
- constraint：是否没有减持。

每个条件独立检查，并分别标记在对应的列中。

现在，具体到各个条件的处理：

1. subject检查：股东身份是否为“董监高”。
   df['meu_14_5_subject'] = (df['股东身份'] == '董监高')

2. condition检查：是否被中国证监会行政处罚，且罚没款未缴纳。根据数据中的“股东涉嫌证券期货违法犯罪事件”列，如果该列的值是“行政处罚决定作出”，则视为满足条件。因为必要信息指出不考虑例外情况，所以只要存在行政处罚决定，就认为满足condition。
   df['meu_14_5_condition'] = (df['股东涉嫌证券期货违法犯罪事件'] == '行政处罚决定作出')

3. constraint检查：是否没有减持。这里需要确定如何判断是否存在减持。根据数据列，可能的字段是“当日减持比例”是否大于0，或者“存在减持计划”是否为True。但约束是“不得减持”，所以实际减持行为才违反。因此，如果“当日减持比例”>0，或者“减持方式”不为空，则视为违反。例如，如果“当日减持比例”>0，则constraint为False（未遵守），否则为True（遵守）。

   因此，valid_constraint = (df['当日减持比例'] <= 0) 或者 (df['减持方式'].isna())，或者类似的判断。例如，如果当日减持比例大于0，则违反约束。或者，如果存在减持行为（如减持方式存在），则违反。需要根据数据中的字段来判断。

   根据数据列中的字段，可能使用“当日减持比例”来判断。如果该比例大于0，表示当日有减持，因此违反约束。因此：

   df['meu_14_5_constraint'] = (df['当日减持比例'] <= 0)

   但需要注意，如果减持比例为0或负数，视为没有减持。或者，可能该比例不可能为负数，所以只要等于0就视为没有减持。因此，valid_constraint的条件是当日减持比例等于0。

   或者，可能“存在减持计划”为True时，视为有计划减持，但尚未执行。此时，是否违反约束？根据法律条文，约束是不得减持，所以只有实际减持才违反。因此，应该根据实际减持行为来判断。因此，正确的判断应该是当日减持比例是否大于0。

   因此，constraint的检查是：当日减持比例是否等于0。如果是，则满足约束（True），否则不满足（False）。

   因此，valid_constraint = (df['当日减持比例'] == 0)

   但需要确认数据中的“当日减持比例”是否为当天的减持比例，如果是累计的，可能需要不同的处理。但根据字段描述，“当日减持比例”是当天的减持比例，所以正确的处理是检查该值是否为0。

   因此，代码中的constraint标记为：

   df['meu_14_5_constraint'] = (df['当日减持比例'] == 0)

   但根据问题描述中的要求，constraint的检查是独立进行的，所以不管subject和condition是否满足，都要标记是否满足constraint。例如，即使某行不是董监高，或者没有被处罚，只要当日没有减持，就标记constraint为True。这可能不符合法律的实际要求，但根据任务要求必须如此处理。

综上，代码的大致结构如下：

- 初始化三个列为False或None。
- 标记subject：股东身份是否为董监高。
- 标记condition：股东是否被行政处罚决定作出。
- 标记constraint：当日减持比例是否为0。
- 将结果填入对应的列中。

现在，将这些步骤转化为代码：

首先，复制数据框以避免修改原始数据。

然后，初始化三个新列：

df['meu_14_5_subject'] = False
df['meu_14_5_condition'] = False
df['meu_14_5_constraint'] = None  # 或者初始化为False，但根据示例可能初始化为None？

根据示例中的处理，初始化为False，然后根据条件设置为True。例如，在示例中，subject和condition初始化为False，然后符合条件的设置为True。而constraint初始化为None，然后根据条件设置为True或False。但示例中的代码可能将constraint初始化为None，然后填充True或False。例如：

在示例中：

df['meu_4_2_constrain'] = None  # constrain需要初始化为None

然后：

df.loc[valid_constraint, 'meu_4_1_constraint'] = True
df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

因此，正确的做法是，将constraint列初始化为None，然后根据条件填充True或False。而subject和condition列初始化为False，然后符合条件的设置为True。

因此，在代码中：

df['meu_14_5_subject'] = False
df['meu_14_5_condition'] = False
df['meu_14_5_constraint'] = None

然后，计算各条件：

valid_subject = df['股东身份'] == '董监高'
valid_condition = df['股东涉嫌证券期货违法犯罪事件'] == '行政处罚决定作出'
valid_constraint = df['当日减持比例'] == 0  # 或者是否等于0？

然后，将valid_subject和valid_condition标记到对应的列：

df.loc[valid_subject, 'meu_14_5_subject'] = True
df.loc[valid_condition, 'meu_14_5_condition'] = True

对于constraint，根据valid_constraint的值填充True或False：

df.loc[valid_constraint, 'meu_14_5_constraint'] = True
df.loc[~valid_constraint, 'meu_14_5_constraint'] = False

但需要注意，如果当日减持比例是NaN的情况如何处理？例如，如果某行没有减持，可能该列为0，或者NaN？需要根据数据情况处理。例如，假设没有减持的情况下，该列为0，则valid_constraint的条件正确。否则，可能需要填充NaN为0，或者根据实际情况处理。但根据问题描述中的字段说明，可能该列在无减持时为0，因此可以安全使用。

综上，最终的代码应该如下：

import pandas as pd

def check_meu_14_5(df):
    '''
    检查MEU_14_5的合规性：
    ""subject"": ""上市公司董监高"",
    ""condition"": ""本人因涉及证券期货违法，被中国证监会行政处罚，罚没款尚未足额缴纳，且不存在法律、行政法规另有规定或减持资金用于缴纳罚没款的情况"",
    ""constraint"": ""不得减持其所持有的本公司股份"",
    ""contextual_info"": NaN
    '''
    df = df.copy()

    # 初始化列
    df['meu_14_5_subject'] = False
    df['meu_14_5_condition'] = False
    df['meu_14_5_constraint'] = None

    # 检查subject：是否为董监高
    valid_subject = df['股东身份'] == '董监高'
    df.loc[valid_subject, 'meu_14_5_subject'] = True

    # 检查condition：是否被行政处罚且未缴纳罚没款（根据必要信息，不考虑例外）
    valid_condition = df['股东涉嫌证券期货违法犯罪事件'] == '行政处罚决定作出'
    df.loc[valid_condition, 'meu_14_5_condition'] = True

    # 检查constraint：是否未减持（当日减持比例为0）
    valid_constraint = df['当日减持比例'] == 0
    df.loc[valid_constraint, 'meu_14_5_constraint'] = True
    df.loc[~valid_constraint, 'meu_14_5_constraint'] = False

    return df

但需要确认condition的条件是否正确。根据MEU的condition，需要满足被行政处罚且罚没款未缴纳，但数据中可能没有直接记录罚没款是否缴纳的字段。根据必要额外信息，不考虑例外情况，即只要被行政处罚，就视为满足条件。因此，代码中的valid_condition是否正确？

例如，假设“股东涉嫌证券期货违法犯罪事件”列中的值为“行政处罚决定作出”时，表示已经被处罚，且罚没款未缴纳。因此，代码中的valid_condition是正确的。

此外，关于constraint的检查，是否应该考虑减持方式或其他字段？例如，如果减持方式不为空，或者存在减持计划，是否视为违反约束？根据法律条文，约束是“不得减持”，即实际减持行为。因此，正确的判断是当日是否有减持，即“当日减持比例”是否大于0。因此，valid_constraint应为当日减持比例等于0，即没有减持。

因此，代码中的处理是正确的。
","CompletionUsage(completion_tokens=4183, prompt_tokens=1740, total_tokens=5923, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=3792, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: 不考虑是否及时通知公司


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_4_1(df):
    '''
    检查MEU_4_1的合规性：
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    额外要求：不考虑是否及时通知公司
    '''

    df = df.copy()

    # 初始化标记列
    df['meu_4_1_subject'] = False
    df['meu_4_1_condition'] = False
    df['meu_4_1_constraint'] = False

    # 1. 标记valid的subject（上市公司大股东 | 董监高）
    # 大股东判断：控股股东/实际控制人/持股5%以上股东 或 持股比例>=5%
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    # 董监高判断：股东身份为董监高（不含离任）
    is_director = (df['股东身份'] == '董监高')
    valid_subject = is_major_shareholder | is_director

    # 2. 标记valid的condition（存在减持计划且减持方式为竞价/大宗）
    valid_condition = (
        df['存在减持计划'] & 
        df['减持方式'].isin(['竞价交易', '大宗交易'])
    )

    # 3. 标记valid的constraint（披露日早于开始日至少15自然日）
    # 计算自然日差（假设日期列已对齐交易日）
    days_diff = (df['计划开始日'] - df['计划披露日']).dt.days
    # 约束条件：存在减持计划且时间差>=15天
    valid_constraint = (
        df['存在减持计划'] & 
        (days_diff >= 15)
    )

    # 更新标记列
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True

    return df
</CODE>","好的，我现在需要编写一个函数来检查MEU_4_1的合规性。首先，我得仔细理解这个MEU的内容。MEU_4_1的责任主体是上市公司大股东或董监高，触发条件是计划通过集中竞价或大宗交易减持股份，约束条件是在首次卖出的15个交易日前披露减持计划。但根据用户提供的额外信息，这里不考虑是否及时通知公司，所以只需要关注披露时间的要求。

接下来，我需要确定如何标记subject、condition和constraint这三个部分。根据示例，每个部分都要独立检查，即使其他部分不满足，也要分别标记。不过，对于constraint的检查，可能需要结合其他条件，但根据任务说明，这里不需要依赖subject和condition是否满足，而是各自独立检查。不过，用户提到对于需要调用LLM的情况才只检查同时满足的情况，而这里不需要，所以constraint的检查也是独立的？

不过，可能我理解错了。根据任务中的更多要求，对于简单操作dataframe的情况，三元组的检查是各自独立的，分别标记。所以即使subject不满足，只要constraint的条件满足，也要标记为True。这可能与实际法律逻辑不符，但根据任务要求，必须这样做。

那现在分步骤处理：

1. 标记subject是否有效。主体是上市公司大股东或董监高。根据数据中的股东身份列，大股东可能包括控股股东、实际控制人、持股5%以上股东。但用户提供的股东身份列有这些选项，但可能有些股东虽然持股超过5%但未被标记为持股5%以上股东，所以需要结合持股比例来判断。例如，如果股东身份是董监高或离任董监高，或者他们的持股比例>=5%，是否属于大股东？

根据MEU的subject是“上市公司大股东 | 董监高”，所以董监高不管持股比例如何都属于subject。而大股东包括控股股东、实际控制人、持股5%以上股东，或者即使股东身份不是这些，但持股比例>=5%的股东。例如，如果股东身份是普通股东，但持股比例>=5%，是否算作大股东？

根据附加信息中的说明，股东身份列中的标签不会并列出现，所以如果一个董监高的持股比例超过5%，其股东身份可能只是“董监高”，而不是“持股5%以上股东”。因此，判断subject时，需要同时检查股东身份是否为控股股东、实际控制人、持股5%以上股东，或者董监高（包括离任董监高？），或者持股比例>=5%的股东？

根据MEU的subject描述，“上市公司大股东”可能指的是控股股东、实际控制人、或者持股5%以上的股东。而董监高则单独作为另一类主体。因此，判断subject的条件应该是：

股东身份属于['控股股东', '实际控制人', '持股5%以上股东']，或者股东身份是董监高（包括离任董监高？），或者持股比例>=5%？

或者，根据附加信息中的说明，股东身份列中的“董监高”和“离任董监高”是独立的标签。例如，离任董监高是否属于董监高？根据法律条文，可能离任后一定期限内仍受约束，但MEU中的subject是否包括离任董监高？

根据MEU的subject是“董监高”，可能不包括离任的，但需要看具体法律条文。但用户提供的MEU内容中的subject是“上市公司大股东 | 董监高”，所以可能离任董监高是否属于董监高？例如，如果股东身份是“离任董监高”，是否属于subject？

这个问题可能需要根据法律条文来判断，但用户没有给出更多信息。假设这里的董监高包括在任的，而离任的不算。因此，在判断subject时，股东身份是“董监高”或者属于大股东类别（控股股东、实际控制人、持股5%以上股东），或者持股比例>=5%？

或者，根据附加信息中的说明，股东身份列中的“董监高”和“离任董监高”是不同的标签。例如，离任董监高可能不属于董监高，所以subject中的董监高仅指在任的。因此，判断subject的条件是：

（股东身份属于['控股股东', '实际控制人', '持股5%以上股东']）或者（股东身份是'董监高'）或者（持股比例 >= 0.05）？

或者，是否大股东的判断除了股东身份外，还要看持股比例？例如，如果股东身份是普通股东，但持股比例>=5%，是否算作大股东？

根据MEU的subject是“上市公司大股东”，这可能包括任何持股5%以上的股东，无论其身份如何。因此，判断subject的条件应为：

（股东身份属于['控股股东', '实际控制人', '持股5%以上股东']）或者（持股比例 >= 0.05）或者（股东身份是'董监高'）？

或者，可能大股东的定义是控股股东、实际控制人、或者持股5%以上的股东，而董监高是另一类主体。所以，subject的条件是：

（股东身份属于['控股股东', '实际控制人', '持股5%以上股东']）或者（股东身份是'董监高'）或者（持股比例 >= 0.05）？

或者，可能大股东的判断需要结合股东身份和持股比例。例如，如果股东身份是普通股东，但持股比例>=5%，是否属于大股东？

根据附加信息中的说明，股东身份列中的标签不会并列出现，所以可能存在股东身份为普通股东但持股比例>=5%的情况。此时，他们是否属于大股东？

根据法律条文中的“上市公司大股东”，通常指持有公司股份达到一定比例（如5%）的股东，无论其身份如何。因此，判断subject的条件应包括：

股东身份属于['控股股东', '实际控制人', '持股5%以上股东']，或者股东身份是'董监高'，或者持股比例 >= 0.05？

或者，可能大股东的定义是控股股东、实际控制人、或者持股5%以上的股东，而董监高是另一类主体。因此，subject的条件是：

（股东身份属于['控股股东', '实际控制人', '持股5%以上股东']）或者（股东身份是'董监高'）或者（持股比例 >= 0.05）？

或者，可能大股东的判断仅基于股东身份列中的标签，而持股比例>=5%的普通股东不被视为大股东？这可能需要更明确的法律定义，但根据用户提供的信息，可能需要结合股东身份和持股比例。

例如，在示例代码中，判断subject的条件是：

is_major_shareholder = (股东身份属于['控股股东', '实际控制人', '持股5%以上股东']) | (持股比例 >= 0.05)

is_director = 股东身份是'董监高'

valid_subject = is_major_shareholder | is_director

这可能就是正确的做法。因此，在MEU_4_1的subject判断中，需要将股东身份为大股东类别或持股比例>=5%，或者股东身份是董监高的标记为有效。

所以，代码中的subject部分应该这样处理：

valid_subject = (df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东'])) | (df['持股比例'] >= 0.05) | (df['股东身份'] == '董监高')

但需要注意，股东身份中的'董监高'是否包括离任的？根据MEU中的描述，可能董监高仅指在任的，所以离任的不算。因此，股东身份等于'董监高'的才属于subject。

接下来是condition的判断。触发条件是“计划通过本所集中竞价或大宗交易减持股份”。在数据中，减持方式列有['竞价交易', '大宗交易', '融券卖出']。根据条件，减持方式如果是竞价交易或大宗交易，则满足条件。因此，valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])。但还需要检查是否存在减持计划，即'存在减持计划'为True？

或者，condition中的“计划”是否对应数据中的'存在减持计划'列？例如，只有当存在减持计划，并且减持方式是竞价或大宗交易时，才满足条件？

根据MEU的condition描述，“计划通过本所集中竞价或大宗交易减持股份”可能意味着该股东有计划进行这样的减持。因此，在数据中，当某行的'存在减持计划'为True，并且减持方式是这两种之一时，condition才满足？

或者，减持方式列可能表示该股东在该交易日实际使用的减持方式，而计划中的减持方式可能在其他列中？

这可能存在歧义。例如，假设'减持方式'列是计划中的减持方式，还是实际的减持方式？

根据数据列中的描述，'减持方式'可能是指该股东在该交易日的减持方式，但如果是计划减持，可能该列的值是计划中的方式。或者，可能'存在减持计划'为True时，'减持方式'列表示计划中的减持方式？

这需要明确数据列的含义。根据用户提供的列说明：

- '减持方式'：交易方式，可能包括计划中的方式？

或者，可能当'存在减持计划'为True时，该行的减持方式列表示计划中的减持方式。例如，当股东有减持计划时，减持方式列填写的是计划采用的方式，如竞价交易或大宗交易。因此，condition的判断需要同时满足存在减持计划，并且减持方式属于这两种之一。

因此，valid_condition的条件应该是：

(df['存在减持计划'] == True) & (df['减持方式'].isin(['竞价交易', '大宗交易']))

但根据示例中的处理方式，示例中的condition检查仅检查了减持方式，而没有检查是否存在减持计划。例如，示例中的valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])，这可能意味着示例中的condition仅检查减持方式，而不管是否存在计划。这可能与MEU中的条件描述不符，因为MEU中的condition是“计划通过...减持股份”，所以必须存在计划。

但根据用户提供的MEU内容中的condition是“计划通过本所集中竞价或大宗交易减持股份”，所以只有当股东有计划减持，并且减持方式是这两种方式之一时，才满足条件。因此，正确的condition判断应该是：

存在减持计划为True，并且减持方式属于这两种之一。

因此，在代码中，valid_condition的条件应为：

(df['存在减持计划'] == True) & (df['减持方式'].isin(['竞价交易', '大宗交易']))

但示例中的处理方式可能没有考虑存在减持计划，这可能是因为示例中的MEU的condition可能不同。例如，示例中的condition是“计划通过本所集中竞价或大宗交易减持股份”，所以需要存在计划，并且减持方式正确。因此，正确的condition判断应该同时满足这两个条件。

现在回到当前任务，MEU_4_1的condition是“计划通过本所集中竞价或大宗交易减持股份”，所以需要同时满足存在减持计划，并且减持方式是这两种方式之一。因此，valid_condition的条件应为：

(df['存在减持计划']) & (df['减持方式'].isin(['竞价交易', '大宗交易']))

接下来是constraint的检查。约束条件是“在首次卖出的15个交易日前向本所报告并预先披露减持计划”。根据用户提供的额外信息，不考虑是否及时通知公司，所以只需要检查是否在首次卖出的15个交易日前披露了计划。

这里需要确定如何计算这个时间差。假设每个股东的计划披露日是'计划披露日'列，而首次卖出的日期是该股东在减持计划中的首次卖出日期。或者，首次卖出日期可能是指该股东在计划开始后的首次减持日期？

或者，可能每个减持计划有一个计划开始日和结束日，而首次卖出日可能是在计划开始日之后。例如，计划开始日是开始减持的日期，而首次卖出日是该股东在计划开始后第一次减持的日期。但数据中是否有这样的列？

根据用户提供的数据列，有'计划开始日'和'计划结束日'，以及'计划披露日'。因此，约束条件要求计划披露日必须在首次卖出日的至少15个交易日前。

但如何确定首次卖出日？假设首次卖出日是该股东在计划开始日之后实际进行减持的第一个交易日。但数据中的每一行代表一个交易日的情况，所以可能需要针对每个股东和公司，找到其计划开始日后的第一个减持日期，然后计算该日期与计划披露日之间的交易日差是否>=15。

或者，可能这里的首次卖出日指的是计划开始日？例如，计划开始日是该股东计划开始减持的日期，而披露必须在计划开始日的15个交易日前。

或者，根据约束条件的描述，“在首次卖出的15个交易日前”披露，所以首次卖出的日期是实际减持的日期，而披露日必须在该日期前至少15个交易日。

但数据中可能没有实际减持的日期，只有计划的信息。因此，可能需要假设首次卖出日是计划开始日，或者需要根据计划开始日来计算。

例如，在示例代码中，计算了'计划开始日'和'计划披露日'之间的交易日差，并检查是否>=15。这可能假设首次卖出日是计划开始日，因此披露日必须在计划开始日前至少15个交易日。

因此，在当前任务中，约束条件的检查应为：计划披露日到计划开始日之间的交易日差是否>=15天？

或者，是否应该计算计划披露日到首次实际减持的日期之间的交易日差？但数据中可能没有实际减持的日期，只有计划的信息。因此，可能只能根据计划开始日来判断。

例如，假设计划开始日是股东计划开始减持的日期，那么披露日必须在该日期前至少15个交易日。因此，交易日差为（计划开始日 - 计划披露日）的交易日数 >=15。

但如何计算两个日期之间的交易日差？根据用户说明，所有日期相关的列已经是pd.datetime格式，并且'日期'列是交易日。但计算两个日期之间的交易日数可能需要参考交易日历，但用户说明中提到，'日期'列本身就是交易日，所以可能可以直接计算日期差，但需要确保这些日期都是交易日。

例如，如果计划披露日是2023-01-01（假设是交易日），计划开始日是2023-01-20，那么两者之间的自然日差是19天，但交易日差可能更少。但根据用户说明，所有日期相关的列已经是交易日，所以可以直接用日期差计算交易日数。

例如，在示例代码中，使用了：

df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days

然后检查是否>=15。这可能假设两个日期之间的自然日差即为交易日差，这可能不正确。但根据用户说明，所有日期列已经是交易日，所以计划开始日和计划披露日都是交易日，因此它们之间的自然日差等于交易日差吗？例如，如果计划披露日是周一，计划开始日是下下周一，那么中间可能有10个自然日，但交易日差是5天（假设中间没有节假日）。但用户说明中提到，所有日期列已经是交易日，所以两个日期之间的自然日差可能不等于交易日差，但用户可能希望我们直接使用自然日差，或者假设这些日期已经是连续的交易日？

这可能是一个问题。例如，如果计划披露日和计划开始日之间有非交易日（如周末或节假日），那么自然日差可能大于实际的交易日差。但根据用户提供的说明，所有日期相关的列已经是pd.datetime格式，并且'日期'列本身就是交易日，但其他日期列（如计划披露日、计划开始日）是否也保证是交易日？

根据用户提供的附加信息中的说明：“所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算.” 这可能意味着其他日期列（如计划披露日、计划开始日）可能不是交易日，但用户希望我们以自然日计算。或者，可能这些日期列已经被处理为交易日？

这可能需要进一步澄清，但根据示例中的处理方式，直接计算自然日差。例如，示例中的代码：

df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days

这可能意味着用户希望我们以自然日差来计算交易日差，这可能不正确，但根据示例，可能需要这样做。或者，可能用户希望我们假设计划开始日和计划披露日都是交易日，因此自然日差等于交易日差。例如，如果计划披露日是某个交易日，计划开始日是该日之后的第15个交易日，那么自然日差可能超过15天，但根据示例的处理方式，直接使用自然日差。

这可能是一个错误，但根据示例，用户可能希望我们直接使用自然日差。因此，在当前任务中，约束条件的检查应为：

（计划开始日 - 计划披露日）的自然日差 >=15天？

或者，是否应该计算两个日期之间的交易日数？例如，使用一个交易日历，但用户没有提供这样的数据。因此，可能无法准确计算交易日差，只能使用自然日差，但示例中的处理方式是这样。

因此，在代码中，计算交易日差为（计划开始日 - 计划披露日）.dt.days，并检查是否>=15。

但根据用户提供的额外信息，约束条件中的“15个交易日前”，所以必须满足计划披露日早于计划开始日至少15个交易日。因此，正确的处理方式应该是计算两个日期之间的交易日数，但如果没有交易日历，可能无法准确计算。因此，用户可能希望我们假设所有日期都是连续的交易日，因此自然日差等于交易日差。或者，可能用户希望我们直接使用自然日差，即使这可能不准确，但根据示例中的处理方式，这可能就是要求。

因此，在代码中，计算交易日差为（计划开始日 - 计划披露日）.dt.days，并检查是否>=15。

此外，约束条件是否仅在存在减持计划的情况下才需要检查？或者，不管是否存在减持计划，只要满足条件，就检查约束？

根据任务中的说明，对于简单操作，三元组的检查是各自独立的。因此，即使subject或condition不满足，只要constraint的条件满足，就标记为True。例如，即使某行中的股东不是大股东或董监高，只要该行的计划披露日与计划开始日之间的差>=15天，就标记constraint为True？

这可能不符合法律逻辑，但根据任务要求，必须独立检查。因此，constraint的检查是独立的，不管subject和condition是否满足。

但根据MEU的约束条件，只有当subject和condition都满足时，才需要满足constraint。但根据任务中的说明，对于不需要调用LLM的情况，三元组的检查是各自独立的。因此，在代码中，必须独立检查每个部分，不管其他部分是否满足。

因此，在代码中，constraint的检查是：对于每一行，只要计划披露日与计划开始日之间的自然日差>=15天，就标记为True，否则False。或者，是否还需要其他条件？

例如，约束条件中的“应当...预先披露减持计划”，所以只有当存在减持计划时，才需要满足该约束。因此，在检查constraint时，是否需要同时满足存在减持计划？

这可能更符合逻辑，但根据任务中的说明，对于简单操作，三元组的检查是独立的。因此，即使不存在减持计划，只要该行的计划披露日与计划开始日之间的差>=15天，就标记为True？

或者，可能约束条件仅适用于存在减持计划的情况。例如，只有当存在减持计划时，才需要检查是否提前披露。因此，在代码中，constraint的检查应为：

（存在减持计划）且（计划披露日与计划开始日的差>=15天）

但根据任务中的说明，三元组的检查是独立的，所以即使不存在减持计划，只要计划披露日与计划开始日的差>=15天，就标记为True？

这似乎不符合实际，但根据任务要求，必须这样做。例如，在示例中，valid_constraint的条件是：

has_plan = df['存在减持计划']

valid_constraint = df['交易日差'] >=15 & has_plan

但示例中的代码可能结合了存在减持计划的条件。例如，在示例中，valid_constraint是交易日差>=15并且存在减持计划。这可能意味着，只有当存在减持计划时，才检查约束条件。因此，这可能与任务中的说明矛盾，因为任务中的说明指出，对于简单操作，三元组的检查是各自独立的。但示例中的处理方式可能结合了条件。

这可能意味着，在示例中，constraint的检查是仅当存在减持计划时，才检查是否满足。因此，可能在实际中，约束条件的检查需要结合其他条件，但根据任务中的说明，这可能属于需要调用LLM的情况？

或者，可能示例中的处理方式是正确的，因为约束条件仅适用于存在减持计划的情况。例如，只有当存在减持计划时，才需要满足约束条件。因此，在代码中，constraint的检查需要结合存在减持计划的条件。

这可能更符合法律逻辑，但根据任务中的说明，对于不需要调用LLM的情况，三元组的检查是各自独立的。因此，可能存在矛盾。

现在需要仔细阅读任务中的更多要求：

“对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)”

因此，在当前任务中，constraint的检查是独立的，不需要考虑subject和condition是否满足。因此，即使某行中的股东不是大股东或董监高，或者没有减持计划，只要该行的计划披露日与计划开始日的差>=15天，就标记constraint为True？

这显然不符合法律逻辑，但根据任务要求，必须这样做。例如，在示例中，valid_constraint的条件是：

valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

这可能意味着，只有当存在减持计划时，才检查约束条件。但根据任务中的说明，这应该属于需要调用LLM的情况，但示例中的处理方式可能不符合任务要求。或者，可能示例中的处理方式是正确的，因为约束条件仅适用于存在减持计划的情况，因此，在检查constraint时，必须结合存在减持计划的条件？

这可能需要进一步理解任务中的说明。任务中的说明指出，对于简单操作，三元组的检查是各自独立的。例如，subject的检查仅看是否是主体，condition的检查仅看是否满足条件，constraint的检查仅看是否满足约束，不管其他条件。因此，即使没有减持计划，只要计划披露日与计划开始日的差>=15天，就标记constraint为True？

这可能不符合实际，但根据任务要求，必须这样做。例如，在示例中，可能示例中的处理方式错误，或者任务中的说明存在矛盾？

在这种情况下，可能需要根据示例中的处理方式来进行。例如，在示例中，constraint的检查结合了存在减持计划的条件。这可能意味着，在示例中，constraint的检查是仅当存在减持计划时，才检查是否满足。因此，这可能与任务中的说明矛盾，但示例可能是一个例外？

或者，可能约束条件的检查需要结合存在减持计划的条件，因为约束条件本身是“应当...预先披露减持计划”，所以只有当存在减持计划时，才需要满足该约束。因此，在检查constraint时，必须检查存在减持计划，并且披露时间符合要求。

这可能更符合逻辑，因此，在代码中，constraint的检查应为：

valid_constraint = (df['计划披露日'] <= df['计划开始日'] - pd.Timedelta(days=15*1))  # 假设自然日差，但需要计算交易日差？

或者，计算自然日差是否>=15天？

或者，计算计划披露日到计划开始日之间的自然日差是否>=15天？

例如，在示例中，代码计算了交易日差，并检查是否>=15，同时结合存在减持计划的条件。这可能意味着，在示例中，只有当存在减持计划时，才检查约束条件，并且交易日差>=15。

因此，在当前任务中，constraint的检查需要满足两个条件：存在减持计划，并且计划披露日早于计划开始日至少15个交易日。

因此，在代码中，valid_constraint的条件是：

(df['存在减持计划']) & ((df['计划开始日'] - df['计划披露日']).dt.days >= 15)

但根据用户提供的额外信息，不考虑是否及时通知公司，所以只需要检查披露时间是否满足。

因此，在代码中，constraint的检查应为：

对于每一行，如果存在减持计划，并且计划披露日早于计划开始日至少15个交易日，则标记为True，否则False。但根据任务中的说明，三元组的检查是独立的，所以即使不存在减持计划，只要计划披露日与计划开始日的差>=15天，就标记为True？

这显然不符合逻辑，但根据任务中的说明，必须独立检查。因此，在代码中，constraint的检查应仅看计划披露日与计划开始日的差是否>=15天，不管是否存在减持计划？

或者，可能约束条件仅适用于存在减持计划的情况，因此，在检查constraint时，必须同时满足存在减持计划和披露时间条件？

这需要根据法律条文来判断。例如，约束条件中的“应当...预先披露减持计划”显然只有在存在减持计划的情况下才适用。因此，在代码中，必须同时检查存在减持计划和披露时间条件。

因此，在代码中，constraint的检查应为：

valid_constraint = (df['存在减持计划']) & ((df['计划开始日'] - df['计划披露日']).dt.days >= 15)

但根据任务中的说明，三元组的检查是独立的，所以这可能属于需要调用LLM的情况，但用户指出当前任务不需要调用LLM，因此，必须独立检查。

这似乎存在矛盾。因此，可能需要重新理解任务中的说明。任务中的说明指出，对于不需要调用LLM的情况，三元组的检查是各自独立的。因此，即使没有减持计划，只要计划披露日与计划开始日的差>=15天，就标记constraint为True？

这显然不符合实际，但根据任务要求，必须这样做。例如，在示例中，可能示例中的处理方式错误，或者任务中的说明存在例外？

在这种情况下，可能需要按照法律逻辑来处理，即约束条件的检查仅适用于存在减持计划的情况。因此，在代码中，constraint的检查需要结合存在减持计划的条件，而不管任务中的说明如何。但这样可能违反任务中的要求。

或者，可能任务中的说明中的“独立检查”指的是每个条件的判断逻辑是独立的，但约束条件本身的逻辑可能包含多个条件。例如，约束条件的检查可能包括多个条件，如存在减持计划，并且时间差足够。因此，在代码中，valid_constraint的条件是这两个条件的逻辑与，但这是约束条件本身的逻辑，而不是依赖于subject或condition的条件。

因此，这可能属于约束条件本身的逻辑，而不是依赖于其他两个条件。因此，在代码中，constraint的检查是独立的，即检查是否存在减持计划，并且时间差足够，而不管subject和condition是否满足。这可能符合任务中的说明，因为约束条件的检查是独立的，不依赖于subject和condition的条件，但约束条件本身的逻辑可能包含多个条件。

因此，在代码中，constraint的检查应为：

valid_constraint = (df['存在减持计划']) & ((df['计划开始日'] - df['计划披露日']).dt.days >= 15)

这属于约束条件本身的逻辑，而不是依赖于subject或condition的条件。因此，这符合任务中的说明，即三元组的检查是各自独立的。

总结：

- subject的检查：股东身份是大股东类别或董监高，或者持股比例>=5%。
- condition的检查：存在减持计划，并且减持方式是竞价交易或大宗交易。
- constraint的检查：存在减持计划，并且计划披露日早于计划开始日至少15个自然日（假设自然日差等于交易日差）。

现在将这些条件转化为代码。

首先，初始化三个新列：

df['meu_4_1_subject'] = False
df['meu_4_1_condition'] = False
df['meu_4_1_constraint'] = None  # 初始化为None，之后填充True或False

然后，计算各条件：

valid_subject的条件：

is_major_shareholder = (df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东'])) | (df['持股比例'] >= 0.05)
is_director = df['股东身份'] == '董监高'
valid_subject = is_major_shareholder | is_director

valid_condition的条件：

valid_condition = (df['存在减持计划']) & (df['减持方式'].isin(['竞价交易', '大宗交易']))

valid_constraint的条件：

# 计算计划披露日与计划开始日之间的自然日差
days_diff = (df['计划开始日'] - df['计划披露日']).dt.days
valid_constraint = (df['存在减持计划']) & (days_diff >= 15)

但根据用户提供的额外信息，不考虑是否及时通知公司，所以不需要检查是否通知公司，但约束条件中的其他部分需要检查。因此，valid_constraint的条件是存在减持计划，并且计划披露日早于计划开始日至少15天。

现在将这些条件应用到dataframe中：

df.loc[valid_subject, 'meu_4_1_subject'] = True
df.loc[valid_condition, 'meu_4_1_condition'] = True
df.loc[valid_constraint, 'meu_4_1_constraint'] = True
df.loc[~valid_constraint, 'meu_4_1_constraint'] = False  # 将剩余的行设为False

但需要注意，在初始化时，constraint列被设为None，之后用valid_constraint的条件来填充True或False。或者，可以直接初始化为False，然后符合条件的设为True？

例如：

df['meu_4_1_constraint'] = False
df.loc[valid_constraint, 'meu_4_1_constraint'] = True

这可能更高效。

现在，将这些步骤整合到函数中。

另外，需要注意，计划开始日和计划披露日可能存在缺失值。例如，如果某行不存在减持计划，那么这两个日期可能为NaN。因此，在计算days_diff时，需要处理NaN的情况。例如，当存在减持计划为False时，valid_constraint的条件自动为False，因此即使日期为NaN，也不会影响结果。但如果存在减持计划为True，但计划开始日或计划披露日为NaN，则days_diff可能为NaN，导致valid_constraint为False。

这可能符合逻辑，因为如果存在减持计划，但缺少计划开始日或披露日，则无法满足约束条件。

综上，最终的代码可能如下：
","CompletionUsage(completion_tokens=7141, prompt_tokens=1725, total_tokens=8866, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=6583, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_11_2
法律的最小可执行单元内容: {""subject"": ""上市公司控股股东 | 实际控制人"", ""condition"": ""上市公司因涉嫌证券期货违法犯罪被中国证监会及其派出机构立案调查或者被司法机关立案侦查，在行政处罚决定、刑事判决作出之后未满6个月的"", ""constraint"": ""不得减持其所持有的本公司股份"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_11_2(df):
    '''
    验证MEU_11_2合规性：
    subject: 上市公司控股股东 | 实际控制人
    condition: 公司被立案调查/侦查且处于处罚后6个月内
    constraint: 不得减持股份
    '''
    df = df.copy()

    # 初始化合规标记列
    df['meu_11_2_subject'] = False
    df['meu_11_2_condition'] = False
    df['meu_11_2_constraint'] = None

    # 1. 验证责任主体
    valid_subject = df['股东身份'].isin(['控股股东', '实际控制人'])
    df.loc[valid_subject, 'meu_11_2_subject'] = True

    # 2. 验证触发条件
    # 获取公司最近处罚日期
    penalty_mask = df['公司涉嫌证券期货违法犯罪事件'].isin(['行政处罚决定作出', '刑事判决作出'])
    latest_penalty = df[penalty_mask].groupby('公司简称')['日期'].max().reset_index()
    latest_penalty.columns = ['公司简称', 'latest_penalty_date']
    
    # 合并处罚日期并计算时间差
    df = df.merge(latest_penalty, on='公司简称', how='left')
    df['penalty_days'] = (df['日期'] - df['latest_penalty_date']).dt.days
    valid_condition = (df['penalty_days'] >= 0) & (df['penalty_days'] <= 180)
    df.loc[valid_condition, 'meu_11_2_condition'] = True

    # 3. 验证约束条件（独立检查）
    df['meu_11_2_constraint'] = df['当日减持比例'] == 0
    df['meu_11_2_constraint'] = df['meu_11_2_constraint'].astype(bool)

    # 清理中间列
    df.drop(['latest_penalty_date', 'penalty_days'], axis=1, inplace=True)

    return df
</CODE>","好的，我现在需要处理这个法律合规性的问题，具体是关于MEU_11_2的检查。首先，我得仔细理解这个MEU的内容。根据提供的资料，MEU_11_2的条件是当上市公司因为涉嫌证券期货违法犯罪被立案调查或侦查，并且在行政处罚决定或刑事判决作出后的六个月内，控股股东或实际控制人不得减持股份。

首先，我需要确定如何将这个法律要求转化为代码中的条件检查。根据任务要求，我需要分别检查subject、condition和constraint，并为每个部分标记True或False。

首先是subject部分。根据MEU_11_2，责任主体是“上市公司控股股东”或“实际控制人”。在数据框中，对应的列是“股东身份”，可能的取值包括['控股股东', '实际控制人']。因此，我需要检查每一行的股东身份是否是这两个中的一个。这一步应该比较简单，直接通过isin方法就可以筛选出来。

接下来是condition部分。条件是上市公司被立案调查或侦查，且在行政处罚或刑事判决后的六个月内。这里的数据列是“公司涉嫌证券期货违法犯罪事件”，可能的取值包括被立案调查、立案结束、行政处罚决定作出等。我需要确定哪些事件属于触发条件。根据MEU的描述，触发条件是“被立案调查或者被侦查”，并且在行政处罚或刑事判决后的六个月内。因此，condition需要满足两个时间点：行政处罚或刑事判决的日期，并且当前日期在该日期之后的六个月内。

这里可能需要处理时间序列的数据。例如，对于每个公司，需要找到行政处罚决定或刑事判决作出的日期，然后检查当前行的日期是否在该日期之后的六个月内。同时，必须确保公司确实存在这样的处罚或判决。因此，可能需要按公司和股东分组，记录每个公司的处罚日期，然后计算时间差。

然后是constraint部分，即不得减持股份。这需要检查在该行对应的日期，股东是否有减持行为。例如，是否有减持比例大于0，或者是否存在减持计划。但根据数据框中的列，可能有“当日减持比例”或“累计减持比例”等字段。如果当日减持比例大于0，则违反约束。或者，如果存在减持计划，也可能需要检查。但需要明确数据中的哪些列可以反映减持行为。

现在，我需要考虑数据框中的可用列。根据提供的列，有“当日减持比例”和“存在减持计划”等。可能，当日的减持比例大于0表示当天有减持行为。因此，constraint的条件是当日减持比例等于0，或者不存在减持行为。但根据MEU的约束，是“不得减持”，所以任何减持行为都是违规的。因此，如果当日减持比例>0，则constraint为False，否则为True。

不过，这里需要注意的是，constraint的检查是否独立于subject和condition。根据任务要求，对于简单操作，三元组的检查是各自独立的，需要分别标记。也就是说，即使subject或condition不满足，也要检查constraint是否符合。但根据MEU的约束，只有当subject和condition都满足时，constraint才需要被检查。不过，根据用户的要求，这里的情况是否需要独立检查？

根据用户给出的更多要求中的说明：“对于简单操作dataframe就可以处理的项目，对三元组<subject, condition, constrain>的检查是各自独立的，你需要分别标记三元组的True和False。并不是只对符合subject和condition进行检查。” 所以，这里的三个条件需要分别独立检查，不管其他条件是否满足，都要标记各自的valid情况。例如，即使subject不满足，只要condition满足，condition的标记为True。同样，constraint的检查也是独立进行的，不管subject和condition是否满足，只要该行的constraint条件满足，就标记为True。

但MEU_11_2的约束是当subject和condition都满足时，才需要遵守constraint。但根据用户的要求，这里的情况属于简单操作，所以需要独立检查。这可能存在矛盾，需要仔细理解任务要求。

但根据用户给出的例子，比如在MEU_4_1的例子中，constraint的检查是独立进行的，例如检查是否存在减持计划以及交易日差是否足够。因此，在MEU_11_2的情况下，constraint的检查可能也是独立于subject和condition的。例如，不管股东是否是控股股东，或者公司是否处于被处罚后的六个月内，只要该行存在减持行为，就标记constraint是否符合。但根据法律条文，只有当subject和condition都满足时，constraint才适用。但根据用户的要求，这里需要将三个条件独立检查，所以可能constraint的检查是独立进行的，不管其他条件是否满足。这可能与实际法律条文不符，但根据任务要求，必须按照用户的指示来处理。

不过，这可能是一个误解。需要再次仔细阅读用户的要求：

“注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)”

因此，在当前的MEU_11_2的情况下，属于简单操作，所以三个条件需要独立检查。也就是说，不管subject和condition是否满足，都要检查constraint是否符合。例如，即使股东不是控股股东，或者公司没有被处罚，只要该行存在减持行为，constraint的标记可能为False？或者，这里的constraint的检查是否应该根据法律条文中的条件？

这显然有问题，因为法律中的约束条件（不得减持）只有在subject和condition都满足的情况下才适用。但根据用户的要求，这里需要将三个条件独立检查，这可能与实际法律逻辑不符。但用户可能希望按照示例中的方式处理，即每个条件独立标记。

这可能是一个矛盾，但根据用户给出的示例，例如在MEU_4_1的例子中，constraint的检查是独立进行的，例如检查是否存在减持计划和交易日差，而不管subject和condition是否满足。例如，在示例中，即使股东不是大股东或董监高，只要存在减持计划且交易日差足够，就标记constraint为True。这可能与实际法律要求不符，但根据用户的要求，必须这样处理。

因此，在当前的MEU_11_2的情况下，需要将三个条件独立检查，分别标记。

现在，我需要具体分析每个条件的判断方法：

1. Subject检查：股东身份是否是控股股东或实际控制人。数据列是“股东身份”，可能的取值为['控股股东', '实际控制人']。因此，valid_subject = df['股东身份'].isin(['控股股东', '实际控制人'])。

2. Condition检查：公司因涉嫌证券期货违法犯罪被立案调查或侦查，且在行政处罚决定或刑事判决作出后的六个月内。这里需要确定公司是否在处罚后的六个月内。数据列是“公司涉嫌证券期货违法犯罪事件”，可能的取值包括“行政处罚决定作出”等。因此，需要找到公司最近一次行政处罚或刑事判决的日期，并检查当前行的日期是否在该日期的六个月内。

但如何确定每个公司的行政处罚日期呢？可能需要按公司分组，找到每个公司最近一次“行政处罚决定作出”或“刑事判决作出”的日期，然后计算当前日期与该日期的差值是否在180天内。

例如，对于每个公司，找到所有事件为“行政处罚决定作出”或“被司法机关立案侦查”的日期？或者，可能事件类型需要是行政处罚决定作出或者刑事判决作出的日期？

根据MEU的条件，condition是“上市公司因涉嫌...被中国证监会及其派出机构立案调查或者被司法机关立案侦查，在行政处罚决定、刑事判决作出之后未满6个月的”。也就是说，当行政处罚决定或刑事判决作出之后，且当前日期在该日期之后的六个月内，condition成立。

因此，condition的触发条件是：存在行政处罚决定或刑事判决作出的记录，并且当前日期在该记录的日期之后的六个月内。

因此，需要为每个公司记录这两个事件的日期，然后检查当前行的日期是否在任何一个日期之后的六个月内。

但数据框中的“公司涉嫌证券期货违法犯罪事件”列可能包含多个事件，比如“行政处罚决定作出”等。因此，需要确定哪些行的事件属于行政处罚决定或刑事判决作出。

例如，当“公司涉嫌证券期货违法犯罪事件”列的值是“行政处罚决定作出”或者“被司法机关立案侦查”吗？或者，是否应该区分立案调查和处罚决定？

根据MEU的条件，condition的触发是当公司被立案调查或侦查，并且在处罚决定或刑事判决作出后的六个月内。因此，condition的条件是处罚决定或判决作出后的六个月。

所以，condition的触发需要两个条件：公司存在处罚决定或判决，并且当前日期在该日期后的六个月内。

因此，需要找到每个公司最近一次处罚决定或判决的日期，然后检查当前日期是否在该日期后的六个月内。

因此，处理步骤可能如下：

- 对于每个公司，筛选出所有事件为“行政处罚决定作出”或“刑事判决作出”的行，并记录这些事件的日期。
- 对于每个公司，找到最大的日期（即最近的处罚日期）。
- 对于每一行，如果该公司的处罚日期存在，并且当前行的日期在该日期之后的180天内，则condition为True。

但如何实现这一点呢？可能需要按公司分组，然后计算每个公司的最大处罚日期，然后合并回原数据框。

例如：

# 筛选出公司有行政处罚或刑事判决的事件
penalty_dates = df[df['公司涉嫌证券期货违法犯罪事件'].isin(['行政处罚决定作出', '刑事判决作出'])]
# 按公司分组，找到每个公司的最新处罚日期
company_penalty = penalty_dates.groupby('公司简称')['日期'].max().reset_index()
company_penalty.rename(columns={'日期': 'latest_penalty_date'}, inplace=True)
# 将latest_penalty_date合并回原数据框
df = df.merge(company_penalty, on='公司简称', how='left')
# 计算当前日期与处罚日期的差值
df['days_since_penalty'] = (df['日期'] - df['latest_penalty_date']).dt.days
# condition成立的条件是days_since_penalty在0到180之间
valid_condition = (df['days_since_penalty'] >= 0) & (df['days_since_penalty'] <= 180)

但需要注意，如果公司没有处罚记录，则latest_penalty_date是NaN，此时days_since_penalty也是NaN，所以valid_condition应为False。

这可能是一个可行的方法。但需要确保只有存在处罚记录的公司才会被考虑。

接下来是constraint的检查，即是否减持。根据数据列，可能有“当日减持比例”或“存在减持计划”等。例如，如果当日减持比例>0，则减持行为存在，违反constraint。因此，constraint的条件是当日减持比例等于0，或者不存在减持行为。但根据MEU的约束，是“不得减持”，所以任何减持行为都是违规的。因此，valid_constraint应为当日减持比例等于0，并且不存在减持计划？或者，只要当日没有减持，就视为符合约束？

或者，可能constraint的检查是：该股东在该日期没有减持行为。例如，如果当日减持比例为0，则constraint为True，否则为False。或者，如果存在减持计划，则constraint为False？

这可能需要更仔细的分析。根据MEU的约束，是“不得减持其所持有的本公司股份”，所以任何减持行为都是不允许的。因此，如果当日减持比例>0，则违反约束，constraint为False。否则为True。

因此，valid_constraint = (df['当日减持比例'] == 0) 或者可能结合其他条件，比如是否存在减持计划？

但根据数据列，可能“存在减持计划”是一个布尔值，表示该股东当天是否有减持计划。如果存在减持计划，则可能计划在未来减持，但尚未实施。此时，是否违反约束？

根据法律条文，约束是“不得减持”，即实际减持行为是被禁止的。因此，计划减持可能不直接违反，但实际减持行为才会触发。因此，constraint的检查应基于实际减持行为，即当日减持比例是否大于0。

因此，valid_constraint = (df['当日减持比例'] == 0)

但需要注意，如果当日减持比例是0，则constraint为True，否则为False。

现在，将这些条件转化为代码：

首先，处理subject：

df['meu_11_2_subject'] = df['股东身份'].isin(['控股股东', '实际控制人'])

然后，处理condition：

需要找到每个公司的行政处罚或刑事判决的日期，并检查当前日期是否在该日期后的六个月内。

步骤：

1. 筛选出公司事件为行政处罚决定作出或刑事判决作出的行。
2. 按公司分组，获取每个公司的最新处罚日期。
3. 将最新处罚日期合并回原数据框。
4. 计算当前日期与处罚日期的天数差，判断是否在0到180天之间。

代码实现：

# 筛选出公司有行政处罚或刑事判决的事件
penalty_events = df['公司涉嫌证券期货违法犯罪事件'].isin(['行政处罚决定作出', '刑事判决作出'])
penalty_dates = df[penalty_events][['公司简称', '日期']]

# 按公司获取最新的处罚日期
company_latest_penalty = penalty_dates.groupby('公司简称')['日期'].max().reset_index()
company_latest_penalty.rename(columns={'日期': 'latest_penalty_date'}, inplace=True)

# 合并到原数据框
df = df.merge(company_latest_penalty, on='公司简称', how='left')

# 计算天数差
df['days_after_penalty'] = (df['日期'] - df['latest_penalty_date']).dt.days

# condition成立的条件是：存在latest_penalty_date，并且days_after_penalty在0到180之间
valid_condition = (df['days_after_penalty'] >= 0) & (df['days_after_penalty'] <= 180)

但需要注意，如果公司没有处罚记录，latest_penalty_date是NaN，此时days_after_penalty也是NaN，所以valid_condition为False。

最后，处理constraint：

valid_constraint = df['当日减持比例'] == 0

但需要确认数据列是否存在“当日减持比例”，并且其类型是否为数值型。根据用户提供的列，确实存在“当日减持比例”列，所以可以直接使用。

现在，将这些条件应用到数据框的相应列：

初始化各列：

df['meu_11_2_subject'] = False
df['meu_11_2_condition'] = False
df['meu_11_2_constraint'] = None  # 或者初始化为False？

根据示例中的处理方式，初始化为False，然后根据条件设置为True。例如：

df['meu_11_2_subject'] = df['股东身份'].isin(['控股股东', '实际控制人'])
df['meu_11_2_condition'] = valid_condition
df['meu_11_2_constraint'] = (df['当日减持比例'] == 0)

但根据用户示例中的处理方式，可能需要将constraint的初始值设为None，然后根据条件设置为True或False。例如：

df['meu_11_2_constraint'] = None
valid_constraint = (df['当日减持比例'] == 0)
df.loc[valid_constraint, 'meu_11_2_constraint'] = True
df.loc[~valid_constraint, 'meu_11_2_constraint'] = False

但根据用户示例中的代码，可能更倾向于直接赋值：

df['meu_11_2_subject'] = valid_subject
df['meu_11_2_condition'] = valid_condition
df['meu_11_2_constraint'] = valid_constraint

但需要确保数据类型正确，例如valid_constraint是布尔型。

现在，将这些步骤整合到函数中：

需要注意，在函数中，可能需要处理分组和合并后的列，避免修改原始数据框。例如，在合并后，可能会有新的列如'latest_penalty_date'和'days_after_penalty'，但这些列在函数返回时是否需要保留？根据用户示例中的处理方式，可能不需要保留这些中间列，因此可以在处理完成后删除，或者在处理时不修改原数据框的结构。

但为了代码的简洁性，可能需要在函数内部进行这些操作，而不保留中间列。例如，使用临时变量。

或者，可以使用transform方法在分组后生成每个公司的最大处罚日期，而不需要合并：

例如：

df['latest_penalty_date'] = df.groupby('公司简称')['日期'].transform(lambda x: x.where(penalty_events).max())

但这种方法可能更高效，不需要合并步骤。

但具体实现可能需要更多的步骤。

现在，编写代码的大致步骤：

函数check_meu_11_2(df):

1. 复制df，避免修改原始数据框。
2. 初始化三个新列为False或None。
3. 处理subject列：股东身份是否是控股股东或实际控制人。
4. 处理condition列：
   a. 筛选出公司事件为行政处罚决定作出或刑事判决作出的行。
   b. 按公司分组，找到每个公司的最新处罚日期。
   c. 将最新处罚日期合并到原数据框。
   d. 计算当前日期与处罚日期的天数差。
   e. 判断是否在0-180天之间。
5. 处理constraint列：当日减持比例是否为0。
6. 将各条件的结果赋值到对应的列。
7. 返回修改后的df。

但需要注意，合并后的列可能会影响数据框的结构，因此在函数中可能需要处理这些中间步骤，并在最后删除这些列，或者使用其他方法避免添加新列。

例如，使用transform：

# 筛选出处罚事件
penalty_mask = df['公司涉嫌证券期货违法犯罪事件'].isin(['行政处罚决定作出', '刑事判决作出'])
# 按公司分组，找到每个公司的最大处罚日期
df['latest_penalty_date'] = df.groupby('公司简称')['日期'].transform(lambda x: x[penalty_mask].max())

但这种方法可能无法正确获取每个公司的处罚日期，因为transform中的lambda函数可能无法正确应用条件。或者，可能需要先创建一个临时数据框，然后合并。

另一种方法是：

# 创建临时数据框，包含每个公司的最新处罚日期
temp = df[df['公司涉嫌证券期货违法犯罪事件'].isin(['行政处罚决定作出', '刑事判决作出'])]
temp = temp.groupby('公司简称')['日期'].max().reset_index()
temp.columns = ['公司简称', 'latest_penalty_date']

# 将temp合并到原df
df = df.merge(temp, on='公司简称', how='left')

然后计算天数差：

df['days_after_penalty'] = (df['日期'] - df['latest_penalty_date']).dt.days
valid_condition = (df['days_after_penalty'] >= 0) & (df['days_after_penalty'] <= 180)

处理完condition后，可以删除中间列：

df.drop(['latest_penalty_date', 'days_after_penalty'], axis=1, inplace=True)

这样，函数返回的df不会包含这些中间列。

现在，将这些步骤整合到函数中：

def check_meu_11_2(df):
    df = df.copy()

    # 初始化列
    df['meu_11_2_subject'] = False
    df['meu_11_2_condition'] = False
    df['meu_11_2_constraint'] = None  # 初始化为None，之后填充True/False

    # 处理subject
    valid_subject = df['股东身份'].isin(['控股股东', '实际控制人'])
    df.loc[valid_subject, 'meu_11_2_subject'] = True

    # 处理condition
    # 筛选出公司的行政处罚或刑事判决事件
    penalty_events = df['公司涉嫌证券期货违法犯罪事件'].isin(['行政处罚决定作出', '刑事判决作出'])
    # 按公司获取最新处罚日期
    temp = df[penalty_events].groupby('公司简称')['日期'].max().reset_index()
    temp.rename(columns={'日期': 'latest_penalty_date'}, inplace=True)
    # 合并到原df
    df = df.merge(temp, on='公司简称', how='left')
    # 计算天数差
    df['days_after_penalty'] = (df['日期'] - df['latest_penalty_date']).dt.days
    # 判断条件
    valid_condition = (df['days_after_penalty'] >= 0) & (df['days_after_penalty'] <= 180)
    df.loc[valid_condition, 'meu_11_2_condition'] = True
    # 删除中间列
    df.drop(['latest_penalty_date', 'days_after_penalty'], axis=1, inplace=True)

    # 处理constraint
    valid_constraint = df['当日减持比例'] == 0
    df.loc[valid_constraint, 'meu_11_2_constraint'] = True
    df.loc[~valid_constraint, 'meu_11_2_constraint'] = False

    return df

但需要注意，合并后的temp可能包含多个公司的latest_penalty_date，而merge操作可能会引入重复的列。此外，当公司没有处罚记录时，latest_penalty_date为NaN，此时days_after_penalty也为NaN，valid_condition为False，这符合要求。

此外，在合并时，如果公司没有处罚记录，latest_penalty_date将为NaN，此时days_after_penalty也为NaN，所以valid_condition自动为False。

现在，测试这个函数是否满足要求：

例如，对于某一行数据：

- 股东身份是控股股东 → subject为True。
- 公司在该行的日期之前有行政处罚决定作出，且当前日期在处罚后的180天内 → condition为True。
- 当日减持比例为0 → constraint为True。但根据法律条文，此时不得减持，所以constraint应为False？或者，constraint的检查是独立于subject和condition的？

根据用户的要求，三个条件独立检查。因此，即使subject和condition都为True，只要当日没有减持，constraint标记为True。但根据法律条文，当subject和condition都满足时，constraint应为“不得减持”，即任何减持行为都是不允许的。因此，正确的逻辑应该是，当subject和condition都满足时，如果存在减持，则constraint为False。否则为True。但根据用户的要求，这里需要将三个条件独立检查，因此constraint的检查不考虑subject和condition的状态。

这可能与实际法律条文不符，但根据用户的任务要求，必须这样处理。例如，在示例中，constraint的检查是独立进行的，不管subject和condition是否满足。

因此，在代码中，constraint的检查是独立进行的，只要当日没有减持，就标记为True，不管股东是否是控股股东或公司是否处于处罚后的六个月内。

这可能与法律的实际要求相矛盾，但根据用户的任务说明，必须这样处理。

因此，上述代码是正确的。

但需要确认用户提供的列中是否存在“当日减持比例”列。根据附加信息中的列列表，确实存在“当日减持比例”列，因此可以使用。

综上，最终的代码应该如上述函数所示。
","CompletionUsage(completion_tokens=5506, prompt_tokens=1725, total_tokens=7231, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=5022, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_12_5
法律的最小可执行单元内容: {""subject"": ""公开发行时持股5%以上的第一大股东 | 一致行动人"", ""condition"": ""上市公司在公开发行股票并上市时披露为无控股股东、实际控制人, 且计划通过集中竞价交易或大宗交易减持股份且首次披露减持计划, 且不存在已经按照本指引第四条披露减持计划，或者中国证监会另有规定的情况的"", ""constraint"": ""不得存在下列情形：最近20个交易日内任一交易日股票收盘价低于公开发行股票并上市的发行价格"", ""contextual_info"": ""股票收盘价以公开发行股票并上市之日为基准向后复权计算""}
必要的额外信息: 不考虑中国证监会另有规定的情况


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_12_5(df):
    df = df.copy()
    
    # 初始化标记列
    df['meu_12_5_subject'] = False
    df['meu_12_5_condition'] = False
    df['meu_12_5_constraint'] = None
    
    # ================== SUBJECT CHECK ==================
    # 验证公开发行时持股5%以上的第一大股东
    # 1. 获取各公司上市日期和发行价格
    company_ipo_info = df.groupby('公司简称').agg(
        上市日期=('上市日期', 'first'),
        发行价格=('发行价格', 'first')
    ).reset_index()
    
    # 2. 找出各公司上市时的第一大股东
    major_shareholders = {}
    for _, row in company_ipo_info.iterrows():
        company = row['公司简称']
        ipo_date = row['上市日期']
        
        # 获取上市当天的股东数据
        ipo_day_data = df[(df['公司简称'] == company) & (df['日期'] == ipo_date)]
        
        if not ipo_day_data.empty:
            # 找到最大持股比例的股东
            max_ratio = ipo_day_data['持股比例'].max()
            if max_ratio >= 0.05:
                valid_shareholders = ipo_day_data[ipo_day_data['持股比例'] == max_ratio]['股东'].unique()
                major_shareholders[company] = list(valid_shareholders)
            else:
                major_shareholders[company] = []
    
    # 3. 标记有效subject
    df['meu_12_5_subject'] = df.apply(
        lambda x: x['股东'] in major_shareholders.get(x['公司简称'], []),
        axis=1
    )
    
    # ================== CONDITION CHECK ==================
    # 验证上市公司无实际控制人且首次披露减持计划
    # 1. 检查公司是否无实际控制人
    df['company_no_control'] = df.groupby('公司简称')['股东身份'].transform(
        lambda x: ~x.isin(['控股股东', '实际控制人']).any()
    )
    
    # 2. 验证减持方式
    valid_method = df['减持方式'].isin(['竞价交易', '大宗交易'])
    
    # 3. 首次减持计划标记
    df.sort_values(['公司简称', '股东', '日期'], inplace=True)
    df['plan_seq'] = df.groupby(['公司简称', '股东'])['存在减持计划'].cumsum()
    first_plan = (df['存在减持计划']) & (df['plan_seq'] == 1)
    
    # 组合条件
    df['meu_12_5_condition'] = df['company_no_control'] & valid_method & first_plan
    
    # ================== CONSTRAINT CHECK ==================
    # 验证20日收盘价不低于发行价
    # 1. 计算复权价格
    df['复权收盘价'] = df['收盘价'] * df['复权因子']
    
    # 2. 获取发行价格
    df = df.merge(company_ipo_info[['公司简称', '发行价格']], on='公司简称', how='left')
    
    # 3. 滚动检查最近20个交易日
    df.sort_values(['公司简称', '日期'], inplace=True)
    df['price_valid'] = df.groupby('公司简称').apply(
        lambda g: g['复权收盘价'].rolling(20, min_periods=1).min() >= g['发行价格']
    ).reset_index(level=0, drop=True)
    
    df['meu_12_5_constraint'] = df['price_valid']
    
    # 清理中间列
    df.drop(columns=['company_no_control', 'plan_seq', '复权收盘价', '发行价格', 'price_valid'],
           inplace=True, errors='ignore')
    
    return df
</CODE>","好的，我现在需要处理这个MEU_12_5的合规性检查任务。首先，我得仔细理解这个MEU的具体内容，然后根据给定的数据框结构来编写相应的函数。

首先，MEU_12_5的subject是“公开发行时持股5%以上的第一大股东 | 一致行动人”。这里的关键点在于确定哪些股东属于这个主体。根据数据中的列，我需要检查股东是否是公开发行时的第一大股东，并且持股比例超过5%。或者他们是一致行动人。但数据中是否有“一致行动人”的标识呢？可能没有直接的列，所以可能需要依赖其他字段，比如股东身份或者是否有其他标记。但根据提供的列，可能只能通过持股比例和是否是第一大股东来判断。可能需要先确定每个公司在公开发行时的第一大股东，并且持股5%以上。或者，可能数据中的“股东身份”列中有相关标记？比如“持股5%以上股东”可能是一个选项。但根据附加信息中的说明，“股东身份”列中的标签不会并列出现，所以可能需要结合持股比例来判断。例如，如果股东身份是“控股股东”或“实际控制人”或“持股5%以上股东”，并且持股比例>=5%，或者在公开发行时是最大的股东。但如何确定谁是公开发行时的第一大股东呢？可能需要根据上市日期来确定，每个公司上市时的第一大股东。可能需要按公司分组，找到上市日期对应的记录，然后确定当时的持股比例最大的股东。这可能比较复杂，因为数据框是按日频的，每个公司可能有多个股东。所以，可能需要为每个公司找到其上市日期，然后在该日期下，找出该公司的股东中持股比例最大的那个，并且持股比例>=5%。然后，这些股东在后续的交易日中是否仍然属于这个subject。或者，是否只要在上市时是持股5%以上的第一大股东，之后无论持股比例如何变化，都算作subject？这个问题需要明确。根据MEU的subject描述，是“公开发行时持股5%以上的第一大股东”，所以可能只要在公开发行时满足条件，之后无论持股是否变化，都属于subject。因此，需要为每个公司确定在上市时的第一大股东，并且持股比例>=5%。这可能需要在数据预处理阶段为每个公司记录这些信息。例如，对于每个公司，找到其上市日期（即上市日期列中的日期），然后在该日期对应的记录中，找出每个股东的持股比例，找到最大的那个，并且是否>=5%。如果是，则这些股东在后续的所有交易日都属于subject。这可能需要在函数中进行预处理，比如为每个公司存储其上市时的第一大股东列表。这可能比较复杂，因为数据框是按日频的，每个公司每天可能有多个股东记录。或者，可能假设在上市日期当天，每个公司的股东数据中包含了当时的持股情况。因此，在函数中，可能需要按公司分组，然后对于每个公司，找到其上市日期，然后在该日期下，找出持股比例最大的股东，并且持股比例>=5%。然后，这些股东在后续的所有交易日都属于subject。此外，还要考虑一致行动人，但数据中可能没有一致行动人的信息，所以可能无法处理这部分，可能需要忽略，或者假设一致行动人已经被标记在某个列中。但根据给定的列，可能没有这个信息，所以可能只能处理“公开发行时持股5%以上的第一大股东”部分，而无法处理一致行动人。或者，可能用户希望我们忽略一致行动人，因为数据中没有相关信息。这可能是一个问题，但根据任务要求，可能需要根据现有数据尽可能处理。因此，可能暂时只能处理第一大股东的情况，而无法处理一致行动人，除非有其他字段可以推断。或者，可能用户希望将“一致行动人”视为另一个条件，但可能没有数据支持，所以可能需要暂时忽略，或者在代码中注释说明这一点。这可能是一个需要假设的地方，但根据问题描述中的必要额外信息，可能不考虑中国证监会另有规定的情况，但关于一致行动人可能需要如何处理呢？可能需要根据现有数据来处理，或者可能用户希望我们假设一致行动人已经被包含在某个字段中，比如股东身份。但根据提供的列，可能没有这个字段，所以可能需要暂时忽略一致行动人，或者认为无法处理这部分，导致subject的条件可能无法完全满足。这可能是一个问题，但可能需要根据现有数据尽可能处理。

接下来是condition部分：“上市公司在公开发行股票并上市时披露为无控股股东、实际控制人，且计划通过集中竞价交易或大宗交易减持股份且首次披露减持计划，且不存在已经按照本指引第四条披露减持计划，或者中国证监会另有规定的情况的”。这里需要满足多个条件：1. 公司在上市时披露无控股股东、实际控制人；2. 股东计划通过集中竞价或大宗交易减持；3. 首次披露减持计划；4. 不存在已经按照第四条披露的情况，或者中国证监会另有规定的情况。但根据必要额外信息，不考虑中国证监会另有规定的情况，所以可以忽略这部分。因此，condition的条件是：公司上市时无控股股东和实际控制人，股东计划通过集中竞价或大宗交易减持，且是首次披露减持计划，且没有已经按照第四条披露过减持计划。这里需要如何判断公司上市时是否披露无控股股东和实际控制人呢？可能需要查看公司在该上市时的相关公告，或者是否有字段记录这一信息。根据提供的列，可能没有直接的字段，但可能可以通过其他方式推断。例如，假设如果公司在上市时的控股股东或实际控制人字段为空，或者在上市日期当天的记录中，控股股东或实际控制人不存在，则可能视为无。或者，可能有一个字段如“公告类型”或“股东身份”来记录。例如，可能在上市时的公告类型中有相关披露。但根据提供的列，可能没有直接的信息，所以可能需要假设公司上市时的控股股东和实际控制人是否存在。例如，如果公司在上市时的股东中没有控股股东或实际控制人，则视为满足条件。或者，可能有一个字段如“公司涉嫌证券期货违法犯罪事件”中的某些情况，但可能不相关。这可能是一个难点，因为数据中可能没有直接的信息。可能需要假设存在一个字段，或者需要根据其他字段推断。例如，如果公司在上市日期当天的记录中，控股股东和实际控制人字段为空，或者对应的股东身份中没有控股股东或实际控制人，则视为无。或者，可能公司上市时的股东中没有被标记为控股股东或实际控制人的股东。例如，在上市日期当天，公司的所有股东中，股东身份列中没有“控股股东”或“实际控制人”，则视为公司披露为无控股股东和实际控制人。这可能是一个可行的判断方法。因此，在代码中，需要为每个公司检查其上市日期当天的股东情况，是否有任何股东被标记为控股股东或实际控制人。如果没有，则该公司满足条件。这可能需要在函数中进行预处理，例如为每个公司记录是否在上市时无控股股东和实际控制人。这可能涉及到按公司分组，找到上市日期，然后检查该日期下是否有股东的身份是控股股东或实际控制人。如果没有，则该公司满足条件。这一步可能需要较多的处理。

然后是减持方式是否为集中竞价或大宗交易，这可以通过减持方式列来判断，是否属于['竞价交易', '大宗交易']。此外，是否是首次披露减持计划。这里需要判断该股东是否在之前已经披露过减持计划。例如，如果存在减持计划为True，并且是第一次出现，则视为首次披露。这可能需要按股东和公司分组，然后检查该股东在之前的记录中是否存在减持计划为True的情况。如果是第一次出现，则视为首次披露。这可能需要使用groupby和cumsum等方法来判断。例如，按['公司简称', '股东']分组，然后对于每个组，检查是否存在减持计划为True的行，并且当前行是否为该组的第一个减持计划为True的行。如果是，则视为首次披露。此外，还需要检查是否已经按照第四条披露过减持计划，但根据必要额外信息，可能不需要处理中国证监会的情况，但第四条的情况可能需要其他条件，但可能数据中没有相关信息，所以可能暂时无法处理，或者假设不存在这种情况。因此，condition的条件可能简化为：公司上市时无控股股东和实际控制人，减持方式为竞价或大宗交易，且该股东是首次披露减持计划。

接下来是constraint部分：“不得存在下列情形：最近20个交易日内任一交易日股票收盘价低于公开发行股票并上市的发行价格”。这里的约束条件是，在最近20个交易日内，任何一天的收盘价都不能低于发行价。需要注意的是，这里的收盘价是经过复权计算的，以公开发行日为准向后复权。因此，需要计算每个交易日相对于发行价格的复权价格。例如，发行价格是公司上市时的发行价，而收盘价需要乘以复权因子来调整。或者，可能数据中已经提供了复权后的价格。根据数据中的列，有“复权因子”和“收盘价”列，可能需要计算复权后的收盘价。例如，复权后的收盘价 = 收盘价 * 复权因子。然后，比较复权后的收盘价是否低于发行价格。发行价格存储在“发行价格”列中，每个公司的发行价格应该是在上市时的发行价。因此，对于每个公司，需要获取其发行价格，然后对于每个交易日，计算复权后的收盘价，并检查最近20个交易日内是否有任何一天的复权收盘价低于发行价。这里的最近20个交易日是指当前行的日期之前的20个交易日（包括当前日？或者不包括？需要明确）。例如，对于当前行的日期，需要检查从当前日期往前推20个交易日的窗口内是否存在收盘价低于发行价的情况。但如何获取这些交易日的数据呢？因为数据框是按日频的，所以可能需要为每个公司的每个交易日，计算过去20个交易日的窗口内的最低收盘价是否低于发行价。这可能需要使用rolling窗口的方法，但需要注意每个公司的数据分组。例如，按公司分组，然后在每个组内，对收盘价进行滚动窗口计算。但复权后的收盘价需要先计算，然后比较。此外，发行价格是每个公司固定的，所以每个公司的发行价可以从其上市日期对应的发行价格列中获取。例如，每个公司的发行价是其在上市日期当天的发行价格。因此，在代码中，可能需要为每个公司确定其发行价格，然后计算复权后的收盘价，再比较是否低于发行价。然后，对于每个交易日，检查过去20个交易日内是否有任何一天的复权收盘价低于发行价。如果有，则违反约束条件，即constraint为False，否则为True。但根据MEU的约束条件，如果存在任一交易日收盘价低于发行价，则不得减持，因此constraint的valid应为最近20个交易日内所有交易日的收盘价都不低于发行价。因此，constraint的条件是：最近20个交易日内所有交易日的复权收盘价都>=发行价。如果存在至少一个交易日低于，则constraint为False。因此，在代码中，需要为每个公司的每个交易日，计算过去20个交易日的复权收盘价是否都>=发行价。如果是，则constraint为True，否则为False。

现在，将这些步骤转化为代码：

首先，处理subject：

1. 确定每个公司在公开发行时的第一大股东，且持股比例>=5%。这需要按公司分组，找到上市日期，然后在该日期下，找出每个股东的持股比例，找到最大的那个，并且持股比例>=5%。这些股东将被视为subject中的“公开发行时持股5%以上的第一大股东”。此外，一致行动人可能无法处理，所以暂时忽略。

如何实现这一点？例如，对于每个公司，找到其上市日期（即'上市日期'列中的日期），然后在该日期下，筛选出该公司的股东记录，找到其中持股比例最大的股东，并且持股比例>=5%。如果存在这样的股东，则这些股东在后续的所有交易日都属于subject。因此，在代码中，可能需要为每个公司存储其上市时的第一大股东列表。这可以通过以下步骤实现：

- 按公司分组，获取每个公司的上市日期。
- 对于每个公司，在上市日期当天，筛选出该公司的所有股东记录。
- 在这些记录中，找到持股比例最大的股东（可能有多个，如果持股比例相同？但通常第一大股东是唯一的）。
- 检查该股东的持股比例是否>=5%。如果是，则将该股东标记为subject中的有效主体。

在代码中，可能需要创建一个新的列，标记该股东是否是公司上市时的第一大股东且持股>=5%。例如，可以创建一个布尔列'is_issuance_major_shareholder'，对于每个公司的股东，如果在上市日期当天，该股东是持股比例最大的且>=5%，则标记为True，否则为False。然后，在后续的处理中，只要该股东存在，其对应的行中的subject条件就为True。

但如何高效地实现这一点呢？因为数据框可能很大，按公司分组处理可能会比较耗时。但根据问题描述，可以假设数据已经按公司、股东和日期排序，或者可以通过分组处理。

具体步骤：

a. 获取每个公司的上市日期：每个公司的上市日期可能存储在'上市日期'列中，但需要确认。例如，每个公司的上市日期是固定的，可能每个公司的所有行的'上市日期'列的值相同。因此，可以取每个公司的第一个'上市日期'值。

b. 对于每个公司，找到其上市日期对应的记录中的股东数据。例如，对于公司A，上市日期是date_x，那么在该日期下，公司A的所有股东记录。

c. 在这些记录中，找到每个股东在该日期的持股比例，确定最大的那个。如果有多个股东持股比例相同且最大，则可能有多个第一大股东。

d. 检查这些股东的持股比例是否>=5%。如果是，则这些股东在后续的所有交易日都属于subject的有效主体。

因此，在代码中，可能需要为每个公司生成一个列表，记录哪些股东是上市时的第一大股东且持股>=5%。然后，在数据框中，对于每个股东，如果属于该列表中的股东，则subject条件为True。

实现方法：

- 首先，创建一个DataFrame，每个公司对应其上市日期，并找到该日期下的股东数据。
- 然后，按公司分组，处理每个公司的股东在上市日期的情况。
- 对于每个公司，筛选出上市日期当天的股东记录。
- 在这些记录中，找到持股比例最大的股东（可能有多个）。
- 检查这些股东的持股比例是否>=5%，如果是，则标记这些股东为有效subject。

例如：

# 获取每个公司的上市日期
company_ipo_dates = df.groupby('公司简称')['上市日期'].first()

# 创建一个字典，记录每个公司的上市时的第一大股东列表
major_shareholders = {}

for company in df['公司简称'].unique():
    ipo_date = company_ipo_dates[company]
    # 获取该公司在上市日期的所有股东记录
    ipo_records = df[(df['公司简称'] == company) & (df['日期'] == ipo_date)]
    if ipo_records.empty:
        continue
    # 找到最大的持股比例
    max_ratio = ipo_records['持股比例'].max()
    if max_ratio >= 0.05:
        # 找出所有持股比例等于max_ratio的股东
        shareholders = ipo_records[ipo_records['持股比例'] == max_ratio]['股东'].unique()
        major_shareholders[company] = shareholders
    else:
        major_shareholders[company] = []

然后，在数据框中，对于每一行，如果该股东属于该公司在major_shareholders中的列表，则subject条件为True。

因此，在代码中：

df['meu_12_5_subject'] = df.apply(lambda row: row['股东'] in major_shareholders.get(row['公司简称'], []), axis=1)

但需要注意，这可能会有性能问题，因为apply函数较慢。或者，可以使用合并的方式，将每个公司的大股东列表合并到主数据框中，然后进行比较。例如，为每个公司生成一个列，存储其大股东列表，然后检查股东是否在该列表中。但pandas处理列表列可能不太方便，所以可能需要另一种方法。

或者，可以创建一个多索引的Series，其中索引是（公司简称，股东），值为是否是大股东。例如：

# 创建一个布尔Series
is_major = pd.Series(False, index=df.index)

for company, shareholders in major_shareholders.items():
    mask = (df['公司简称'] == company) & (df['股东'].isin(shareholders))
    is_major.loc[mask] = True

df['meu_12_5_subject'] = is_major

这样可能更高效。

接下来处理condition：

condition的条件包括：

1. 公司上市时披露为无控股股东、实际控制人。
2. 股东计划通过集中竞价或大宗交易减持股份。
3. 首次披露减持计划。
4. 不存在已经按照本指引第四条披露减持计划的情况（假设不考虑）。

首先，判断公司是否在上市时无控股股东和实际控制人。这需要检查在上市日期当天，公司是否有任何股东被标记为控股股东或实际控制人。如果没有，则视为满足条件。

如何实现这一点：

a. 对于每个公司，获取其上市日期。
b. 在上市日期当天的所有股东记录中，检查是否有股东的'股东身份'是'控股股东'或'实际控制人'。
c. 如果没有，则该公司满足条件。

因此，可以创建一个字典，记录每个公司是否在上市时无控股股东和实际控制人：

company_no_control = {}

for company in df['公司简称'].unique():
    ipo_date = company_ipo_dates[company]
    # 获取该公司在上市日期的所有股东记录
    ipo_records = df[(df['公司简称'] == company) & (df['日期'] == ipo_date)]
    # 检查是否有股东身份为控股股东或实际控制人
    has_control = ipo_records['股东身份'].isin(['控股股东', '实际控制人']).any()
    company_no_control[company] = not has_control

然后，在数据框中，为每个公司添加一个列，表示该公司是否满足无控股股东和实际控制人：

df['company_no_control'] = df['公司简称'].map(company_no_control)

接下来，减持方式是否为集中竞价或大宗交易：

valid_d_method = df['减持方式'].isin(['竞价交易', '大宗交易'])

然后，首次披露减持计划。这需要判断该股东是否在之前的任何时间点已经披露过减持计划。如果是首次出现减持计划为True的行，则视为首次披露。这可以通过按['公司简称', '股东']分组，然后使用cumsum或shift来判断是否为第一次出现。

例如：

# 按公司和股东分组，按日期排序
df.sort_values(['公司简称', '股东', '日期'], inplace=True)

# 对于每个组，计算减持计划的累计出现次数
df['plan_cumsum'] = df.groupby(['公司简称', '股东'])['存在减持计划'].cumsum()

# 首次披露的条件是当前行的存在减持计划为True，且累计次数为1
first_disclosure = (df['存在减持计划']) & (df['plan_cumsum'] == 1)

因此，condition的条件是：

valid_condition = (
    df['company_no_control'] & 
    valid_d_method & 
    first_disclosure
)

现在，将这些条件组合起来，标记condition列。

接下来处理constraint：

constraint要求最近20个交易日内任一交易日的收盘价（复权后）不低于发行价。需要计算复权后的收盘价，并检查过去20个交易日内是否有任何一天低于发行价。

首先，计算复权后的收盘价：

df['复权收盘价'] = df['收盘价'] * df['复权因子']

然后，获取每个公司的发行价格。发行价格是公司在上市时的发行价，即每个公司的发行价格列中的值。假设每个公司的发行价格在上市日期当天的记录中是固定的，因此可以按公司获取发行价格：

company_issue_price = df.groupby('公司简称')['发行价格'].first()

df['发行价格'] = df['公司简称'].map(company_issue_price)

然后，对于每个公司的每个交易日，计算复权收盘价是否>=发行价：

df['price_above_issue'] = df['复权收盘价'] >= df['发行价格']

接下来，需要检查过去20个交易日内是否有任何price_above_issue为False的情况。如果有，则constraint为False，否则为True。

这需要使用rolling窗口，按公司分组，计算每个交易日过去20个交易日的price_above_issue的最小值。如果最小值是False（即存在至少一个交易日低于发行价），则constraint为False。

例如：

# 按公司分组，对price_above_issue进行滚动窗口计算，窗口大小为20，min_periods=1
df['price_check'] = df.groupby('公司简称')['price_above_issue'].transform(
    lambda x: x.rolling(window=20, min_periods=1).min()
)

# 如果price_check为True，表示过去20个交易日都>=发行价，否则为False
valid_constraint = df['price_check'] == True

但需要注意，这里的窗口是向前滚动的，即包括当前行在内的过去20行。例如，对于当前行，窗口是前19行加上当前行，共20行。因此，需要确保数据按日期排序，并且每个公司的数据是按日期排序的。

因此，在代码中，需要先按公司和日期排序：

df.sort_values(['公司简称', '日期'], inplace=True)

然后，进行分组滚动计算。

但可能每个公司的交易日可能不连续，所以需要确保每个公司的日期是连续的，或者使用时间序列的rolling方法。但根据问题描述，日期列已经是交易日，所以可以假设每个公司的日期是连续的，或者按日期排序后，每个公司的数据是按时间顺序排列的。

因此，代码步骤：

1. 按公司分组，按日期排序。
2. 计算复权收盘价。
3. 获取发行价格。
4. 计算price_above_issue。
5. 使用rolling窗口计算过去20个交易日的price_above_issue的最小值。
6. 如果最小值是True，则valid_constraint为True，否则为False。

现在，将这些步骤整合到代码中：

最后，将subject、condition、constraint的结果标记到对应的列中。

需要注意的是，根据任务要求，对于三元组的检查是各自独立的，需要分别标记。因此，即使subject和condition不满足，也需要标记constraint的条件是否满足。但根据问题描述中的注意点，对于简单操作dataframe就可以处理的项目，三元组的检查是独立的，需要分别标记。因此，constraint的检查不需要依赖subject和condition是否满足，而是对所有行进行检查。

因此，在代码中，需要分别计算subject、condition、constraint的条件，并分别标记到对应的列中。

现在，将这些思考整合成代码：

首先，处理subject：

- 确定每个公司在上市时的第一大股东，且持股>=5%。

然后，处理condition：

- 公司上市时无控股股东和实际控制人。
- 减持方式为竞价或大宗交易。
- 首次披露减持计划。

处理constraint：

- 最近20个交易日的复权收盘价均>=发行价。

现在，编写代码：

import pandas as pd

def check_meu_12_5(df):
    df = df.copy()
    
    # 初始化标记列
    df['meu_12_5_subject'] = False
    df['meu_12_5_condition'] = False
    df['meu_12_5_constraint'] = None  # 初始化为None，后续填充True/False
    
    # 处理subject: 公开发行时持股5%以上的第一大股东 | 一致行动人（暂时处理第一大股东部分）
    # 获取每个公司的上市日期
    company_ipo_dates = df.groupby('公司简称')['上市日期'].first()
    
    # 存储每个公司的第一大股东列表（上市时持股>=5%）
    major_shareholders = {}
    for company in df['公司简称'].unique():
        ipo_date = company_ipo_dates[company]
        # 获取上市当天的股东记录
        ipo_records = df[(df['公司简称'] == company) & (df['日期'] == ipo_date)]
        if not ipo_records.empty:
            max_ratio = ipo_records['持股比例'].max()
            if max_ratio >= 0.05:
                # 找出所有持股比例等于max_ratio的股东
                shareholders = ipo_records[ipo_records['持股比例'] == max_ratio]['股东'].unique()
                major_shareholders[company] = list(shareholders)
            else:
                major_shareholders[company] = []
        else:
            major_shareholders[company] = []
    
    # 标记subject
    df['meu_12_5_subject'] = df.apply(
        lambda row: row['股东'] in major_shareholders.get(row['公司简称'], []), 
        axis=1
    )
    
    # 处理condition: 公司上市时无控股股东和实际控制人，减持方式正确，首次披露减持计划
    # 判断公司是否在上市时无控股股东和实际控制人
    company_no_control = {}
    for company in df['公司简称'].unique():
        ipo_date = company_ipo_dates[company]
        ipo_records = df[(df['公司简称'] == company) & (df['日期'] == ipo_date)]
        has_control = ipo_records['股东身份'].isin(['控股股东', '实际控制人']).any()
        company_no_control[company] = not has_control
    df['company_no_control'] = df['公司简称'].map(company_no_control)
    
    # 减持方式是否为竞价或大宗交易
    valid_d_method = df['减持方式'].isin(['竞价交易', '大宗交易'])
    
    # 首次披露减持计划：按公司和股东分组，计算是否为首次出现存在减持计划为True
    df.sort_values(['公司简称', '股东', '日期'], inplace=True)
    df['plan_cumsum'] = df.groupby(['公司简称', '股东'])['存在减持计划'].cumsum()
    first_disclosure = (df['存在减持计划']) & (df['plan_cumsum'] == 1)
    
    # 组合condition条件
    df['meu_12_5_condition'] = (
        df['company_no_control'] & 
        valid_d_method & 
        first_disclosure
    )
    
    # 处理constraint: 最近20个交易日复权收盘价均不低于发行价
    # 计算复权收盘价
    df['复权收盘价'] = df['收盘价'] * df['复权因子']
    
    # 获取每个公司的发行价格
    company_issue_price = df.groupby('公司简称')['发行价格'].first()
    df['发行价格_公司'] = df['公司简称'].map(company_issue_price)
    
    # 判断复权收盘价是否>=发行价
    df['price_above_issue'] = df['复权收盘价'] >= df['发行价格_公司']
    
    # 按公司分组，计算过去20个交易日的price_above_issue的最小值
    df.sort_values(['公司简称', '日期'], inplace=True)
    df['rolling_min'] = df.groupby('公司简称')['price_above_issue'].transform(
        lambda x: x.rolling(window=20, min_periods=1).min()
    )
    
    # valid_constraint为True当且仅当rolling_min为True（即所有都>=发行价）
    valid_constraint = df['rolling_min'] == True
    df['meu_12_5_constraint'] = valid_constraint
    
    # 清理临时列
    df.drop(columns=['company_no_control', 'plan_cumsum', '复权收盘价', 
                     '发行价格_公司', 'price_above_issue', 'rolling_min'], 
            inplace=True, errors='ignore')
    
    return df
","CompletionUsage(completion_tokens=6905, prompt_tokens=1793, total_tokens=8698, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=6015, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_14_6
法律的最小可执行单元内容: {""subject"": ""上市公司董监高"", ""condition"": ""本人因涉及与本上市公司有关的违法违规，被证券交易所公开谴责未满三个月"", ""constraint"": ""不得减持其所持有的本公司股份"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_14_6(df):
    '''
    检查MEU_14_6合规性：
    subject: 上市公司董监高
    condition: 被交易所公开谴责未满三个月
    constraint: 不得减持股份
    
    处理逻辑：
    1. subject标记：股东身份为""董监高""
    2. condition标记：按股东追踪最近谴责日期，计算90天窗口期
    3. constraint标记：当日无减持行为（减持比例<=0）
    '''
    df = df.copy()

    # 初始化标记列
    df['meu_14_6_subject'] = False
    df['meu_14_6_condition'] = False
    df['meu_14_6_constraint'] = None

    # 标记valid的subject
    df['meu_14_6_subject'] = df['股东身份'] == '董监高'

    # 标记valid的condition
    # 创建临时谴责日期列
    df['_condemn_date'] = pd.NaT
    condemn_mask = df['股东涉嫌证券期货违法犯罪事件'] == '被本所公开谴责'
    df.loc[condemn_mask, '_condemn_date'] = df.loc[condemn_mask, '日期']
    
    # 按股东计算累积最大谴责日期
    df['_last_condemn'] = df.groupby(['公司简称', '股东'])['_condemn_date'].cummax()
    
    # 计算自然日差
    date_diff = df['日期'] - df['_last_condemn']
    valid_condition = (date_diff <= pd.Timedelta(days=90)) & df['_last_condemn'].notna()
    df['meu_14_6_condition'] = valid_condition

    # 标记valid的constraint（独立检查）
    df['meu_14_6_constraint'] = (df['当日减持比例'] <= 0) | df['当日减持比例'].isna()
    df['meu_14_6_constraint'] = df['meu_14_6_constraint'].astype(bool)

    # 清理临时列
    df.drop(columns=['_condemn_date', '_last_condemn'], inplace=True)

    return df
</CODE>","好的，我现在需要处理这个MEU_14_6的合规性检查。首先，我得仔细理解这个MEU的内容。根据提供的描述，MEU_14_6的subject是“上市公司董监高”，condition是“本人因涉及与本上市公司有关的违法违规，被证券交易所公开谴责未满三个月”，constraint是“不得减持其所持有的本公司股份”。所以，我需要编写一个函数，检查每个交易日中，符合条件的董监高是否在禁止减持的期间内。

首先，处理subject部分。根据附加信息中的列，股东身份有“董监高”这一项。所以，我需要标记所有股东身份为“董监高”的行。但要注意，可能有些董监高的持股比例超过5%，但他们的身份标签可能只是“董监高”，而不是“持股5%以上股东”，所以这里直接根据“股东身份”列是否为“董监高”来判断即可。这一步应该比较简单，用df['股东身份'] == '董监高'就能得到valid_subject。

接下来是condition部分。条件是股东被交易所公开谴责未满三个月。这里需要查看“公司/股东涉嫌证券期货违法犯罪事件”列。根据附加信息，该列可能包含“被本所公开谴责”的事件。但这里可能需要区分是公司还是股东被谴责。因为MEU的条件是“本人”被谴责，所以应该检查股东相关的记录。假设该列中的事件如果是股东被公开谴责的话，应该记录在这里。但可能需要更仔细的处理。

不过，根据提供的列名，可能有一个列是“股东涉嫌证券期货违法犯罪事件”，而另一个是“公司涉嫌证券期货违法犯罪事件”。但用户提供的列中，有一个列是“公司涉嫌证券期货违法犯罪事件”，另一个是“股东涉嫌证券期货违法犯罪事件”？或者可能合并在一起？根据用户提供的列列表，确实存在两个列：'公司涉嫌证券期货违法犯罪事件'和'股东涉嫌证券期货违法犯罪事件'。所以，这里应该检查“股东涉嫌证券期货违法犯罪事件”列是否包含“被本所公开谴责”的事件，并且该事件发生的时间是否在三个月内。

但问题是如何确定每个股东被公开谴责的日期，并计算到当前行的日期是否未满三个月。例如，某股东在某个日期被公开谴责，那么在之后的三个月内，该condition为真。因此，需要针对每个股东，找到他们最近一次被公开谴责的日期，然后检查当前行的日期是否在该日期之后的三个月内。

这可能涉及到分组处理，按公司和股东分组，然后对于每个股东，找到他们被谴责的日期。例如，当某行的“股东涉嫌证券期货违法犯罪事件”为“被本所公开谴责”时，记录该日期。然后，对于该股东后续的日期，如果在该日期后的三个月内，则condition为真。

但如何跟踪每个股东被公开谴责的日期呢？可能需要创建一个新的列，记录每个股东最近一次被公开谴责的日期。这可能需要使用groupby和transform方法，或者使用cummax等函数来记录每个股东的最新谴责日期。

例如，对于每个股东，当“股东涉嫌证券期货违法犯罪事件”为“被本所公开谴责”时，记录该行的日期。然后，对于每个行，该股东的最新谴责日期是到当前行为止的最大日期。如果当前行的日期与该谴责日期的差小于三个月（90天左右），则condition满足。

所以，处理condition的步骤可能如下：

1. 对每个股东，确定他们被公开谴责的日期。这可能是在“股东涉嫌证券期货违法犯罪事件”列中值为“被本所公开谴责”的那些行的日期。
2. 对于每个股东，计算到当前行日期为止，最近一次被公开谴责的日期。
3. 检查当前行的日期是否在该谴责日期之后的三个月内（比如90天）。

但如何实现这个呢？可能需要按股东分组，然后对于每个组，计算累积的最大谴责日期。例如，当某股东在某个日期被谴责，那么之后的所有行的谴责日期都应该是该日期或更早的日期中的最大值。这样，每个行中的谴责日期是该股东到当前日期为止的最后一次被谴责的日期。

例如，可以创建一个新列'last_condemn_date'，对于每个股东，当事件是“被本所公开谴责”时，记录该日期，否则为NaT。然后，使用groupby和cummax来填充每个股东的最新谴责日期。

具体步骤可能如下：

- 创建一个临时列'condemn_date'，当“股东涉嫌证券期货违法犯罪事件”等于“被本所公开谴责”时，取该行的日期，否则为NaT。
- 按['公司简称', '股东']分组，对每个组内的'condemn_date'进行cummax操作，得到每个行的最新谴责日期。
- 然后，计算当前行的日期与最新谴责日期的差是否小于等于90天（三个月假设为90天）。

但需要注意，如果该股东从未被谴责过，则这个差是NaT，此时condition不满足。

所以，valid_condition的条件是：

(current_date - last_condemn_date) <= pd.Timedelta(days=90)

并且last_condemn_date不为空。

接下来是constraint部分，即“不得减持其所持有的本公司股份”。这需要检查该行是否有减持行为。例如，减持方式是否不为空，或者是否有减持比例等。根据提供的列，可能有“当日减持比例”或“减持方式”等列。例如，如果当日减持比例大于0，或者减持方式存在，则视为减持行为。此时，如果该行的constraint条件满足，则必须没有减持行为。

但具体的判断可能需要根据数据中的列来确定。例如，如果“当日减持比例”>0，或者存在减持计划（但减持计划可能只是计划，不一定实际减持）。或者，可能要看是否有实际的减持行为，比如“减持方式”列是否有值，或者“当日减持比例”是否大于0。

根据用户提供的列，存在“当日减持比例”列，所以如果该列的值大于0，则视为当日有减持行为。此时，constraint要求不得减持，所以当valid_subject和valid_condition都为True时，如果当日减持比例>0，则constraint为False，否则为True。

但根据任务要求，对于constraint的检查是独立进行的，即不管subject和condition是否满足，都要检查。但根据用户的要求，对于不需要调用LLM的情况，三元组的检查是各自独立的。所以，不管subject和condition是否满足，都要标记constraint是否符合。例如，不管是否是董监高，或者是否被谴责，只要该行存在减持行为，那么constraint是否满足？

但MEU中的constraint是“不得减持”，所以只有当subject和condition都满足时，才需要遵守这个constraint。但根据用户的任务说明，对于不需要调用LLM的情况，三元组的检查是各自独立的。也就是说，每个条件（subject、condition、constraint）的检查是独立的，不管其他条件是否满足。例如，constraint的检查是，无论该行是否满足subject和condition，只要该行存在减持，则constraint是否被违反？

或者，可能我的理解有误。根据用户的任务说明中的“更多要求”部分：

“对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)”

所以，对于当前任务，constraint的检查是独立进行的，不管subject和condition是否满足。也就是说，不管该行是否是董监高，或者是否被谴责，只要该行存在减持行为，那么constraint是否被满足？

但MEU中的constraint是“不得减持”，这显然只有在subject和condition都满足的情况下才适用。但根据用户的要求，这里需要将三个条件独立检查。这可能是一个矛盾，但根据用户给出的示例，比如在示例中的constraint检查是独立进行的，比如检查是否存在减持计划以及交易日差是否足够。这可能意味着，在示例中，不管subject和condition是否满足，只要存在减持计划且交易日差足够，则constraint为True。这可能与实际情况不符，但根据用户的要求，必须这样处理。

因此，在当前任务中，constraint的检查需要独立进行，即不管该行是否属于董监高，或者是否被谴责，只要该行存在减持行为，则constraint被标记为False，否则为True。或者，这里的constraint的检查是否应该根据MEU中的要求，即当subject和condition都满足时，是否违反constraint？

但根据用户的要求，对于不需要调用LLM的情况，三个条件的检查是独立的。因此，constraint的检查是独立于subject和condition的。例如，在示例中，constraint的检查是检查是否存在减持计划以及交易日差是否足够，而不管subject和condition是否满足。因此，在当前任务中，constraint的检查应该独立进行，即检查该行是否存在减持行为，如果存在，则constraint为False，否则为True。但MEU中的constraint是“不得减持”，所以只有当减持发生时，才违反constraint。因此，constraint的valid情况是：该行没有减持行为。

但如何判断是否存在减持行为？根据提供的列，可能可以通过“当日减持比例”是否大于0，或者“减持方式”是否非空来判断。例如，如果“当日减持比例”>0，则视为减持。或者，如果存在减持计划，并且在该日执行了减持。但根据用户提供的列，可能“当日减持比例”是更直接的指标。因此，判断该列是否大于0即可。

因此，constraint的valid条件是：该行的“当日减持比例”<=0，或者减持方式为空，或者没有减持行为。如果当日减持比例>0，则constraint为False，否则为True。

但根据MEU的constraint，只有当subject和condition都满足时，才需要遵守不得减持。但根据用户的要求，这里需要将三个条件独立检查。因此，不管该行是否属于董监高或被谴责，只要当日有减持，则constraint标记为False。这可能与实际情况不符，但根据用户的任务要求，必须这样处理。例如，在示例中，constraint的检查是独立进行的，不管subject和condition是否满足。

但根据用户给出的示例中的MEU，其constraint是“应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划”，而示例中的代码检查了是否存在减持计划以及交易日差是否足够，而不管subject和condition是否满足。这可能意味着，在示例中，所有行的constraint都被检查，而不仅仅是那些满足subject和condition的行。因此，在当前任务中，constraint的检查同样需要独立进行，即所有行都要检查是否满足constraint的条件，而不管subject和condition的情况。

因此，对于constraint的检查，需要判断该行是否存在减持行为。如果存在，则constraint为False，否则为True。但根据MEU的约束，只有当subject和condition都满足时，才需要遵守这个constraint。但根据用户的要求，这里需要将三个条件独立检查，所以不管其他条件是否满足，只要该行存在减持，则constraint标记为False。这可能不符合实际法律逻辑，但根据任务要求必须这样处理。

或者，可能我的理解有误。用户可能的意思是，三个条件各自是否满足，而constraint的检查是否满足，但只有当subject和condition都满足时，才需要检查constraint。但根据用户给出的示例，在示例中，constraint的检查是独立进行的，例如，检查所有行的“存在减持计划”和“交易日差”，而不管subject和condition是否满足。因此，在当前任务中，constraint的检查同样需要独立进行，即所有行都要检查是否满足constraint的条件，而不管subject和condition的情况。

这可能是一个矛盾，但根据用户的要求，必须按照示例的方式处理。因此，现在需要明确：

- subject的检查：该行是否是董监高。
- condition的检查：该股东是否在三个月内被公开谴责。
- constraint的检查：该行是否存在减持行为（如当日减持比例>0）。

这三个条件的检查是独立的，每个条件都单独标记True或False，不管其他条件是否满足。

现在，具体到代码实现：

首先，处理subject：

df['meu_14_6_subject'] = (df['股东身份'] == '董监高')

然后，处理condition：

需要确定每个股东被公开谴责的日期，并检查当前日期是否在该日期后的三个月内。

步骤：

1. 筛选出所有“股东涉嫌证券期货违法犯罪事件”为“被本所公开谴责”的行，记录日期。
2. 对每个股东，找到最近的被谴责日期。
3. 对于每个行，计算当前日期与该股东最近被谴责日期的差，是否<=90天。

如何实现？

可以使用groupby来按股东分组，然后对于每个股东，计算到当前行为止的最大谴责日期。例如：

df['condemn_date'] = df.apply(lambda x: x['日期'] if x['股东涉嫌证券期货违法犯罪事件'] == '被本所公开谴责' else pd.NaT, axis=1)

然后，按['公司简称', '股东']分组，对每个组内的condemn_date进行cummax，得到每个行的最新谴责日期：

df['last_condemn_date'] = df.groupby(['公司简称', '股东'])['condemn_date'].cummax()

然后，计算当前日期与last_condemn_date的差是否<=90天：

valid_condition = (df['日期'] - df['last_condemn_date']) <= pd.Timedelta(days=90)

但需要注意，如果last_condemn_date是NaT，则条件不满足。因此，valid_condition需要同时满足last_condemn_date不为NaT，并且日期差<=90天。

所以，valid_condition = (df['last_condemn_date'].notna()) & ((df['日期'] - df['last_condemn_date']) <= pd.Timedelta(days=90))

接下来，处理constraint：

constraint是“不得减持”，即该行是否存在减持行为。根据提供的列，可能可以通过“当日减持比例”是否>0来判断。如果当日减持比例>0，则视为减持，此时constraint为False，否则为True。

所以，valid_constraint = df['当日减持比例'] <= 0

或者，如果当日减持比例是0或NaN，则视为没有减持。但需要确认数据中的情况。例如，如果某行没有减持，则“当日减持比例”可能为0或NaN？假设该列在减持时为正值，否则为0或NaN。因此，valid_constraint应为df['当日减持比例'] <= 0，或者是否为0。或者，可能该列在未减持时为0，减持时为正数。因此，判断是否为0即可。或者，如果该列存在NaN，可能需要填充为0？

但根据用户提供的列描述，“当日减持比例”可能是一个数值列，所以如果当日没有减持，该值可能为0。因此，valid_constraint可以判断该列是否等于0。或者，如果该列存在NaN，可能需要处理。例如，假设未减持时该列为0，减持时为正数。因此，valid_constraint = (df['当日减持比例'] == 0) | (df['当日减持比例'].isna())

但根据用户提供的列信息，可能该列不会有NaN，而是0。因此，valid_constraint = df['当日减持比例'] == 0

或者，可能该列在减持时记录减持的比例，否则为0。因此，只要该列>0，则视为减持，此时constraint为False。否则为True。

所以，valid_constraint = df['当日减持比例'] <= 0

或者，可能该列在减持时是正数，否则为0。因此，判断是否等于0即可。或者，可能该列在减持时是正数，否则为0或NaN。需要明确如何处理NaN。例如，假设NaN表示没有减持，则valid_constraint = (df['当日减持比例'] <= 0) | df['当日减持比例'].isna()

但为了保险起见，可能应该将NaN视为没有减持，因此valid_constraint为True。例如：

valid_constraint = (df['当日减持比例'] <= 0) | df['当日减持比例'].isna()

或者，如果该列在减持时一定会有数值，否则为0或NaN，那么可以这样处理。

综上，constraint的valid条件是当日减持比例<=0或者为NaN，此时为True（即没有减持），否则为False。

现在，将这些条件应用到代码中：

首先，初始化三个列：

df['meu_14_6_subject'] = False
df['meu_14_6_condition'] = False
df['meu_14_6_constraint'] = False  # 或者初始化为None？根据示例中的情况，示例中的constraint初始化为None，但之后设置为True或False。例如，示例中的代码：

df['meu_4_2_constrain'] = None  # constrain需要初始化为None

然后，在示例中，valid_constraint被计算后，用loc来设置True和False。所以，可能正确的做法是初始化为None，然后根据条件设置True或False。

因此，正确的初始化应为：

df['meu_14_6_subject'] = False
df['meu_14_6_condition'] = False
df['meu_14_6_constraint'] = None  # 初始化为None，之后根据条件设置True或False

然后，处理subject：

valid_subject = df['股东身份'] == '董监高'
df.loc[valid_subject, 'meu_14_6_subject'] = True

处理condition：

创建condemn_date列：

df['condemn_date'] = pd.NaT
mask = df['股东涉嫌证券期货违法犯罪事件'] == '被本所公开谴责'
df.loc[mask, 'condemn_date'] = df.loc[mask, '日期']

然后，按公司和股东分组，计算每个组的cummax：

df['last_condemn_date'] = df.groupby(['公司简称', '股东'])['condemn_date'].cummax()

然后，计算valid_condition：

valid_condition = df['last_condemn_date'].notna() & (df['日期'] - df['last_condemn_date'] <= pd.Timedelta(days=90))

df.loc[valid_condition, 'meu_14_6_condition'] = True

处理constraint：

valid_constraint = (df['当日减持比例'] <= 0) | df['当日减持比例'].isna()

df.loc[valid_constraint, 'meu_14_6_constraint'] = True
df.loc[~valid_constraint, 'meu_14_6_constraint'] = False

但根据用户示例中的处理方式，constraint的初始化为None，然后根据条件设置为True或False。例如，在示例中：

valid_constraint = ... 

df.loc[valid_constraint, 'meu_4_1_constraint'] = True
df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

因此，在当前任务中，同样需要这样处理。

综上，完整的代码可能如下：

import pandas as pd

def check_meu_14_6(df):
    '''
    检查MEU_14_6的合规性：
    subject: 上市公司董监高
    condition: 本人因涉及与本上市公司有关的违法违规，被证券交易所公开谴责未满三个月
    constraint: 不得减持其所持有的本公司股份
    '''
    df = df.copy()

    # 初始化标记列
    df['meu_14_6_subject'] = False
    df['meu_14_6_condition'] = False
    df['meu_14_6_constraint'] = None  # 初始化为None，之后根据条件设置True/False

    # 标记subject
    valid_subject = df['股东身份'] == '董监高'
    df.loc[valid_subject, 'meu_14_6_subject'] = True

    # 标记condition
    # 创建condemn_date列，记录被公开谴责的日期
    df['condemn_date'] = pd.NaT
    mask_condemn = df['股东涉嫌证券期货违法犯罪事件'] == '被本所公开谴责'
    df.loc[mask_condemn, 'condemn_date'] = df.loc[mask_condemn, '日期']

    # 按公司和股东分组，计算每个股东的最新谴责日期
    df['last_condemn_date'] = df.groupby(['公司简称', '股东'])['condemn_date'].cummax()

    # 计算是否在三个月内
    valid_condition = (
        df['last_condemn_date'].notna() &
        ((df['日期'] - df['last_condemn_date']) <= pd.Timedelta(days=90))
    )
    df.loc[valid_condition, 'meu_14_6_condition'] = True

    # 标记constraint
    # 检查当日是否有减持（当日减持比例>0）
    has_reduction = df['当日减持比例'] > 0
    valid_constraint = ~has_reduction
    df.loc[valid_constraint, 'meu_14_6_constraint'] = True
    df.loc[~valid_constraint, 'meu_14_6_constraint'] = False

    # 清理临时列
    df.drop(columns=['condemn_date', 'last_condemn_date'], inplace=True)

    return df

但需要注意以下几点：

1. 在计算last_condemn_date时，是否应该使用cummax？例如，对于每个股东，每个行的last_condemn_date是该行之前（包括当前行）的最大condemn_date。这样，当某股东在某个日期被谴责后，之后的所有行的last_condemn_date都会是该日期，直到有新的谴责日期出现。这可能正确，因为一旦被谴责，该日期就是最新的，后续的日期不会更早。

例如，假设股东A在2023-01-01被谴责，然后在2023-02-01又被谴责，那么对于2023-03-01的行，last_condemn_date是2023-02-01，而三个月后的日期是2023-05-01。因此，在2023-03-01到2023-05-01之间的日期，condition为True。

2. 在计算valid_condition时，是否应该使用自然日还是交易日？根据MEU的描述，condition中的三个月是自然日。因此，使用pd.Timedelta(days=90)是合理的，尽管实际可能三个月是90天或91天，但这里假设三个月为90天。

3. 在计算减持时，是否应该考虑其他减持方式？例如，减持方式列中的“竞价交易”、“大宗交易”等。但根据constraint的描述，无论减持方式如何，只要减持就违反。因此，只要当日减持比例>0，无论减持方式如何，都视为违反constraint。

4. 在示例中，constraint的检查是独立进行的，即不管subject和condition是否满足，只要存在减持计划且交易日差足够，就标记为True。因此，在当前任务中，constraint的检查同样独立，即不管是否是董监高或被谴责，只要当日没有减持，就标记为True，否则False。

综上，上述代码应该能够满足任务要求。
","CompletionUsage(completion_tokens=5533, prompt_tokens=1704, total_tokens=7237, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=5027, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_9_1
法律的最小可执行单元内容: {""subject"": ""控股股东 | 实际控制人 | 董监高"", ""condition"": ""公司上市时未盈利且处于实现盈利前阶段"", ""constraint"": ""自公司股票上市之日起2个完整会计年度内不得减持公开发行并上市前股份"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_9_1(df):
    '''
    检查MEU_9_1合规性：
    subject: 控股股东 | 实际控制人 | 董监高
    condition: 公司上市时未盈利且处于实现盈利前阶段
    constraint: 自上市之日起2个完整会计年度内不得减持公开发行前股份
    '''
    df = df.copy()

    # 初始化标记列
    df['meu_9_1_subject'] = False
    df['meu_9_1_condition'] = False
    df['meu_9_1_constraint'] = True  # 默认符合约束

    # 标记subject(独立检查)
    valid_subject = df['股东身份'].isin(['控股股东', '实际控制人', '董监高'])
    df.loc[valid_subject, 'meu_9_1_subject'] = True

    # 计算公司上市时净利润(按公司映射)
    company_ipo_profit = df.groupby('公司简称').apply(
        lambda x: x.set_index('日期').loc[x['上市日期'].iloc[0], '净利润']
    ).to_dict()
    df['_temp_ipo_profit'] = df['公司简称'].map(company_ipo_profit)

    # 计算两年后日期(自然年)
    df['_temp_two_year'] = df['上市日期'] + pd.DateOffset(years=2)

    # 标记condition(独立检查)
    ipo_unprofit = (df['_temp_ipo_profit'] <= 0)
    in_period = (df['日期'] <= df['_temp_two_year'])
    df['meu_9_1_condition'] = ipo_unprofit & in_period

    # 标记constraint(独立检查)
    has_sold = (df['当日减持比例'] > 0)
    df['meu_9_1_constraint'] = ~(in_period & has_sold)

    # 清理临时列
    df.drop(columns=['_temp_ipo_profit', '_temp_two_year'], inplace=True)
    
    return df
</CODE>","好的，我现在需要处理这个MEU_9_1的合规性检查。首先，我得仔细理解这个MEU的内容。责任主体是控股股东、实际控制人或董监高。触发条件是公司上市时未盈利且处于实现盈利前的阶段。约束内容是在上市后的两个完整会计年度内不得减持公开发行前的股份。

首先，我需要确定如何标记subject。根据提供的股东身份列，我需要检查股东是否是控股股东、实际控制人或董监高。这里需要注意的是，股东身份列中的值可能包括这些类别，所以可以直接用isin方法来判断。比如，df['股东身份'].isin(['控股股东', '实际控制人', '董监高'])，这样就能得到有效的subject。

接下来是condition的条件。这里需要判断公司上市时未盈利，并且当前仍处于盈利前的阶段。如何确定公司上市时是否盈利呢？可能需要查看公司上市时的净利润是否为负或者零。而处于实现盈利前阶段可能意味着，从上市到当前日期为止，公司还没有实现盈利。或者，可能要看公司是否在上市后的两个会计年度内仍未盈利？

不过，根据MEU的约束条件，约束是自上市之日起两个完整会计年度内不得减持。所以这里的condition可能是指公司上市时未盈利，并且在这两个会计年度内还未盈利。或者，可能只要公司上市时未盈利，不管之后是否盈利，在这两个会计年度内都受约束？

需要明确条件的具体含义。根据MEU的描述，“公司上市时未盈利且处于实现盈利前阶段”，可能意味着公司上市时未盈利，并且当前还未实现盈利。或者，只要上市时未盈利，不管之后是否盈利，在这两个会计年度内都适用？

假设这里的条件是公司上市时未盈利，并且在这两个会计年度内，无论是否盈利，都适用。或者，可能要看公司是否在上市后的两个完整会计年度内仍未盈利？

可能需要进一步分析。例如，公司上市时的净利润是否为负或零。然后，在上市后的两个完整会计年度内，是否处于盈利前的阶段。例如，如果公司在这两年中的任何一个会计年度实现了盈利，那么是否就不再处于该阶段？

或者，可能这里的“处于实现盈利前阶段”指的是在上市后的两个会计年度结束前，公司尚未实现盈利。或者，不管是否盈利，只要在两年内，都受约束？

这个问题可能需要更仔细的理解。根据MEU的约束内容，约束是自上市之日起两个完整会计年度内不得减持。所以，不管公司在这两年内是否盈利，只要上市时未盈利，那么在这两年内都受约束。而触发条件中的“处于实现盈利前阶段”可能指的是在这两年期间内，公司还未盈利。或者，可能触发条件中的“处于实现盈利前阶段”是附加的条件，即公司上市时未盈利，并且当前还未盈利？

这可能需要更多的信息。例如，假设公司上市时未盈利，但之后在第一年就盈利了，那么是否还满足触发条件？

根据MEU的原文，“公司上市时未盈利且处于实现盈利前阶段”，这里的“且”可能意味着，这两个条件都需要满足。也就是说，公司上市时未盈利，并且当前仍处于盈利前的阶段。因此，如果公司在上市后的某个时间点已经盈利了，那么就不再满足触发条件，此时约束可能不再适用？

或者，这里的“处于实现盈利前阶段”可能指的是整个两个会计年度期间，无论是否盈利，只要上市时未盈利，就满足条件？

这个问题可能需要结合法律条文的理解。例如，假设约束是无论之后是否盈利，只要上市时未盈利，那么在两年内都不得减持。那么触发条件中的“处于实现盈利前阶段”可能只是说明公司上市时的状态，而不管之后的情况。或者，可能触发条件中的两个条件都需要满足，即上市时未盈利，并且当前还未盈利。

在这种情况下，可能需要确定如何计算这两个条件。例如，公司上市时的净利润是否为负或零，以及当前日期是否在上市后的两个完整会计年度内，并且公司在该期间内尚未盈利。

这可能比较复杂。例如，如何确定公司上市时的净利润？可能需要获取公司上市时的财务数据。在给定的数据列中，有'净利润'这一列，但这是否是当期的净利润？例如，每个交易日可能有不同的净利润？这显然不合理，因为净利润通常是按季度或年度报告的。可能数据中的净利润是最近一个报告期的数据？

或者，可能这里的净利润是指公司上市时的财务数据，即首次公开发行时的财务数据。例如，假设公司上市时的净利润为负，那么上市时未盈利。而之后，每个报告期的净利润可能变化。例如，如果在上市后的第一个会计年度实现了盈利，那么是否还处于“实现盈利前阶段”？

这可能涉及到如何判断公司是否已经盈利。例如，在上市后的两个会计年度内，只要有一个会计年度的净利润为正，那么就不再处于盈利前阶段？

或者，这里的“处于实现盈利前阶段”指的是公司自上市以来从未实现盈利，直到当前日期为止？

这个问题可能需要更明确的规则。例如，假设公司上市时的净利润为负，那么触发条件中的“公司上市时未盈利”成立。而“处于实现盈利前阶段”需要判断当前是否在上市后的两个会计年度内，并且公司在这期间尚未盈利。

例如，假设公司上市日期是2020-01-01，那么两个完整会计年度是2020年和2021年。在这两年内，如果公司在这两个会计年度的净利润均为负，则处于盈利前阶段。如果其中任何一个年度的净利润为正，则可能不再处于该阶段？

或者，这里的“处于实现盈利前阶段”可能指的是公司尚未实现首次盈利，无论时间是否超过两年？

这可能需要更明确的逻辑。例如，如果公司上市时未盈利（即上市时的净利润<=0），并且在当前日期时，公司尚未有任何会计年度的净利润>0，则满足条件。

或者，可能触发条件中的“处于实现盈利前阶段”是指公司当前仍处于未盈利状态，无论是否在两年内？

这可能需要结合数据中的净利润字段。例如，每个交易日的数据中，净利润可能代表最近一个报告期的数据。例如，如果净利润>0，则公司已经盈利，否则未盈利。

假设在数据中，每个交易日都有最新的净利润数据，那么我们可以判断，在每一个交易日，公司是否已经盈利。如果公司上市时未盈利（即上市时的净利润<=0），并且在当前交易日，公司的最近报告期净利润<=0，则满足条件。

但这里的数据结构可能存在问题，因为净利润通常是季度或年度数据，而不是每日数据。所以，可能数据中的净利润是最近一个报告期的数据，例如，每个季度的数据会被填充到该季度的所有交易日中。

在这种情况下，判断公司是否处于盈利前阶段，可能需要检查自上市以来，是否有任何一个报告期的净利润>0。如果有，则不再处于盈利前阶段；否则，仍处于该阶段。

或者，可能触发条件中的“处于实现盈利前阶段”仅指公司上市时未盈利，而不管之后的情况，只要在上市后的两个会计年度内，无论是否盈利，都适用约束？

这可能需要根据法律条文的具体规定来判断。例如，假设法律条文规定，只要公司上市时未盈利，那么控股股东等在上市后的两个会计年度内不得减持，无论这两个年度内公司是否盈利。此时，触发条件中的“处于实现盈利前阶段”可能只是指公司上市时未盈利，而不管之后的情况。

这种情况下，condition的判断可能只需要公司上市时的净利润<=0，并且当前日期在上市后的两个完整会计年度内。

例如，公司上市日期是D，那么两个完整会计年度后的日期是D + 2年。如果当前日期在该日期之前，则满足条件。

但如何确定两个完整会计年度？例如，如果公司上市日期是2020-03-15，那么两个完整会计年度可能是指2020年和2021年，或者可能是指从上市日起的两年？

这可能因公司会计年度的定义而异。例如，如果公司的会计年度是自然年度，那么上市日期在2020年，则两个完整会计年度是2020和2021年。如果当前日期在2022年1月1日之后，则已经过了两个完整会计年度。

或者，可能需要计算自上市日期起，加上两个完整的会计年度。例如，如果公司上市日期是2020-06-30，那么第一个会计年度可能到2020-12-31结束，第二个到2021-12-31。所以，两个完整会计年度后的日期是2021-12-31。如果当前日期在2022年1月1日之后，则不再处于该阶段。

这可能比较复杂。在数据中，如何确定两个完整会计年度？

假设数据中的'上市日期'列是公司的上市日期，例如，某公司的上市日期是某个具体的日期。那么，两个完整会计年度后的日期可以通过将年份加2，并保持月份和日期相同？例如，上市日期是2020-05-15，那么两个完整会计年度后的日期是2022-05-15？

或者，会计年度可能与自然年度不同，例如，公司的会计年度结束日是每年的6月30日。此时，可能需要根据公司的会计年度来计算两个完整会计年度后的日期。但数据中可能没有会计年度的信息，所以可能需要假设会计年度是自然年度。

在这种情况下，可能需要将两个完整会计年度视为自上市日期起两年后的同一日期。例如，上市日期是2020-03-01，那么两个完整会计年度后的日期是2022-03-01。如果当前日期在该日期之前，则处于两个完整会计年度内。

因此，condition的条件可能分为两部分：

1. 公司上市时未盈利：即公司上市时的净利润<=0。如何确定公司上市时的净利润？可能需要获取公司上市时的财务数据。例如，在数据中，每个公司的上市日期是已知的，那么可以取该公司在上市日期对应的财务数据中的净利润是否<=0。或者，可能数据中的'净利润'列是每个报告期的最新数据，而公司上市时的净利润可能需要在上市当天的数据中查找。

但数据中的每一行是日频数据，每个交易日都有该公司的财务数据。这可能不太合理，因为财务数据通常是季度或年度更新的。因此，可能数据中的财务数据（如净利润）是最近一次报告期的数据，例如，每个季度的数据会被填充到该季度的所有交易日中。

在这种情况下，要确定公司上市时的净利润，可能需要找到该公司上市日期所在季度的财务数据中的净利润。或者，可能公司上市时的净利润是首次公开时的数据，例如，在上市当天的数据中，净利润是否为负或零。

假设在数据中，每个公司的'上市日期'列是已知的，并且每个公司的财务数据在上市当天的数据中反映了上市时的净利润。例如，对于某公司，其上市日期是某一天，当天的净利润即为上市时的净利润。因此，我们可以通过筛选该公司在上市当天的数据中的净利润来判断是否未盈利。

但如何获取每个公司的上市当天的净利润？可能需要按公司分组，然后找到每个公司的上市日期对应的行，并获取该行的净利润值。

例如，对于每个公司，找到其上市日期对应的行，然后检查该行的净利润是否<=0。如果是，则该公司上市时未盈利。

然后，对于每个交易日，判断该日期是否在该公司上市日期后的两个完整会计年度内。如果是，并且公司上市时未盈利，则触发条件成立。

或者，触发条件中的“处于实现盈利前阶段”可能还需要公司当前仍未盈利。例如，在上市后的两个会计年度内，并且当前净利润仍<=0。

这可能需要同时满足两个条件：公司上市时未盈利，并且当前日期在上市后的两个会计年度内，并且当前净利润<=0。

或者，可能触发条件中的“处于实现盈利前阶段”仅指公司上市时未盈利，而不管当前是否盈利，只要在两年内。

这需要根据法律条文的具体规定。例如，假设MEU中的约束是，只要公司上市时未盈利，那么控股股东等在两年内不得减持，无论这两年内公司是否盈利。此时，触发条件中的“处于实现盈利前阶段”可能只是公司上市时未盈利，并且当前日期在两年内。

在这种情况下，condition的条件是：

公司上市时未盈利（即上市当天的净利润<=0），并且当前日期在上市日期后的两年内。

此时，如何计算两年后的日期？例如，上市日期是2020-05-15，那么两年后的日期是2022-05-15。如果当前行的日期在该日期之前，则满足条件。

现在，如何实现这一点？

首先，需要为每个公司确定其上市日期，并计算两年后的日期。然后，对于每一行，判断该行的日期是否在上市日期和两年后的日期之间，并且该公司上市时的净利润<=0。

在数据中，每一行包含公司简称、日期等信息。因此，需要按公司简称分组，获取每个公司的上市日期，并计算两年后的日期。

例如，在代码中，可以创建一个新列，表示每个公司的上市日期对应的两年后的日期。然后，对于每一行，判断当前日期是否在上市日期之后，且在两年后的日期之前，并且该公司上市时的净利润<=0。

但如何获取每个公司上市当天的净利润？

可能需要为每个公司找到其上市日期对应的行，然后获取该行的净利润值。例如，对于每个公司，上市日期是df['上市日期']，然后在该公司的数据中，找到日期等于上市日期的行，取该行的净利润作为上市时的净利润。

但数据是按日频的，可能上市当天的数据存在吗？例如，假设公司上市日期是某个交易日，那么该公司的数据中应该包含该日的记录。因此，可以按公司分组，然后对于每个公司，找到其上市日期对应的净利润。

这可能需要使用groupby和transform等方法。例如：

df['上市时净利润'] = df.groupby('公司简称')['净利润'].transform(lambda x: x[x['日期'] == x['上市日期'].iloc[0]].iloc[0])

但这里可能存在一些问题，比如，每个公司的上市日期可能不同，且每个公司的数据中是否包含上市当天的记录？

假设数据中的每个公司都有上市当天的记录，那么可以这样处理。

然后，判断公司上市时是否未盈利的条件是：df['上市时净利润'] <= 0。

同时，当前日期是否在上市日期后的两年内：df['日期'] <= (df['上市日期'] + pd.DateOffset(years=2))

或者，可能需要计算两个完整的会计年度。例如，如果上市日期是2020-03-15，那么两个完整会计年度后的日期是2022-03-15。当前日期是否在该日期之前？

因此，condition的条件是：

(公司上市时净利润 <= 0) & (当前日期 <= 上市日期 + 2年)

此外，是否还需要考虑公司是否已经盈利？例如，如果公司在两年内已经盈利，是否还满足触发条件？

根据MEU的原文，触发条件是“公司上市时未盈利且处于实现盈利前阶段”。这里的“处于实现盈利前阶段”可能指的是公司尚未实现盈利。因此，可能还需要当前净利润<=0。

或者，可能这里的“处于实现盈利前阶段”指的是在上市后的两个会计年度内，无论是否盈利，只要上市时未盈利，就满足条件？

这需要明确法律条文的具体含义。例如，如果法律条文规定，只要公司上市时未盈利，控股股东等在两年内不得减持，无论这两年内公司是否盈利，那么触发条件中的“处于实现盈利前阶段”可能只是指公司上市时未盈利，并且当前日期在两年内。

在这种情况下，condition的条件是：

公司上市时未盈利，并且当前日期在上市后的两年内。

此时，不需要考虑当前是否盈利，只要在两年内，就满足触发条件。

这可能更符合MEU的约束内容，因为约束是“自公司股票上市之日起2个完整会计年度内不得减持”，无论期间是否盈利。

因此，触发条件中的“处于实现盈利前阶段”可能只是补充说明，而实际触发条件可能只需要公司上市时未盈利，并且当前日期在两年内。

因此，condition的条件是：

公司上市时未盈利，并且当前日期在上市后的两年内。

现在，如何实现这一点？

步骤：

1. 对每个公司，获取其上市日期和上市时的净利润。

2. 计算每个公司的两年后的日期（上市日期 + 2年）。

3. 判断当前行的日期是否在上市日期之后，且在两年后的日期之前，并且上市时的净利润<=0。

这样，condition的条件就满足了。

接下来是constraint的约束内容：自公司股票上市之日起2个完整会计年度内不得减持公开发行并上市前股份。

这里的约束是，在两年内，股东不能减持公开发行前的股份。因此，需要检查股东是否在两年内减持了这些股份。

但如何判断减持的是否为公开发行前的股份？根据附加信息中的说明，“持股比例”全部是公开上市前取得的股份。因此，所有减持的股份都属于公开发行前的股份。因此，只要在两年内减持，就违反约束。

因此，constraint的条件是：在两年内，股东没有减持行为。或者，在两年内，股东减持的数量是否为0？

或者，约束是股东在两年内不得减持，因此，任何减持行为都是违规的。

在数据中，如何判断股东是否在两年内减持？

可能需要检查该股东在该交易日是否有减持行为。例如，当日减持比例>0，或者累计减持比例增加。

或者，可能数据中的'当日减持比例'列表示该股东在该交易日减持的比例。如果该值>0，则表示当日有减持行为。

因此，constraint的条件是：在上市后的两年内，股东没有进行任何减持（即当日减持比例<=0）。

但根据MEU的约束，股东在两年内不得减持。因此，任何在两年内的减持行为都是违规的。因此，constraint的valid条件是：在两年内，股东没有减持行为。即，当日减持比例<=0，并且累计减持比例在两年内没有增加。

或者，可能约束的检查是针对减持计划的。例如，股东是否有计划在两年内减持，或者是否实际减持。

根据MEU的约束内容，是“不得减持”，因此，实际减持行为是否发生是判断依据。因此，如果股东在两年内的任何交易日有减持行为（当日减持比例>0），则违反约束。

因此，constraint的valid条件是：在上市后的两年内，该股东没有减持行为（即当日减持比例<=0）。

但如何确定该减持行为是否发生在两年内？

例如，对于每一行，如果该行的日期在上市后的两年内，并且当日减持比例>0，则constraint不满足，即valid_constraint为False。

否则，如果日期在两年之后，或者当日减持比例<=0，则valid_constraint为True？

或者，constraint的检查是针对减持行为是否发生在两年内。因此，对于每一行，如果该行的日期在两年内，并且当日减持比例>0，则constraint不满足。否则，满足。

因此，constraint的valid条件为：

如果该行日期在上市后的两年内，并且当日减持比例>0 → 违反约束 → valid_constraint为False。

否则 → valid_constraint为True。

但根据MEU的约束，股东在两年内不得减持。因此，任何在两年内的减持行为都是违规的。因此，在两年内的任何减持行为都会导致constraint为False，而两年之外的减持行为不影响。

因此，constraint的检查需要判断：如果该行的日期在上市后的两年内，并且当日减持比例>0 → 违规 → valid_constraint为False。否则，valid_constraint为True。

但根据任务要求，对于三元组的检查是各自独立的，需要分别标记。因此，constraint的检查是独立于subject和condition的。也就是说，不管subject和condition是否满足，都要检查constraint的条件，并标记valid情况。

但根据附加要求中的说明：“对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)”

因此，对于MEU_9_1，constraint的检查是独立的，不需要考虑subject和condition是否满足。因此，无论subject和condition是否为True，都要检查constraint的条件，并标记valid_constraint。

但根据MEU的约束内容，约束是“自公司股票上市之日起2个完整会计年度内不得减持公开发行并上市前股份”，因此，只有当股东是subject（控股股东等）且公司满足condition（上市未盈利且在两年内）时，才需要遵守该约束。但根据任务要求，这里的constraint检查是独立的，即不管subject和condition是否满足，都要检查该约束是否被满足。这可能与实际的法律逻辑不符，但根据任务要求，必须这样做。

这可能是一个矛盾。例如，如果某个股东不是subject（例如普通股东），但根据constraint的独立检查，其减持行为在两年内是否会被标记为违规？

根据任务要求，是的。但根据法律条文，约束仅适用于subject。因此，这可能是一个问题。但根据任务中的示例，例如MEU_4_1的代码中，constraint的检查是独立的，例如：

在示例中，valid_constraint的计算是基于存在减持计划和交易日差>=15，而不管subject和condition是否满足。这可能意味着，在示例中，constraint的检查是独立的，即不管subject和condition是否满足，都标记该行是否满足constraint的条件。

这可能与实际的法律逻辑不符，但根据任务要求，必须这样处理。因此，在MEU_9_1中，constraint的检查也需要独立进行，即不管subject和condition是否满足，只要在上市后的两年内减持，就标记为违反约束。

但根据法律条文，约束仅适用于subject在满足condition的情况下。因此，这可能是一个错误。但根据任务要求，必须按照示例的方式处理，即三元组的检查是独立的。

因此，在编写代码时，需要将subject、condition、constraint的检查独立进行，分别标记各自的valid情况，不管其他条件是否满足。

现在，回到constraint的检查：

constraint的条件是：在上市后的两年内，股东没有减持行为。即，如果该行的日期在上市后的两年内，并且当日减持比例>0，则valid_constraint为False，否则为True。

但如何确定上市后的两年？

同样，需要为每个公司计算上市日期后的两年，然后判断当前日期是否在该期间内。

因此，步骤：

1. 对每个公司，计算上市日期后的两年日期：上市日期 + 2年。

2. 对于每一行，如果日期在上市日期和两年日期之间，并且当日减持比例>0 → valid_constraint为False。

否则 → valid_constraint为True。

但需要注意，这里可能每个公司的上市日期不同，因此需要按公司分组处理。

现在，将这些逻辑转化为代码：

首先，处理subject：

df['meu_9_1_subject'] = df['股东身份'].isin(['控股股东', '实际控制人', '董监高'])

或者，可能还需要考虑持股比例是否>=5%的情况？例如，股东身份可能为董监高，同时持股比例>=5%。但根据附加信息中的说明，股东身份列中的标签不会并列出现，例如，董监高即使持股超过5%也不会被标记为“持股5%以上股东”，因此，需要手动判断。

但根据MEU_9_1的subject是“控股股东 | 实际控制人 | 董监高”，因此，直接根据股东身份列中的值来判断即可，不需要考虑持股比例。例如，如果股东身份是“董监高”，则属于subject，而不管其持股比例。而如果股东身份是“离任董监高”，则不属于subject，除非MEU中的subject包括离任的。

但MEU中的subject是“控股股东 | 实际控制人 | 董监高”，离任董监高可能不属于董监高。因此，股东身份为“离任董监高”的不属于subject。

因此，subject的条件是：

df['股东身份'].isin(['控股股东', '实际控制人', '董监高'])

接下来，处理condition：

condition的条件是公司上市时未盈利，并且当前日期在上市后的两年内。

首先，需要确定公司上市时的净利润是否<=0。这需要获取每个公司上市日期对应的净利润。

在代码中，可以按公司分组，然后找到每个公司上市日期对应的净利润：

df['上市时净利润'] = df.groupby('公司简称').apply(lambda x: x.loc[x['日期'] == x['上市日期'].iloc[0], '净利润'].iloc[0]).reset_index(level=0, drop=True)

或者，使用transform：

df['上市时净利润'] = df.groupby('公司简称')['净利润'].transform(lambda x: x[x['日期'] == x['上市日期'].iloc[0]].iloc[0])

但需要确保每个公司的上市日期存在，并且对应的净利润存在。

然后，计算两年后的日期：

df['两年后日期'] = df['上市日期'] + pd.DateOffset(years=2)

然后，判断当前日期是否在上市日期之后，且在两年后日期之前：

condition1 = df['日期'] <= df['两年后日期']

同时，公司上市时净利润<=0：

condition2 = df['上市时净利润'] <= 0

因此，valid_condition = condition1 & condition2

但根据MEU的condition描述，“公司上市时未盈利且处于实现盈利前阶段”，这里的“处于实现盈利前阶段”可能指的是在两年内，因此，valid_condition的条件是公司上市时未盈利，并且当前日期在两年内。

因此，valid_condition = (df['上市时净利润'] <= 0) & (df['日期'] <= df['两年后日期'])

接下来，处理constraint：

constraint的条件是，在两年内，股东没有减持。即，如果当前日期在两年内，并且当日减持比例>0，则违反约束，valid_constraint为False。否则为True。

因此：

valid_constraint = ~((df['日期'] <= df['两年后日期']) & (df['当日减持比例'] > 0))

或者：

within_two_years = df['日期'] <= df['两年后日期']
has_sold = df['当日减持比例'] > 0
valid_constraint = ~(within_two_years & has_sold)

但根据任务要求，constraint的检查是独立的，即不管subject和condition是否满足，都要标记是否满足约束条件。因此，即使某个股东不是subject，或者公司不满足condition，只要在两年内减持，就会被标记为constraint不满足。

这可能与实际法律条文不符，但根据任务要求必须如此处理。

现在，将这些逻辑整合到代码中：

首先，初始化各列：

df['meu_9_1_subject'] = False
df['meu_9_1_condition'] = False
df['meu_9_1_constraint'] = None  # 之后会被设置为True或False

然后，计算各条件：

# 处理subject
valid_subject = df['股东身份'].isin(['控股股东', '实际控制人', '董监高'])
df.loc[valid_subject, 'meu_9_1_subject'] = True

# 处理condition
# 计算每个公司的上市时净利润
# 注意：这里假设每个公司的上市日期在数据中存在对应的行，并且该行的净利润正确
# 按公司分组，获取上市日期对应的净利润
# 方法：创建一个临时列，按公司简称分组，取上市日期对应的净利润
# 使用groupby + transform
# 但transform的函数可能无法直接处理日期匹配，因此可能需要更复杂的处理

# 另一种方法：创建一个映射，每个公司的上市日期对应的净利润
company_ipo_profit = df.groupby('公司简称').apply(lambda x: x.set_index('日期').loc[x['上市日期'].iloc[0], '净利润']).to_dict()
df['上市时净利润'] = df['公司简称'].map(company_ipo_profit)

# 计算两年后的日期
df['两年后日期'] = df['上市日期'] + pd.DateOffset(years=2)

# 判断当前日期是否在两年内
within_two_years = df['日期'] <= df['两年后日期']
# 判断公司上市时是否未盈利
ipo_not_profitable = df['上市时净利润'] <= 0
valid_condition = within_two_years & ipo_not_profitable
df.loc[valid_condition, 'meu_9_1_condition'] = True

# 处理constraint
# 判断是否在两年内减持
has_sold = df['当日减持比例'] > 0
constraint_violation = within_two_years & has_sold
df['meu_9_1_constraint'] = ~constraint_violation
# 将布尔值转换为True/False
df['meu_9_1_constraint'] = df['meu_9_1_constraint'].astype(bool)

但需要注意，在初始化时，meu_9_1_constraint被设置为None，这里可能需要直接赋值：

或者，直接计算：

df['meu_9_1_constraint'] = ~(within_two_years & has_sold)

但需要确保数据类型正确。

现在，将这些步骤整合到函数中：

import pandas as pd

def check_meu_9_1(df):
    '''
    检查MEU_9_1的合规性：
    subject: 控股股东 | 实际控制人 | 董监高
    condition: 公司上市时未盈利且处于实现盈利前阶段
    constraint: 自上市之日起2个完整会计年度内不得减持公开发行前股份
    '''
    df = df.copy()

    # 初始化标记列
    df['meu_9_1_subject'] = False
    df['meu_9_1_condition'] = False
    df['meu_9_1_constraint'] = True  # 默认认为符合约束，除非条件满足

    # 标记subject
    valid_subject = df['股东身份'].isin(['控股股东', '实际控制人', '董监高'])
    df.loc[valid_subject, 'meu_9_1_subject'] = True

    # 计算每个公司上市时的净利润
    # 创建公司到上市时净利润的映射
    company_ipo_profit = df.groupby('公司简称').apply(
        lambda x: x.set_index('日期').loc[x['上市日期'].iloc[0], '净利润']
    ).to_dict()
    df['上市时净利润'] = df['公司简称'].map(company_ipo_profit)

    # 计算两年后的日期
    df['两年后日期'] = df['上市日期'] + pd.DateOffset(years=2)

    # 标记condition
    # 公司上市时未盈利且当前日期在两年内
    ipo_not_profitable = df['上市时净利润'] <= 0
    within_two_years = df['日期'] <= df['两年后日期']
    valid_condition = ipo_not_profitable & within_two_years
    df.loc[valid_condition, 'meu_9_1_condition'] = True

    # 标记constraint
    # 在两年内减持则违规
    has_sold = df['当日减持比例'] > 0
    constraint_violation = within_two_years & has_sold
    df.loc[constraint_violation, 'meu_9_1_constraint'] = False

    # 清理临时列
    df.drop(columns=['上市时净利润', '两年后日期'], inplace=True)

    return df

但需要注意，在计算company_ipo_profit时，可能存在groupby的问题。例如，每个公司的上市日期可能不同，且每个公司必须有上市日期的记录。假设数据中的每个公司都有上市日期的记录，并且该日期的净利润存在，则此方法有效。

此外，在计算两年后的日期时，使用pd.DateOffset(years=2)可能更准确，因为它会考虑闰年等情况。

另外，在标记constraint时，初始值设为True，然后对于违规的行设置为False。这可能更高效。

最后，清理临时生成的列，如'上市时净利润'和'两年后日期'。

现在，测试这个函数是否满足要求：

例如，对于某公司，上市日期为2020-01-01，上市时的净利润为-100万（即<=0），则：

- 在2020-01-01到2022-01-01之间的日期，condition为True。
- 对于subject为控股股东的行，subject标记为True。
- 对于在两年内的日期，如果当日减持比例>0，则constraint标记为False。

对于另一个公司，上市时净利润为100万（>0），则condition为False，无论日期是否在两年内。

对于股东身份为普通股东的行，subject标记为False。

对于在两年后的日期，减持行为不影响constraint，因为此时constraint的条件不适用，所以标记为True。

综上，这个函数应该能够正确标记各条件。
","CompletionUsage(completion_tokens=7556, prompt_tokens=1721, total_tokens=9277, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=7078, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_11_3
法律的最小可执行单元内容: {""subject"": ""上市公司控股股东 | 实际控制人"", ""condition"": ""上市公司被本所公开谴责未满3个月"", ""constraint"": ""不得减持其所持有的本公司股份"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_11_3(df):
    '''
    验证MEU_11_3合规性：
    ""subject"": ""上市公司控股股东 | 实际控制人"", 
    ""condition"": ""上市公司被本所公开谴责未满3个月"", 
    ""constraint"": ""不得减持其所持有的本公司股份""
    '''
    df = df.copy()

    # 初始化标记列
    df['meu_11_3_subject'] = False
    df['meu_11_3_condition'] = False
    df['meu_11_3_constraint'] = None

    # 1. 标记valid的subject
    valid_subject = df['股东身份'].isin(['控股股东', '实际控制人'])
    df.loc[valid_subject, 'meu_11_3_subject'] = True

    # 2. 标记valid的condition
    # 获取各公司被公开谴责的日期列表
    condemn_dates = (
        df[df['公司涉嫌证券期货违法犯罪事件'] == '被本所公开谴责']
        .groupby('公司简称')['日期']
        .apply(list)
        .to_dict()
    )

    # 定义日期检查函数
    def check_condemn_window(row):
        company = row['公司简称']
        current_date = row['日期']
        for d in condemn_dates.get(company, []):
            if 0 <= (current_date - d).days <= 90:
                return True
        return False

    df['meu_11_3_condition'] = df.apply(check_condemn_window, axis=1)

    # 3. 标记valid的constraint（独立检查）
    # 通过当日减持比例判断是否发生减持
    valid_constraint = df['当日减持比例'] <= 0
    df.loc[valid_constraint, 'meu_11_3_constraint'] = True
    df.loc[~valid_constraint, 'meu_11_3_constraint'] = False

    return df
</CODE>","好的，我现在需要处理这个MEU_11_3的合规性检查任务。首先，我得仔细理解这个MEU的具体内容。根据给定的信息，MEU_11_3的subject是“上市公司控股股东 | 实际控制人”，condition是“上市公司被本所公开谴责未满3个月”，constraint是“不得减持其所持有的本公司股份”。我的任务是为输入的DataFrame中的每一行标记这三个条件的满足情况。

首先，处理subject部分。根据附加信息中的股东身份列，合法的subject是控股股东或实际控制人。所以，我需要检查每一行的股东身份是否是这两个中的一个。DataFrame中的股东身份列包含['控股股东', '实际控制人']，所以可以直接用isin方法筛选。这一步应该比较简单，标记meu_11_3_subject列为True或False。

接下来是condition部分。条件是上市公司被本所公开谴责未满3个月。这里需要确定的是，在当前的日期（即该行的日期）之前的三个月内，公司是否被公开谴责过。公司涉嫌证券期货违法犯罪事件列中的事件包括“被本所公开谴责”。所以，我需要为每个公司检查在过去的三个月内是否有被公开谴责的记录。

这里需要注意的是，这个检查是针对公司的，而不是股东。因此，对于同一公司的不同股东，这个条件的结果可能相同。因此，可能需要按公司分组，然后对于每个日期，检查该公司在该日期之前的三个月内是否有被公开谴责的记录。例如，对于某一行，如果该公司的某个日期之前三个月内有被公开谴责的记录，则condition为True。

具体来说，对于每一行，我需要查看该公司的历史事件中是否有“被本所公开谴责”的事件，并且该事件的日期在当天的日期减去三个月之内。这可能需要使用到时间窗口的计算。例如，对于每个公司，找出所有被公开谴责的日期，然后检查当前行的日期是否在这些日期之后的三个月内。

这里可能需要用到groupby和transform方法。例如，对每个公司，创建一个列，记录最近的被公开谴责的日期，然后计算当前日期与该日期的差值是否小于等于三个月（90天左右）。或者，对于每一行，检查该公司在该行日期之前的三个月内是否有被公开谴责的事件发生。

具体实现可能如下：首先筛选出所有公司被公开谴责的事件，然后对于每个公司，记录这些事件的日期。然后，对于每一行，检查该公司的这些事件日期是否在当天的日期之前的三个月内。如果有任何一个日期满足这个条件，则condition为True。

然后是constraint部分，即不得减持股份。这里的约束是当subject和condition都满足时，股东不得减持。因此，需要检查该股东在该日是否有减持行为。减持可能通过减持方式列来判断，或者是否有减持计划的存在。但根据附加信息中的列，存在减持计划是一个布尔值，但可能还需要结合其他列，比如当日减持比例是否大于0，或者累计减持比例是否有变化？

或者，可能减持行为可以通过是否存在减持计划，并且在该日期处于计划的时间范围内。或者，是否有实际的减持动作，比如当日减持比例大于0。但根据MEU的约束，是“不得减持”，所以如果股东在此时有减持行为，则违反约束。因此，需要确定该行是否属于减持的情况。

但根据MEU的condition是“被公开谴责未满3个月”，而constraint是“不得减持”，所以当subject和condition都满足时，如果该股东在该日有减持行为，则违反约束。因此，在标记constraint时，需要检查该股东在该日是否有减持行为。例如，当日减持比例是否大于0，或者是否存在减持计划在该日执行。

但根据给定的列，可能存在的列是“存在减持计划”、“当日减持比例”等。如果“当日减持比例”大于0，则表示当天有减持。因此，约束条件应为：如果subject和condition都满足，则当日减持比例必须为0，否则违反约束。或者，如果存在减持计划，则违反约束？

这里可能需要更仔细的分析。MEU的constraint是“不得减持其所持有的本公司股份”，所以无论是否有计划，只要实际减持了，或者计划减持，都可能违反。但根据法律条文，可能是指禁止进行任何减持行为，包括计划中的减持。但根据MEU中的condition是“被公开谴责未满3个月”，此时如果股东在此时有减持计划或实际减持，则违反约束。

但根据问题中的示例，constraint的检查是独立进行的，只有当subject和condition都满足时才需要检查constraint吗？或者，根据用户的要求，对于简单操作，三元组的检查是各自独立的，分别标记。只有当需要调用LLM函数时，才只检查符合subject和condition的行。但用户明确说明，本任务中没有需要调用LLM的情况，所以constraint的检查是独立的，不管subject和condition是否满足，都要检查。

但根据MEU的约束，只有当subject和condition同时满足时，才需要遵守constraint。例如，如果某股东是控股股东，且公司被公开谴责未满三个月，那么该股东不得减持。因此，在这种情况下，只有当subject和condition都为True时，才需要检查constraint是否为True（即没有减持）。否则，constraint可能不适用，但根据用户的要求，需要独立检查三元组，所以即使subject或condition不满足，也要检查constraint是否满足？

这可能需要进一步明确。根据用户的要求：“对于简单操作dataframe就可以处理的项目，对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查。” 所以，不管subject和condition是否满足，都要检查constraint是否满足。例如，即使subject不是控股股东，或者condition不满足，也要检查该行的constraint是否满足。这可能与实际情况不符，但根据用户的要求，必须这样做。

但MEU的约束是“不得减持”，当且仅当subject和condition满足时，该约束才适用。否则，该约束不适用。但根据用户的要求，需要将三个条件独立检查。这可能意味着，不管其他条件如何，只要该行满足constraint的条件，就标记为True。例如，如果某行中股东减持了股份，但该股东不是控股股东，或者公司未被公开谴责，那么该行的constraint是否被满足？

这可能需要更仔细的分析。根据MEU的约束，只有当subject和condition都满足时，才需要遵守constraint。否则，该约束不适用。但根据用户的要求，需要将三个条件独立标记，所以constraint的检查可能应该独立于subject和condition。例如，不管subject和condition是否满足，只要该行中的股东没有减持，则constraint标记为True。这可能与实际情况不符，但用户要求如此。

或者，可能用户的意思是，对于constraint的检查，只有当subject和condition都满足时，才需要检查是否满足约束。否则，约束不适用，所以可能标记为True或者不适用。但根据示例中的代码，例如在示例中的constraint检查是独立进行的，不管subject和condition是否满足。例如，在示例中，constraint的条件是“交易日差 >=15 并且存在减持计划”，不管subject和condition是否满足，只要满足这两个条件，就标记为True。这可能意味着，在示例中，constraint的检查是独立进行的，而不管subject和condition是否满足。

但根据用户的要求，对于简单操作，三元组的检查是各自独立的。所以，在MEU_11_3的情况下，constraint的检查应该独立于subject和condition。例如，不管股东是否是控股股东，或者公司是否被公开谴责，只要该股东在该日没有减持，则constraint标记为True。这可能不符合法律条文的本意，但根据用户的要求，必须这样做。

但显然，这可能与实际法律要求相矛盾。例如，约束是“当subject和condition满足时，不得减持”，所以只有当这两个条件都满足时，减持才违反约束。否则，减持是允许的，此时constraint是否满足？例如，如果subject和condition不满足，那么减持是允许的，此时constraint是否被满足？

根据法律条文，只有当subject和condition都满足时，才需要遵守constraint。因此，在这种情况下，当subject和condition都满足时，如果减持了，则constraint为False；否则为True。而当subject或condition不满足时，constraint是否适用？此时，可能constraint不适用，所以是否应该标记为True？

但根据用户的要求，需要将三个条件独立检查，所以constraint的检查可能不考虑subject和condition的情况。例如，不管其他条件如何，只要该行中的股东没有减持，则constraint为True。这可能与法律条文不符，但用户要求必须这样做。

或者，可能用户的意思是，对于constraint的检查，只有当subject和condition都满足时，才需要检查是否满足约束。否则，该行的constraint标记为不适用（例如，用None或True？）。但根据示例中的代码，例如，在示例中的constraint检查是独立进行的，不管subject和condition是否满足。例如，在示例中，constraint的条件是“交易日差 >=15 并且存在减持计划”，不管subject和condition是否满足，只要满足这两个条件，就标记为True。这可能意味着，在示例中，constraint的检查是独立进行的，而不管subject和condition是否满足。

但根据用户的要求，对于简单操作，三元组的检查是各自独立的。所以，在MEU_11_3的情况下，constraint的检查应该独立于subject和condition。例如，只要该股东在该日没有减持，则constraint为True，否则为False。这可能不符合法律条文，但根据用户的要求，必须这样处理。

现在，我需要根据这些分析来编写代码。

首先，处理subject：

subject是“上市公司控股股东 | 实际控制人”，即股东身份列中的“控股股东”或“实际控制人”。因此，valid_subject = df['股东身份'].isin(['控股股东', '实际控制人'])

接下来，condition：

条件是“上市公司被本所公开谴责未满3个月”。这需要检查公司在该行日期之前的三个月内是否被公开谴责过。具体来说，对于每一行，需要确定该公司在该日期之前的三个月内是否有“被本所公开谴责”的事件。

如何实现这一点？首先，需要筛选出该公司所有被公开谴责的事件日期。然后，对于每一行，检查该行的日期是否在某个被公开谴责的日期之后的三个月内。

例如，假设某公司在2023-01-01被公开谴责，那么从该日期开始的三个月内（比如到2023-04-01），所有该公司的行在日期处于这个区间内的，condition为True。

因此，对于每个公司，需要收集所有被公开谴责的日期，然后对于每一行，检查该行的日期是否在任何一个被公开谴责日期之后的三个月内。

这可以通过以下步骤实现：

1. 创建一个DataFrame，包含所有公司被公开谴责的事件。例如，筛选出公司涉嫌证券期货违法犯罪事件列中包含“被本所公开谴责”的行，并记录公司简称、日期。

2. 对于每个公司，将这些日期保存为一个列表。

3. 对于原始DataFrame中的每一行，检查该公司的被公开谴责日期是否存在在该行日期之前的三个月内的日期。

具体实现可能如下：

首先，筛选出所有被公开谴责的事件：

condemn_dates = df[df['公司涉嫌证券期货违法犯罪事件'] == '被本所公开谴责'][['公司简称', '日期']]

然后，对于每个公司，将这些日期保存。然后，对于原始df中的每一行，检查该行的日期是否在任何一个谴责日期的三个月内。

例如，对于某行的公司A，日期为date，检查是否存在谴责日期d，使得date >= d 且 date <= d + 3个月。

这可以通过groupby和transform来实现。例如：

对于每个公司，找出所有谴责日期，然后对于每一行，检查是否有谴责日期满足条件。

或者，可以创建一个辅助列，记录每个公司最近的谴责日期，然后计算当前日期与该日期的差值是否在三个月内。

但可能更高效的方式是，对每个公司，生成一个所有谴责日期的列表，然后对每一行应用一个函数，检查是否有谴责日期在该行的日期之前的三个月内。

例如：

# 获取每个公司的所有被公开谴责的日期
company_condemn_dates = df[df['公司涉嫌证券期货违法犯罪事件'] == '被本所公开谴责'].groupby('公司简称')['日期'].apply(list)

# 对于每一行，检查该公司的谴责日期是否在该行日期之前的三个月内
def check_condition(row):
    company = row['公司简称']
    current_date = row['日期']
    condemn_dates = company_condemn_dates.get(company, [])
    for d in condemn_dates:
        if (current_date - d).days <= 90 and (current_date >= d):
            return True
    return False

df['meu_11_3_condition'] = df.apply(check_condition, axis=1)

但这种方法可能效率较低，因为对于每一行都要遍历该公司的所有谴责日期。如果数据量很大，可能会比较慢。有没有更高效的方法？

另一种方法是，对于每个公司，找到最大的谴责日期，使得该日期 <= 当前日期，并且当前日期 - 该日期 <= 90天。如果存在这样的日期，则condition为True。

例如，对于每个公司，找到所有谴责日期中，最大的那个在current_date之前的，并且current_date - d <=90天。如果存在这样的d，则condition为True。

这可以通过：

对于每个公司，计算每个谴责日期与当前日期的差值，找到是否有差值在0到90天之间。

或者，对每个公司，找到最大的谴责日期，如果该日期 <= current_date，并且current_date - d <=90天，则返回True。

这可能更高效，因为只需要比较最大的谴责日期。

例如：

# 对每个公司，找到最大的谴责日期，并保存为一个Series
max_condemn_dates = df[df['公司涉嫌证券期货违法犯罪事件'] == '被本所公开谴责'].groupby('公司简称')['日期'].max()

# 对于每一行，检查该公司的最大谴责日期是否在current_date的三个月内
valid_condition = (df['日期'] - df['公司简称'].map(max_condemn_dates)) <= pd.Timedelta(days=90) & (df['日期'] >= df['公司简称'].map(max_condemn_dates))

但需要注意，如果公司没有谴责日期，则map会返回NaN，此时条件会为False。因此，需要处理NaN的情况。

或者，可以先将max_condemn_dates填充为NaT，然后进行比较：

max_condemn_dates = df[df['公司涉嫌证券期货违法犯罪事件'] == '被本所公开谴责'].groupby('公司简称')['日期'].max().reset_index()
max_condemn_dates.columns = ['公司简称', 'max_condemn_date']

然后，将原始df与max_condemn_dates合并：

df = df.merge(max_condemn_dates, on='公司简称', how='left')

然后，计算条件：

valid_condition = (df['日期'] - df['max_condemn_date']).dt.days <= 90) & (df['日期'] >= df['max_condemn_date'])

但这种方法可能忽略多个谴责日期的情况。例如，如果公司有多个谴责日期，其中有一个在三个月内，而最大的谴责日期可能不在三个月内。例如，假设公司有两个谴责日期：2023-01-01和2023-04-01。当前日期是2023-02-01，那么最大的谴责日期是2023-04-01，此时current_date - max_date是负数，所以条件不满足。但实际上，2023-01-01的谴责日期在三个月内，所以条件应该为True。因此，这种方法不正确。

因此，必须检查所有谴责日期，而不仅仅是最大的那个。因此，回到最初的方法，可能需要使用apply函数来遍历每个公司的所有谴责日期。

但如何处理大数据量下的效率问题？或者，假设数据量不大，可以接受。

现在，回到代码编写：

首先，处理subject：

df['meu_11_3_subject'] = df['股东身份'].isin(['控股股东', '实际控制人'])

然后，处理condition：

需要找出每个公司被公开谴责的日期，并检查当前行日期是否在某个谴责日期的三个月内。

步骤：

1. 创建一个DataFrame，记录每个公司被公开谴责的日期：

condemn_events = df[df['公司涉嫌证券期货违法犯罪事件'] == '被本所公开谴责'][['公司简称', '日期']].drop_duplicates()

2. 对每个公司，收集所有谴责日期：

company_condemn_dates = condemn_events.groupby('公司简称')['日期'].apply(list).to_dict()

3. 对于每一行，检查该公司的谴责日期是否存在在三个月内的：

def check_condition(row):
    company = row['公司简称']
    current_date = row['日期']
    dates = company_condemn_dates.get(company, [])
    for d in dates:
        delta = (current_date - d).days
        if delta >=0 and delta <=90:
            return True
    return False

df['meu_11_3_condition'] = df.apply(check_condition, axis=1)

或者，更高效的方式可能使用向量化操作，但可能比较复杂。

接下来，处理constraint：

constraint是“不得减持其所持有的本公司股份”。这里的减持可能指的是实际减持行为，例如当日减持比例>0，或者存在减持计划。根据给定的列，可能可以检查当日减持比例是否大于0，或者累计减持比例是否有变化，或者存在减持计划。

但根据附加信息中的列，存在“存在减持计划”列，这是一个布尔值。但约束是“不得减持”，所以可能指的是实际减持行为。例如，如果当日减持比例>0，则违反约束。或者，如果存在减持计划，则可能属于计划阶段，但尚未实际减持。此时，是否违反约束？

根据法律条文，“不得减持”应指实际减持行为。因此，如果当日减持比例>0，则违反约束。否则，不违反。因此，constraint的检查应为：当日减持比例 <=0，或者没有减持行为。

但根据给定的列，是否有“当日减持比例”这一列？根据附加信息中的列，确实存在“当日减持比例”列。因此，可以检查该列是否大于0。如果大于0，则违反约束，即constraint为False；否则为True。

因此，valid_constraint = df['当日减持比例'] <= 0

但需要注意，可能减持比例可能为0，或者NaN？需要确认数据中的情况。假设该列不会为NaN，且当没有减持时为0，有减持时为正值。因此，valid_constraint = df['当日减持比例'] <= 0

因此，标记meu_11_3_constraint列为True或False。

但根据用户的要求，三个条件需要独立检查，所以不管subject和condition是否满足，都要检查constraint。例如，即使该股东不是控股股东，或者公司未被公开谴责，只要当日减持比例>0，则constraint标记为False。这可能不符合法律条文，但根据用户的要求，必须这样做。

综上，代码的大致结构如下：

def check_meu_11_3(df):
    df = df.copy()

    # 初始化列
    df['meu_11_3_subject'] = False
    df['meu_11_3_condition'] = False
    df['meu_11_3_constraint'] = None  # 初始化为None，之后填充True/False

    # 处理subject
    valid_subject = df['股东身份'].isin(['控股股东', '实际控制人'])
    df.loc[valid_subject, 'meu_11_3_subject'] = True

    # 处理condition
    # 获取所有公司被公开谴责的日期
    condemn_events = df[df['公司涉嫌证券期货违法犯罪事件'] == '被本所公开谴责'][['公司简称', '日期']].drop_duplicates()
    company_condemn_dates = condemn_events.groupby('公司简称')['日期'].apply(list).to_dict()

    # 定义检查condition的函数
    def check_condition(row):
        company = row['公司简称']
        current_date = row['日期']
        dates = company_condemn_dates.get(company, [])
        for d in dates:
            delta_days = (current_date - d).days
            if 0 <= delta_days <= 90:
                return True
        return False

    df['meu_11_3_condition'] = df.apply(check_condition, axis=1)

    # 处理constraint
    # 检查当日减持比例是否<=0
    valid_constraint = df['当日减持比例'] <= 0
    df.loc[valid_constraint, 'meu_11_3_constraint'] = True
    df.loc[~valid_constraint, 'meu_11_3_constraint'] = False

    return df

但需要注意，在示例中，constraint的列初始化为None，然后填充True/False。因此，在代码中，应该先初始化meu_11_3_constraint为None，然后根据条件设置True或False。

此外，在示例中，constraint的检查是独立进行的，不管subject和condition是否满足。因此，即使股东不是控股股东，或者公司未被公开谴责，只要当日减持比例>0，则constraint标记为False。这可能与实际法律要求不符，但根据用户的要求，必须这样做。

现在，测试代码是否正确：

例如，某行数据中，股东是控股股东，公司被公开谴责未满三个月，且当日减持比例>0。此时，subject和condition都为True，而constraint为False。这符合要求。

另一情况，股东不是控股股东，但当日减持比例>0，此时constraint标记为False，尽管法律条文不适用，但根据用户的要求，必须标记为False。

这可能不符合实际法律要求，但用户要求独立检查三个条件，因此必须如此处理。

综上，代码应该如上述结构。
","CompletionUsage(completion_tokens=5146, prompt_tokens=1703, total_tokens=6849, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=4696, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_23_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": NaN, ""constraint"": ""不得融券卖出本公司股份"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_23_1(df):
    '''
    检查MEU_23_1合规性：
    ""subject"": ""上市公司大股东 | 董监高"",
    ""condition"": NaN,
    ""constraint"": ""不得融券卖出本公司股份"",
    ""contextual_info"": NaN
    '''
    df = df.copy()

    # 初始化标记列
    df['meu_23_1_subject'] = False
    df['meu_23_1_condition'] = False  # 初始化为False，后续统一处理
    df['meu_23_1_constraint'] = None  # 初始化为None，后续用布尔值填充

    # 1. 标记valid的subject（大股东或董监高）
    # 判断逻辑：股东身份属于董监高/控股股东/实际控制人，或持股比例≥5%
    subject_criteria = (
        df['股东身份'].isin(['董监高', '控股股东', '实际控制人']) |
        (df['持股比例'] >= 0.05)
    )
    df.loc[subject_criteria, 'meu_23_1_subject'] = True

    # 2. 标记valid的condition（由于MEU中condition为NaN，视为无条件触发，所有行标记为True）
    df['meu_23_1_condition'] = True  # 无条件约束，所有行条件满足

    # 3. 标记valid的constraint（减持方式非融券卖出）
    # 独立检查：无论subject是否满足，只要减持方式是融券卖出即违规
    constraint_met = (df['减持方式'] != '融券卖出')
    df['meu_23_1_constraint'] = constraint_met  # True表示合规，False表示违规

    return df
</CODE>","好的，我现在需要处理这个MEU_23_1的合规性检查。首先，我得仔细理解这个MEU的内容。根据提供的法律单元，subject是“上市公司大股东 | 董监高”，condition是NaN，也就是没有触发条件，而constraint是“不得融券卖出本公司股份”。contextual_info也是空的。

那任务就是编写一个函数，检查每个交易日的数据，标记出subject、condition和constraint是否符合。根据要求，这三个部分是独立检查的，所以即使subject不符合，也要检查condition和constraint是否符合。不过这里的condition是NaN，可能意味着不需要检查条件，或者条件总是满足？

首先，处理subject部分。根据MEU的subject，需要识别哪些股东属于大股东或董监高。根据附加信息中的股东身份列，可能的取值包括董监高、控股股东、实际控制人、持股5%以上股东等。此外，即使股东身份没有标明“持股5%以上股东”，如果他们的持股比例大于等于5%，也应该被算作大股东。所以，判断subject是否有效的逻辑应该是：股东身份属于董监高、控股股东、实际控制人，或者持股比例>=5%的股东。

接下来是condition部分。MEU中的condition是NaN，这可能意味着这个约束是无条件的，无论是否有减持行为或其他条件，只要属于subject，就必须遵守constraint。因此，condition在这里可能被忽略，或者视为总是满足。但根据任务要求，condition需要被标记为True或False。但原MEU的condition是NaN，这可能意味着condition不存在，所以所有行的condition都应该标记为True？或者是否需要根据其他条件？

这里可能需要明确，当condition为NaN时，是否意味着没有触发条件，即所有情况都需要满足约束？或者是否condition不存在，因此condition的检查被跳过？根据示例中的处理，当condition存在时才会检查。例如，在示例中，condition是“计划通过本所集中竞价或大宗交易减持股份”，所以只有当减持方式符合时才标记condition为True。而在这个MEU中，condition是NaN，可能意味着没有条件，所以condition的检查可能被设置为所有行都为True，或者不需要检查。但根据框架要求，三元组的检查是各自独立的，所以即使condition是NaN，也需要处理。

但原MEU中的condition字段是NaN，可能意味着该约束的触发条件不存在，即无论什么情况，只要属于subject，就必须遵守constraint。或者，可能condition在这里被省略，所以condition的检查应该被忽略。但根据任务说明中的框架，必须标记三个部分。例如，在示例中，condition被明确检查，而这里的情况如何处理？

可能需要重新理解MEU的结构。根据MEU的定义，condition是触发条件，如果condition是NaN，可能意味着该约束的触发条件不存在，即无论是否满足任何条件，只要属于subject，就必须遵守约束。或者，可能该约束的触发条件总是成立，比如只要存在某个行为，比如融券卖出，就触发约束。但MEU中的constraint是“不得融券卖出本公司股份”，所以触发条件可能实际上是股东进行了融券卖出操作。但MEU中的condition字段是NaN，这可能是一个错误，或者可能condition被合并到constraint中？

或者，可能这里的condition不存在，所以无论股东处于什么状态，只要属于subject，就必须遵守约束。例如，无论是否有减持计划，只要是大股东或董监高，就不能融券卖出。因此，condition在这里可能被视为总是True，即无论什么情况，只要属于subject，就必须满足约束。因此，在代码中，condition的检查可能被设置为所有行的condition为True，或者不需要检查condition，直接检查constraint？

这个问题需要仔细处理。根据任务说明中的框架，每个MEU的三元组需要分别检查。如果MEU中的condition是NaN，那么可能意味着condition不存在，即condition的检查不适用，或者视为所有行的condition为True。在这种情况下，condition的标记应该如何处理？

根据示例中的情况，当condition存在时，才会检查。例如，在示例中，condition是减持方式，所以只有当减持方式符合时才标记condition为True。而在这个MEU中，condition是NaN，可能意味着没有触发条件，所以condition的检查可能被忽略，或者视为所有行的condition为True。但根据框架要求，必须标记三个部分。因此，可能在这个情况下，condition的标记应该全部为True，或者根据其他逻辑？

或者，可能这里的condition被错误地设置为NaN，而实际应该存在触发条件，例如“融券卖出本公司股份”作为condition，而constraint是“不得进行该行为”。但根据MEU的内容，constraint是“不得融券卖出本公司股份”，所以触发条件可能应该是股东进行了融券卖出。但MEU中的condition是NaN，这可能意味着condition不存在，因此无论股东是否进行任何操作，只要属于subject，就必须遵守约束。例如，无论是否卖出，只要属于大股东或董监高，就不能在任何情况下进行融券卖出。

因此，在这种情况下，condition的检查可能被设置为所有行的condition为True，因为约束是无条件的。或者，可能condition的检查被跳过，但根据框架要求，必须标记condition的valid情况。这时候可能需要将condition的valid标记为True，因为约束是无条件的，即无论什么情况都需要遵守。

但根据任务说明中的要求，对于三元组的检查是各自独立的，所以即使condition是NaN，也需要处理。例如，在示例中，condition是存在的，所以检查。而在这个MEU中，condition是NaN，可能意味着condition不存在，所以condition的valid标记可能全部为True，或者如何处理？

可能需要根据任务说明中的示例来推断。例如，当condition不存在时，是否意味着condition的检查被忽略，或者视为True？

在示例中，当condition存在时，检查减持方式。而在这个MEU中，condition是NaN，可能意味着没有触发条件，所以condition的检查可能被设置为所有行的condition为True。因此，在代码中，condition的valid列会被标记为True，或者可能被标记为False？

或者，可能这里的condition是NaN，所以condition的检查不需要进行，因此condition的valid列被设置为None或者保持初始化的False？

这可能需要更仔细的分析。根据MEU的定义，condition是触发条件，如果触发条件不存在，那么约束是否总是适用？例如，无论股东是否进行任何操作，只要属于subject，就必须遵守约束。例如，约束是“不得融券卖出”，所以无论股东是否计划或实际进行融券卖出，只要属于subject，就不能进行该操作。因此，触发条件可能隐含在constraint中，即当股东进行融券卖出时，触发约束。但MEU中的condition是NaN，这可能意味着触发条件不存在，所以无论股东是否进行任何操作，只要属于subject，就必须遵守约束。这可能不太合理，因为约束是“不得融券卖出”，所以只有当股东进行融券卖出时，才违反约束。因此，触发条件应该是股东进行了融券卖出，而约束是不得进行该行为。但MEU中的condition是NaN，这可能是一个错误，或者可能原MEU的结构需要重新理解。

或者，可能这里的condition被省略，而触发条件实际上是股东进行了融券卖出，所以condition是“融券卖出本公司股份”，而constraint是“不得进行该行为”。但MEU中的condition字段是NaN，这可能是一个输入错误。但根据用户给出的MEU内容，condition是NaN，所以必须按照给定的内容处理。

在这种情况下，如何处理condition的检查？根据任务说明中的框架，必须分别检查三元组。如果condition是NaN，可能意味着没有触发条件，所以condition的检查被忽略，或者视为所有行的condition为True。例如，在示例中，当condition存在时，检查减持方式，而这里没有condition，所以condition的valid列可能被设置为True，或者可能被设置为False？

或者，可能当condition是NaN时，condition的检查被跳过，即所有行的condition标记为True，因为约束是无条件的。例如，无论是否有任何触发条件，只要属于subject，就必须遵守约束。这可能意味着condition的valid列被设置为True，因为不需要满足任何条件，所以条件总是满足。

但根据任务说明中的示例，当condition存在时，才会检查。而在这个案例中，condition不存在，所以可能condition的valid列被设置为True，或者如何处理？

这个问题可能需要根据框架中的要求来处理。根据框架中的步骤：

1. 标记valid的subject
2. 标记valid的condition
3. 标记valid的constraint
4. 在dataframe中记录这三个的valid情况

所以，即使condition是NaN，也需要处理。例如，当MEU中的condition是NaN时，可能意味着没有触发条件，所以condition的valid列被设置为True，因为不需要满足任何条件。或者，可能condition的valid列被设置为False，因为没有条件需要满足？

或者，可能当condition是NaN时，condition的检查被忽略，即所有行的condition标记为True，因为约束适用于所有情况，无论是否有触发条件。例如，约束是“不得融券卖出”，所以无论股东是否计划或进行其他操作，只要属于subject，就不能融券卖出。因此，触发条件可能不存在，所以condition的valid列被设置为True，即无论什么情况，只要属于subject，就必须遵守约束。

在这种情况下，condition的valid列可能被设置为True，因为约束是无条件的。因此，在代码中，condition的valid列会被初始化为False，然后所有行的condition标记为True？

或者，可能这里的condition不存在，所以condition的检查被跳过，即condition的valid列保持初始化的False？

这可能需要更仔细地分析MEU的结构。根据MEU的定义，condition是触发条件，如果触发条件不存在，那么约束是否总是适用？例如，约束是“不得融券卖出”，所以无论股东是否进行任何操作，只要属于subject，就不能进行融券卖出。因此，触发条件可能不存在，即无论股东是否进行融券卖出，只要属于subject，就必须遵守约束。这可能不太合理，因为约束是禁止某个行为，所以只有当该行为发生时，才违反约束。因此，触发条件应该是该行为的发生，即condition是“融券卖出本公司股份”，而constraint是“不得进行该行为”。但MEU中的condition是NaN，这可能是一个错误，或者可能原MEU的结构需要重新理解。

但根据用户给出的MEU内容，condition是NaN，所以必须按照给定的内容处理。在这种情况下，可能原MEU的condition被省略，而触发条件被包含在constraint中。例如，约束是“不得融券卖出”，所以触发条件实际上是股东进行了融券卖出，而约束是禁止该行为。因此，condition应该是“融券卖出本公司股份”，而constraint是“不得进行该行为”。但MEU中的condition是NaN，这可能是一个输入错误。但用户给出的MEU内容中condition是NaN，所以必须按照这个来处理。

在这种情况下，可能原MEU的condition不存在，所以触发条件被忽略，即无论股东是否进行任何操作，只要属于subject，就必须遵守约束。这可能意味着，约束是无条件的，只要属于subject，就必须满足。例如，无论股东是否进行融券卖出，只要属于subject，就不能在任何时候进行融券卖出。因此，触发条件不存在，所以condition的valid列可能被设置为True，因为约束适用于所有情况，无论是否有触发条件。或者，可能触发条件被隐含在constraint中，即当股东进行融券卖出时，触发约束，此时需要检查是否属于subject，并且是否进行了该行为，从而违反约束。

但根据MEU的结构，condition是触发条件，而constraint是约束内容。例如，在示例中，condition是“计划通过本所集中竞价或大宗交易减持股份”，而constraint是“应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划”。因此，当condition满足时，必须满足constraint。如果condition不满足，则不需要满足constraint。

但在当前MEU中，condition是NaN，所以可能触发条件不存在，即无论是否满足任何条件，只要属于subject，就必须满足constraint。例如，无论股东是否进行任何操作，只要属于subject，就不能融券卖出。这可能不太合理，因为约束是禁止某个行为，所以只有当该行为发生时，才需要检查。因此，可能这里的condition应该是“融券卖出本公司股份”，而constraint是“不得进行该行为”。但MEU中的condition是NaN，这可能是一个输入错误。但用户给出的MEU内容必须按照此处理。

在这种情况下，如何处理condition的检查？根据任务说明中的框架，必须分别检查三元组。如果condition是NaN，可能意味着没有触发条件，所以condition的valid列被设置为True，即所有行都满足条件，因此必须检查constraint是否满足。或者，可能condition的valid列被设置为False，因为没有触发条件，所以不需要检查constraint？

或者，可能当condition是NaN时，condition的检查被忽略，即所有行的condition标记为True，因此constraint的检查需要针对所有属于subject的行进行？

这可能需要结合MEU的意图来理解。例如，MEU的约束是“不得融券卖出本公司股份”，所以触发条件应该是股东进行了融券卖出。因此，condition应该是“融券卖出本公司股份”，而constraint是“不得进行该行为”。但MEU中的condition是NaN，这可能是一个错误。但根据用户给出的内容，必须处理这种情况。

在这种情况下，可能原MEU的condition被省略，所以触发条件被隐含在constraint中。因此，在代码中，condition的valid列可能被设置为True，当且仅当股东进行了融券卖出。但根据MEU中的condition是NaN，所以可能无法这样处理。

或者，可能这里的condition不存在，所以触发条件被忽略，即无论股东是否进行任何操作，只要属于subject，就必须遵守约束。例如，即使股东没有进行任何融券卖出，只要属于subject，就必须满足约束。这可能不太合理，因为约束是禁止某个行为，所以只有当该行为发生时，才需要检查。

综上，可能用户给出的MEU存在错误，但必须按照给定的内容处理。在这种情况下，condition是NaN，所以触发条件不存在，因此无论股东是否进行任何操作，只要属于subject，就必须遵守约束。因此，在代码中，condition的valid列被设置为True，因为触发条件不存在，所以所有行都满足条件，因此必须检查constraint是否满足。但约束是“不得融券卖出”，所以只有当股东进行了融券卖出时，才违反约束。因此，constraint的检查应该是：股东没有进行融券卖出。

但根据MEU的结构，当condition不存在时，可能触发条件被忽略，因此约束适用于所有属于subject的行，无论是否有任何触发条件。因此，只要属于subject，就必须满足约束，即不能进行融券卖出。因此，constraint的检查应该是：在属于subject的情况下，股东没有进行融券卖出。但如何确定股东是否进行了融券卖出？

根据数据中的列，有一个“减持方式”列，可能的取值包括“融券卖出”。因此，如果某行的减持方式是“融券卖出”，则违反约束。因此，constraint的检查应该是：减持方式不等于“融券卖出”。

但根据MEU的结构，当condition不存在时，可能触发条件被忽略，因此无论股东是否进行融券卖出，只要属于subject，就必须满足约束。因此，约束的检查应该是：股东没有进行融券卖出。因此，在代码中，constraint的valid列应为减持方式不等于“融券卖出”。

现在，总结各部分的处理：

1. subject的检查：股东身份属于大股东或董监高。具体来说，股东身份是董监高、控股股东、实际控制人，或者持股比例>=5%的股东。需要结合股东身份列和持股比例列来判断。

2. condition的检查：由于MEU中的condition是NaN，可能意味着没有触发条件，所以condition的valid列应标记为True。或者，可能condition不存在，所以condition的检查被跳过，但根据框架要求，必须标记condition的valid情况。在这种情况下，如何处理？

根据任务说明中的示例，当condition存在时，才会检查。而在这个案例中，condition不存在，所以可能condition的valid列应被设置为True，因为触发条件不存在，即无论是否有触发条件，都需要检查约束。或者，可能condition的valid列被设置为False，因为没有触发条件？

或者，可能当condition是NaN时，condition的检查被忽略，即所有行的condition标记为True，因此约束的检查需要针对所有属于subject的行进行？

这可能需要根据框架中的要求来处理。根据任务说明中的要求：“对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition都符合的行进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)”

因此，三元组的检查是各自独立的，所以即使condition不存在，也需要独立检查condition的valid情况。但MEU中的condition是NaN，所以如何检查？

可能在这种情况下，condition的valid列被设置为True，因为触发条件不存在，所以无论是否有触发条件，都视为满足条件。或者，可能condition的valid列被设置为False，因为没有触发条件？

或者，可能当condition是NaN时，condition的valid列被设置为True，因为触发条件不存在，所以条件被视为自动满足？

例如，在示例中，当condition存在时，检查减持方式是否符合。而在这个案例中，condition不存在，所以条件被视为自动满足，即所有行的condition标记为True。因此，在代码中，condition的valid列会被初始化为False，然后所有行的condition标记为True？

或者，可能当condition是NaN时，condition的valid列被设置为True，因为触发条件不存在，所以条件被视为满足？

这可能需要根据法律逻辑来判断。例如，如果MEU的condition不存在，那么约束是否适用于所有情况，无论是否有触发条件？例如，约束是“不得融券卖出”，所以无论股东是否计划或进行其他操作，只要属于subject，就不能进行融券卖出。因此，触发条件不存在，所以约束适用于所有属于subject的行。因此，condition的valid列应被设置为True，因为触发条件不存在，所以条件被视为满足，因此约束必须被检查。

在这种情况下，condition的valid列会被标记为True，因此约束的检查需要针对所有属于subject的行进行。但根据任务说明中的框架，三元组的检查是各自独立的，所以即使condition的valid列是True，也需要检查constraint的valid情况，无论subject和condition是否满足。

但根据MEU的结构，当condition不存在时，约束是否适用于所有属于subject的行？例如，无论股东是否进行任何操作，只要属于subject，就必须遵守约束。因此，约束的检查应该是：属于subject的股东是否进行了融券卖出。因此，在代码中，constraint的valid列应为：减持方式不等于“融券卖出”。

现在，具体处理各部分的代码：

1. 标记subject的valid情况：

subject的条件是股东属于大股东或董监高。根据股东身份列，可能的取值包括董监高、控股股东、实际控制人、持股5%以上股东等。此外，即使股东身份没有标明“持股5%以上股东”，如果他们的持股比例>=5%，也应视为大股东。因此，判断逻辑为：

valid_subject = (df['股东身份'].isin(['董监高', '控股股东', '实际控制人'])) | (df['持股比例'] >= 0.05)

注意，这里的“持股5%以上股东”可能已经包含在股东身份列中，但根据附加信息，如果股东身份是董监高或离任董监高，但持股比例>=5%，也需要视为大股东。因此，需要结合股东身份和持股比例来判断。

2. 标记condition的valid情况：

由于MEU中的condition是NaN，可能意味着没有触发条件，所以condition的valid列应标记为True。或者，可能condition不存在，所以condition的检查被跳过，但根据框架要求，必须标记condition的valid情况。在这种情况下，如何处理？

根据任务说明中的示例，当condition存在时，才会检查。而在这个案例中，condition不存在，所以可能condition的valid列应被设置为True，因为触发条件不存在，即所有行都满足条件。或者，可能condition的valid列被设置为False？

或者，可能当condition是NaN时，condition的valid列被设置为True，因为触发条件不存在，所以条件被视为自动满足？

在这种情况下，可能condition的valid列被设置为True，因为触发条件不存在，所以所有行的condition标记为True。因此，在代码中：

valid_condition = pd.Series(True, index=df.index)

或者，可能condition的valid列被设置为True，因为触发条件不存在，所以无论什么情况都视为满足条件？

但根据框架中的示例，当condition存在时，才会检查。而在这个案例中，condition不存在，所以可能condition的valid列被设置为True，因为触发条件不存在，所以条件被视为满足。因此，在代码中，所有行的condition标记为True。

3. 标记constraint的valid情况：

constraint是“不得融券卖出本公司股份”，即减持方式不能是融券卖出。因此，只要减持方式不等于“融券卖出”，则满足约束。因此，valid_constraint = df['减持方式'] != '融券卖出'

但根据MEU的结构，当condition不存在时，约束是否适用于所有属于subject的行？或者，无论subject是否满足，只要减持方式是融券卖出，就违反约束？

根据任务说明中的框架，三元组的检查是各自独立的，所以即使subject和condition不满足，也需要检查constraint的valid情况。因此，无论subject和condition是否满足，只要减持方式是融券卖出，则constraint的valid列为False，否则为True。

但根据法律逻辑，可能只有属于subject的股东才需要遵守该约束。例如，普通股东可以融券卖出，而大股东或董监高则不能。因此，约束的检查应针对属于subject的股东，即当subject为True时，减持方式不能是融券卖出。否则，不需要检查。

但根据任务说明中的要求，三元组的检查是各自独立的，所以即使subject和condition不满足，也需要检查constraint的valid情况。例如，即使股东不是大股东或董监高，只要减持方式是融券卖出，则constraint的valid列为False？

或者，可能约束的检查是独立的，即无论subject和condition是否满足，只要减持方式是融券卖出，就违反约束？

这可能需要根据法律条文的具体要求来判断。例如，法律条文可能规定所有股东都不得融券卖出，但MEU的subject是特定的，所以约束仅适用于subject。但根据MEU的内容，约束是“不得融券卖出本公司股份”，而subject是“上市公司大股东 | 董监高”，所以约束仅适用于这些subject。因此，只有当subject为True时，才需要检查constraint。否则，不需要检查。

但根据任务说明中的框架，三元组的检查是各自独立的，所以即使subject不满足，也需要检查constraint的valid情况。例如，即使股东不是大股东或董监高，只要减持方式是融券卖出，则constraint的valid列为False？

这可能不符合法律逻辑，因为约束仅适用于subject。因此，正确的处理应该是：只有当subject为True时，才需要检查constraint。否则，constraint的valid列可能被标记为True，因为约束不适用于该股东。

但根据任务说明中的要求，三元组的检查是各自独立的，所以必须分别标记。例如，即使subject为False，也需要检查constraint是否满足。这可能与法律逻辑不符，但必须按照任务说明中的要求处理。

例如，在示例中，constraint的检查是独立进行的，即无论subject和condition是否满足，只要存在减持计划且交易日差>=15，则标记为True。这可能与法律逻辑不符，但根据任务说明中的框架，必须这样做。

因此，在当前MEU的情况下，constraint的检查应独立于subject和condition。即，无论股东是否属于subject，只要减持方式是融券卖出，则constraint的valid列为False，否则为True。这可能不符合法律逻辑，但必须按照任务说明中的框架处理。

或者，可能任务说明中的示例中的constraint检查是独立进行的，但实际法律中，约束仅适用于满足subject和condition的情况。但在任务说明中，对于简单操作dataframe的项目，三元组的检查是各自独立的。因此，必须分别标记，而不管其他条件是否满足。

因此，在当前MEU的情况下，constraint的检查应独立于subject和condition。即，无论股东是否属于subject，只要减持方式是融券卖出，则constraint的valid列为False，否则为True。

但根据法律逻辑，约束仅适用于subject，所以正确的处理应该是：只有当subject为True时，才需要检查constraint。否则，约束不适用，所以constraint的valid列可能被标记为True，因为不违反约束。但根据任务说明中的框架，必须独立检查，所以可能必须按照所有行都检查，无论subject是否满足。

这可能需要进一步澄清。例如，在示例中，constraint的检查是独立进行的，即无论subject和condition是否满足，只要存在减持计划且交易日差>=15，则标记为True。这可能意味着，即使股东不是subject，只要满足减持计划的条件，就检查constraint。这可能与法律逻辑不符，但根据任务说明中的框架，必须这样做。

因此，在当前情况下，constraint的检查应独立于subject和condition。即，无论股东是否属于subject，只要减持方式是融券卖出，则constraint的valid列为False，否则为True。

但根据MEU的约束内容，“不得融券卖出本公司股份”是针对subject的，所以正确的处理应该是：只有当subject为True时，才需要检查constraint。否则，约束不适用，所以constraint的valid列应标记为True（因为不违反约束）。

但根据任务说明中的框架，三元组的检查是各自独立的，所以必须分别标记。因此，constraint的检查应独立于subject和condition。例如，在示例中，constraint的检查是独立进行的，不管subject和condition是否满足。因此，在当前情况下，constraint的检查应独立进行，即所有行中，减持方式是否为融券卖出，如果是，则constraint的valid列为False，否则为True。

这可能与法律逻辑不符，但必须按照任务说明中的框架处理。例如，在示例中，即使股东不是subject，只要存在减持计划且交易日差>=15，则标记为True。这可能意味着，即使股东不是subject，只要满足条件，就认为constraint有效。这可能不符合实际情况，但根据任务说明，必须这样做。

因此，在当前情况下，constraint的检查应独立于subject和condition。即，所有行中，只要减持方式是融券卖出，则constraint的valid列为False，否则为True。

综上，代码的编写步骤如下：

1. 初始化三个列：meu_23_1_subject、meu_23_1_condition、meu_23_1_constraint，初始值为False、False、None，然后根据条件更新。

2. 标记subject的valid情况：

valid_subject = (df['股东身份'].isin(['董监高', '控股股东', '实际控制人'])) | (df['持股比例'] >= 0.05)

3. 标记condition的valid情况：由于MEU中的condition是NaN，可能意味着没有触发条件，所以所有行的condition标记为True。或者，可能condition不存在，所以condition的valid列被设置为True？

根据任务说明中的示例，当condition存在时，才会检查。而在这个案例中，condition不存在，所以可能condition的valid列被设置为True，因为触发条件不存在，即所有行都满足条件。或者，可能condition的valid列被设置为False？

或者，可能当condition是NaN时，condition的valid列被设置为True，因为触发条件不存在，所以条件被视为自动满足？

在这种情况下，可能condition的valid列被设置为True。因此：

valid_condition = pd.Series(True, index=df.index)

或者，可能condition的valid列被设置为True，因为触发条件不存在，所以所有行都满足条件。因此，在代码中：

df['meu_23_1_condition'] = True

但根据示例中的处理，当condition存在时，才会检查。例如，在示例中，condition是减持方式，所以只有当减持方式符合时才标记为True。而在这个案例中，condition不存在，所以可能condition的valid列被设置为True，因为触发条件不存在，所以条件被视为满足。

4. 标记constraint的valid情况：

valid_constraint = df['减持方式'] != '融券卖出'

因此，只要减持方式不是融券卖出，则constraint的valid列为True，否则为False。

综上，代码的大致结构如下：

def check_meu_23_1(df):
    df = df.copy()

    # 初始化列
    df['meu_23_1_subject'] = False
    df['meu_23_1_condition'] = False
    df['meu_23_1_constraint'] = None  # 初始化为None，之后用布尔值填充

    # 标记subject
    valid_subject = (df['股东身份'].isin(['董监高', '控股股东', '实际控制人'])) | (df['持股比例'] >= 0.05)
    df.loc[valid_subject, 'meu_23_1_subject'] = True

    # 标记condition：由于condition是NaN，视为无触发条件，所以所有行condition为True
    df['meu_23_1_condition'] = True

    # 标记constraint
    valid_constraint = df['减持方式'] != '融券卖出'
    df['meu_23_1_constraint'] = valid_constraint

    return df

但需要确认是否正确处理了condition的情况。例如，当MEU的condition是NaN时，是否所有行的condition标记为True？

根据任务说明中的示例，当condition存在时，才会检查。而在这个案例中，condition不存在，所以可能所有行的condition标记为True，因为触发条件不存在，所以条件被视为满足。因此，在代码中，将condition的valid列设置为True。

然后，constraint的检查是独立进行的，即所有行中，只要减持方式不是融券卖出，则标记为True，否则为False。

但根据法律逻辑，约束仅适用于subject，所以正确的处理应该是：只有当subject为True时，才需要检查constraint。否则，约束不适用，所以constraint的valid列应标记为True（因为不违反约束）。但根据任务说明中的框架，三元组的检查是各自独立的，所以必须独立检查，不管subject和condition是否满足。

例如，在示例中，constraint的检查是独立进行的，不管subject和condition是否满足。因此，在当前情况下，constraint的检查也应独立进行，即所有行中，只要减持方式是融券卖出，则标记为False，否则为True。

因此，代码中的constraint检查是正确的。

综上，最终的代码如下：
","CompletionUsage(completion_tokens=6991, prompt_tokens=1693, total_tokens=8684, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=6584, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_10_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东"", ""condition"": ""因涉嫌与本上市公司有关的证券期货违法犯罪，在被中国证监会及其派出机构立案调查或者被司法机关立案侦查期间"", ""constraint"": ""不得减持其所持有的本公司股份"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_10_1(df):
    '''
    验证MEU_10_1合规性：
    ""subject"": ""上市公司大股东"",
    ""condition"": ""因涉嫌与本上市公司有关的证券期货违法犯罪，在被中国证监会及其派出机构立案调查或者被司法机关立案侦查期间"",
    ""constraint"": ""不得减持其所持有的本公司股份""
    '''
    df = df.copy()

    # 初始化标记列
    df['meu_10_1_subject'] = False
    df['meu_10_1_condition'] = False
    df['meu_10_1_constraint'] = None  # 初始化为None便于后续布尔类型填充

    # 1. 标记责任主体有效性(上市公司大股东)
    # 判断标准：股东身份属于大股东类别或持股比例≥5%
    major_shareholder_mask = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    df.loc[major_shareholder_mask, 'meu_10_1_subject'] = True

    # 2. 标记触发条件有效性(处于被调查/侦查期间)
    # 判断标准：股东涉嫌事件包含立案调查/侦查状态
    investigation_status = [
        '被中国证监会及其派出机构立案调查',
        '被司法机关立案侦查'
    ]
    df['meu_10_1_condition'] = df['股东涉嫌证券期货违法犯罪事件'].isin(investigation_status)

    # 3. 标记约束有效性(未减持股份)
    # 判断标准：当日减持比例≤0（独立检查，不考虑主体和条件状态）
    df['meu_10_1_constraint'] = df['当日减持比例'] <= 0
    # 将布尔值转换为True/False显式标记（覆盖None初始值）
    df['meu_10_1_constraint'] = df['meu_10_1_constraint'].astype(bool)

    return df
</CODE>","好的，我现在需要处理这个MEU_10_1的合规性检查。首先，我得仔细理解这个MEU的内容。根据给定的信息，责任主体是“上市公司大股东”，触发条件是“因涉嫌与本上市公司有关的证券期货违法犯罪，在被中国证监会及其派出机构立案调查或者被司法机关立案侦查期间”，而约束是“不得减持其所持有的本公司股份”。

接下来，我需要将这些条件转化为代码，检查数据框中的每一行是否符合这三个条件。根据用户提供的dataframe列，我需要找到对应的列来判断每个条件是否满足。

首先处理subject部分。根据MEU的subject是“上市公司大股东”，而数据中的股东身份列有多个选项，包括控股股东、实际控制人、持股5%以上股东等。但这里可能需要明确“大股东”的定义。根据附加信息中的说明，股东身份列中的“控股股东”、“实际控制人”、“持股5%以上股东”可能属于大股东。此外，可能还需要检查持股比例是否达到一定标准，比如5%以上。但根据MEU的subject描述，可能直接根据股东身份来判断。例如，如果股东身份是控股股东、实际控制人或持股5%以上股东，则视为符合subject条件。或者，可能需要结合持股比例，比如即使股东身份不是这些标签，但持股比例超过5%也算。但根据附加信息中的说明，股东身份列中的标签不会并列出现，所以可能需要同时检查股东身份和持股比例。例如，如果股东身份是控股股东、实际控制人，或者持股比例≥5%的股东，则视为大股东。但用户提供的示例中，比如MEU_4_1的处理中，subject的判断是结合了股东身份和持股比例。因此，这里可能需要同样的处理方式。例如，判断股东身份是否为控股股东、实际控制人，或者持股比例≥5%的股东。但MEU_10_1的subject是“上市公司大股东”，可能更严格，比如控股股东或实际控制人，或者持股5%以上的股东。所以，在代码中，我需要将subject的条件设置为：股东身份是控股股东、实际控制人、持股5%以上股东，或者持股比例≥5%。这可能通过检查股东身份列中的值，或者持股比例是否≥0.05。

接下来是condition条件：股东因涉嫌与本公司有关的证券期货违法犯罪，在被立案调查或侦查期间。对应的数据列是“股东涉嫌证券期货违法犯罪事件”。该列的可能值包括被立案调查、调查结束、被侦查等。需要确定在哪些情况下condition为真。例如，当该列的值是“被中国证监会及其派出机构立案调查”或“被司法机关立案侦查”时，表示处于调查或侦查期间。而如果事件是调查结束或侦查结束，则可能不在期间内。因此，condition的条件应为：股东涉嫌证券期货违法犯罪事件列的值是“被中国证监会及其派出机构立案调查”或者“被司法机关立案侦查”。这时候，该股东处于被调查或侦查期间，触发条件成立。

然后是constraint约束：不得减持股份。因此，需要检查该股东在该交易日是否有减持行为。减持可能通过减持比例来判断，比如当日减持比例是否大于0。或者是否有减持的记录。但根据数据列中的信息，可能有“当日减持比例”这一列，如果该值大于0，则表示当天有减持。因此，约束条件应为：当日减持比例<=0，即没有减持。或者，如果当日减持比例>0，则违反约束。因此，在标记constraint时，当subject和condition都满足的情况下，如果当日减持比例>0，则constraint为False，否则为True。但根据用户的要求，对于三元组的检查是各自独立的，除了需要调用llm_content_check的情况。但在这个任务中，不需要调用该函数，所以constraint的检查是独立的，不需要依赖subject和condition是否满足。但根据用户的要求中的说明：“对于简单操作dataframe就可以处理的项目，对三元组<subject, conditon, constrain>的检查是各自独立的，你需要分别标记三元组的True和False。” 所以，这里的constraint检查应该独立于subject和condition。例如，不管subject和condition是否满足，只要该行存在减持行为，就标记constraint是否符合。但根据MEU的约束内容，只有当subject和condition都满足时，才需要遵守不得减持的约束。但根据用户的要求，这里需要分别标记三个条件是否满足，而constraint的检查是独立的。这可能存在矛盾，需要仔细理解用户的要求。

根据用户的要求中的说明：“对于简单操作dataframe就可以处理的项目，对三元组<subject, conditon, constrain>的检查是各自独立的，你需要分别标记三元组的True和False。并不是只对符合subject和condition进行检查。” 所以，这里的三个条件需要分别检查，不管其他条件是否满足。例如，即使subject不满足，只要constraint的条件满足（比如没有减持），则标记为True。这可能不符合实际法律逻辑，但根据用户的要求，需要这样处理。但MEU的约束是当subject和condition满足时，必须满足constraint。但在这种情况下，用户可能希望将三个条件独立标记，而最终的合规性可能需要结合这三个条件。但根据任务要求，代码需要分别标记这三个条件是否各自满足，而不是综合判断。例如，每个条件是否成立，不管其他条件是否成立。这可能意味着，即使subject和condition都不满足，只要该行没有减持，constraint会被标记为True。这可能与实际法律要求不符，但根据用户的要求，必须这样处理。因此，在代码中，需要分别处理这三个条件，各自标记是否满足。

但MEU的约束是“不得减持”，所以约束的正确性应该是在subject和condition都满足的情况下，是否减持。但根据用户的要求，这里需要将三个条件独立检查。这可能是一个矛盾。例如，约束条件是否满足，应该是在subject和condition都满足的情况下，是否满足。但用户的要求中说，对于不需要调用llm_content_check的情况，三个条件各自独立检查。这可能意味着，在代码中，constraint的检查不考虑subject和condition是否满足，而是直接检查是否满足约束条件。例如，不管股东是否是大股东，是否被调查，只要当天没有减持，则constraint为True。这可能不符合实际法律意义，但根据用户的要求，必须这样处理。因此，我需要按照用户的要求来编写代码，即三个条件独立检查。

现在，我需要具体分析每个条件如何判断：

1. subject：上市公司大股东。根据数据中的股东身份列，可能包括控股股东、实际控制人、持股5%以上股东。或者，如果股东身份是普通股东，但持股比例≥5%，是否也算？根据附加信息中的说明，股东身份列中的标签不会并列出现，所以可能需要结合股东身份和持股比例来判断。例如，如果股东身份是控股股东、实际控制人、持股5%以上股东，或者持股比例≥5%，则视为大股东。因此，subject的条件可以写成：

valid_subject = (df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东'])) | (df['持股比例'] >= 0.05)

但需要确认是否股东身份列中的其他情况可能属于大股东。例如，董监高可能同时是大股东，但根据MEU_10_1的subject是“上市公司大股东”，而董监高可能属于不同的身份。因此，这里可能只需要判断股东身份是否属于大股东类别，或者持股比例是否达标。

2. condition：被立案调查或侦查。对应的列是“股东涉嫌证券期货违法犯罪事件”，当该列的值是“被中国证监会及其派出机构立案调查”或“被司法机关立案侦查”时，条件成立。因此：

valid_condition = df['股东涉嫌证券期货违法犯罪事件'].isin(['被中国证监会及其派出机构立案调查', '被司法机关立案侦查'])

3. constraint：不得减持。即当日减持比例是否为0。如果当日减持比例>0，则违反约束。因此，constraint的条件是当日减持比例<=0：

valid_constraint = df['当日减持比例'] <= 0

但需要注意，减持比例可能为0，或者没有减持。因此，只要当日减持比例<=0，则满足约束。否则，不满足。

现在，将这些条件转化为代码：

首先，初始化三个新的列，meu_10_1_subject、meu_10_1_condition、meu_10_1_constraint，初始值为False或None。根据示例，subject和condition初始化为False，constraint初始化为None，但之后会被填充为True或False。

然后，分别计算每个条件的布尔序列，并将对应的位置标记为True或False。

对于subject：

valid_subject = (df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东'])) | (df['持股比例'] >= 0.05)

对于condition：

valid_condition = df['股东涉嫌证券期货违法犯罪事件'].isin(['被中国证监会及其派出机构立案调查', '被司法机关立案侦查'])

对于constraint：

valid_constraint = df['当日减持比例'] <= 0

然后，将这些布尔序列赋值给对应的列。

需要注意的是，在示例中，constraint的初始值是None，但之后用loc方法赋值True和False。例如：

df.loc[valid_constraint, 'meu_4_1_constraint'] = True
df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

这可能是因为在示例中，constraint的条件可能涉及多个步骤，比如计算交易日差等。但在当前情况下，constraint的条件比较简单，可以直接用布尔序列赋值。

现在，将这些步骤整合到函数中：

函数名为check_meu_10_1，输入是df，返回处理后的df。

初始化三个新列：

df['meu_10_1_subject'] = False
df['meu_10_1_condition'] = False
df['meu_10_1_constraint'] = None  # 或者初始化为False？

但根据示例，constraint初始化为None，然后根据条件赋值为True或False。因此，这里应该初始化为None，然后填充。

然后，计算各条件：

valid_subject = ... 

valid_condition = ...

valid_constraint = df['当日减持比例'] <= 0

然后，用loc方法赋值：

df.loc[valid_subject, 'meu_10_1_subject'] = True

df.loc[valid_condition, 'meu_10_1_condition'] = True

对于constraint，因为初始化为None，所以需要将满足条件的设为True，不满足的设为False：

df.loc[valid_constraint, 'meu_10_1_constraint'] = True
df.loc[~valid_constraint, 'meu_10_1_constraint'] = False

但需要注意，如果当日减持比例是NaN的情况如何处理？例如，如果某行没有减持，可能该列是0或者NaN？根据数据描述中的列信息，可能存在“当日减持比例”列，当没有减持时，该值为0。因此，可能不需要处理NaN的情况。但如果有NaN，则valid_constraint会是False吗？例如，NaN <=0 是False，所以会被标记为False。这可能不正确，但假设数据中的“当日减持比例”在无减持时为0，那么不会有问题。

综上，代码的大致结构如下：

import pandas as pd

def check_meu_10_1(df):
    df = df.copy()
    
    # 初始化列
    df['meu_10_1_subject'] = False
    df['meu_10_1_condition'] = False
    df['meu_10_1_constraint'] = None
    
    # 检查subject
    valid_subject = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    df.loc[valid_subject, 'meu_10_1_subject'] = True
    
    # 检查condition
    valid_condition = df['股东涉嫌证券期货违法犯罪事件'].isin([
        '被中国证监会及其派出机构立案调查', 
        '被司法机关立案侦查'
    ])
    df.loc[valid_condition, 'meu_10_1_condition'] = True
    
    # 检查constraint
    valid_constraint = df['当日减持比例'] <= 0
    df.loc[valid_constraint, 'meu_10_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_10_1_constraint'] = False
    
    return df

这样，每个条件都被独立检查，并标记在对应的列中。例如，无论subject和condition是否满足，只要当日减持比例<=0，constraint就被标记为True。这可能与实际法律要求不符，但根据用户的要求，三个条件是独立检查的。例如，当subject和condition都满足时，如果constraint为False，则表示违规。但根据代码中的标记，这三个条件会被分别记录，用户可能需要后续处理这三个条件同时满足的情况，以判断是否违规。但根据任务要求，函数只需要分别标记这三个条件是否满足，而不是综合判断是否合规。因此，这样的代码是符合要求的。
","CompletionUsage(completion_tokens=3253, prompt_tokens=1711, total_tokens=4964, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=2796, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_13_2
法律的最小可执行单元内容: {""subject"": ""大股东"", ""condition"": ""通过协议转让方式减持股份导致出让方不再具有大股东身份, 且处在减持后6个月内"", ""constraint"": ""继续遵守本指引第四条规定"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_13_2(df):
    '''
    检查MEU_13_2合规性：
    subject: 大股东（控股股东/实际控制人/持股5%以上股东或持股比例≥5%）
    condition: 通过协议转让减持导致失去大股东身份且在减持后6个月内
    constraint: 继续遵守第四条（假设为减持预披露要求）
    '''
    df = df.copy()
    
    # 初始化标记列
    df['meu_13_2_subject'] = False
    df['meu_13_2_condition'] = False
    df['meu_13_2_constraint'] = False

    # 1. 标记subject有效性
    major_roles = ['控股股东', '实际控制人', '持股5%以上股东']
    df['meu_13_2_subject'] = df['股东身份'].isin(major_roles) | (df['持股比例'] >= 0.05)

    # 2. 标记condition有效性（分组处理股东减持事件）
    for (company, shareholder), group in df.groupby(['公司简称', '股东']):
        # 找出协议转让且导致失去大股东资格的日期
        condition_dates = group[
            (group['减持方式'] == '协议转让') &
            (group['持股比例'] < 0.05)  # 减持后失去大股东身份
        ]['日期']
        
        # 标记后续6个月内的交易日
        for trigger_date in condition_dates:
            mask = (
                (df['公司简称'] == company) &
                (df['股东'] == shareholder) &
                (df['日期'].between(
                    trigger_date,
                    trigger_date + pd.DateOffset(months=6) - pd.DateOffset(days=1),
                    inclusive='both'
                ))
            )
            df.loc[mask, 'meu_13_2_condition'] = True

    # 3. 标记constraint有效性（独立检查所有减持计划的预披露）
    df['预披露天数'] = (df['计划开始日'] - df['计划披露日']).dt.days
    df['meu_13_2_constraint'] = df['存在减持计划'] & (df['预披露天数'] >= 15)

    return df
</CODE>","好的，我现在需要处理这个MEU_13_2的合规性检查。首先，我得仔细理解这个MEU的内容。它的主体是“大股东”，条件是通过协议转让减持导致不再是大股东，并且在减持后的6个月内。约束是继续遵守指引第四条规定。不过这里的第四条具体内容可能没有给出，但根据任务要求，可能只需要标记是否符合这个约束条件的存在，而不是具体检查第四条的内容。

接下来，我需要根据提供的dataframe的列来编写代码。首先，确定subject是否符合“大股东”。根据附加信息中的股东身份列，可能包括控股股东、实际控制人、持股5%以上股东，或者需要根据持股比例来判断。比如，如果股东身份列中有这些标签，或者持股比例>=5%，则视为大股东。但要注意，股东身份列中的标签是互斥的，所以可能需要结合持股比例来判断。例如，即使股东身份是普通股东，但持股比例超过5%，也可能属于大股东？

不过根据MEU中的subject是“大股东”，可能需要明确哪些情况属于大股东。根据常规定义，大股东通常指持股5%以上的股东。所以，判断subject的条件应该是股东身份是控股股东、实际控制人、持股5%以上股东，或者持股比例>=5%。或者可能股东身份列中的某些标签已经代表了大股东，比如“控股股东”、“实际控制人”、“持股5%以上股东”都属于大股东。所以，在代码中，subject的有效性可以通过检查股东身份是否属于这些类别，或者持股比例是否>=5%。

然后是condition部分：通过协议转让方式减持股份导致不再具有大股东身份，并且在减持后的6个月内。这里需要分步骤处理。首先，减持方式是否是协议转让？但提供的减持方式列中的选项是['竞价交易', '大宗交易', '融券卖出']，没有协议转让。这可能有问题，或者可能协议转让属于其他方式？或者可能用户的数据中的减持方式可能有其他值？或者可能这里的协议转让需要对应到某个特定的列？

或者，可能这里的协议转让方式在数据中没有对应的列，可能需要假设存在其他方式？或者可能这是一个错误？比如，原问题中的MEU条件中的减持方式是协议转让，但数据中的减持方式列没有这个选项。这可能是一个矛盾，需要如何处理？

这时候可能需要根据用户提供的列来处理。例如，用户提供的减持方式列中没有协议转让，这可能意味着在数据中，协议转让可能未被记录，或者可能被归类到其他方式。或者可能用户的数据存在错误，但根据任务要求，我需要假设数据中的减持方式列包含所有可能的情况，包括协议转让。或者可能用户给出的例子中的减持方式列可能不完整？

这里可能需要进一步澄清，但根据用户给出的数据列，减持方式包括协议转让吗？根据用户提供的列中的减持方式选项是['竞价交易', '大宗交易', '融券卖出']，所以协议转让可能不在其中。这可能意味着在数据中，协议转让的减持方式可能未被正确记录，或者可能用户的问题中存在错误。但根据任务要求，我需要根据给定的列来处理。

这时候可能需要重新审视问题。MEU的条件是“通过协议转让方式减持股份导致出让方不再具有大股东身份，且处在减持后6个月内”。但数据中的减持方式列没有协议转让，这可能意味着无法直接判断减持方式是否为协议转让。这可能是一个问题，或者可能用户的数据中存在其他列可以推断？

或者，可能用户的数据中的减持方式列可能存在其他值，比如协议转让未被列出？或者可能用户的问题中的MEU条件中的减持方式与实际数据中的列不符，导致无法正确判断？

这时候可能需要假设，用户的数据中的减持方式列可能存在协议转让的情况，或者可能用户的问题中的MEU条件中的协议转让是其他方式。例如，可能协议转让属于大宗交易的一种？或者可能用户的数据中的减持方式列中的某个值对应协议转让？

或者，可能用户的问题中存在错误，比如MEU的条件中的减持方式应为大宗交易或其他方式？但根据用户给出的MEU内容，必须按照协议转让来处理。这时候可能需要用户的数据中存在协议转让的减持方式，否则无法正确标记condition的条件。

这可能是一个矛盾，但根据任务要求，我需要根据给定的列来编写代码。假设减持方式列中存在协议转让的情况，或者可能用户的数据中的减持方式列中的某个值对应协议转让？

或者，可能用户的数据中的减持方式列中的协议转让未被列出，但可能通过其他方式推断？例如，可能协议转让的减持方式在数据中被记录为其他方式，或者可能通过其他列的组合来判断？

这时候可能需要重新检查用户提供的dataframe的列。用户提供的列中有“减持方式”列，可能的值是['竞价交易', '大宗交易', '融券卖出']。所以，协议转让可能不在其中。这可能意味着在数据中，无法直接判断减持方式是否为协议转让，因此无法正确标记condition的条件。这会导致代码无法正确实现，但根据任务要求，必须编写代码。

这时候可能需要假设用户的数据中存在协议转让的减持方式，或者可能用户的问题中的MEU条件中的减持方式应为其他方式。例如，可能用户的问题中的MEU条件中的协议转让是笔误，实际应为大宗交易？或者可能用户的数据中的减持方式列中的某个值对应协议转让？

或者，可能用户的数据中的减持方式列存在其他未被列出的值，比如协议转让。例如，可能减持方式列中的某些行存在“协议转让”的值，但用户没有在附加信息中明确列出。因此，在代码中，需要检查减持方式是否为“协议转让”。

因此，在代码中，condition的有效性需要满足两个条件：减持方式是协议转让，并且减持导致不再是大股东，且在减持后的6个月内。

但根据用户提供的减持方式列的可能值，没有协议转让，这可能意味着无法正确判断condition的条件。这时候可能需要用户的数据中存在协议转让的情况，或者可能这是一个错误，需要如何处理？

在这种情况下，可能需要假设减持方式列中存在协议转让的情况，或者可能用户的问题中的MEU条件中的减持方式应为其他方式。例如，可能用户的问题中的MEU条件中的协议转让应为大宗交易，或者其他方式？

或者，可能用户的数据中的减持方式列中的协议转让未被正确列出，但实际存在。例如，可能用户的数据中的减持方式列中存在“协议转让”的值，但用户没有在附加信息中说明。因此，在代码中，需要检查减持方式是否为“协议转让”。

因此，在代码中，condition的有效性部分需要检查减持方式是否为协议转让。例如：

valid_condition = (df['减持方式'] == '协议转让') & ...其他条件。

但根据用户提供的减持方式的可能值中没有协议转让，这可能意味着代码中的这一部分将永远为False，或者用户的数据中存在该值。因此，可能需要按照用户给出的条件来编写代码，假设减持方式中存在协议转让的情况。

接下来，处理条件中的其他部分：减持导致出让方不再具有大股东身份，并且在减持后的6个月内。

首先，减持导致不再是大股东。这需要判断在减持之后，该股东的持股比例是否低于5%（假设大股东的定义是持股5%以上）。或者，根据股东身份列中的标签，如果减持后股东身份不再是控股股东、实际控制人、持股5%以上股东，或者持股比例低于5%。

但如何判断减持是否导致不再是大股东？这可能需要比较减持前后的持股比例。例如，在减持之后，该股东的持股比例是否低于5%。或者，在减持之后，股东身份是否不再属于大股东类别。

但dataframe中的每一行代表的是某个交易日的情况，所以可能需要跟踪每个股东在每个交易日的持股变化，并确定在减持后的时间点是否不再是大股东。

或者，可能需要在数据中找到该股东减持的日期，并计算减持后的持股比例是否低于5%。例如，当某一行中的减持方式为协议转让，并且减持导致持股比例从5%以上变为5%以下，那么该股东在该减持后不再是大股东。

这可能需要分组处理每个公司和股东，然后检查每次减持后的情况。

此外，条件中的时间部分：减持后的6个月内。这里的6个月是自然日还是交易日？根据附加信息中的说明，自然日需要计算，而日期列已经是交易日。因此，可能需要将减持日期加上6个月的自然日，然后检查当前日期是否在该时间范围内。

现在，具体步骤：

1. 标记subject是否为大股东。判断条件：股东身份是控股股东、实际控制人、持股5%以上股东，或者持股比例>=5%。

2. 标记condition是否满足：减持方式是协议转让，并且减持导致不再是大股东，且在减持后的6个月内。

对于condition的标记，需要：

a. 减持方式为协议转让。

b. 减持导致该股东不再是大股东（即减持后的持股比例<5%或股东身份不再属于大股东类别）。

c. 当前日期处于减持后的6个月内。

但如何确定减持后的时间？例如，在数据中，某一行可能记录了减持事件，那么需要确定该减持事件后的6个月内。

或者，可能需要针对每个减持事件，标记之后6个月内的所有日期为满足条件。

这可能需要分组处理每个股东的减持记录，并确定哪些日期处于减持后的6个月内，并且减持导致不再是大股东。

这可能比较复杂，因为需要跟踪每个减持事件的影响。

例如，假设某股东在某个日期通过协议转让减持，导致其持股比例从6%降到4%。那么，从该减持日期开始的6个月内，该股东的所有行都应标记为满足condition的条件。

因此，处理步骤可能如下：

对于每个股东，找出所有减持方式为协议转让，并且减持导致其不再是大股东的日期。然后，对于这些日期之后的6个月内的所有行，标记condition为True。

但如何确定减持是否导致不再是大股东？这需要比较减持前后的持股比例或股东身份。

例如，在减持当天的持股比例是否低于5%，或者股东身份是否不再是控股股东等。

或者，可能需要在数据中，每次减持后，该股东的持股比例是否低于5%。

这可能需要计算每次减持后的持股比例，或者是否有减持事件导致持股比例从>=5%变为<5%。

这可能需要分组处理每个股东，并跟踪其持股比例的变化。

例如，对于每个股东，按日期排序，计算每次减持后的持股比例是否低于5%。

但dataframe中的每一行可能包含当日的减持情况，比如当日减持比例。例如，当日减持比例可能为某个值，导致累计减持比例超过某个阈值。

或者，可能需要根据累计减持比例来判断是否导致不再是大股东。

但根据数据中的列，有“累计减持比例”列。假设累计减持比例是该股东从某个初始持股比例到当前日期累计减持的比例。例如，初始持股比例是X，累计减持比例是Y，那么当前持股比例是X - Y。如果X - Y <5%，则不再是大股东。

或者，可能数据中的“持股比例”列已经是减持后的当前比例。例如，每一行的持股比例是该股东在该日期的当前持股比例。如果是这样，那么判断减持后的持股比例是否<5%即可。

假设数据中的“持股比例”列是当前的最新比例，那么当某次减持导致该比例降至5%以下时，该股东不再是大股东。

因此，对于condition的条件，需要：

减持方式为协议转让，并且减持后的持股比例<5%，并且当前日期处于减持日期之后的6个月内。

但如何确定减持日期？例如，在数据中，某一行可能记录了减持事件（比如当日减持比例>0），并且减持方式为协议转让，导致持股比例从>=5%变为<5%。那么，该行的日期即为减持日期，之后6个月内的所有行都应标记为满足condition的条件。

因此，处理步骤可能如下：

对于每个股东，找出所有减持方式为协议转让，并且减持后的持股比例<5%的日期。然后，对于这些日期之后的6个月内的所有行，标记condition为True。

但如何确定减持后的持股比例是否<5%？例如，在减持当日的持股比例是否<5%。或者，是否在减持后的下一个交易日？

可能需要假设，在减持当日，持股比例已经更新为减持后的值。因此，在减持当日，如果减持方式为协议转让，并且减持后的持股比例<5%，则该日期为减持日期，之后6个月内的所有行都满足条件。

因此，在代码中，需要：

1. 对每个股东，找到所有减持方式为协议转让，并且减持后的持股比例<5%的日期。

2. 对于每个这样的日期，将该日期之后6个月内的所有行标记为condition=True。

但如何实现这一点？

可能需要先确定哪些行是减持事件导致不再是大股东的日期。例如，筛选出减持方式为协议转让，且减持后的持股比例<5%的行。然后，对于这些行中的日期，计算每个日期之后的6个月内的日期范围，并将这些日期范围内的行标记为condition=True。

这可能需要为每个符合条件的减持日期生成一个时间范围，并检查每一行的日期是否在该时间范围内。

例如，假设某股东在日期D减持，导致持股比例<5%。那么，从D开始到D+6个月（自然日）之间的所有日期，该股东的condition条件为True。

因此，在代码中，可能需要：

- 分组处理每个股东的数据。

- 对于每个股东，找到所有满足减持方式为协议转让，且减持后的持股比例<5%的日期。

- 对于每个这样的日期D，创建一个时间范围：D <= date < D + 6个月。

- 对于该股东的所有行，如果日期在该时间范围内，则标记condition为True。

但如何高效地实现这一点？

可能需要使用pandas的apply函数，或者使用时间区间合并。

例如，对于每个股东，生成一个时间区间列表，然后检查每个行的日期是否落在任何一个时间区间内。

这可能需要为每个股东生成一个包含所有相关时间区间的列表，然后使用pd.Interval或类似的方法来检查。

或者，可以使用逐行处理，但效率可能较低。

另一种方法是，对于每个股东，找到所有符合条件的减持日期，然后为每个日期生成一个日期范围，并将这些日期范围合并，最后标记所有在该范围内的行。

例如：

对于每个股东：

1. 筛选出该股东减持方式为协议转让，且减持后的持股比例<5%的行，得到这些行的日期列表D_list。

2. 对于每个D in D_list，生成一个日期范围：D到D+6个月。

3. 合并所有日期范围，得到该股东的所有需要标记为condition=True的日期。

4. 在原始dataframe中，对于该股东的所有行，如果日期在合并后的日期范围内，则标记condition为True。

这可能需要使用date_range函数生成每个D的日期范围，然后合并这些范围，并检查每个行的日期是否在其中。

但需要注意，6个月的自然日可能不是固定的天数，比如180天或182天，或者根据月份的不同而变化。例如，D + pd.DateOffset(months=6)会正确增加6个月，不管每个月的天数如何。

因此，在代码中，对于每个符合条件的减持日期D，时间范围是[D, D + 6 months)，即从D当天开始，到D+6个月的前一天结束？或者包括D+6个月当天？

需要明确时间范围的结束点。例如，假设减持日期是2023-01-15，那么6个月后是2023-07-15。因此，时间范围是2023-01-15到2023-07-15（包含该日吗？）。根据法律条文，通常“减持后6个月内”可能包括第6个月的最后一天。因此，时间范围应为[D, D + 6 months - 1 day]？或者可能使用D + 6 months作为截止日期，并检查日期是否小于该日期？

这可能需要用pd.DateOffset(months=6)来处理。例如，结束日期是D + 6 months，然后检查日期是否在[D, D + 6 months)之间。

在pandas中，可以使用布尔条件：(df['日期'] >= D) & (df['日期'] < (D + pd.DateOffset(months=6)))。

因此，在代码中，对于每个符合条件的D，生成这样的条件，并将所有符合条件的行标记为condition=True。

现在，如何将这些条件应用到dataframe中？

可能的步骤：

1. 创建一个空的condition_series，初始为False。

2. 对每个股东，找到所有符合条件的D（减持日期）。

3. 对每个D，生成一个布尔掩码，表示该行属于该股东，且日期在[D, D+6 months)之间。

4. 将这些掩码合并，并将condition_series相应的位置设为True。

5. 最后，将condition_series赋值给df['meu_13_2_condition']。

但如何高效地实现这一点？

可能需要分组处理每个股东，然后处理每个股东的数据。

例如：

grouped = df.groupby(['公司简称', '股东'])

然后，对每个组进行处理：

for (company, shareholder), group in grouped:

    # 找出该股东所有减持方式为协议转让，且减持后的持股比例<5%的日期

    mask = (group['减持方式'] == '协议转让') & (group['持股比例'] < 0.05)

    # 注意：这里是否正确？因为减持后的持股比例是否在减持当日就已经更新？

    # 例如，假设在减持当日，减持方式为协议转让，并且减持后的持股比例<5%

    # 因此，mask的条件是减持方式为协议转让，并且当日的持股比例<5%

    # 这可能不正确，因为减持后的持股比例可能是在减持之后才变化的。例如，减持当日的持股比例可能已经反映了减持后的值。

    # 因此，如果某股东在减持当日的持股比例变为<5%，则说明该次减持导致其不再是大股东。

    # 因此，mask的条件是正确的。

    # 获取这些日期

    valid_dates = group.loc[mask, '日期']

    # 对于每个valid_date，生成时间范围

    for date in valid_dates:

        start_date = date

        end_date = start_date + pd.DateOffset(months=6)

        # 在原始dataframe中，找到该股东在start_date到end_date之间的行，并标记condition为True

        mask = (df['公司简称'] == company) & (df['股东'] == shareholder) & (df['日期'] >= start_date) & (df['日期'] < end_date)

        df.loc[mask, 'meu_13_2_condition'] = True

这可能比较耗时，但可以正确标记所有符合条件的行。

但需要注意，如果同一股东有多个符合条件的减持日期，每个日期都会生成一个时间范围，可能会有重叠，但最终结果需要将这些时间范围合并。

现在，处理完condition的条件后，接下来是constraint的约束：继续遵守本指引第四条规定。但用户的任务中可能不需要具体检查第四条的内容，而是需要标记是否满足约束条件。但根据任务要求，对于简单操作dataframe可以处理的项目，三元组的检查是各自独立的。因此，constraint的检查需要独立进行，而不是仅在subject和condition都满足的情况下检查。

但根据MEU的约束内容，这里可能无法直接从dataframe的列中判断是否遵守了第四条。因此，可能需要假设约束条件是否满足需要其他条件，或者可能用户的任务中约束条件无法被检查，因此需要标记为无法处理？

但根据任务要求，需要编写代码来标记三元组的每个部分。因此，可能需要将constraint的检查留空，或者根据其他条件判断？

或者，可能约束条件“继续遵守本指引第四条规定”需要被转化为具体的检查条件。例如，假设第四条是关于减持预披露的规定，那么约束可能是在减持后的6个月内，每次减持都需要预先披露。但如果没有具体的第四条内容，可能无法正确实现。

在这种情况下，可能需要用户提供更多信息，但根据任务描述，必要的额外信息是NaN。因此，可能无法正确检查约束条件，导致无法编写代码。但根据任务要求，必须编写代码，因此可能需要忽略约束条件的检查，或者假设约束条件无法检查，因此标记为None或False？

或者，可能约束条件的检查需要其他列的信息，例如存在减持计划、提前披露等。例如，第四条可能要求减持前需要预先披露，因此在减持后的6个月内，每次减持都需要满足预先披露的条件。但如何确定？

这可能超出了当前的信息范围，因此可能需要假设无法检查约束条件，或者根据其他列的信息进行判断。

例如，假设第四条要求减持前需要提前15天披露计划，那么约束条件可能是在减持后的6个月内，每次减持都需要满足提前15天披露。因此，在代码中，需要检查是否存在减持计划，并且计划披露日早于计划开始日至少15天。

但根据数据中的列，存在“存在减持计划”、“计划披露日”、“计划开始日”等列。因此，可能可以检查这些条件。

例如，约束条件可能被转化为：在减持后的6个月内，如果该股东有减持行为，必须满足提前15天披露减持计划。因此，在代码中，需要检查在减持后的6个月内，每次减持是否有提前15天披露。

但如何确定减持后的6个月内是否有减持行为，并且这些减持是否满足约束？

这可能非常复杂，因为需要跟踪减持后的每次减持是否符合条件。

但根据任务要求，约束的检查是独立的，即不管subject和condition是否满足，都需要检查约束条件。或者，根据任务中的说明，对于需要调用llm_content_check()函数的项目，只检查subject和condition都满足的行的constraint。但当前任务中没有需要调用该函数，因此，约束条件的检查是独立的。

因此，约束条件的检查需要独立于subject和condition，对所有行进行检查。

但约束条件是“继续遵守本指引第四条规定”，而第四条的具体内容未知。因此，无法直接编写代码。这可能意味着无法正确实现约束条件的检查，因此需要假设无法处理，或者可能用户希望将约束条件的检查留空？

或者，可能约束条件在MEU中的描述是“继续遵守”，即只要在减持后的6个月内，该股东仍需遵守第四条。因此，约束条件的检查可能是在该时间段内，该股东的所有行为是否符合第四条。但第四条的内容未知，因此无法实现。

这可能是一个问题，但根据任务要求，必须编写代码。因此，可能需要假设约束条件无法检查，或者将其标记为None或False。

或者，可能用户希望将约束条件的检查留空，或者根据其他条件进行假设。例如，假设第四条要求减持前必须披露，因此约束条件是在减持后的6个月内，每次减持都必须有存在减持计划，并且计划披露日提前15天。

但如何将这些条件转化为代码？

例如，在约束条件中，需要检查该股东在减持后的6个月内，每次减持是否满足：

- 存在减持计划

- 计划披露日早于计划开始日至少15天。

这可能涉及到对每次减持的检查，但如何确定哪些减持属于减持后的6个月内？

这可能非常复杂，因为需要跟踪每个减持事件后的时间段内的其他减持行为。

或者，可能约束条件与MEU_4_1中的约束类似，即需要提前15天披露。因此，在代码中，约束条件的检查可能类似于MEU_4_1中的处理，即检查是否存在减持计划，并且计划披露日与计划开始日之间的天数>=15。

但约束条件是针对减持后的6个月内的所有减持行为，因此需要检查在该时间段内的所有减持是否满足这些条件。

这可能需要在代码中，对于每个股东，在减持后的6个月内，检查每次减持是否满足约束条件。

例如，对于每个股东，在减持后的6个月内，每次减持（无论方式）都需要满足：

存在减持计划，并且计划披露日提前至少15天。

因此，在代码中，约束条件的有效标记需要：

对于每一行，如果该行属于某个股东在减持后的6个月内，并且该行中存在减持计划，则检查计划披露日是否提前至少15天。

否则，约束条件可能不适用，或者标记为True或False？

这可能比较复杂，但根据任务要求，需要独立检查约束条件，不管subject和condition是否满足。

因此，约束条件的检查可能包括：

对于所有行，检查是否存在减持计划，并且计划披露日提前至少15天。如果满足，则标记为True，否则False。

但这可能不正确，因为约束条件仅适用于减持后的6个月内的情况。因此，约束条件的检查应仅针对那些在减持后的6个月内的行，并且该股东在减持后不再是大股东的情况下？

或者，根据MEU的约束条件，只要满足subject和condition，就需要遵守约束。但根据任务中的说明，对于不需要调用llm_content_check()的项目，三元组的检查是各自独立的。因此，约束条件的检查需要独立进行，不管subject和condition是否满足。

这可能意味着，约束条件的检查需要针对所有行，检查是否满足某些条件，例如存在减持计划且提前披露。

例如，约束条件的有效标记可能为：

valid_constraint = (df['存在减持计划'] == True) & ((df['计划开始日'] - df['计划披露日']).dt.days >= 15)

这可能与MEU_4_1中的处理类似。但这是否正确？

但MEU_13_2的约束条件是“继续遵守本指引第四条规定”，而第四条可能包含不同的要求。例如，第四条可能要求减持前需要提前公告，因此约束条件的检查可能和MEU_4_1相同。

因此，在代码中，约束条件的检查可能与MEU_4_1中的约束条件相同，即检查是否存在减持计划，并且计划披露日提前至少15天。

因此，在代码中，约束条件的有效标记为：

df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days

valid_constraint = (df['存在减持计划']) & (df['交易日差'] >= 15)

但需要确认这是否正确。如果第四条的要求与MEU_4_1相同，则可能正确。否则，可能不正确。但根据用户提供的信息，无法确定第四条的具体内容，因此可能需要假设。

综上，现在将各个部分的代码逻辑整理如下：

1. 标记subject是否为大股东：

   - 股东身份是控股股东、实际控制人、持股5%以上股东，或者持股比例>=5%。

2. 标记condition是否满足：

   - 减持方式是协议转让。

   - 减持导致该股东不再是大股东（减持后的持股比例<5%）。

   - 当前日期处于减持后的6个月内。

3. 标记constraint是否满足：

   - 存在减持计划，并且计划披露日提前至少15天。

但需要注意，constraint的检查是独立的，即不管subject和condition是否满足，都需要检查。

现在，编写代码：

首先，处理subject：

valid_subject = (df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东'])) | (df['持股比例'] >= 0.05)

然后，处理condition：

需要分组处理每个股东，找到所有减持方式为协议转让，且减持后的持股比例<5%的日期，然后标记这些日期之后6个月内的行。

这部分的代码可能比较复杂：

# 初始化condition列为False

df['meu_13_2_condition'] = False

# 分组处理每个股东

for (company, shareholder), group in df.groupby(['公司简称', '股东']):

    # 找出该股东所有减持方式为协议转让，且减持后的持股比例<5%的日期

    mask = (group['减持方式'] == '协议转让') & (group['持股比例'] < 0.05)

    valid_dates = group.loc[mask, '日期']

    # 对于每个有效日期，标记之后6个月内的行

    for date in valid_dates:

        start_date = date

        end_date = start_date + pd.DateOffset(months=6)

        # 在原始df中找到该股东在start_date到end_date之间的行

        condition_mask = (

            (df['公司简称'] == company) &

            (df['股东'] == shareholder) &

            (df['日期'] >= start_date) &

            (df['日期'] < end_date)

        )

        df.loc[condition_mask, 'meu_13_2_condition'] = True

然后，处理constraint：

df['计划披露日'] = pd.to_datetime(df['计划披露日'])  # 假设这些列已经是datetime类型

df['计划开始日'] = pd.to_datetime(df['计划开始日'])

df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days

valid_constraint = (df['存在减持计划']) & (df['交易日差'] >= 15)

但需要确认这些列是否存在，并且数据类型正确。根据用户提供的列，存在“存在减持计划”、“计划披露日”、“计划开始日”等列。

综上，完整的代码可能如下：

import pandas as pd

def check_meu_13_2(df):
    '''
    检查MEU_13_2的合规性：
    subject: 大股东
    condition: 通过协议转让减持导致不再是大股东，且在减持后6个月内
    constraint: 继续遵守第四条
    '''
    df = df.copy()

    # 初始化各列
    df['meu_13_2_subject'] = False
    df['meu_13_2_condition'] = False
    df['meu_13_2_constraint'] = False

    # 标记subject
    # 大股东：股东身份为控股股东、实际控制人、持股5%以上股东，或持股比例>=5%
    is_major = df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东'])
    has_5_percent = df['持股比例'] >= 0.05
    df['meu_13_2_subject'] = is_major | has_5_percent

    # 标记condition
    # 需要分组处理每个股东的减持事件
    # 先重置索引以便修改
    df.reset_index(drop=True, inplace=True)
    for (company, shareholder), group in df.groupby(['公司简称', '股东']):
        # 找出该股东减持方式为协议转让且减持后持股比例<5%的日期
        mask = (group['减持方式'] == '协议转让') & (group['持股比例'] < 0.05)
        valid_dates = group.loc[mask, '日期']
        # 对每个有效日期，标记之后6个月内的行
        for date in valid_dates:
            start = date
            end = start + pd.DateOffset(months=6)
            # 创建条件掩码
            cond_mask = (
                (df['公司简称'] == company) &
                (df['股东'] == shareholder) &
                (df['日期'] >= start) &
                (df['日期'] < end)
            )
            df.loc[cond_mask, 'meu_13_2_condition'] = True

    # 标记constraint
    # 假设第四条要求减持前15天披露计划，类似MEU_4_1
    # 计算交易日差
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    # 存在减持计划且提前15天披露
    valid_constraint = df['存在减持计划'] & (df['交易日差'] >= 15)
    df['meu_13_2_constraint'] = valid_constraint

    return df

但需要注意以下几点：

1. 在标记condition时，假设减持方式列中存在“协议转让”的值。如果数据中不存在该值，则condition将永远为False。

2. 在计算减持后的持股比例时，假设减持当日的持股比例已经反映了减持后的值。因此，如果某次减持导致持股比例降至5%以下，当日的减持方式为协议转让，则该日期被选为有效日期。

3. 在标记constraint时，假设第四条的要求与MEU_4_1相同，即需要提前15天披露减持计划。这可能不一定正确，但根据用户提供的信息，这是合理的假设。

此外，代码中可能需要处理缺失值。例如，计划披露日或计划开始日可能为NaT，导致计算交易日差时出错。因此，可能需要填充缺失值或处理异常情况。例如：

df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days.fillna(-1)

这样，当计划披露日或计划开始日缺失时，交易日差为-1，导致valid_constraint为False。

综上，上述代码可能满足任务要求。
","CompletionUsage(completion_tokens=7409, prompt_tokens=1709, total_tokens=9118, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=6899, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_14_7
法律的最小可执行单元内容: {""subject"": ""上市公司董监高"", ""condition"": ""上市公司股票因可能触及重大违法强制退市情形而被本所实施退市风险警示，且处于本所规定的限制转让的期限内"", ""constraint"": ""不得减持其所持有的本公司股份"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_14_7(df):
    '''
    检查MEU_14_7合规性：
    subject: 上市公司董监高
    condition: 公司股票因重大违法强制退市风险被实施退市风险警示且处于限制转让期
    constraint: 不得减持所持股份
    
    实现逻辑：
    1. subject标记：股东身份为""董监高""
    2. condition标记：公司存在重大违法调查且处于限制转让期
    3. constraint标记：当日无减持行为
    '''
    df = df.copy()

    # 初始化标记列
    df['meu_14_7_subject'] = False
    df['meu_14_7_condition'] = False
    df['meu_14_7_constraint'] = None

    # 标记subject：股东身份为董监高
    valid_subject = df['股东身份'] == '董监高'
    df.loc[valid_subject, 'meu_14_7_subject'] = True

    # 标记condition：公司处于限制转让期
    def _calc_restriction(group):
        # 获取公司所有重大违法调查日期
        investigation_dates = group[group['公司涉嫌证券期货违法犯罪事件'] == '被中国证监会及其派出机构立案调查']['日期'].unique()
        # 生成限制转让期(假设调查后180自然日)
        restriction_periods = [
            (date, date + pd.Timedelta(days=180)) 
            for date in investigation_dates
        ]
        # 标记当前日期是否在任意限制期内
        group['in_restriction'] = group['日期'].apply(
            lambda x: any(start <= x <= end for start, end in restriction_periods)
        )
        return group
    
    df = df.groupby('公司简称', group_keys=False).apply(_calc_restriction)
    valid_condition = df['in_restriction']
    df.loc[valid_condition, 'meu_14_7_condition'] = True

    # 标记constraint：当日无减持
    valid_constraint = df['当日减持比例'] == 0
    df.loc[valid_constraint, 'meu_14_7_constraint'] = True
    df.loc[~valid_constraint, 'meu_14_7_constraint'] = False

    # 清理辅助列
    df.drop(columns=['in_restriction'], inplace=True, errors='ignore')

    return df
</CODE>","好的，我现在需要处理这个MEU_14_7的合规检查问题。首先，我得仔细理解这个MEU的具体内容。MEU_14_7的subject是“上市公司董监高”，condition是当公司股票因可能触及重大违法强制退市情形而被实施退市风险警示，并且处于限制转让期限内。constraint是不得减持所持有的本公司股份。

首先，我需要确定如何标记这三个条件：subject、condition和constraint。根据用户的要求，这三个条件是各自独立检查的，所以需要分别处理，而不是只在subject和condition都满足的情况下检查constraint。不过，对于constraint的检查，可能只有在subject和condition都满足的情况下才需要应用，但根据用户说明，这里的情况是简单操作，所以constraint的检查是独立的？或者需要结合？这里可能需要仔细看用户的要求。

用户提到，对于需要调用llm_content_check()的情况，才需要检查subject和condition都满足时的constraint，但当前任务中没有这种情况。所以，这里的三个条件是各自独立标记的。也就是说，不管subject和condition是否为真，都要检查constraint是否满足，并分别标记每个条件的真伪。不过这可能不太对，因为constraint可能只有在subject和condition都满足时才适用。比如，这里的constraint“不得减持”可能只有当subject是董监高，并且处于condition的情况下才需要检查。但根据用户的要求，对于简单操作，三元组的检查是各自独立的，所以需要分别标记每个条件的真伪，不管其他条件是否满足。这可能是一个需要注意的地方，但根据用户给出的例子，比如在例子中的constraint检查是独立进行的，比如检查是否存在减持计划以及交易日差是否足够，不管subject和condition是否满足。所以在这种情况下，constraint的检查是独立进行的，不管subject和condition是否为真。这可能意味着，即使某个行中的subject不是董监高，或者condition不满足，只要constraint的条件不满足，就会被标记为False。但根据法律的实际要求，可能只有当subject和condition都满足时，constraint才需要被检查。但根据用户的要求，这里需要分开处理，所以可能用户给出的例子中的处理方式是正确的，即三个条件各自独立标记。这可能与实际法律应用不符，但需要按照用户的要求来处理。

不过，我需要再仔细看一下用户的要求。用户说：“对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查。” 所以，这里的三个条件需要各自独立检查，不管其他条件是否满足。例如，即使subject不满足，只要condition满足，condition列就标记为True。同样，constraint的检查也是独立进行的，不管subject和condition是否满足。这可能与实际法律条文的应用不同，但根据用户的要求，必须这样处理。例如，在例子中的constraint检查是独立进行的，比如检查是否存在减持计划和交易日差，不管subject和condition是否为真。这可能意味着，即使某个股东不是董监高，或者没有减持计划，只要存在减持计划且交易日差足够，那么constraint就会被标记为True。这可能与实际法律要求不符，但根据用户的要求，必须这样处理。因此，我需要按照这个逻辑来编写代码。

现在，针对MEU_14_7的具体情况：

1. 标记subject：检查是否是“上市公司董监高”。根据数据中的“股东身份”列，可能的值包括“董监高”、“离任董监高”等。所以，有效的subject应该是“股东身份”列等于“董监高”的行。注意，离任董监高可能不算，因为MEU中的subject是现任的董监高。因此，valid_subject的条件是df['股东身份'] == '董监高'。

2. 标记condition：条件是公司股票因可能触及重大违法强制退市情形而被实施退市风险警示，并且处于限制转让期限内。这需要检查两个部分：公司是否被实施退市风险警示，并且处于限制转让期。在数据中，是否有相关的列？根据提供的columns列表，有一个列是“公司涉嫌证券期货违法犯罪事件”，可能的值包括被立案调查、调查结束等。但退市风险警示可能属于另一个事件类型。或者，可能该列中的某些值可以表示公司被实施退市风险警示。例如，如果公司被实施退市风险警示，可能在“公司涉嫌证券期货违法犯罪事件”列中有对应的标记。或者，是否有其他列可以表示这一点？比如，是否有“退市风险警示”相关的列？根据用户提供的columns列表，可能没有直接的列。这时候可能需要假设，当公司存在某种事件时，比如被中国证监会立案调查，可能触发退市风险警示。或者，可能用户的数据中存在其他逻辑，比如当“公司涉嫌证券期货违法犯罪事件”列包含“可能触及重大违法强制退市情形”时，才会被实施退市风险警示。但根据现有的列，可能无法直接判断。这时候可能需要用户提供更多的信息，但根据问题描述，用户可能希望我们利用现有的列来推断。

或者，可能“公司涉嫌证券期货违法犯罪事件”列中的某些值对应退市风险警示。例如，如果该列的值是“被中国证监会及其派出机构立案调查”，这可能意味着公司可能触及重大违法，从而被实施退市风险警示。但需要明确的是，这里的条件是否满足。例如，当公司被实施退市风险警示时，可能在该事件列中有对应的标记。或者，可能该列中的某些事件类型会触发退市风险警示。例如，如果公司被立案调查，可能触发退市风险警示。或者，可能该列中的某个特定值，如“可能触及重大违法强制退市情形而被本所实施退市风险警示”是否存在？但根据提供的列的可能值，该列的可能值包括“被中国证监会及其派出机构立案调查”、“中国证监会及其派出机构立案调查结束”等，可能没有直接对应的值。这时候可能需要假设，当公司存在“被中国证监会及其派出机构立案调查”时，可能触发退市风险警示。或者，可能用户的数据中存在其他逻辑，比如当公司存在某种类型的违法事件时，会被实施退市风险警示。但这里可能需要根据现有列进行推断。

或者，可能该条件中的“被本所实施退市风险警示”对应数据中的某个特定事件。例如，当“公司涉嫌证券期货违法犯罪事件”列中出现“被本所实施退市风险警示”时，才满足条件。但根据提供的列的可能值，该列的可能值中没有这个选项。这可能意味着，当前的数据中没有直接对应的列，因此无法正确判断condition是否满足。这时候可能需要用户提供更多的信息，或者可能这是一个错误。但根据问题描述，用户可能希望我们利用现有的列来构造条件。

或者，可能该条件中的“可能触及重大违法强制退市情形而被本所实施退市风险警示”对应数据中的某些事件。例如，当公司被中国证监会立案调查时，可能被视为可能触及重大违法，从而被实施退市风险警示。或者，当公司存在“被中国证监会及其派出机构立案调查”时，可能触发退市风险警示。因此，condition的条件可能转化为：公司在该行的日期是否处于被实施退市风险警示的状态，并且处于限制转让期内。

但如何确定公司是否处于退市风险警示状态？可能需要构造一个时间范围。例如，假设当公司被立案调查后，会被实施退市风险警示，并且该状态持续到调查结束或者行政处罚决定作出。或者，可能退市风险警示的开始和结束日期需要根据其他列来推断。例如，当“公司涉嫌证券期货违法犯罪事件”列中出现“被中国证监会及其派出机构立案调查”时，视为开始实施退市风险警示，而当出现“中国证监会及其派出机构立案调查结束”或“行政处罚决定作出”时，视为结束。但具体的规则可能因法律而异，这里可能需要假设。

例如，假设当公司存在“被中国证监会及其派出机构立案调查”的事件时，公司被实施退市风险警示，并且处于限制转让期。而限制转让期的开始和结束时间可能需要根据事件的时间来确定。例如，从立案调查的日期开始，到调查结束的日期为止，或者到行政处罚决定作出的日期为止。或者，可能限制转让期的期限由交易所规定，比如自实施退市风险警示之日起一定时间内。

但根据现有的数据，可能无法直接获取退市风险警示的开始和结束日期。因此，这可能是一个难点。或者，可能用户的数据中存在其他逻辑，比如当公司存在某种事件时，自动处于退市风险警示状态，并且限制转让期是事件后的某个时间段。例如，当公司被立案调查时，退市风险警示开始，并且限制转让期为一定天数，比如30天。但用户的数据中没有这些信息，因此可能需要假设。

在这种情况下，可能需要根据“公司涉嫌证券期货违法犯罪事件”列中的事件来判断。例如，当该列的值是“被中国证监会及其派出机构立案调查”时，视为公司被实施退市风险警示，并且处于限制转让期内。而限制转让期的结束时间可能是在调查结束或者行政处罚决定作出之后。例如，假设限制转让期从立案调查开始，到调查结束后的某个时间点。或者，可能限制转让期是自事件发生之日起一定天数，比如30天。但具体如何计算，需要用户提供更多信息，但根据问题描述，用户可能希望我们根据现有的列进行推断。

例如，假设当公司存在“被中国证监会及其派出机构立案调查”的事件时，公司被实施退市风险警示，并且限制转让期从该事件发生之日起到调查结束后的某个时间。但如何确定每个公司的限制转让期的时间范围？

这可能比较复杂。例如，对于每个公司，需要找到其被立案调查的日期，然后确定限制转让期的开始和结束日期。例如，假设限制转让期从立案调查的日期开始，持续到调查结束后的某个天数，或者直到行政处罚决定作出。或者，可能限制转让期是自退市风险警示实施之日起的固定天数，比如30天。但用户的数据中没有这些具体的时间信息，因此可能需要根据现有列进行推断。

例如，假设当公司某天的“公司涉嫌证券期货违法犯罪事件”列的值是“被中国证监会及其派出机构立案调查”，则从该日期开始，公司处于退市风险警示状态，并且限制转让期开始。而限制转让期的结束日期可能是在该事件后的某个时间段，比如30天之后，或者直到调查结束。但如何确定这个时间段？

或者，可能用户的数据中，当公司处于退市风险警示状态时，会有一个时间段，比如从某个日期开始到另一个日期结束。例如，可能有一个列“退市风险警示开始日期”和“退市风险警示结束日期”，但根据提供的columns列表，没有这样的列。因此，这可能是一个无法处理的问题，因为数据中缺少必要的信息。

这可能意味着，当前的数据不足以正确判断condition是否满足，因此需要用户提供更多的信息。但根据问题描述，用户可能希望我们利用现有的列来构造条件，因此可能需要做一些假设。

例如，假设当公司某天的“公司涉嫌证券期货违法犯罪事件”列的值是“被中国证监会及其派出机构立案调查”，则从该日期开始，公司被实施退市风险警示，并且限制转让期为该日期之后的30个自然日。或者，可能限制转让期是直到调查结束。例如，当公司存在“中国证监会及其派出机构立案调查结束”事件时，限制转让期结束。

但如何确定每个公司的限制转让期的时间范围？例如，对于每个公司，找到其被立案调查的日期，然后确定限制转让期的结束日期。例如，如果公司之后有“中国证监会及其派出机构立案调查结束”事件，则限制转让期到该事件的日期为止。否则，限制转让期可能持续到未来的某个日期。

这可能需要分组处理每个公司，并跟踪每个公司的退市风险警示状态和限制转让期的时间范围。

例如，对于每个公司，找到所有“被中国证监会及其派出机构立案调查”的事件日期，然后对于每个这样的日期，确定限制转让期的开始和结束日期。例如，假设限制转让期从立案调查日期开始，到调查结束日期后的30天。或者，可能限制转让期是自立案调查之日起的30个自然日。

但具体的规则可能因法律而异，这里可能需要假设。例如，假设限制转让期是自立案调查之日起的30个自然日，或者直到调查结束，以较晚者为准。或者，可能限制转让期是自退市风险警示实施之日起的固定天数。

由于用户的数据中没有直接的列来表示退市风险警示的状态和限制转让期的时间范围，因此可能需要根据现有数据进行推断。这可能比较复杂，但根据用户提供的columns，可能需要构造这样的条件。

例如，假设当公司某天的“公司涉嫌证券期货违法犯罪事件”列的值是“被中国证监会及其派出机构立案调查”，则从该日期开始，公司处于退市风险警示状态，并且限制转让期为该日期之后的30个自然日。因此，在之后的30天内，公司处于限制转让期。或者，可能限制转让期是直到调查结束，即当出现“中国证监会及其派出机构立案调查结束”事件时，限制转让期结束。

这可能需要为每个公司构建一个时间线，记录每个事件的发生日期，并确定每个日期是否处于限制转让期内。

例如，对于每个公司，首先收集所有相关的事件日期：

- 被立案调查的日期（事件类型为“被中国证监会及其派出机构立案调查”）
- 调查结束的日期（事件类型为“中国证监会及其派出机构立案调查结束”）
- 行政处罚决定作出的日期（事件类型为“行政处罚决定作出”）

然后，对于每个被立案调查的事件，限制转让期可能从该日期开始，直到调查结束后的某个日期，比如30天之后。或者，可能限制转让期在调查结束后仍然有效一段时间。

例如，假设当公司被立案调查时，限制转让期开始，并在调查结束后的30天结束。或者，可能限制转让期持续到调查结束后的某个时间点，比如行政处罚决定作出之日。

但具体的规则不明确，这里可能需要做一些假设。例如，假设限制转让期从立案调查的日期开始，持续到调查结束后的30天。如果调查尚未结束，则限制转让期持续到当前日期之后。

这可能比较复杂，但需要根据现有数据来构造条件。

现在，回到问题本身，MEU_14_7的condition是“上市公司股票因可能触及重大违法强制退市情形而被本所实施退市风险警示，且处于本所规定的限制转让的期限内”。因此，需要判断两个条件：

1. 公司被实施退市风险警示（由于可能触及重大违法强制退市情形）
2. 当前日期处于限制转让期内

假设，当公司被立案调查时，视为被实施退市风险警示，并且限制转让期开始。例如，当“公司涉嫌证券期货违法犯罪事件”列的值是“被中国证监会及其派出机构立案调查”时，公司被实施退市风险警示，并且限制转让期开始。然后，限制转让期的结束日期可能是在调查结束后的某个时间，或者根据交易所的规定。

例如，假设限制转让期为自退市风险警示实施之日起的6个月。或者，可能限制转让期持续到退市风险警示被解除。但如何确定退市风险警示的解除时间？

这可能无法从现有数据中直接推断，因此可能需要另一个假设。例如，当公司出现“中国证监会及其派出机构立案调查结束”事件时，退市风险警示被解除，限制转让期结束。或者，可能退市风险警示的解除需要其他条件，比如行政处罚决定作出之后。

但根据现有数据，可能只能根据事件的发生日期来判断。例如，当公司被立案调查时，开始实施退市风险警示，并且限制转让期开始。当调查结束后，退市风险警示可能被解除，限制转让期结束。或者，可能限制转让期在调查结束后仍然持续一段时间。

例如，假设限制转让期从立案调查的日期开始，到调查结束后的30天为止。如果调查尚未结束，则限制转让期持续到当前日期之后。

因此，对于每个公司，我们需要确定每个交易日是否处于任何一个限制转让期内。例如，对于每个公司，找到所有立案调查的日期，并为每个这样的日期创建一个时间范围（开始日期到结束日期），然后检查当前行的日期是否落在任何一个这样的时间范围内。

这可能需要分组处理每个公司，并为每个公司生成所有限制转让期的时间段，然后检查当前行的日期是否处于其中任何一个时间段内。

具体步骤可能如下：

1. 对每个公司，收集所有“被中国证监会及其派出机构立案调查”的事件日期，作为退市风险警示的开始日期。
2. 对于每个开始日期，找到对应的结束日期，比如调查结束日期加上30天。假设当公司出现“中国证监会及其派出机构立案调查结束”事件时，结束日期为该事件日期加30天。如果没有调查结束事件，则结束日期为开始日期加一年（假设的默认值，或者根据交易所规定）。
3. 对于每个公司，生成所有可能的限制转让期时间段（开始日期到结束日期）。
4. 对于每一行数据，检查该行的日期是否处于任何限制转让期的时间段内。

这可能需要为每个公司生成一个时间段列表，然后检查当前行的日期是否在任何一个时间段内。

但如何实现这一点呢？在pandas中，可能需要使用groupby和apply函数来处理每个公司的时间段。

例如，首先筛选出所有公司被立案调查的事件：

df_events = df[df['公司涉嫌证券期货违法犯罪事件'] == '被中国证监会及其派出机构立案调查']

然后，对于每个公司，收集这些事件的日期，并找到对应的结束日期。例如，假设结束日期是调查结束事件的日期加30天：

对于每个公司，找到所有调查结束的事件：

df_end_events = df[df['公司涉嫌证券期货违法犯罪事件'] == '中国证监会及其派出机构立案调查结束']

然后，对于每个立案调查的开始日期，找到对应的结束日期。例如，假设每个开始日期对应的结束日期是调查结束事件中最近的日期，如果没有，则设为开始日期加一年。

这可能比较复杂，但可以尝试以下步骤：

1. 对每个公司，收集所有立案调查的开始日期和调查结束的日期。
2. 对于每个开始日期，找到对应的结束日期（如果有的话），并计算结束日期加30天。
3. 如果没有对应的结束日期，则结束日期设为开始日期加一年（或其他假设的时间段）。
4. 生成时间段列表。
5. 对于每一行数据，检查其日期是否处于任何时间段内。

这可能需要在数据中创建辅助列或使用apply函数。

但考虑到时间和复杂度，可能用户希望简化处理。例如，假设只要公司存在被立案调查的事件，则从该日期开始，限制转让期为该日期之后的30个自然日。或者，可能只要公司存在被立案调查的事件，则整个期间都处于限制转让期，直到调查结束。

例如，假设当公司某天存在“被中国证监会及其派出机构立案调查”事件时，从该日期开始，公司处于限制转让期，直到该事件后的某个日期。例如，限制转让期为该事件日期后的180天。

这可能是一个简化的处理方式，但需要根据用户的数据进行假设。

或者，可能用户的数据中，当公司存在被立案调查的事件时，该行的日期处于限制转让期内。例如，当某行的“公司涉嫌证券期货违法犯罪事件”列的值是“被中国证监会及其派出机构立案调查”时，该行的日期处于限制转让期。但这样可能无法覆盖后续的日期，因为该事件可能只在发生的那一天被记录，而限制转让期可能持续多天。

因此，可能需要将每个立案调查事件的日期扩展为一个时间段。例如，当公司被立案调查时，限制转让期从该日期开始，持续到该日期后的180天。

例如，对于每个公司，找到所有立案调查的日期，然后为每个日期生成一个时间段（start_date, start_date + 180 days）。然后，检查当前行的日期是否落在任何一个这样的时间段内。

这可能更可行。例如，假设限制转让期为自立案调查之日起的180天。

现在，如何实现这一点？

首先，为每个公司生成所有立案调查的日期：

df_events = df[df['公司涉嫌证券期货违法犯罪事件'] == '被中国证监会及其派出机构立案调查']

然后，对于每个公司，收集这些日期，并为每个日期生成一个时间段：

对于每个公司，创建一个列表，其中每个元素是一个元组（start_date, end_date），其中end_date = start_date + 180 days。

然后，对于每一行数据，检查该行的日期是否处于任何这样的时间段内。

这可以通过定义一个函数，对每个公司的每一行数据进行检查，判断其日期是否在任何一个时间段内。

例如，使用groupby('公司简称')，然后对每个组进行处理：

def check_restriction_period(group):
    # 获取该公司的所有立案调查日期
    investigation_dates = group[group['公司涉嫌证券期货违法犯罪事件'] == '被中国证监会及其派出机构立案调查']['日期'].unique()
    # 生成时间段列表
    periods = [(date, date + pd.Timedelta(days=180)) for date in investigation_dates]
    # 对每一行，检查是否在任何一个时间段内
    group['in_restriction_period'] = group['日期'].apply(lambda x: any(start <= x <= end for start, end in periods))
    return group

然后，应用这个函数到每个公司：

df = df.groupby('公司简称', group_keys=False).apply(check_restriction_period)

这样，每个公司的行都会被标记是否处于限制转让期内。

但需要注意，这可能是一个简化的假设，因为实际的限制转让期可能由交易所规定，可能不是固定的180天。但根据用户的数据，可能需要这样的假设。

现在，回到MEU_14_7的condition，需要满足两个条件：

1. 公司被实施退市风险警示（可能对应被立案调查）
2. 处于限制转让期内

因此，condition的valid条件应该是：

valid_condition = (df['公司涉嫌证券期货违法犯罪事件'] == '被中国证监会及其派出机构立案调查') & (df['in_restriction_period'] == True)

或者，根据之前的处理，当公司处于限制转让期时，即in_restriction_period为True，并且被实施退市风险警示（即被立案调查）。

但可能退市风险警示的实施和限制转让期是同时发生的，因此当公司处于限制转让期时，即意味着被实施退市风险警示。因此，condition的valid条件可能只需要检查是否处于限制转让期内。

或者，可能被实施退市风险警示是条件的一部分，而限制转让期是另一个部分。因此，需要同时满足这两个条件。

但根据MEU的描述，condition是“上市公司股票因可能触及重大违法强制退市情形而被本所实施退市风险警示，且处于本所规定的限制转让的期限内”。因此，两个条件都需要满足：被实施退市风险警示，并且处于限制转让期。

因此，在代码中，需要同时检查这两个条件。例如，当公司被实施退市风险警示（即被立案调查）并且处于限制转让期内时，condition为True。

但根据之前的处理，in_restriction_period列已经表示公司是否处于限制转让期内，这可能已经包含了被实施退市风险警示的条件。或者，可能需要更精确的条件。

例如，假设被实施退市风险警示的条件是公司存在被立案调查的事件，而限制转让期是自该事件后的时间段。因此，当处于限制转让期内时，公司已经被实施退市风险警示。因此，condition的valid条件可能只需要检查是否处于限制转让期内。

或者，可能需要同时检查公司是否被实施退市风险警示（即存在被立案调查的事件）并且处于限制转让期内。例如，当公司被立案调查，并且当前日期处于该事件后的限制转让期内时，condition为True。

因此，valid_condition的条件可能为：

valid_condition = (df['公司涉嫌证券期货违法犯罪事件'] == '被中国证监会及其派出机构立案调查') & (df['in_restriction_period'] == True)

或者，可能更准确的条件是，公司被实施退市风险警示，并且处于限制转让期。而实施退市风险警示的条件是存在被立案调查的事件，而限制转让期是自该事件后的时间段。因此，当处于限制转让期内时，公司已经被实施退市风险警示。因此，valid_condition的条件可能只需要检查是否处于限制转让期内。

这可能需要根据具体的法律条文来判断，但根据MEU的描述，condition是两个条件的联合，因此需要同时满足。

但根据用户的数据，可能无法直接判断公司是否被实施退市风险警示，因此可能需要假设被立案调查即视为被实施退市风险警示。因此，condition的valid条件为：

valid_condition = (df['公司涉嫌证券期货违法犯罪事件'] == '被中国证监会及其派出机构立案调查') & (df['in_restriction_period'] == True)

或者，可能被立案调查即触发退市风险警示，并且限制转让期是自该事件后的时间段。因此，当处于限制转让期内时，两个条件都满足。因此，valid_condition的条件可能只需要检查是否处于限制转让期内。

这可能取决于法律的具体规定，但根据MEU的描述，condition是两个条件的联合，因此需要分别检查。

现在，假设我们通过之前的处理，已经为每个公司生成了in_restriction_period列，表示是否处于限制转让期内。那么，condition的valid条件可以简化为：

valid_condition = df['in_restriction_period']

因为处于限制转让期意味着公司已经被实施退市风险警示，并且处于限制转让期内。或者，可能需要更精确的条件。

例如，假设公司被实施退市风险警示的时间段是从被立案调查的日期开始，到调查结束后的某个日期。因此，当处于限制转让期内时，公司已经被实施退市风险警示。因此，valid_condition的条件是处于限制转让期内。

因此，在代码中，condition的valid条件可能只需要检查是否处于限制转让期内，即：

valid_condition = df['in_restriction_period']

但需要确保in_restriction_period列正确反映了公司是否处于退市风险警示状态下的限制转让期。

现在，关于constraint的检查：constraint是“不得减持其所持有的本公司股份”。因此，需要检查该股东在该交易日是否有减持行为。例如，减持比例是否大于0，或者是否存在减持记录。

根据数据中的列，可能相关的列是“当日减持比例”或“累计减持比例”。例如，如果“当日减持比例”大于0，则表示该股东在该交易日减持了股份。因此，constraint的valid条件是该股东在该交易日没有减持，即“当日减持比例”等于0。

因此，valid_constraint的条件是：

valid_constraint = df['当日减持比例'] == 0

但需要注意，constraint的检查是独立进行的，不管subject和condition是否为真。因此，即使某个股东不是董监高，或者公司不处于限制转让期，只要该股东在该交易日减持了股份，constraint就会被标记为False。反之，如果该股东没有减持，则constraint标记为True。

但根据法律的实际要求，只有当subject和condition都满足时，才需要遵守constraint。但根据用户的要求，三个条件是独立检查的，因此需要分别标记每个条件的真伪，不管其他条件是否满足。因此，即使subject和condition都不满足，只要该股东减持了股份，constraint就会被标记为False。这可能与实际法律要求不符，但根据用户的要求，必须这样处理。

现在，总结各部分的处理：

1. subject的valid条件是股东身份为“董监高”：

valid_subject = df['股东身份'] == '董监高'

2. condition的valid条件是公司处于限制转让期内，即in_restriction_period为True。而in_restriction_period的计算需要根据公司是否被立案调查，并处于限制转让期的时间段内。这需要先为每个公司生成该时间段，并标记每一行是否处于其中。

3. constraint的valid条件是当日减持比例为0：

valid_constraint = df['当日减持比例'] == 0

现在，编写代码的步骤：

首先，处理condition的条件，需要为每个公司生成限制转让期的时间段，并标记每一行是否处于其中。

在代码中，需要添加一个辅助列'in_restriction_period'，表示该行日期是否处于限制转让期内。

这可以通过以下步骤实现：

a. 筛选出公司被立案调查的事件，即“公司涉嫌证券期货违法犯罪事件”为“被中国证监会及其派出机构立案调查”的行。

b. 对每个公司，收集这些事件的日期，并为每个日期生成一个时间段（例如，开始日期到开始日期+180天）。

c. 对每一行数据，检查其日期是否处于任何时间段内。

例如：

def check_restriction_period(group):
    # 获取该公司的所有立案调查日期
    investigation_dates = group[group['公司涉嫌证券期货违法犯罪事件'] == '被中国证监会及其派出机构立案调查']['日期'].dt.date.unique()
    # 生成时间段列表，每个时间段为立案调查日期后的180天
    periods = []
    for date in investigation_dates:
        start_date = pd.to_datetime(date)
        end_date = start_date + pd.Timedelta(days=180)
        periods.append((start_date, end_date))
    # 检查每一行的日期是否在任何一个时间段内
    group['in_restriction_period'] = group['日期'].apply(
        lambda x: any(start <= x <= end for start, end in periods)
    )
    return group

然后，应用这个函数到每个公司：

df = df.groupby('公司简称', group_keys=False).apply(check_restriction_period)

这将为每个公司的行添加'in_restriction_period'列，表示是否处于限制转让期内。

然后，condition的valid条件为：

valid_condition = df['in_restriction_period']

现在，编写完整的代码：

首先，初始化各列：

df['meu_14_7_subject'] = False
df['meu_14_7_condition'] = False
df['meu_14_7_constraint'] = None  # 初始化为None，之后填充True或False

处理subject：

valid_subject = df['股东身份'] == '董监高'
df.loc[valid_subject, 'meu_14_7_subject'] = True

处理condition：

# 已经通过之前的处理添加了'in_restriction_period'列
valid_condition = df['in_restriction_period']
df.loc[valid_condition, 'meu_14_7_condition'] = True

处理constraint：

valid_constraint = df['当日减持比例'] == 0
df.loc[valid_constraint, 'meu_14_7_constraint'] = True
df.loc[~valid_constraint, 'meu_14_7_constraint'] = False

但需要注意，constraint的检查是独立进行的，不管其他条件是否满足。因此，所有行都需要检查，无论subject和condition是否为真。

现在，整合所有步骤到函数中：

import pandas as pd

def check_meu_14_7(df):
    '''
    检查MEU_14_7的合规性：
    subject: 上市公司董监高
    condition: 公司股票因可能触及重大违法强制退市情形被实施退市风险警示，且处于限制转让期
    constraint: 不得减持所持本公司股份
    '''
    df = df.copy()

    # 初始化标记列
    df['meu_14_7_subject'] = False
    df['meu_14_7_condition'] = False
    df['meu_14_7_constraint'] = None  # 初始化为None，之后填充True/False

    # 标记subject：股东身份为董监高
    valid_subject = df['股东身份'] == '董监高'
    df.loc[valid_subject, 'meu_14_7_subject'] = True

    # 处理condition：公司处于限制转让期内
    # 辅助函数，为每个公司生成限制转让期标记
    def check_restriction_period(group):
        # 获取该公司的所有立案调查日期
        investigation_dates = group[group['公司涉嫌证券期货违法犯罪事件'] == '被中国证监会及其派出机构立案调查']['日期'].dt.date.unique()
        periods = []
        for date in investigation_dates:
            start_date = pd.to_datetime(date)
            end_date = start_date + pd.Timedelta(days=180)  # 假设限制转让期为180天
            periods.append((start_date, end_date))
        # 检查每一行日期是否在任何一个时间段内
        group['in_restriction_period'] = group['日期'].apply(
            lambda x: any(start <= x <= end for start, end in periods)
        )
        return group

    # 应用辅助函数，按公司分组处理
    df = df.groupby('公司简称', group_keys=False).apply(check_restriction_period)

    # 标记condition
    valid_condition = df['in_restriction_period']
    df.loc[valid_condition, 'meu_14_7_condition'] = True

    # 标记constraint：当日减持比例为0
    valid_constraint = df['当日减持比例'] == 0
    df.loc[valid_constraint, 'meu_14_7_constraint'] = True
    df.loc[~valid_constraint, 'meu_14_7_constraint'] = False

    # 删除辅助列
    df.drop(columns=['in_restriction_period'], inplace=True, errors='ignore')

    return df

但需要注意，这里假设限制转让期为自立案调查之日起的180天。这可能不符合实际法律要求，但根据用户的数据，只能做这样的假设。此外，可能还需要处理同一公司多次被立案调查的情况，即多个时间段。例如，如果公司多次被立案调查，每个事件都会生成一个时间段，当前日期只要处于任何一个时间段内，就视为处于限制转让期。

此外，可能还需要考虑自然日与交易日的区别。例如，限制转让期是按自然日计算的，而数据中的日期是交易日。但根据用户说明，所有日期相关的列已经是pd.datetime格式，且“日期”列是交易日。因此，在计算时间段时，可能需要使用自然日，但检查时使用交易日。例如，如果限制转让期是自立案调查日期（某个交易日）后的180个自然日，那么时间段将覆盖这些自然日，而数据中的日期可能不是连续的交易日。因此，在检查时，只要该行的日期（某个交易日）落在自然日的时间段内，就视为处于限制转让期。

这可能是一个合理的处理方式，因为法律中的期限通常是按自然日计算的，而不是交易日。

现在，测试代码是否满足用户的要求：

- subject被正确标记为股东身份是董监高的行。
- condition被正确标记为公司处于限制转让期内的行。
- constraint被正确标记为当日减持比例是否为0的行。

此外，三个条件的标记是独立的，不管其他条件是否满足。例如，即使某个股东不是董监高，只要当日减持比例大于0，constraint会被标记为False。或者，即使公司不处于限制转让期，只要当日减持比例为0，constraint会被标记为True。

最后，返回的dataframe应包含三个新的列：meu_14_7_subject、meu_14_7_condition、meu_14_7_constraint，分别记录各条件的满足情况。
","CompletionUsage(completion_tokens=8122, prompt_tokens=1718, total_tokens=9840, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=7569, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_14_1
法律的最小可执行单元内容: {""subject"": ""上市公司董监高"", ""condition"": ""上市公司因涉嫌证券期货违法犯罪，在被中国证监会及其派出机构立案调查或者被司法机关立案侦查期间"", ""constraint"": ""不得减持其所持有的本公司股份"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_14_1(df):
    '''
    检查MEU_14_1合规性：
    subject: 上市公司董监高
    condition: 公司因涉嫌证券期货违法犯罪被立案调查或侦查期间
    constraint: 不得减持股份
    '''
    df = df.copy()

    # 初始化标记列
    df['meu_14_1_subject'] = False
    df['meu_14_1_condition'] = False
    df['meu_14_1_constraint'] = None

    # 1. 验证责任主体：股东身份为董监高
    valid_subject = df['股东身份'] == '董监高'
    df.loc[valid_subject, 'meu_14_1_subject'] = True

    # 2. 验证触发条件：公司处于被立案调查/侦查状态
    investigation_conditions = ['被中国证监会及其派出机构立案调查', '被司法机关立案侦查']
    valid_condition = df['公司涉嫌证券期货违法犯罪事件'].isin(investigation_conditions)
    df.loc[valid_condition, 'meu_14_1_condition'] = True

    # 3. 验证约束条件：当日无减持行为
    # 处理空值并转换为数值型
    df['当日减持比例'] = pd.to_numeric(df['当日减持比例'], errors='coerce').fillna(0)
    valid_constraint = df['当日减持比例'] == 0
    # 设置约束标记
    df.loc[valid_constraint, 'meu_14_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_14_1_constraint'] = False

    return df
</CODE>","好的，我现在需要处理这个MEU_14_1的合规性检查。首先，我得仔细理解这个MEU的内容。根据给定的信息，MEU_14_1的subject是“上市公司董监高”，condition是“公司因涉嫌证券期货违法犯罪被立案调查或侦查期间”，而constraint是“不得减持股份”。

首先，处理subject部分。根据dataframe中的列，股东身份有“董监高”这一项。所以，我需要检查每一行的股东身份是否是“董监高”。这里需要注意的是，离任董监高可能不算，所以应该直接筛选股东身份等于“董监高”的行。

接下来是condition部分。condition的条件是公司被中国证监会或其派出机构立案调查，或者被司法机关立案侦查。在数据中，公司涉嫌证券期货违法犯罪事件的列是存在的，所以需要检查该列是否包含“被中国证监会及其派出机构立案调查”或“被司法机关立案侦查”这两个值。当公司处于这些状态时，condition成立。

然后是constraint部分。约束是不得减持股份。这里需要检查在该交易日是否有减持行为。可能的判断依据是当日减持比例是否大于0，或者是否存在减持计划。但根据数据中的列，可能存在“当日减持比例”这一项，如果该值大于0，则表示当天有减持。因此，constraint的valid应该是该股东当天没有减持行为，即当日减持比例等于0，或者不存在减持计划？

不过根据MEU的约束，只要在立案期间，董监高不得减持。所以，只要在满足subject和condition的情况下，如果当日有减持行为（比如当日减持比例>0），则违反约束。但根据任务要求，constraint的检查是独立的，即不管subject和condition是否符合，都要检查。但根据附加信息中的说明，对于不需要调用LLM的情况，三元组的检查是各自独立的。所以，这里可能需要将constraint的条件单独判断，即无论subject和condition是否满足，只要该股东当天减持了股份，就标记constraint为False？或者这里的constraint是否仅在subject和condition满足时才有效？

根据用户的任务要求中的说明：“对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查。”所以，constraint的检查是独立的，不管subject和condition是否满足，都要检查。但MEU中的约束是“不得减持”，所以无论什么情况下，只要减持了，就违反约束？或者这里的约束是否仅在满足subject和condition的情况下才需要遵守？

这可能存在矛盾。根据法律条文，约束是当subject和condition都满足时，才需要遵守。但根据任务中的要求，对于不需要调用LLM的情况，三元组的检查是各自独立的。所以在这种情况下，constraint的检查可能只是单纯检查是否减持，而不管subject和condition是否满足。但这样的话，可能不符合实际的法律逻辑。例如，如果某个股东不是董监高，或者公司没有被立案，那么减持是否违反这个MEU的约束？

根据用户提供的示例，比如MEU_4_1的示例中，constraint的检查是独立进行的，比如检查是否有提前15天披露，不管subject和condition是否满足。这可能是因为示例中的约束条件可能在任何情况下都需要满足，比如只要存在减持计划，不管是否是董监高，都需要提前披露。但实际情况可能并非如此，但根据任务要求，必须按照独立检查来处理。

所以，针对MEU_14_1的constraint，正确的处理方式应该是：无论subject和condition是否满足，只要该股东在当天减持了股份，则constraint为False，否则为True？或者这里的约束是否仅在满足subject和condition的情况下才适用？

根据MEU_14_1的约束内容，“不得减持其所持有的本公司股份”应该是在满足subject和condition的情况下才生效。但根据用户的任务要求，对于不需要调用LLM的情况，三元组的检查是各自独立的。因此，这里的constraint检查可能需要独立判断，即不管subject和condition是否满足，只要该股东当天减持了，则标记constraint为False，否则为True。但这样可能不符合法律的实际要求，因为约束只有在特定条件下才适用。

这可能是一个矛盾点。需要仔细阅读用户的任务说明。用户提到：“对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)”

因此，在MEU_14_1的情况下，constraint的检查是独立的，即不管subject和condition是否满足，都要检查。但根据法律条文，约束只有在subject和condition都满足时才适用。但根据任务要求，必须独立检查。这可能意味着，在代码中，constraint的检查条件可能被错误地处理，但根据用户的要求，必须这样做。

例如，在示例中，MEU_4_1的constraint检查是独立进行的，比如检查是否有提前15天披露，不管是否是董监高或是否有减持计划。这可能不符合实际法律要求，但根据任务要求，必须这样处理。

因此，针对MEU_14_1的constraint，正确的处理方式应该是：检查该股东在当天是否有减持行为，即当日减持比例是否大于0。如果有，则constraint为False，否则为True。不管该股东是否是董监高，或者公司是否被立案。

但这样显然不符合法律的实际要求，因为约束只有在公司被立案且股东是董监高时才适用。但根据任务要求，必须独立检查。这可能是一个问题，但根据用户给出的示例，必须按照独立检查来处理。

或者，可能我误解了任务要求。需要再仔细阅读任务说明：

“对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)”

所以，对于当前任务中的MEU_14_1，属于不需要调用LLM的情况，因此三元组的检查是各自独立的。即：

- subject的检查：是否属于董监高。
- condition的检查：公司是否被立案调查或侦查。
- constraint的检查：是否减持股份。

这三个条件的检查是独立的，不管其他条件是否满足。例如，即使股东不是董监高，或者公司没有被立案，只要该股东减持了股份，则constraint标记为False。这可能与实际法律条文不符，但根据任务要求必须这样处理。

但这样的话，constraint的检查可能过于宽泛，因为法律条文中的约束只有在特定条件下才适用。但根据用户的要求，必须独立检查。这可能是一个矛盾，但必须按照用户的要求来编写代码。

现在，我需要根据这些理解来编写代码。

首先，处理subject：

subject是“上市公司董监高”，对应的数据列是“股东身份”是否为“董监高”。因此，valid_subject = df['股东身份'] == '董监高'。

接下来，condition的条件是公司因涉嫌证券期货违法犯罪，在被中国证监会及其派出机构立案调查或者被司法机关立案侦查期间。对应的数据列是“公司涉嫌证券期货违法犯罪事件”，需要检查该列是否包含“被中国证监会及其派出机构立案调查”或“被司法机关立案侦查”。例如，当该列的值是这两个中的一个时，condition成立。因此，valid_condition = df['公司涉嫌证券期货违法犯罪事件'].isin(['被中国证监会及其派出机构立案调查', '被司法机关立案侦查'])。

然后是constraint的检查，即是否减持了股份。根据数据中的列，可能有“当日减持比例”或“存在减持计划”等。但根据MEU的约束，是“不得减持”，所以只要当日有减持行为，就违反约束。因此，判断条件可以是当日减持比例是否大于0。如果该列存在，则valid_constraint = df['当日减持比例'] <= 0。或者，如果存在“当日减持数量”或类似列，但根据提供的列，有“当日减持比例”这一列。因此，如果当日减持比例大于0，则constraint为False，否则为True。因此，valid_constraint = (df['当日减持比例'] == 0) | (df['当日减持比例'].isna())。或者，假设如果当日减持比例为0或不存在减持行为，则满足约束。但需要确认数据中的列是否存在。根据提供的列，确实有“当日减持比例”这一列，所以：

valid_constraint = df['当日减持比例'] <= 0

但需要注意，如果当日减持比例是0，则满足约束；如果大于0，则违反。但可能该列的值可能为NaN，比如没有减持的情况下，可能为0或者NaN？需要根据数据情况处理。例如，假设没有减持的情况下，当日减持比例是0，或者可能为NaN？如果数据中，当没有减持时，该列可能为0，则可以直接判断是否等于0。或者，如果存在减持计划，但当日未减持，可能该列为0。因此，valid_constraint = (df['当日减持比例'] == 0) | (df['当日减持比例'].isna())，但需要根据实际情况调整。或者，假设只要当日减持比例大于0，就视为减持，否则视为未减持。因此，valid_constraint = df['当日减持比例'] <= 0。或者，可能该列在减持时才会有数值，否则为0？需要明确数据中的情况。例如，如果某天该股东没有减持，那么“当日减持比例”可能为0，或者可能不存在（NaN）？或者该列可能默认填充0？

假设该列在未减持时是0，减持时是正数，那么valid_constraint = df['当日减持比例'] == 0。或者，如果该列在未减持时为NaN，则需要处理NaN的情况。例如，使用fillna(0)后判断是否为0。但根据用户提供的列描述，“当日减持比例”应该是一个存在的列，可能默认值为0，当有减持时填写相应的比例。因此，正确的判断条件应该是：

valid_constraint = df['当日减持比例'] == 0

或者，如果该列在减持时填写了正数，否则为0，则这样处理是正确的。因此，当该列等于0时，constraint为True，否则为False。

综上，代码的大致结构如下：

1. 初始化三个新列，初始值为False或None。
2. 标记subject：股东身份是否为董监高。
3. 标记condition：公司是否处于被立案调查或侦查的状态。
4. 标记constraint：当日是否没有减持（当日减持比例等于0）。
5. 将这三个条件的结果分别填入对应的列中。

现在，编写代码：

首先，复制dataframe以避免修改原始数据。

然后，初始化三个新列：

df['meu_14_1_subject'] = False
df['meu_14_1_condition'] = False
df['meu_14_1_constraint'] = None  # 初始化为None，之后根据条件设置为True或False

接下来，处理subject：

valid_subject = df['股东身份'] == '董监高'

处理condition：

valid_condition = df['公司涉嫌证券期货违法犯罪事件'].isin(['被中国证监会及其派出机构立案调查', '被司法机关立案侦查'])

处理constraint：

valid_constraint = df['当日减持比例'] == 0

然后，将这三个条件的结果赋值到对应的列：

df.loc[valid_subject, 'meu_14_1_subject'] = True
df.loc[valid_condition, 'meu_14_1_condition'] = True
df.loc[valid_constraint, 'meu_14_1_constraint'] = True
df.loc[~valid_constraint, 'meu_14_1_constraint'] = False  # 将不满足条件的行设为False

但需要注意，如果当日减持比例是NaN的情况如何处理。例如，如果某行没有减持，可能该列为NaN，此时valid_constraint会被视为False。但根据数据描述，可能该列在无减持时为0，所以可能不需要处理NaN。或者，如果存在NaN，则需要填充为0。例如：

df['当日减持比例'] = df['当日减持比例'].fillna(0)
valid_constraint = df['当日减持比例'] == 0

但根据用户提供的列描述，可能该列在无减持时是0，所以不需要处理NaN。但为了保险起见，可以填充NaN为0：

df['当日减持比例'] = df['当日减持比例'].fillna(0)
valid_constraint = df['当日减持比例'] == 0

或者在处理时直接填充：

valid_constraint = (df['当日减持比例'].fillna(0) == 0)

这样，即使存在NaN，也会被视为0，从而满足约束条件。

综上，代码的编写需要考虑这些情况。因此，在处理constraint时，应该填充NaN为0，然后判断是否等于0。

现在，将这些步骤整合到代码中：

def check_meu_14_1(df):
    '''
    检查MEU_14_1的合规性：
    subject: 上市公司董监高
    condition: 公司因涉嫌证券期货违法犯罪被立案调查或侦查期间
    constraint: 不得减持股份
    '''
    df = df.copy()

    # 初始化列
    df['meu_14_1_subject'] = False
    df['meu_14_1_condition'] = False
    df['meu_14_1_constraint'] = None  # 之后设置为True或False

    # 检查subject
    valid_subject = df['股东身份'] == '董监高'
    df.loc[valid_subject, 'meu_14_1_subject'] = True

    # 检查condition
    valid_condition = df['公司涉嫌证券期货违法犯罪事件'].isin(['被中国证监会及其派出机构立案调查', '被司法机关立案侦查'])
    df.loc[valid_condition, 'meu_14_1_condition'] = True

    # 检查constraint：当日是否没有减持
    # 填充NaN为0，假设没有减持的情况下当日减持比例为0
    df['当日减持比例_filled'] = df['当日减持比例'].fillna(0)
    valid_constraint = df['当日减持比例_filled'] == 0
    df['meu_14_1_constraint'] = valid_constraint

    return df

但根据用户提供的示例，constraint列需要初始化为None，然后根据条件设置为True或False。但上面的代码中，直接使用valid_constraint的结果来填充整个列。这可能与示例中的处理方式不同。例如，在示例中，constraint列初始化为None，然后通过loc来设置True和False。因此，正确的处理方式应该是：

df['meu_14_1_constraint'] = None  # 初始化为None
valid_constraint = (df['当日减持比例'].fillna(0) == 0)
df.loc[valid_constraint, 'meu_14_1_constraint'] = True
df.loc[~valid_constraint, 'meu_14_1_constraint'] = False

或者，更简洁的方式：

df['meu_14_1_constraint'] = (df['当日减持比例'].fillna(0) == 0).astype(bool)

但根据示例中的处理方式，可能更倾向于使用loc来设置值。例如：

# 处理constraint
df['meu_14_1_constraint'] = None  # 初始化为None
# 填充当日减持比例的NaN为0
df['当日减持比例'] = df['当日减持比例'].fillna(0)
valid_constraint = df['当日减持比例'] == 0
df.loc[valid_constraint, 'meu_14_1_constraint'] = True
df.loc[~valid_constraint, 'meu_14_1_constraint'] = False

这样处理可能更清晰。

综上，最终的代码应该包括：

- 初始化三个列
- 分别计算三个条件
- 使用loc来设置对应的值

现在，将这些步骤整合到代码中：

def check_meu_14_1(df):
    '''
    检查MEU_14_1的合规性：
    subject: 上市公司董监高
    condition: 公司因涉嫌证券期货违法犯罪被立案调查或侦查期间
    constraint: 不得减持股份
    '''
    df = df.copy()

    # 初始化列
    df['meu_14_1_subject'] = False
    df['meu_14_1_condition'] = False
    df['meu_14_1_constraint'] = None

    # 检查subject是否为董监高
    valid_subject = df['股东身份'] == '董监高'
    df.loc[valid_subject, 'meu_14_1_subject'] = True

    # 检查condition：公司是否被立案调查或侦查
    valid_condition = df['公司涉嫌证券期货违法犯罪事件'].isin(['被中国证监会及其派出机构立案调查', '被司法机关立案侦查'])
    df.loc[valid_condition, 'meu_14_1_condition'] = True

    # 检查constraint：当日是否没有减持
    # 处理可能的NaN值，假设无减持时为0
    df['当日减持比例'] = df['当日减持比例'].fillna(0)
    valid_constraint = df['当日减持比例'] == 0
    df.loc[valid_constraint, 'meu_14_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_14_1_constraint'] = False

    return df

这样，代码就完成了。每个条件的检查都是独立的，符合任务要求。例如，不管股东是否是董监高，或者公司是否被立案，只要当日减持比例大于0，constraint就会被标记为False。这可能与实际法律条文中的约束条件不符，但根据用户的任务要求，必须这样处理。
","CompletionUsage(completion_tokens=4302, prompt_tokens=1710, total_tokens=6012, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=3913, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_9_3
法律的最小可执行单元内容: {""subject"": ""董监高"", ""condition"": ""在前款规定的2个完整会计年度期间内离职"", ""constraint"": ""应当继续遵守前款规定的减持限制"", ""contextual_info"": NaN}
必要的额外信息: nan

你被分配的MEU coding任务存在refer_to关系, 你需要参考下面这个MEU的必要内容来完成你被安排的任务, 但你不需要直接执行下面的MEU: 
【MEU_9_1】
subject: 控股股东 | 实际控制人 | 董监高
condition: 公司上市时未盈利且处于实现盈利前阶段
constrain: 自公司股票上市之日起2个完整会计年度内不得减持公开发行并上市前股份
contextual_info: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_9_3(df):
    '''
    验证MEU_9_3合规性：
    subject: 董监高
    condition: 在MEU_9_1规定的2个完整会计年度期间内离职
    constraint: 继续遵守减持限制
    '''
    df = df.copy()

    # 初始化标记列
    df['meu_9_3_subject'] = False
    df['meu_9_3_condition'] = False
    df['meu_9_3_constraint'] = None

    # 标记valid的subject（董监高或离任董监高）
    valid_subject = df['股东身份'].isin(['董监高', '离任董监高'])
    df.loc[valid_subject, 'meu_9_3_subject'] = True

    # 预处理公司基础信息
    company_info = df.groupby('公司简称').apply(
        lambda x: pd.Series({
            '上市日期': x['上市日期'].iloc[0],
            '上市时每股净利润': x.loc[x['日期'] == x['上市日期'].iloc[0], '每股净利润'].values[0] 
            if not x.loc[x['日期'] == x['上市日期'].iloc[0]].empty else None
        })
    ).reset_index()

    # 预处理股东离职信息
    resign_info = df.groupby(['公司简称', '股东']).apply(
        lambda x: pd.Series({
            '离任日期': x['离任日期'].dropna().iloc[0] 
            if not x['离任日期'].dropna().empty else None
        })
    ).reset_index()

    # 合并公司信息并计算时间窗口
    resign_info = resign_info.merge(company_info, on='公司简称', how='left')
    resign_info['两年结束日期'] = resign_info['上市日期'] + pd.DateOffset(years=2)
    
    # 获取离任时财务数据
    eps_ref = df[['公司简称', '日期', '每股净利润']].drop_duplicates()
    resign_info = resign_info.merge(
        eps_ref,
        left_on=['公司简称', '离任日期'],
        right_on=['公司简称', '日期'],
        how='left'
    ).rename(columns={'每股净利润': '离任时每股净利润'})

    # 计算condition有效性
    resign_info['condition_met'] = (
        (resign_info['上市时每股净利润'] < 0) &          # 上市时未盈利
        (resign_info['离任时每股净利润'] < 0) &        # 离职时未实现盈利
        (resign_info['离任日期'] <= resign_info['两年结束日期']) &  # 离职在时间窗口内
        (resign_info['离任日期'] >= resign_info['上市日期'])
    )

    # 合并condition标记到主表
    df = df.merge(
        resign_info[['公司简称', '股东', 'condition_met']],
        on=['公司简称', '股东'],
        how='left'
    )
    df['meu_9_3_condition'] = df['condition_met'].fillna(False)

    # 标记constraint有效性（所有行独立检查）
    df['上市日期'] = df.groupby('公司简称')['上市日期'].transform('first')
    df['两年结束日期'] = df['上市日期'] + pd.DateOffset(years=2)
    in_window = (df['日期'] >= df['上市日期']) & (df['日期'] <= df['两年结束日期'])
    has_reduce = df['当日减持比例'] > 0
    df['meu_9_3_constraint'] = ~(in_window & has_reduce)

    # 清理临时列
    df.drop(columns=['condition_met', '上市日期', '两年结束日期'], inplace=True, errors='ignore')
    
    return df
</CODE>","好的，我现在需要处理MEU_9_3的合规性检查。首先，我得仔细理解这个MEU的内容。MEU_9_3的subject是“董监高”，condition是“在前款规定的2个完整会计年度期间内离职”，constraint是“应当继续遵守前款规定的减持限制”。这里的“前款”应该是指MEU_9_1，所以需要参考MEU_9_1的内容。

MEU_9_1中的subject包括控股股东、实际控制人、董监高，condition是公司上市时未盈利且处于实现盈利前阶段，constraint是自上市之日起2个完整会计年度内不得减持。而MEU_9_3针对的是在MEU_9_1规定的两年期间内离职的董监高，他们仍需遵守减持限制。

首先，处理subject部分。MEU_9_3的subject是“董监高”，所以需要检查股东身份是否为“董监高”或“离任董监高”？或者是否在离职前是董监高？根据数据中的股东身份列，可能的值包括“董监高”和“离任董监高”。这里可能需要确认，离职后的董监高是否仍然属于subject的范围。根据MEU_9_3的描述，离职发生在两年期间内，所以即使离职了，仍然属于subject。因此，在数据中，股东身份如果是“董监高”或“离任董监高”的都应该被标记为有效subject吗？或者需要更精确的条件？

接下来是condition部分：“在前款规定的2个完整会计年度期间内离职”。这里的“前款”即MEU_9_1，所以需要确定公司是否处于MEU_9_1适用的条件，即公司上市时未盈利且处于实现盈利前阶段。同时，股东需要在这两年期间内离职。因此，condition的检查分为两部分：公司是否符合MEU_9_1的条件，以及该股东是否在这两年期间离职。

然后是constraint部分：“应当继续遵守前款规定的减持限制”，即MEU_9_1的constraint，也就是在上市后的两年内不得减持。但MEU_9_3的情况是，股东在这两年期间离职了，但依然需要遵守这两年的减持限制。因此，即使离职了，在这两年内他们仍然不能减持。

现在，如何将这些逻辑转化为代码？

首先，处理subject。MEU_9_3的subject是“董监高”，所以需要检查股东身份是否为“董监高”或“离任董监高”？或者是否在离职前是董监高？根据数据中的股东身份列，可能的值包括“董监高”和“离任董监高”。但MEU_9_3的subject是“董监高”，所以可能仅指在离职前是董监高的股东。例如，离职后变为离任董监高，但此时是否属于subject？根据问题描述中的MEU_9_3，离职发生在两年期间内，所以即使离职了，仍然属于subject。因此，在数据中，股东身份如果是“董监高”或“离任董监高”的都应该被标记为有效subject吗？或者需要更精确的条件？

可能正确的做法是，只要该股东曾经是董监高，并且在MEU_9_1的两年期间内离职，就属于subject。但如何从数据中判断这一点？

数据中的“离任日期”列可能有用。假设离任日期在MEU_9_1规定的两年期间内，那么该股东属于condition满足的情况。因此，在检查subject时，可能只需要股东身份是董监高或者离任董监高，但需要结合离职时间是否在两年期间内？

或者，subject的检查仅需要当前行的股东身份是否是董监高或离任董监高？例如，不管离职时间，只要当前行的股东身份是董监高或离任董监高，就标记为subject有效？

这可能不正确，因为MEU_9_3的subject是董监高，而离职后的可能属于离任董监高。所以，在数据中，股东身份如果是“董监高”或“离任董监高”的都应该被标记为subject有效？

或者，是否应该将离任董监高也视为subject？例如，原董监高离职后，仍然属于subject的范围？

根据MEU_9_3的描述，离职发生在两年期间内，所以即使离职了，仍然属于subject。因此，在数据中，股东身份如果是“董监高”或“离任董监高”的都应该被标记为subject有效。但需要确认这一点是否正确。

接下来，处理condition。condition是“在前款规定的2个完整会计年度期间内离职”。这里的“前款”即MEU_9_1，所以需要满足两个条件：

1. 公司处于MEU_9_1的适用条件，即公司上市时未盈利且处于实现盈利前阶段。
2. 该股东在这两个完整会计年度期间内离职。

首先，如何确定公司是否符合MEU_9_1的条件？

MEU_9_1的条件是公司上市时未盈利且处于实现盈利前阶段。根据数据中的字段，可能需要检查公司上市时的净利润是否为负，并且在当前时间点是否仍未盈利。或者，是否有字段可以直接判断公司是否处于实现盈利前阶段？

例如，可能需要计算公司上市后的净利润是否转为正。例如，公司上市日期是已知的，那么需要检查从上市日期到当前日期，公司是否已经实现盈利。如果还没有实现盈利，则处于实现盈利前阶段。

但数据中的字段可能包括净利润、每股净利润等。例如，如果公司上市时的净利润是负数，并且当前日期所在的会计年度仍未盈利，则满足条件。

或者，是否有其他字段可以判断公司是否处于实现盈利前阶段？比如，是否存在某个指标表明公司是否已经盈利？

假设公司上市时的净利润为负，并且当前日期所在的会计年度仍未盈利，那么公司处于MEU_9_1的条件。例如，在MEU_9_1中，公司上市时未盈利，且当前仍处于未盈利状态。

这可能比较复杂。例如，需要确定公司上市时的净利润是否为负，并且之后是否仍未盈利。例如，在数据中，可能有“净利润”字段，但需要按时间来判断。

或者，是否有其他字段如“公司上市时未盈利”这样的标志？可能没有，所以需要根据数据中的信息计算。

例如，公司上市日期是已知的，可以找到上市当日的净利润是否为负。假设数据中的“净利润”是每个交易日的数据，但可能更合理的是，净利润是按季度或年度公布的。但数据中的字段可能无法直接获取上市时的净利润。可能需要假设，如果公司上市时的发行价对应的净利润为负，或者根据其他字段推断。

或者，可能数据中的“发行价格”与净利润有关？例如，如果公司上市时未盈利，可能发行价格较低，或者有其他指标。但这里可能需要假设，公司上市时的净利润是否为负，可以通过某些字段来判断。

例如，在数据中，可能有“上市日期”列，而每个公司的上市日期是已知的。然后，需要找到该公司在上市时的净利润是否为负。例如，在上市日期对应的行中，净利润是否为负。或者，可能每个公司的净利润是按季度或年度更新的，所以需要找到公司上市后的第一个完整会计年度的净利润情况。

这可能比较复杂，可能需要分组处理每个公司，找到其上市后的前两个会计年度的净利润情况。

或者，是否有其他字段如“公司涉嫌证券期货违法犯罪事件”等，但可能无关。

假设数据中的“净利润”字段是每个交易日的数据，这可能不太合理。可能更合理的假设是，净利润是按季度或年度更新的，所以每个交易日的数据可能重复该季度的净利润。例如，同一季度的所有交易日，净利润字段相同。

因此，要判断公司是否在上市时未盈利，并且处于实现盈利前阶段，可能需要找到公司上市时的净利润是否为负，并且在当前日期时，公司是否仍未盈利。

例如，对于每个公司，找到其上市日期对应的净利润是否为负。如果是，并且当前行的日期所在的会计年度仍未盈利，则满足MEU_9_1的条件。

这可能比较复杂，需要按公司分组处理。

现在，回到MEU_9_3的condition检查：

1. 公司处于MEU_9_1的条件（即上市时未盈利且处于实现盈利前阶段）。
2. 股东在MEU_9_1规定的两年期间内离职。

MEU_9_1的constraint是自上市之日起2个完整会计年度内不得减持。因此，MEU_9_3中的“前款规定的2个完整会计年度期间”指的是上市后的前两个完整会计年度。因此，股东必须在这两个会计年度期间内离职。

所以，离职日期（离任日期）必须在这两个会计年度的期间内。

如何计算这两个完整会计年度的结束日期？

例如，假设公司上市日期是2020-03-01，那么第一个完整会计年度可能是2020年，第二个是2021年？或者会计年度可能与自然年不同，比如有些公司的会计年度是到3月31日。但这里可能需要简化处理，假设会计年度是自然年，即完整会计年度为上市后的前两个自然年。例如，上市日期在2020年，则两个完整会计年度是2020年和2021年，结束日期是2021-12-31。

或者，可能需要根据上市日期计算两个完整的会计年度。例如，上市日期后的第一个完整会计年度结束日期是上市日期后一年的最后一天，第二个是两年后的最后一天？

例如，如果公司上市日期是2020-06-15，那么第一个完整会计年度可能到2020-12-31，第二个到2021-12-31？或者可能根据公司的会计年度设置，比如如果公司会计年度是自然年，则如此处理。

但这里可能需要简化处理，假设两个完整会计年度是指自上市日期起算的两年时间。例如，上市日期后的两年时间，即结束日期是上市日期加两年。

或者，可能根据数据中的字段，比如是否有会计年度的信息？但根据提供的列，可能没有。因此，可能需要假设两个完整会计年度是指自上市日期起算的两年时间，即结束日期为上市日期 + 2年。

例如，上市日期是2020-01-01，则两年期间到2022-01-01？或者到2021-12-31？

这可能存在歧义，但根据法律条文，通常“完整会计年度”指的是完整的会计年度周期。例如，如果公司上市日期在2020年3月，那么第一个完整会计年度可能是2020年全年，第二个是2021年全年。因此，两年期间的结束日期是2022年1月1日之前？

或者，可能将两个完整会计年度视为自上市之日起的两年时间，即730天？

这可能比较复杂，但根据问题描述中的附加信息，所有日期相关的列已经是pd.datetime格式，所以需要计算离任日期是否在上市日期后的两年内。

例如，对于每个公司，计算其上市日期后的两年时间，如果股东的离任日期在该时间段内，则满足condition。

但MEU_9_1中的constraint是“自公司股票上市之日起2个完整会计年度内不得减持”，而MEU_9_3的condition是“在前款规定的2个完整会计年度期间内离职”，所以这里的期间就是MEU_9_1中的两年期间。因此，离职日期必须在这两年期间内。

因此，对于每个公司，计算其上市日期后的两年时间，如果股东的离任日期在该时间段内，则满足condition的条件之一。

同时，公司必须处于MEU_9_1的条件，即上市时未盈利且处于实现盈利前阶段。

现在，如何判断公司是否处于MEU_9_1的条件？

根据MEU_9_1的condition是公司上市时未盈利且处于实现盈利前阶段。这可能意味着，在上市时，公司的净利润为负，并且当前仍未盈利。

例如，在上市当日的净利润是否为负，并且当前行的净利润是否仍为负？

或者，可能更复杂，比如公司是否在上市后的任何时间点实现了盈利？如果一旦盈利，就不再处于实现盈利前阶段。

例如，如果公司上市时未盈利（净利润为负），但在某个时间点后净利润转为正，则之后不再处于实现盈利前阶段。因此，只有当公司从未盈利过，或者当前仍处于未盈利状态时，才满足条件。

这可能比较复杂，需要按公司分组，检查其历史净利润是否曾经为正。

例如，对于每个公司，找到其上市后的所有净利润数据，如果存在任何一个时间点的净利润>=0，则公司已经实现盈利，不再处于实现盈利前阶段。否则，仍处于该阶段。

但数据中的净利润是按日记录的，可能重复，所以需要找到每个公司的最早出现净利润>=0的日期。如果该日期存在，则公司在该日期之后不再处于实现盈利前阶段。

这可能比较复杂，但根据问题描述中的可用字段，可能需要使用净利润字段来判断。

现在，回到MEU_9_3的condition检查：

1. 公司处于MEU_9_1的条件（上市时未盈利且处于实现盈利前阶段）。
2. 股东在MEU_9_1的两年期间内离职。

因此，对于每个公司，首先判断是否满足MEU_9_1的条件：

- 上市时的净利润是否为负？
- 是否在上市后的前两个会计年度内仍未盈利？

或者，可能更简单的判断是，公司是否在上市后的前两个会计年度内未盈利？

或者，只要公司上市时未盈利，并且在当前日期时仍未盈利，则处于实现盈利前阶段？

这可能取决于法律条文的具体解释，但根据问题描述，可能需要假设公司上市时未盈利，并且当前仍处于未盈利状态。

例如，在数据中，如果某行的“净利润”字段为负，则公司在该日处于未盈利状态。但需要确定公司是否在上市时未盈利，并且当前日期是否在实现盈利前阶段。

这可能比较复杂，但根据问题描述中的可用字段，可能需要使用“净利润”字段来判断。

现在，如何编写代码：

首先，处理subject：

MEU_9_3的subject是“董监高”，所以需要检查股东身份是否为“董监高”或“离任董监高”？或者是否在离职前是董监高？

根据问题描述中的股东身份列的可能值，包括“董监高”和“离任董监高”。因此，在数据中，如果股东身份是“董监高”或“离任董监高”，则subject有效？

或者，是否应该仅考虑当前行的股东身份是否为“董监高”或“离任董监高”？

例如，假设某行的股东身份是“离任董监高”，则属于subject。因此，valid_subject的条件是：

df['股东身份'].isin(['董监高', '离任董监高'])

这可能正确，因为MEU_9_3的subject是“董监高”，而离职后的董监高可能仍然属于该subject的范围。

接下来，处理condition：

condition是“在前款规定的2个完整会计年度期间内离职”，即MEU_9_1的两年期间内离职，并且公司处于MEU_9_1的条件。

因此，需要分两步：

a. 公司是否满足MEU_9_1的条件（上市时未盈利且处于实现盈利前阶段）。

b. 股东的离任日期是否在MEU_9_1的两年期间内。

对于a部分，如何判断公司是否满足MEU_9_1的条件？

根据MEU_9_1的condition是公司上市时未盈利且处于实现盈利前阶段。因此，需要：

- 公司上市时的净利润为负。
- 公司当前仍处于实现盈利前阶段（即仍未盈利）。

或者，可能只要公司上市时未盈利，并且在上市后的前两个会计年度内，不管之后是否盈利，都适用MEU_9_1的条件？

这可能取决于法律条文的具体规定。例如，MEU_9_1的constraint是自上市之日起两年内不得减持，无论之后是否盈利。因此，只要公司上市时未盈利，不管之后是否盈利，在这两年内都适用减持限制。

但MEU_9_3的condition是股东在这两年期间内离职，所以即使公司在这两年期间之后盈利，只要离职发生在两年内，condition就满足？

或者，是否公司必须在这两年期间内仍然处于未盈利状态？

这可能比较复杂，但根据问题描述中的MEU_9_1的condition是“公司上市时未盈利且处于实现盈利前阶段”，所以可能公司必须同时满足上市时未盈利，并且在减持发生时仍处于实现盈利前阶段。但MEU_9_3的condition是离职发生在两年期间内，而公司是否处于MEU_9_1的条件可能需要同时满足。

例如，如果公司上市时未盈利，但在离职时已经盈利，那么是否还满足MEU_9_1的条件？

这可能取决于法律条文的解释，但根据问题描述，可能需要假设只要公司上市时未盈利，并且在离职时仍处于实现盈利前阶段，才满足MEU_9_1的条件。

因此，判断公司是否满足MEU_9_1的条件需要：

1. 公司上市时的净利润为负。
2. 在离职日期时，公司仍处于实现盈利前阶段（即净利润仍为负）。

或者，可能更严格，需要公司在整个两年期间内都处于未盈利状态？

这可能难以处理，但根据问题描述中的可用数据，可能需要简化处理。

例如，对于每个公司，判断其上市时的净利润是否为负，并且在离职日期时的净利润是否为负。

但数据中的净利润是每个交易日的数据，所以对于离职日期，需要找到该公司的该日期的净利润是否为负？

或者，可能更简单，假设如果公司上市时的净利润为负，并且在离职日期所在年度的净利润仍未正，则处于实现盈利前阶段？

或者，可能使用每股净利润来判断？

例如，公司上市时的每股净利润为负，并且在离职日期时，每股净利润仍为负。

这可能更可行，因为数据中有“每股净利润”字段。

因此，步骤可能如下：

对于每个公司：

1. 找到其上市日期（假设是“上市日期”列）。
2. 在上市日期对应的行中，检查“每股净利润”是否为负。如果是，则公司上市时未盈利。
3. 在离职日期对应的行中，检查“每股净利润”是否为负。如果是，则公司仍处于实现盈利前阶段。

但离职日期可能不是交易日，因此需要找到离职日期对应的公司在该日期的数据？

或者，可能离职日期是交易日，或者需要找到最接近的交易日？

这可能比较复杂，但根据问题描述中的附加信息，所有日期相关的列已经是pd.datetime格式，并且数据中的日期是交易日。因此，离职日期可能不在数据中，或者需要其他处理方式。

或者，可能“离任日期”列是存在的，并且对于每个股东，该列记录了离职的具体日期。因此，需要判断该离任日期是否在上市后的两年内，并且在该离任日期时，公司是否满足MEU_9_1的条件。

例如，对于每个行（即特定公司、股东、交易日），需要判断：

- 该股东的离任日期是否在上市后的两年内。
- 在离任日期时，公司的每股净利润是否为负（即公司仍处于实现盈利前阶段）。

这可能比较复杂，因为需要跨行获取数据。例如，对于某一行，该行的日期是某个交易日，而离任日期可能与该行的日期无关。需要针对每个股东和公司，找到其离任日期，并检查该离任日期是否满足条件。

例如，对于每个公司，计算其上市日期后的两年时间窗口。然后，对于每个股东，检查其离任日期是否在该时间窗口内，并且在离任日期时，公司的每股净利润是否为负。

这可能需要对数据进行分组处理，按公司和股东分组，然后处理每个组的离任日期。

但如何在pandas中高效处理这一点？

例如，对于每个行，获取该行的公司简称和股东，然后找到该股东的离任日期，并计算是否在上市后的两年内，同时在该离任日期时，公司的每股净利润是否为负。

这可能需要对每个行进行这样的计算，但效率可能较低。

或者，可以按公司和股东分组，然后为每个组计算是否满足条件，然后将结果合并回原数据框。

例如，步骤如下：

1. 按['公司简称', '股东']分组。
2. 对于每个组，获取该公司的上市日期。
3. 计算该公司的上市日期后的两年结束日期（例如，上市日期 + 2年）。
4. 获取该股东的离任日期。
5. 判断离任日期是否在上市日期和两年结束日期之间。
6. 同时，在离任日期时，公司的每股净利润是否为负。
7. 如果以上条件都满足，则该组的condition为True，否则为False。
8. 将结果合并回原数据框，使得每个行对应的组中的condition结果被标记。

这可能更高效，但需要处理分组后的数据。

但如何获取离任日期对应的每股净利润？

例如，对于每个组，离任日期是某个日期，需要找到该公司在该日期的每股净利润。如果该日期不存在于数据中，可能需要找到最接近的日期，或者假设该日期的每股净利润与离任日期所在期间的财报数据一致。

这可能比较复杂，但根据问题描述中的可用数据，可能需要假设每股净利润是按季度或年度更新的，因此，在离任日期所在季度或年度的每股净利润即可作为判断依据。

或者，可能使用该股东离任日期所在行的每股净利润？例如，如果离任日期是该行的日期，则直接使用该行的每股净利润。否则，可能需要查找离任日期所在行的数据。

这可能不太容易，因为离任日期可能与该行的日期无关。例如，某行的日期是2023-01-05，而离任日期是2022-06-01，此时需要找到2022-06-01对应的公司的每股净利润。

因此，可能需要为每个公司创建一个时间序列，记录每个日期的每股净利润，然后对于离任日期，查找对应的值。

例如，对于每个公司，创建一个DataFrame，其中日期为索引，每股净利润为列。然后，对于离任日期，使用该公司的DataFrame来查找对应的每股净利润。

这可能比较复杂，但可以使用pandas的merge或map方法来实现。

例如，对于每个公司，创建一个参考表，将日期与每股净利润对应。然后，对于每个离任日期，使用该参考表来查找对应的每股净利润。

但如何实现这一点？

可能的步骤：

- 创建一个公司日期参考表，包含每个公司的所有日期和对应的每股净利润。
- 对于每个股东的离任日期，找到其对应的公司，并在参考表中查找该日期的每股净利润。

例如：

参考表 = df[['公司简称', '日期', '每股净利润']].drop_duplicates()

然后，对于每个组的离任日期，合并参考表，以获取该日期的每股净利润。

但离任日期可能不在参考表的日期中，因此可能需要找到最接近的日期，或者使用插值方法。但这里可能需要假设，如果离任日期不是交易日，则取该日期之前的最近交易日的每股净利润。

这可能比较复杂，但根据问题描述中的附加信息，所有日期相关的列已经是交易日，所以离任日期可能是一个交易日，或者需要处理为非交易日的情况？

或者，可能离任日期列中的日期都是交易日？

这可能不确定，但根据问题描述中的说明，离任日期列已经是pd.datetime格式，但未明确是否是交易日。因此，可能需要处理离任日期是否在数据中的日期中。

例如，如果离任日期不在数据中的日期中，则无法找到对应的每股净利润，此时可能认为条件不满足？

或者，可能需要使用该公司的最近可用数据。

这可能比较复杂，但为了简化，假设离任日期是交易日，并且可以在数据中找到对应的行。

因此，对于每个组的离任日期，可以合并参考表，以获取该日期的每股净利润。

现在，回到代码编写：

首先，处理subject：

df['meu_9_3_subject'] = df['股东身份'].isin(['董监高', '离任董监高'])

然后，处理condition：

需要判断：

1. 公司是否满足MEU_9_1的条件（上市时未盈利且处于实现盈利前阶段）。
2. 股东的离任日期是否在上市后的两年内。

对于MEU_9_1的条件：

a. 公司上市时未盈利：在上市日期的每股净利润 < 0。
b. 公司处于实现盈利前阶段：在离任日期的每股净利润 < 0。

同时，离任日期必须在上市后的两年内。

因此，步骤：

按公司和股东分组：

grouped = df.groupby(['公司简称', '股东'])

对于每个组：

- 获取公司的上市日期（假设是每个公司的上市日期相同，取第一个非空值）。
- 计算上市后的两年结束日期（上市日期 + 2年）。
- 获取该股东的离任日期（假设每个股东只有一个离任日期，取非空值）。
- 检查离任日期是否在上市日期和两年结束日期之间。
- 检查上市日期的每股净利润是否 < 0。
- 检查离任日期的每股净利润是否 < 0。

如果以上条件都满足，则该组的condition为True。

但如何将这些条件应用到每一行？

例如，每个行属于某个公司和股东的组合，该组合的condition是否满足？

因此，需要为每个公司和股东的组合计算condition是否满足，然后将结果映射到每一行。

可能的代码步骤：

# 创建参考表，每个公司的上市日期和上市时的每股净利润
company_info = df.groupby('公司简称').agg(
   上市日期=('上市日期', 'first'),
   上市时每股净利润=('每股净利润', lambda x: x[df['上市日期'] == x.name].iloc[0] if not x.empty else None)
).reset_index()

# 创建离任日期和每股净利润的参考表
# 假设每个股东的离任日期是唯一的，取非空值
resign_info = df.groupby(['公司简称', '股东']).agg(
   离任日期=('离任日期', 'first')
).reset_index()

# 合并公司信息到resign_info
resign_info = resign_info.merge(company_info, on='公司简称', how='left')

# 计算两年结束日期
resign_info['两年结束日期'] = resign_info['上市日期'] + pd.DateOffset(years=2)

# 判断离任日期是否在两年期间内
resign_info['离任在两年内'] = (resign_info['离任日期'] >= resign_info['上市日期']) & (resign_info['离任日期'] <= resign_info['两年结束日期'])

# 获取离任日期的每股净利润
# 需要将resign_info中的离任日期与df中的日期匹配，获取对应的每股净利润
# 方法：合并df中的日期和每股净利润
resign_info = resign_info.merge(
   df[['公司简称', '日期', '每股净利润']],
   left_on=['公司简称', '离任日期'],
   right_on=['公司简称', '日期'],
   how='left'
)
resign_info.rename(columns={'每股净利润': '离任时每股净利润'}, inplace=True)

# 判断条件
resign_info['condition_met'] = (
   (resign_info['上市时每股净利润'] < 0) &  # 上市时未盈利
   (resign_info['离任时每股净利润'] < 0) &  # 离任时仍处于未盈利
   (resign_info['离任在两年内'])  # 离任日期在两年内
)

# 将结果合并回原数据框
df = df.merge(
   resign_info[['公司简称', '股东', 'condition_met']],
   on=['公司简称', '股东'],
   how='left'
)

# 标记condition为True或False
df['meu_9_3_condition'] = df['condition_met'].fillna(False)

但需要注意，如果离任日期为空，或者无法匹配到对应的每股净利润，则condition_met为False。

这可能是一个可行的方案。

最后，处理constraint：

constraint是“应当继续遵守前款规定的减持限制”，即MEU_9_1的constraint，也就是在上市后的两年内不得减持。但MEU_9_3的constraint要求即使离职，仍需遵守该限制。因此，在MEU_9_1的两年期间内，该股东不得减持。

因此，constraint的检查是：在上市后的两年期间内，该股东是否减持？

或者，是否在两年期间内的任何减持都是违规的？

例如，如果股东在两年期间内减持了股份，则违反constraint。

因此，constraint的有效性检查是：在上市后的两年期间内，该股东没有减持。

但如何标记每一行的constraint是否满足？

例如，对于每一行，如果该行的日期在上市后的两年期间内，并且该股东在该行有减持行为（例如，当日减持比例 > 0），则constraint不满足。

或者，constraint的检查是：在两年期间内，股东是否减持？

因此，对于每一行，如果该行的日期在上市后的两年期间内，并且该股东减持了股份（当日减持比例 > 0），则constraint为False。

但MEU_9_3的constraint是“应当继续遵守前款规定的减持限制”，即MEU_9_1的constraint。MEU_9_1的constraint是两年内不得减持，因此，在两年期间内的任何减持都是违规的。

因此，对于每一行，如果该行的日期在上市后的两年期间内，并且该股东减持了股份，则constraint不满足。

因此，constraint的有效性检查是：

该行的日期是否在上市后的两年期间内，并且该行的当日减持比例 > 0？

如果是，则constraint为False，否则为True。

但需要注意，MEU_9_3的constraint是要求继续遵守，即即使离职了，在两年期间内仍不能减持。因此，无论是否离职，只要在两年期间内减持，就违反constraint。

因此，constraint的检查是：

对于每一行，如果该行的日期在上市后的两年期间内，并且当日减持比例 > 0，则constraint为False，否则为True。

但需要按公司和股东来判断上市日期，并计算该行的日期是否在两年期间内。

因此，步骤：

1. 获取该行的公司上市日期。
2. 计算两年结束日期（上市日期 + 2年）。
3. 判断该行的日期是否在上市日期和两年结束日期之间。
4. 如果在该期间内，且当日减持比例 > 0，则constraint为False。
5. 否则，constraint为True。

因此，代码可能如下：

# 计算每个公司的上市日期
df['上市日期'] = df.groupby('公司简称')['上市日期'].transform('first')

# 计算两年结束日期
df['两年结束日期'] = df['上市日期'] + pd.DateOffset(years=2)

# 判断当前日期是否在两年期间内
in_window = (df['日期'] >= df['上市日期']) & (df['日期'] <= df['两年结束日期'])

# 判断是否有减持
has_reduce = df['当日减持比例'] > 0

# constraint为True的条件是：不在期间内，或者在期间内但没有减持
valid_constraint = ~in_window | (~has_reduce)

因此，df['meu_9_3_constraint'] = valid_constraint

但需要注意，MEU_9_3的constraint是要求继续遵守，所以即使离职了，在两年期间内减持仍然违规。因此，无论是否离职，只要在两年期间内减持，就违反constraint。

因此，上述代码是正确的。

现在，将这三部分整合到函数中：

首先，初始化各列：

df['meu_9_3_subject'] = False
df['meu_9_3_condition'] = False
df['meu_9_3_constraint'] = None

然后，处理subject：

valid_subject = df['股东身份'].isin(['董监高', '离任董监高'])
df.loc[valid_subject, 'meu_9_3_subject'] = True

处理condition：

需要如前所述，按公司和股东分组，计算是否满足条件。

但如何在函数中实现这一点？

可能需要在函数内部创建resign_info等中间DataFrame，然后合并回原df。

例如，在函数中：

def check_meu_9_3(df):
    df = df.copy()

    # 初始化列
    df['meu_9_3_subject'] = False
    df['meu_9_3_condition'] = False
    df['meu_9_3_constraint'] = None

    # 标记subject
    valid_subject = df['股东身份'].isin(['董监高', '离任董监高'])
    df.loc[valid_subject, 'meu_9_3_subject'] = True

    # 处理condition
    # 获取公司信息：上市日期和上市时的每股净利润
    company_info = df.groupby('公司简称').apply(
        lambda x: pd.Series({
            '上市日期': x['上市日期'].iloc[0],
            '上市时每股净利润': x.loc[x['日期'] == x['上市日期'].iloc[0], '每股净利润'].values[0] if not x.loc[x['日期'] == x['上市日期'].iloc[0]].empty else None
        })
    ).reset_index()

    # 获取股东的离任日期
    resign_info = df.groupby(['公司简称', '股东']).apply(
        lambda x: pd.Series({
            '离任日期': x['离任日期'].dropna().iloc[0] if not x['离任日期'].dropna().empty else None
        })
    ).reset_index()

    # 合并公司信息到resign_info
    resign_info = resign_info.merge(company_info, on='公司简称', how='left')

    # 计算两年结束日期
    resign_info['两年结束日期'] = resign_info['上市日期'] + pd.DateOffset(years=2)

    # 判断离任日期是否在两年期间内
    resign_info['离任在两年内'] = (resign_info['离任日期'] >= resign_info['上市日期']) & (resign_info['离任日期'] <= resign_info['两年结束日期'])

    # 获取离任日期的每股净利润
    # 需要将离任日期与df中的日期匹配
    # 创建参考表
    eps_ref = df[['公司简称', '日期', '每股净利润']].drop_duplicates()
    resign_info = resign_info.merge(
        eps_ref,
        left_on=['公司简称', '离任日期'],
        right_on=['公司简称', '日期'],
        how='left'
    )
    resign_info.rename(columns={'每股净利润': '离任时每股净利润'}, inplace=True)

    # 判断condition条件
    resign_info['condition_met'] = (
        (resign_info['上市时每股净利润'] < 0) &
        (resign_info['离任时每股净利润'] < 0) &
        resign_info['离任在两年内']
    )

    # 将condition_met合并回原df
    df = df.merge(
        resign_info[['公司简称', '股东', 'condition_met']],
        on=['公司简称', '股东'],
        how='left'
    )
    df['meu_9_3_condition'] = df['condition_met'].fillna(False)

    # 处理constraint
    # 计算每个公司的上市日期和两年结束日期
    df['上市日期'] = df.groupby('公司简称')['上市日期'].transform('first')
    df['两年结束日期'] = df['上市日期'] + pd.DateOffset(years=2)

    # 判断当前日期是否在两年期间内
    in_window = (df['日期'] >= df['上市日期']) & (df['日期'] <= df['两年结束日期'])

    # 判断是否有减持
    has_reduce = df['当日减持比例'] > 0

    # constraint为True的条件是：不在期间内，或者在期间内但没有减持
    valid_constraint = ~in_window | (~has_reduce)
    df['meu_9_3_constraint'] = valid_constraint

    # 清理临时列
    df.drop(columns=['condition_met', '上市日期', '两年结束日期'], inplace=True, errors='ignore')

    return df

但需要注意，在获取上市时的每股净利润时，可能存在空值的情况，需要处理。例如，如果上市日期对应的行中没有每股净利润的数据，则上市时每股净利润可能为NaN，此时condition_met将为False。

此外，离任日期可能为空，此时condition_met也为False。

此外，在合并resign_info时，如果某个股东没有离任日期，则condition_met为False。

最后，constraint的检查是独立于subject和condition的，即无论subject和condition是否满足，都需要检查constraint。根据问题描述中的要求，对于简单操作dataframe就可以处理的项目，三元组的检查是各自独立的，需要分别标记。因此，constraint的检查不需要考虑subject和condition是否满足，而是对所有行进行检查。

但根据MEU_9_3的constraint，是否仅对subject和condition满足的行进行检查？根据问题描述中的要求，对于需要调用llm_content_check()函数的项目，只对符合subject和condition的constrain进行检查。但本任务中没有需要调用该函数的项目，因此，constraint的检查是独立的，即对所有行进行标记，不管subject和condition是否满足。

因此，上述代码中的constraint处理是正确的，即对所有行进行判断，无论subject和condition是否满足。

综上，最终的代码应该包括：

- 标记subject为董监高或离任董监高。
- 标记condition为：公司上市时未盈利，离任时仍处于未盈利，且离任日期在两年内。
- 标记constraint为：在两年期间内没有减持。

现在，测试代码是否存在错误：

例如，在获取上市时的每股净利润时，可能使用：

x.loc[x['日期'] == x['上市日期'].iloc[0], '每股净利润'].values[0]

但如果上市日期对应的行不存在，或者有多个行，可能出错。例如，如果上市日期对应的行不存在，则.values[0]会报错。因此，需要处理这种情况。

可以修改为：

if not x.loc[x['日期'] == x['上市日期'].iloc[0]].empty:
   上市时每股净利润 = x.loc[x['日期'] == x['上市日期'].iloc[0], '每股净利润'].values[0]
else:
   上市时每股净利润 = None

或者，使用.iloc[0]可能更安全，但需要确保存在至少一行。

或者，可能上市日期对应的行不存在于数据中，此时无法获取每股净利润，因此认为公司不满足条件。

这可能是一个潜在的问题，但根据问题描述中的假设，数据中的公司均为已上市公司，因此上市日期应该存在对应的行。

综上，代码应该可以正确运行。
","CompletionUsage(completion_tokens=9305, prompt_tokens=1807, total_tokens=11112, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=8428, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_11_4
法律的最小可执行单元内容: {""subject"": ""上市公司控股股东 | 实际控制人"", ""condition"": ""市公司股票因可能触及重大违法强制退市情形，而被本所实施退市风险警示，在本所规定的限制减持期限内的"", ""constraint"": ""不得减持其所持有的本公司股份"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_11_4(df):
    '''
    检查MEU_11_4合规性：
    subject: 控股股东或实际控制人
    condition: 公司因重大违法被实施退市风险警示且在限制期内
    constraint: 不得减持股份
    '''
    df = df.copy()

    # 初始化标记列
    df['meu_11_4_subject'] = False
    df['meu_11_4_condition'] = False
    df['meu_11_4_constraint'] = None

    # 标记valid的subject
    valid_subject = df['股东身份'].isin(['控股股东', '实际控制人'])
    df.loc[valid_subject, 'meu_11_4_subject'] = True

    # 标记valid的condition（需要分组处理公司状态）
    def get_restriction_periods(group):
        '''识别公司退市风险警示期间'''
        periods = []
        in_restriction = False
        start_date = None
        
        # 按时间排序处理事件序列
        sorted_group = group.sort_values('日期')
        for _, row in sorted_group.iterrows():
            event = row['公司涉嫌证券期货违法犯罪事件']
            current_date = row['日期']
            
            if event == '被中国证监会及其派出机构立案调查' and not in_restriction:
                start_date = current_date
                in_restriction = True
            elif event in ['中国证监会及其派出机构立案调查结束', '行政处罚决定作出'] and in_restriction:
                end_date = current_date
                periods.append((start_date, end_date))
                in_restriction = False
                start_date = None
        
        # 处理未结束的警示状态
        if in_restriction and start_date:
            end_date = sorted_group['日期'].max()
            periods.append((start_date, end_date))
            
        return periods

    # 获取各公司限制期列表
    restriction_dict = df.groupby('公司简称').apply(get_restriction_periods).to_dict()

    # 检查日期是否在限制期内
    def check_condition(row):
        company = row['公司简称']
        date = row['日期']
        for period in restriction_dict.get(company, []):
            if period[0] <= date <= period[1]:
                return True
        return False

    valid_condition = df.apply(check_condition, axis=1)
    df.loc[valid_condition, 'meu_11_4_condition'] = True

    # 标记valid的constraint（独立检查所有记录）
    df['meu_11_4_constraint'] = (df['当日减持比例'] == 0)

    return df
</CODE>","好的，我现在需要处理这个MEU_11_4的合规性检查。首先，我得仔细理解这个MEU的内容。根据提供的MEU信息，责任主体是上市公司的控股股东或实际控制人，触发条件是公司股票因可能触及重大违法强制退市情形而被实施退市风险警示，并且在交易所规定的限制减持期限内。约束内容是不能减持所持有的本公司股份。

接下来，我需要考虑如何将这些条件转化为代码，检查数据框中的每一行是否符合这些条件。首先，我需要确定如何标记subject、condition和constraint这三个部分。

对于subject部分，MEU中的subject是“上市公司控股股东 | 实际控制人”。在数据框中，对应的列是“股东身份”，其中可能包含“控股股东”或“实际控制人”。所以，我需要检查“股东身份”列是否为这两个值之一。因此，valid_subject的条件应该是股东身份等于“控股股东”或“实际控制人”。

然后是condition部分。触发条件是公司股票因可能触及重大违法强制退市情形而被实施退市风险警示，并且在限制减持期限内。这里可能需要查看公司是否处于被实施退市风险警示的状态，并且处于限制减持的期限内。但数据框中的列可能没有直接的字段。我需要看看可用的列。例如，是否有列表示公司当前是否处于退市风险警示状态？或者是否有其他相关的事件标记？

根据提供的附加信息中的列，有一个列是“公司涉嫌证券期货违法犯罪事件”，可能包含事件如“被中国证监会立案调查”等。但MEU中的条件是关于触及重大违法强制退市情形而被实施退市风险警示。这可能对应到公司是否处于退市风险警示状态，并且该状态是由于重大违法导致的。但数据框中是否有这样的列呢？可能没有直接的列，但可能需要根据其他列推断。例如，是否有某个事件标记表明公司被实施退市风险警示？

或者，可能这个条件需要结合其他信息，比如公司是否处于退市风险警示期间，并且该警示是因为重大违法。但数据中可能没有直接的字段，所以可能需要假设存在一个列，比如“退市风险警示状态”或者类似的。但根据用户提供的可用列，可能没有这样的列。这时候可能需要进一步澄清，但根据问题描述，用户可能希望用现有的列来模拟。

或者，可能“公司涉嫌证券期货违法犯罪事件”中的某些事件可以触发退市风险警示。例如，如果公司被中国证监会立案调查，并且可能触及重大违法退市情形，那么可能被实施退市风险警示。但具体如何映射可能需要更详细的信息。但根据现有数据，可能无法直接判断公司是否处于退市风险警示状态。这可能是一个问题，因为用户提供的列中没有明确的退市风险警示状态列。

这时候可能需要假设，或者用户是否有其他信息？比如，可能当“公司涉嫌证券期货违法犯罪事件”列中出现特定的事件时，比如“被中国证监会及其派出机构立案调查”可能触发退市风险警示。或者，可能当公司存在某些事件时，会被实施退市风险警示。但MEU中的条件明确是“因可能触及重大违法强制退市情形而被实施退市风险警示”，所以可能需要找到对应的触发事件。

例如，假设当公司被中国证监会立案调查时，可能触及重大违法退市情形，从而被实施退市风险警示。那么，在数据框中，当“公司涉嫌证券期货违法犯罪事件”列包含“被中国证监会及其派出机构立案调查”时，可能视为满足条件。但需要确认该事件是否会导致退市风险警示的实施。此外，还需要确定限制减持期限的时间范围。例如，可能在该事件发生后的一段时间内，比如从立案调查开始到结束，或者到退市风险警示解除为止。

但数据框中可能没有具体的退市风险警示开始和结束日期，或者限制减持的期限。这可能是一个挑战。例如，如何确定某一行数据中的日期是否处于限制减持期限内？

可能的解决方法是，假设当公司存在某个事件时，比如被立案调查，那么从该事件的公告日期开始，进入限制减持期，持续一定时间。例如，假设限制减持期是从事件公告日开始后的某个时间段。但具体如何确定这个时间段可能需要更多的信息，但问题中没有给出，可能需要做一些假设。

或者，可能数据框中有一个列，比如“退市风险警示开始日期”和“退市风险警示结束日期”，但根据用户提供的列列表，没有这样的列。因此，这可能意味着在现有数据中无法直接判断condition是否满足，这会导致无法正确编写代码。这时候可能需要用户进一步说明，或者需要根据现有列进行推断。

这可能是一个问题，因为根据现有的列，可能无法准确判断公司是否处于被实施退市风险警示的状态，以及是否处于限制减持期限内。因此，可能需要假设某些列的组合可以代表这种情况。例如，当“公司涉嫌证券期货违法犯罪事件”列中存在特定事件时，视为满足条件，并且限制减持期限为某个时间段。

例如，假设当公司被中国证监会立案调查时，即视为可能触及重大违法强制退市情形，从而被实施退市风险警示，并且限制减持期限为从立案调查开始到调查结束后的某个时间。例如，在立案调查期间及之后的一段时间内，股东不得减持。但具体的时间范围可能需要根据相关法规确定，但问题中没有给出，可能需要假设。

或者，可能限制减持期限是交易所规定的，比如在退市风险警示实施后的特定天数内。例如，假设在退市风险警示实施后的180天内，股东不得减持。但同样，数据中没有退市风险警示的实施日期，所以无法直接应用。

这可能意味着当前的数据框不足以准确判断condition是否满足，但根据用户的要求，可能需要基于现有的列进行近似处理。例如，假设当公司存在被立案调查的事件时，视为处于退市风险警示状态，并且限制减持期限为该事件发生后的某个时间段。例如，从事件发生日起的某个时间段内，比如一年内。

但这样的假设可能不准确，但可能在没有更多数据的情况下只能这样做。或者，可能用户希望将condition中的条件简化为公司存在被立案调查的事件，而限制减持期限由其他列决定，比如“公告日期”到某个结束日期之间的时间段。

或者，可能数据中的“公司涉嫌证券期货违法犯罪事件”列中的某些事件可以触发退市风险警示，例如“被中国证监会及其派出机构立案调查”可能对应MEU中的条件。因此，当该列中存在该事件时，视为满足condition中的触发条件。而限制减持期限可能由该事件的开始日期和结束日期决定。例如，在事件发生后的某个时间段内，比如从事件公告日开始到调查结束后的某个日期。

但数据中的“公司涉嫌证券期货违法犯罪事件”列可能包含多个事件，例如“被中国证监会及其派出机构立案调查”和“中国证监会及其派出机构立案调查结束”等。因此，可能需要跟踪每个公司的事件时间线，确定在哪些时间段内处于被实施退市风险警示的状态。

例如，当公司有一个“被中国证监会立案调查”的事件时，退市风险警示可能从该事件的日期开始，直到调查结束的事件日期。因此，在数据框中，对于每个公司，需要确定在哪些日期处于退市风险警示状态，并且处于限制减持期限内。

因此，处理condition的步骤可能如下：

1. 对于每个公司，找出所有“被中国证监会及其派出机构立案调查”的事件日期，以及对应的“立案调查结束”的日期。
2. 确定在这些事件期间以及可能的后续期限内，公司处于限制减持期。
3. 对于数据框中的每一行，如果该行的日期处于该公司的某个限制减持期内，则condition为True。

但如何从现有的数据框中提取这些信息呢？例如，数据框中的每一行可能有不同的“公司涉嫌证券期货违法犯罪事件”的值，可能是一个列表或者单个事件。或者，该列可能是一个字符串，表示当天的公司事件状态。

根据用户提供的列信息，“公司涉嫌证券期货违法犯罪事件”的可能值包括多个事件，例如“被中国证监会及其派出机构立案调查”等。假设该列记录的是当天公司是否有该事件发生。例如，如果某行的该列值为“被中国证监会及其派出机构立案调查”，则表示在该日期，公司被立案调查。而后续可能有“中国证监会及其派出机构立案调查结束”的事件，表示调查结束。

因此，可能需要为每个公司构建一个时间线，记录立案调查的开始和结束日期，从而确定限制减持的期限。例如，当公司被立案调查时，开始进入限制减持期，直到调查结束后的某个时间，比如调查结束后的6个月。或者，根据交易所的规定，限制减持期可能持续到退市风险警示解除为止。

但具体的时间范围可能需要根据法律条文确定，但问题中没有给出，可能需要假设。例如，假设限制减持期从立案调查开始日起，持续到调查结束后的180天。或者，可能限制减持期是立案调查期间加上一定时间。

这可能比较复杂，但根据用户给出的数据列，可能需要处理如下：

对于每个公司，当存在“被中国证监会及其派出机构立案调查”的事件时，该事件发生的日期即为退市风险警示的开始日期。然后，当出现“中国证监会及其派出机构立案调查结束”的事件时，视为调查结束。假设限制减持期从调查开始日起，到调查结束后的某个时间段，比如调查结束后的6个月。或者，可能限制减持期仅持续到调查结束日。

但MEU中的条件是“在本所规定的限制减持期限内”，所以需要明确这个期限的具体时间范围。例如，交易所可能规定在退市风险警示期间内不得减持。因此，如果退市风险警示在调查结束后解除，那么限制减持期可能持续到退市风险警示解除日。

但如果没有退市风险警示解除的日期，可能需要假设退市风险警示的持续时间。例如，从立案调查开始到调查结束后的某个时间。

这可能变得非常复杂，但根据用户提供的数据，可能无法准确处理。因此，可能需要简化处理，例如，只要公司存在被立案调查的事件，且在调查期间及之后的一段时间内，视为处于限制减持期。

或者，可能用户希望将condition中的条件简化为：当公司存在被立案调查的事件时，即视为满足触发条件，而不管时间限制。这可能不符合MEU的要求，但可能由于数据限制只能这样做。

或者，可能用户希望将condition中的条件视为：当公司处于退市风险警示状态时，并且该状态是由于重大违法导致的。此时，可能需要假设当公司存在被立案调查的事件时，即处于退市风险警示状态，并且限制减持期是整个退市风险警示期间。

因此，处理condition的步骤可能如下：

1. 确定公司是否处于退市风险警示状态，并且该状态是由于重大违法导致的。这可能需要检查“公司涉嫌证券期货违法犯罪事件”列是否包含相关事件，如“被中国证监会及其派出机构立案调查”。

2. 确定当前日期是否处于限制减持期内。例如，从立案调查开始日期到退市风险警示解除日期之间的时间段。

但如果没有退市风险警示解除的日期，可能需要假设该状态一直持续，直到有另一个事件表明解除。例如，当出现“中国证监会及其派出机构立案调查结束”或“行政处罚决定作出”等事件时，可能解除退市风险警示。

因此，对于每个公司，需要跟踪其退市风险警示的开始和结束日期：

- 当公司出现“被中国证监会及其派出机构立案调查”时，视为退市风险警示开始。
- 当公司出现“中国证监会及其派出机构立案调查结束”或“行政处罚决定作出”时，视为退市风险警示结束。

然后，在数据框中的每一行，如果该行的日期处于退市风险警示期间，则condition为True。

因此，处理步骤可能如下：

对于每个公司，收集所有“被中国证监会及其派出机构立案调查”的事件日期，以及对应的结束日期。然后，对于每个日期，判断是否处于任何一个退市风险警示期间内。

这需要按公司分组，处理每个公司的事件时间线。

例如，对于公司A，假设在日期D1发生了“被中国证监会立案调查”，在日期D2发生了“调查结束”，则退市风险警示期间是D1到D2。如果D2之后没有其他事件，则限制减持期可能到D2为止。或者，可能限制减持期持续到D2之后的某个日期，比如D2+180天。

但如果没有结束日期的数据，可能需要假设退市风险警示一直持续，直到数据中的最后日期。

这可能比较复杂，但根据现有数据，可能需要这样处理。

现在，回到代码编写。我需要编写一个函数，检查每一行是否符合MEU_11_4的条件。

首先，处理subject部分：

subject是控股股东或实际控制人。数据框中的“股东身份”列包含这些值。因此，valid_subject的条件是：

df['股东身份'].isin(['控股股东', '实际控制人'])

接下来，处理condition部分：

需要确定公司是否处于退市风险警示状态，并且处于限制减持期内。这需要：

1. 对于每个公司，确定退市风险警示的期间。
2. 对于每一行，判断该行的日期是否处于该公司的退市风险警示期间内。

如何确定退市风险警示期间？

假设当公司出现“被中国证监会及其派出机构立案调查”时，开始退市风险警示，当出现“中国证监会及其派出机构立案调查结束”或“行政处罚决定作出”时，结束退市风险警示。或者，可能退市风险警示持续到调查结束后的某个时间。

但具体如何确定需要根据交易所的规定。例如，可能退市风险警示在调查结束后仍然持续一段时间，或者立即解除。

假设退市风险警示期间为从立案调查开始到调查结束后的某个期限，比如调查结束后的180天。或者，可能退市风险警示期间仅持续到调查结束日。

这里可能需要简化处理，假设退市风险警示期间为从立案调查开始日到调查结束日。或者，如果调查未结束，则持续到数据中的最后日期。

因此，处理步骤：

对于每个公司，收集所有“被中国证监会及其派出机构立案调查”的事件日期，并找到对应的结束日期（如果有的话）。

例如，对于公司A，在日期D1发生立案调查，在日期D2发生调查结束。则退市风险警示期间是D1到D2。如果D2不存在，则期间是D1到数据中的最后日期。

然后，对于每一行，如果该行的日期在退市风险警示期间内，并且公司简称对应的公司处于该期间，则condition为True。

因此，需要为每个公司构建一个时间段列表，表示退市风险警示期间。

如何实现这一点？

可能需要按公司分组，然后为每个公司处理事件序列。

例如，对于每个公司，找到所有立案调查的开始日期和结束日期，然后生成期间列表。

然后，对于每一行，检查该行的日期是否处于任何一个期间内。

这可能需要使用pandas的groupby和apply方法，或者使用merge来标记每个日期是否在期间内。

但具体如何实现呢？

例如，可以创建一个辅助的DataFrame，记录每个公司的退市风险警示期间，然后对原始df进行标记。

但可能比较复杂，因为每个公司可能有多个期间。

另一种方法是，对于每一行，检查该公司的历史事件，确定该日期是否处于退市风险警示期间。

这可能效率较低，但可行。

具体步骤：

1. 对于每个公司，找到所有“被中国证监会及其派出机构立案调查”的事件日期，作为开始日期。
2. 对于每个开始日期，找到对应的结束日期，即该公司后续的“中国证监会及其派出机构立案调查结束”或“行政处罚决定作出”的日期。
3. 如果没有结束日期，则结束日期为数据中的最大日期（即数据框的最后日期）。
4. 对于每个开始和结束日期，生成一个时间段。
5. 对于每一行，如果该行的日期处于任何一个时间段内，则condition为True。

这需要为每个公司生成时间段列表，然后检查每个日期是否在任何一个时间段内。

这在代码中如何实现？

例如，可以按公司分组，然后对每个公司处理事件：

首先，筛选出公司的事件：

company_events = df[df['公司涉嫌证券期货违法犯罪事件'].isin(['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出'])]

然后，按公司分组，并为每个公司构建时间段：

对于每个公司，收集所有立案调查的开始日期，并为每个开始日期找到对应的结束日期。

例如：

def get_restriction_periods(group):
    periods = []
    current_start = None
    for idx, row in group.iterrows():
        event = row['公司涉嫌证券期货违法犯罪事件']
        date = row['日期']
        if event == '被中国证监会及其派出机构立案调查':
            current_start = date
        elif event in ['中国证监会及其派出机构立案调查结束', '行政处罚决定作出'] and current_start is not None:
            periods.append((current_start, date))
            current_start = None
    # 处理未结束的立案调查
    if current_start is not None:
        periods.append((current_start, group['日期'].max()))
    return periods

然后，应用这个函数到每个公司：

restriction_periods = df.groupby('公司简称').apply(get_restriction_periods)

然后，对于原始df中的每一行，检查该行的日期是否在该公司的任何一个periods内。

这可能需要将restriction_periods转换为一个字典，其中键是公司简称，值是该公司的periods列表。

然后，对于每一行，使用公司简称查找对应的periods，并检查日期是否在任何一个(start, end)区间内。

例如：

def is_in_restriction_period(row, periods_dict):
    company = row['公司简称']
    date = row['日期']
    if company not in periods_dict:
        return False
    for start, end in periods_dict[company]:
        if start <= date <= end:
            return True
    return False

然后，应用这个函数到每一行：

valid_condition = df.apply(lambda row: is_in_restriction_period(row, restriction_periods), axis=1)

但这个过程可能比较耗时，特别是对于大数据集。但根据问题描述，用户希望代码能够处理，所以需要这样处理。

不过，在用户提供的列中，可能没有“公司涉嫌证券期货违法犯罪事件”的详细时间线，而是每一行代表某一天的状态。例如，某一天公司是否处于被立案调查的状态。例如，如果某行的“公司涉嫌证券期货违法犯罪事件”是“被中国证监会及其派出机构立案调查”，则表示该天公司被立案调查。而后续的日期可能没有该事件，或者有结束事件。

这可能意味着，对于每个公司，退市风险警示期间是从第一次出现该事件的日期开始，到出现结束事件的日期为止。或者，可能每次出现该事件都会开启一个新的期间。

例如，公司可能在多个时间点被立案调查，每次都会开启一个新的退市风险警示期间。

因此，需要处理每个事件的出现，并记录期间。

但如何从数据框中提取这些期间？

例如，假设数据框中的每一行代表某一天的公司状态，如果某行的“公司涉嫌证券期货违法犯罪事件”是“被中国证监会及其派出机构立案调查”，则视为该天开始了一个新的退市风险警示期间。然后，当出现结束事件时，该期间结束。

但同一公司可能在多个时间点被多次立案调查，因此需要处理多个期间。

这可能比较复杂，但代码需要处理这种情况。

现在，回到代码编写：

首先，处理subject部分：

df['meu_11_4_subject'] = df['股东身份'].isin(['控股股东', '实际控制人'])

然后，处理condition部分：

需要确定公司是否处于退市风险警示期间，并且处于限制减持期内。

假设退市风险警示期间是公司被立案调查的期间，即从立案调查开始到调查结束或行政处罚决定作出。

因此，需要为每个公司构建这些期间。

然后，对于每一行，如果该行的日期属于该公司的任何一个退市风险警示期间，则condition为True。

现在，如何构建这些期间？

例如，对于每个公司，收集所有立案调查的开始日期和对应的结束日期。

这可能通过以下步骤：

1. 按公司分组。
2. 对每个公司，按日期排序。
3. 遍历每个事件，记录开始和结束日期。

例如：

def get_periods(group):
    periods = []
    in_restriction = False
    start_date = None
    for idx, row in group.sort_values('日期').iterrows():
        event = row['公司涉嫌证券期货违法犯罪事件']
        if event == '被中国证监会及其派出机构立案调查' and not in_restriction:
            start_date = row['日期']
            in_restriction = True
        elif event in ['中国证监会及其派出机构立案调查结束', '行政处罚决定作出'] and in_restriction:
            end_date = row['日期']
            periods.append((start_date, end_date))
            in_restriction = False
            start_date = None
    # 处理未结束的情况
    if in_restriction and start_date is not None:
        periods.append((start_date, group['日期'].max()))
    return periods

然后，应用这个函数到每个公司：

restriction_periods = df.groupby('公司简称').apply(get_periods).to_dict()

然后，对于每一行，检查日期是否在对应的公司的任何一个期间内。

例如：

def check_condition(row, periods_dict):
    company = row['公司简称']
    date = row['日期']
    if company not in periods_dict:
        return False
    for (start, end) in periods_dict[company]:
        if start <= date <= end:
            return True
    return False

然后，应用这个函数：

valid_condition = df.apply(lambda row: check_condition(row, restriction_periods), axis=1)

这可能是一个可行的方法。

最后，处理constraint部分：不得减持股份。这需要检查该股东在该交易日是否有减持行为。例如，当日减持比例是否大于0，或者是否有减持记录。

根据数据框中的列，可能有“当日减持比例”列，如果该值大于0，则表示减持了股份。因此，valid_constraint的条件是当日减持比例等于0，或者不存在减持行为。

但MEU中的constraint是“不得减持”，所以如果当日减持比例>0，则违反约束，即constraint为False。反之，如果当日减持比例为0，则符合约束，即constraint为True。

因此，valid_constraint = df['当日减持比例'] == 0

但需要注意，对于所有行，无论subject和condition是否满足，都需要检查constraint。根据用户的要求，对于简单操作，三元组的检查是各自独立的。因此，即使subject或condition不满足，也需要标记constraint是否符合。

但根据MEU的逻辑，只有当subject和condition都满足时，才需要遵守constraint。但用户的要求是，对于简单操作，三元组的检查是各自独立的，分别标记。因此，不管subject和condition是否为True，都要检查constraint是否满足，并标记。

例如，即使某行的subject是False，或者condition是False，只要该行存在减持行为（当日减持比例>0），则constraint为False。但根据法律条文，只有当subject和condition都满足时，才需要遵守constraint。但用户的要求是，对于简单操作，三个条件独立检查，因此需要分别标记。

这可能与法律逻辑不符，但根据用户的要求，必须这样做。例如，在示例中，constraint的检查是独立于subject和condition的。例如，在示例中的MEU_4_1，constraint的检查是检查所有行的“交易日差”是否>=15，而不管subject和condition是否为True。

因此，在本题中，constraint的检查是：该股东在该交易日是否减持了股份。即，如果当日减持比例>0，则constraint为False，否则为True。这需要检查所有行，不管subject和condition是否为True。

因此，valid_constraint = df['当日减持比例'] <= 0

或者，如果当日减持比例是0，则为True，否则False。

但需要注意，减持比例可能为0，表示没有减持。因此：

df['meu_11_4_constraint'] = (df['当日减持比例'] == 0)

但需要确认数据中的“当日减持比例”是否为当天的减持比例，如果是累计的，可能需要不同的处理。但根据列描述，“当日减持比例”是当天的减持比例，所以如果该值大于0，表示当天有减持，违反约束。

因此，constraint的标记为：当日减持比例等于0时为True，否则为False。

综上，代码的大致结构如下：

1. 标记subject是否为控股股东或实际控制人。
2. 标记condition是否为公司处于退市风险警示期间。
3. 标记constraint是否为当日没有减持股份。

现在，将这些步骤转化为代码：

首先，初始化各列：

df['meu_11_4_subject'] = False
df['meu_11_4_condition'] = False
df['meu_11_4_constraint'] = None

然后，处理subject：

valid_subject = df['股东身份'].isin(['控股股东', '实际控制人'])
df.loc[valid_subject, 'meu_11_4_subject'] = True

处理condition：

需要构建每个公司的退市风险警示期间，然后标记日期是否在这些期间内。

为此，编写一个函数来生成每个公司的期间列表：

def get_restriction_periods(df_group):
    periods = []
    in_restriction = False
    start_date = None
    # 按日期排序
    sorted_group = df_group.sort_values('日期')
    for _, row in sorted_group.iterrows():
        event = row['公司涉嫌证券期货违法犯罪事件']
        current_date = row['日期']
        if event == '被中国证监会及其派出机构立案调查' and not in_restriction:
            start_date = current_date
            in_restriction = True
        elif event in ['中国证监会及其派出机构立案调查结束', '行政处罚决定作出'] and in_restriction:
            end_date = current_date
            periods.append((start_date, end_date))
            in_restriction = False
            start_date = None
    # 处理未结束的期间
    if in_restriction and start_date is not None:
        end_date = sorted_group['日期'].max()
        periods.append((start_date, end_date))
    return periods

然后，按公司分组，获取每个公司的期间列表：

restriction_periods = df.groupby('公司简称').apply(get_restriction_periods).to_dict()

然后，定义一个函数检查日期是否在期间内：

def is_in_period(date, periods):
    for start, end in periods:
        if start <= date <= end:
            return True
    return False

然后，应用这个函数到每一行：

df['meu_11_4_condition'] = df.apply(
    lambda row: is_in_period(row['日期'], restriction_periods.get(row['公司简称'], [])),
    axis=1
)

或者，更高效的方式可能是在分组时处理，但这里使用apply方法。

最后，处理constraint：

df['meu_11_4_constraint'] = (df['当日减持比例'] == 0)

但根据用户的要求，constraint的列需要是布尔值，所以：

df['meu_11_4_constraint'] = df['当日减持比例'] == 0

综上，完整的代码可能如下：

import pandas as pd

def check_meu_11_4(df):
    '''
    检查MEU_11_4的合规性：
    subject: 控股股东或实际控制人
    condition: 公司股票因可能触及重大违法强制退市情形被实施退市风险警示，并在限制减持期内
    constraint: 不得减持股份
    '''
    df = df.copy()
    
    # 初始化标记列
    df['meu_11_4_subject'] = False
    df['meu_11_4_condition'] = False
    df['meu_11_4_constraint'] = False  # 初始化为False，后续根据条件更新
    
    # 标记subject
    valid_subject = df['股东身份'].isin(['控股股东', '实际控制人'])
    df.loc[valid_subject, 'meu_11_4_subject'] = True
    
    # 标记condition：需要确定公司处于退市风险警示期间
    # 首先按公司分组，生成每个公司的退市风险警示期间
    def get_restriction_periods(group):
        periods = []
        in_restriction = False
        start_date = None
        sorted_group = group.sort_values('日期')
        for _, row in sorted_group.iterrows():
            event = row['公司涉嫌证券期货违法犯罪事件']
            current_date = row['日期']
            if event == '被中国证监会及其派出机构立案调查':
                if not in_restriction:
                    start_date = current_date
                    in_restriction = True
            elif event in ['中国证监会及其派出机构立案调查结束', '行政处罚决定作出']:
                if in_restriction:
                    end_date = current_date
                    periods.append((start_date, end_date))
                    in_restriction = False
                    start_date = None
        # 处理未结束的期间
        if in_restriction and start_date is not None:
            end_date = sorted_group['日期'].max()
            periods.append((start_date, end_date))
        return periods
    
    # 获取每个公司的期间列表
    restriction_periods = df.groupby('公司简称').apply(get_restriction_periods).to_dict()
    
    # 检查每一行是否在期间内
    def is_in_restriction(row):
        company = row['公司简称']
        date = row['日期']
        periods = restriction_periods.get(company, [])
        for (start, end) in periods:
            if start <= date <= end:
                return True
        return False
    
    valid_condition = df.apply(is_in_restriction, axis=1)
    df.loc[valid_condition, 'meu_11_4_condition'] = True
    
    # 标记constraint：当日减持比例为0
    df['meu_11_4_constraint'] = (df['当日减持比例'] == 0)
    
    return df

但需要注意，在示例中，constraint的列初始化为None，然后根据条件设置为True或False。但根据用户的要求，对于简单操作，三元组的检查是各自独立的，所以constraint的检查不需要依赖subject和condition。因此，在代码中，constraint的标记是直接根据当日减持比例是否为0来设置。

此外，在示例中，constraint的列初始化为None，然后设置为True或False。但在上面的代码中，初始化为False，然后设置为True或False。这可能会有问题，因为初始化为False，然后正确的值可能覆盖。例如，如果当日减持比例为0，则设置为True。否则保持False。这可能正确，因为初始化为False，然后：

df['meu_11_4_constraint'] = (df['当日减持比例'] == 0)

这会覆盖初始化的False，所以是正确的。

综上，这段代码应该能够正确标记各条件。
","CompletionUsage(completion_tokens=7246, prompt_tokens=1722, total_tokens=8968, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=6646, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_13_3
法律的最小可执行单元内容: {""subject"": ""控股股东 | 实际控制人"", ""condition"": ""通过协议转让方式减持股份导致其不再具有控股股东、实际控制人身份, 且处于减持后的6个月内"", ""constraint"": ""应当继续遵守本指引第十二条第一款第二、三项规定"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_13_3(df):
    '''
    检查MEU_13_3的合规性：
    subject: 控股股东 | 实际控制人
    condition: 通过协议转让减持导致失去身份，且在减持后的6个月内
    constraint: 继续遵守第十二条相关规定（假设检查减持后的六个月内是否有减持行为）
    '''
    df = df.copy()
    
    # 初始化标记列
    df['meu_13_3_subject'] = df['股东身份'].isin(['控股股东', '实际控制人'])
    df['meu_13_3_condition'] = False
    df['meu_13_3_constraint'] = True  # 初始假设为True
    
    # 处理condition和constraint
    # 分组处理每个公司和股东
    def process_group(group):
        # 找到所有协议转让且subject为True的行
        protocol_mask = (group['减持方式'] == '协议转让') & (group['meu_13_3_subject'])
        protocol_dates = group.loc[protocol_mask, '日期'].tolist()
        
        # 检查每个协议转让日期是否导致身份变化
        for date in protocol_dates:
            # 找到该日期之后的行
            subsequent = group[group['日期'] > date]
            if not subsequent.empty:
                # 检查后续第一个行是否身份变化
                first_subsequent = subsequent.iloc[0]
                if not first_subsequent['meu_13_3_subject']:
                    # 触发点date，计算六个月后的日期
                    end_date = date + pd.DateOffset(months=6)
                    # 标记condition为True
                    condition_mask = (group['日期'] >= date) & (group['日期'] <= end_date)
                    group.loc[condition_mask, 'meu_13_3_condition'] = True
        
        # 独立处理constraint：检查所有减持后的六个月内是否有减持行为
        dissolution_dates = group[group['当日减持比例'] > 0]['日期']
        for date in dissolution_dates:
            end_date = date + pd.DateOffset(months=6)
            constraint_mask = (group['日期'] > date) & (group['日期'] <= end_date)
            group.loc[constraint_mask, 'meu_13_3_constraint'] = False
        
        return group
    
    df = df.groupby(['公司简称', '股东'], group_keys=False).apply(process_group)
    
    return df
</CODE>","好的，我现在需要处理这个MEU_13_3的合规性检查。首先，我得仔细理解这个MEU的内容。根据提供的MEU信息，责任主体是控股股东或实际控制人，触发条件是他们通过协议转让方式减持股份导致失去控股股东或实际控制人身份，并且在减持后的6个月内。约束内容是需要继续遵守第十二条第一款第二、三项的规定，不过这里可能不需要具体处理那两条的内容，而是标记是否符合约束条件。

接下来，我需要根据提供的dataframe的列来编写代码。首先，处理subject部分。根据MEU的subject是控股股东或实际控制人，所以需要检查股东身份是否是这两个中的一个。在数据中，股东身份列有对应的标签，所以可以直接用isin(['控股股东', '实际控制人'])来判断。

然后是condition部分。条件有两个部分：一是通过协议转让方式减持股份导致不再具有身份，二是处于减持后的6个月内。这里可能需要拆解。首先，减持方式是否是协议转让？数据中的减持方式列可能有这个信息。然后，减持导致身份变化，可能需要跟踪股东在减持后的身份是否不再是控股股东或实际控制人。此外，减持后的6个月内需要计算时间窗口。

不过，这里的数据是日频的，所以可能需要针对每个股东，检查他们减持导致身份变化的时间点，然后确定之后6个月内的日期是否满足条件。例如，当某次减持导致股东失去身份，那么从该减持日期开始算6个月内的所有行都需要标记condition为True。

但具体如何操作呢？可能需要分组处理每个公司和股东，找到他们身份变化的日期。例如，当某股东在某一日的减持后，持股比例下降到不再是控股股东或实际控制人，那么该日期之后6个月内的交易日都属于condition满足的情况。

不过，数据中的股东身份列可能已经反映了当天的身份，所以如果某行的股东身份不再是控股股东或实际控制人，但之前曾经是，那么这可能意味着发生了身份变化。但需要确定身份变化的具体日期，这可能比较复杂。或者，可能需要在数据中找到该股东最后一次作为控股股东或实际控制人的日期，然后之后的6个月内都算作条件满足。

另外，减持方式必须是协议转让。所以需要检查减持方式是否为协议转让，并且在该减持行为导致身份变化的情况下，才会触发条件。

这可能涉及到分组处理，每个股东在每次减持协议转让时，是否导致身份变化。例如，当某股东通过协议转让减持股份，导致其持股比例低于控股股东或实际控制人的标准，那么该次减持的日期就是触发点，之后6个月内的交易日都满足条件。

但如何确定减持导致身份变化呢？可能需要比较减持前后的身份。例如，在减持当天或之后，股东身份不再是控股股东或实际控制人。或者，可能需要跟踪该股东的持股比例变化，当某次减持后，其身份发生了变化。

不过，数据中的股东身份列可能已经直接反映了当天的身份，所以如果某行的股东身份不是控股股东或实际控制人，但之前曾经是，那么可能该股东在之前的某个时间点减持导致身份变化。但如何确定这个时间点呢？

或者，可能需要在数据中，对于每个股东，找到他们最后一次作为控股股东或实际控制人的日期，然后检查之后是否有通过协议转让减持的行为，并且之后6个月内的日期都满足条件。这可能比较复杂，需要分组处理。

或者，可能假设当减持方式为协议转让，并且该行的股东身份不再是控股股东或实际控制人，那么该次减持导致身份变化。但这样可能不够准确，因为身份变化可能发生在减持之后的某个时间点，而不是当天。

这里可能需要简化处理，比如，当某股东在某一日减持方式为协议转让，并且在该日之后，其身份不再是控股股东或实际控制人，那么从该减持日期开始算6个月内的交易日都满足条件。或者，可能需要找到该股东最后一次减持协议转让的日期，并且在该日期之后身份发生了变化，那么该日期之后的6个月内都算作条件满足。

这可能需要分组处理每个股东，找到他们减持协议转让的日期，并检查这些减持是否导致身份变化。例如，对于每个股东，找到所有减持方式为协议转让的行，然后检查这些行之后是否身份变为非控股股东或实际控制人。如果是，则这些减持日期作为触发点，之后6个月内的交易日都满足条件。

但具体如何实现呢？可能需要按公司和股东分组，然后对于每个组，找到所有减持协议转让的日期，并检查这些日期之后该股东的身份是否变为非控股股东或实际控制人。如果是，则这些日期之后的6个月内，该股东的condition为True。

这可能需要遍历每个分组，记录每个触发点，然后为每个日期判断是否处于这些触发点之后的6个月内。

例如，对于每个股东，收集所有减持协议转让的日期，然后对于每个这样的日期，检查之后该股东的身份是否变为非控股股东或实际控制人。如果是，则将该日期作为触发点，之后6个月内的所有行的condition标记为True。

这可能比较复杂，但考虑到数据是按日记录的，可能需要这样的处理。

现在，关于约束条件，即constraint部分，这里需要检查是否遵守了第十二条的相关规定。但根据任务要求，可能不需要具体检查第十二条的内容，而是根据MEU的约束条件，标记是否满足。但根据MEU的描述，约束条件是“应当继续遵守”，所以可能需要在满足subject和condition的情况下，检查是否满足该约束条件。但具体的约束条件可能涉及其他MEU，比如第十二条的相关内容，但这里可能无法处理，所以可能只需要标记在满足subject和condition的情况下，是否满足约束条件。但用户可能希望将约束条件的检查独立处理，或者根据其他条件。

不过根据任务要求，对于三元组的检查是各自独立的，所以需要分别标记subject、condition、constraint的满足情况。但根据用户的要求，对于需要调用llm_content_check()的情况，只检查满足subject和condition的行的constraint。但当前任务中没有需要调用该函数的情况，所以对于constraint的检查是独立的，即不管subject和condition是否满足，都要检查constraint是否满足。

但根据MEU的约束条件，可能只有当subject和condition都满足时，才需要满足constraint。但根据用户的要求，对于简单操作dataframe的情况，三元组的检查是各自独立的。所以需要分别标记每个部分是否满足，不管其他条件是否满足。

但这里可能存在矛盾，因为约束条件可能只有在subject和condition都满足时才需要被检查。例如，只有当股东是控股股东或实际控制人，并且处于减持后的6个月内，才需要遵守约束条件。但根据用户的要求，对于简单操作dataframe的情况，三个条件的检查是独立的。所以需要分别标记每个条件是否满足，不管其他条件是否满足。

但根据MEU的约束条件，可能约束条件是否满足只有在subject和condition都满足的情况下才有意义。但根据用户的任务要求，对于不需要调用llm_content_check()的情况，三个条件的检查是独立的。所以需要分别标记每个条件是否满足，不管其他条件是否满足。

这可能意味着，在标记constraint时，不管subject和condition是否满足，都要检查是否满足约束条件。例如，约束条件可能涉及其他行为，如是否提前公告等，但这里MEU_13_3的约束条件是指需要遵守其他条款，可能需要检查是否满足这些条款的要求。但用户可能希望将约束条件的检查独立处理，比如，假设约束条件是否满足需要根据其他列的数据来判断，而不管subject和condition是否满足。

但根据MEU_13_3的约束条件，即“应当继续遵守本指引第十二条第一款第二、三项规定”，这可能意味着需要检查该股东是否在减持后的6个月内遵守了这些规定。例如，第十二条可能规定了某些减持的限制，如减持比例、披露要求等。但具体如何检查这些可能不在当前任务范围内，因为用户可能希望将约束条件的检查独立处理，或者可能需要根据其他列的数据来判断。

但根据用户提供的附加信息中的dataframe列，可能没有直接相关的列来检查第十二条的内容。因此，可能需要假设约束条件的检查无法在当前数据中完成，或者需要其他处理。但根据任务要求，可能需要忽略约束条件的具体内容，仅根据MEU的描述进行标记，或者可能无法处理，所以可能将约束条件的检查留空或标记为None。但根据示例中的处理方式，示例中的约束条件检查是独立进行的，例如检查是否存在减持计划以及交易日差是否大于等于15天。

但在这个MEU_13_3的情况下，约束条件是继续遵守其他条款，可能无法直接根据现有列来判断，所以可能需要将约束条件的检查留空，或者假设该约束条件在此任务中无法处理，因此标记为False或None。但根据用户的要求，可能需要编写代码来标记约束条件是否满足，但可能无法实现，所以需要进一步分析。

或者，可能用户希望将约束条件的检查视为需要满足其他MEU的条件，例如MEU_12_1_2和MEU_12_1_3，但此时可能需要调用其他检查函数。但当前任务中可能无法处理，因此可能需要将约束条件的检查留空，或者根据现有数据无法判断，所以标记为None或False。但根据示例中的处理，约束条件的检查是独立进行的，所以可能需要找到与约束条件相关的列。

例如，假设第十二条第一款第二项可能要求减持比例不超过一定数值，或者需要披露某些信息，那么可能需要检查累计减持比例、是否存在减持计划等。但如果没有具体的信息，可能需要假设无法处理，或者根据现有列进行假设。

但根据用户提供的dataframe列，可能有“累计减持比例”、“计划减持比例”等列，但不确定是否与第十二条相关。因此，可能需要根据这些列来检查约束条件。例如，假设第十二条要求减持比例不超过1%，那么约束条件可能被标记为累计减持比例是否超过1%。但如果没有具体的信息，可能需要假设无法处理，或者用户希望我们忽略约束条件的检查，仅标记subject和condition。

但根据任务要求，必须编写代码来标记三个条件的满足情况。因此，可能需要将约束条件的检查留空，或者根据现有数据进行假设。例如，假设约束条件要求减持后的六个月内不得减持，那么需要检查在该期间内是否有减持行为。或者，可能需要检查是否存在减持计划，或者是否满足某些披露要求。

但根据MEU_13_3的约束条件，可能需要检查是否遵守了第十二条的相关规定，但具体内容未知。因此，可能需要假设无法处理，或者用户希望我们暂时忽略约束条件的检查，仅标记为True或False。但根据示例中的处理，约束条件可能被独立检查，例如示例中的valid_constraint是根据交易日差和存在减持计划来判断的。

因此，可能需要根据现有数据中的某些列来推断约束条件是否满足。例如，假设第十二条的规定可能涉及减持计划的披露时间，或者减持比例的限制，那么可能需要检查相关列。例如，是否存在减持计划，或者累计减持比例是否超过某个阈值。

但如果没有具体的信息，可能需要根据示例中的处理方式，将约束条件的检查留空，或者根据其他条件进行假设。例如，假设约束条件要求在该期间内不得减持，那么需要检查该股东在减持后的六个月内是否有减持行为。如果有，则约束条件不满足。

例如，在减持后的六个月内，如果该股东有减持行为，则约束条件不满足。或者，如果该股东在减持后的六个月内没有减持，则约束条件满足。但需要根据数据中的减持记录来判断。

但数据中的“当日减持比例”列可能记录了每天的减持情况。因此，在减持后的六个月内，如果该股东有当日减持比例大于0的情况，则约束条件不满足。否则，满足。

但如何确定减持的日期呢？例如，当股东通过协议转让减持导致身份变化，那么该减持的日期是触发点，之后六个月内如果有减持行为，则违反约束条件。

因此，约束条件的检查可能涉及在触发点之后的六个月内，该股东是否有减持行为。如果有，则约束条件不满足；否则，满足。

但如何实现这一点呢？可能需要找到每个触发点（即导致身份变化的协议转让减持日期），然后对于每个触发点之后的六个月内，检查该股东是否有减持行为（即当日减持比例>0）。

但具体如何操作呢？可能需要按公司和股东分组，然后对于每个分组，找到所有触发点（协议转让减持导致身份变化的日期），然后对于每个触发点，检查该日期之后的六个月内，该股东是否有减持行为。

例如，对于每个触发点，生成一个时间范围（触发点日期到触发点日期+6个月），然后在该时间范围内，如果该股东的当日减持比例>0，则约束条件不满足。

但如何将这些信息标记到dataframe中的每一行呢？可能需要为每个行判断其是否处于任何触发点的六个月内，并且在该期间内有减持行为。

这可能比较复杂，需要分组处理，并为每个行判断是否处于某个触发点的六个月内，并且该行是否有减持行为。

但根据用户提供的dataframe列，可能没有直接记录触发点的信息，因此需要先确定触发点。

总结一下，处理步骤可能如下：

1. 标记subject：股东身份是控股股东或实际控制人。
2. 标记condition：通过协议转让减持导致失去身份，并且在减持后的六个月内。
3. 标记constraint：在减持后的六个月内遵守第十二条的相关规定（假设需要检查是否有减持行为）。

具体实现步骤：

对于subject：
- 检查股东身份是否为“控股股东”或“实际控制人”。

对于condition：
- 需要满足两个条件：减持方式是协议转让，并且减持导致不再具有身份，且处于减持后的六个月内。
- 因此，需要找到该股东通过协议转让减持的日期，并且在该日期之后，其身份不再是控股股东或实际控制人。
- 然后，对于每个这样的日期，将该日期之后的六个月内所有行标记为condition满足。

对于constraint：
- 假设约束条件是在减持后的六个月内不得减持，因此需要检查在该期间内是否有减持行为（当日减持比例>0）。
- 因此，对于每个触发点（导致身份变化的协议转让减持日期），检查该日期之后的六个月内，该股东是否有减持行为。如果有，则这些行的constraint为False，否则为True。

但如何实现这些步骤呢？

首先，处理subject：

df['meu_13_3_subject'] = df['股东身份'].isin(['控股股东', '实际控制人'])

然后，处理condition：

需要找到每个股东通过协议转让减持，并且导致身份变化的日期。这可能比较复杂。

步骤：

1. 按公司和股东分组。
2. 对于每个分组，找到所有减持方式为协议转让的行。
3. 对于这些行，检查该行之后该股东的身份是否不再是控股股东或实际控制人。
4. 如果是，则该减持日期作为触发点。
5. 对于每个触发点，将该日期之后的六个月内（自然日）的所有行标记为condition满足。

但如何确定减持导致身份变化呢？例如，某股东在减持协议转让后，身份变为非控股股东或实际控制人。因此，需要检查该股东在减持后的身份是否发生了变化。

例如，对于每个协议转让减持的行，如果该行的股东身份是控股股东或实际控制人，并且在之后的任何行中，该股东的身份不再是控股股东或实际控制人，那么该减持日期可能被视为触发点。

或者，可能需要在减持协议转让的日期之后，该股东的身份立即变为非控股股东或实际控制人。这可能更简单，但可能不准确。

或者，可能假设在减持协议转让的日期，该股东的身份变为非控股股东或实际控制人，因此该日期即为触发点。

但数据中的股东身份列可能已经反映了当天的身份，因此，如果在减持协议转让的日期，股东身份变为非控股股东或实际控制人，则该日期即为触发点。

因此，处理步骤：

对于每个行，如果减持方式为协议转让，并且股东身份在当天是控股股东或实际控制人，并且在减持后的行中，该股东的身份不再是控股股东或实际控制人，那么该日期作为触发点。

或者，更简单的方式：对于每个协议转让减持的行，如果该行的股东身份是控股股东或实际控制人，并且在之后的任何行中，该股东的身份变为非控股股东或实际控制人，则触发点为该减持日期。

这可能比较复杂，需要按分组处理，并跟踪每个协议转让减持后的身份变化。

或者，可以简化处理：假设在协议转让减持的当天，该股东的身份变为非控股股东或实际控制人，因此该日期即为触发点。这可能不准确，但可能是一个可行的简化方法。

例如，当某行的减持方式为协议转让，并且股东身份是控股股东或实际控制人，并且该行的股东身份在之后的行中变为非控股股东或实际控制人，那么该行的日期即为触发点。

但如何确定这一点呢？可能需要按分组处理，找到每个协议转让减持的日期，并检查该日期之后是否有身份变化。

例如，对于每个分组（公司和股东），找到所有减持方式为协议转让的日期，然后对于每个这样的日期，检查该日期之后是否存在该股东身份变为非控股股东或实际控制人的情况。如果存在，则将该日期作为触发点。

这可能涉及到对每个分组进行遍历，记录触发点，然后为每个行判断是否处于任何触发点的六个月内。

具体实现可能如下：

对于每个分组（公司简称，股东）：

- 获取所有减持方式为协议转让的行，按日期排序。
- 对于每个这样的行，检查该行之后是否存在该股东身份变为非控股股东或实际控制人的情况。
- 如果存在，则记录该减持日期作为触发点。
- 然后，对于每个触发点，计算其后的六个月时间窗口。
- 对于每个行，如果其日期处于任何触发点的六个月窗口内，则condition为True。

但如何实现这个逻辑呢？可能需要使用groupby和apply方法，或者使用滚动窗口。

例如，按分组处理：

def check_condition(group):
    # 找到所有协议转让的日期
    protocol_transfer_dates = group[group['减持方式'] == '协议转让']['日期']
    trigger_dates = []
    for date in protocol_transfer_dates:
        # 检查该日期之后，该股东的身份是否变为非控股股东或实际控制人
        subsequent_rows = group[group['日期'] > date]
        if len(subsequent_rows) > 0:
            # 检查后续行中的股东身份是否不再是控股股东或实际控制人
            if not subsequent_rows.iloc[0]['股东身份'] in ['控股股东', '实际控制人']:
                trigger_dates.append(date)
    # 对于每个触发日期，生成六个月的时间窗口
    for trigger_date in trigger_dates:
        start_date = trigger_date
        end_date = trigger_date + pd.DateOffset(months=6)
        # 标记该时间窗口内的行condition为True
        mask = (group['日期'] >= start_date) & (group['日期'] <= end_date)
        group.loc[mask, 'meu_13_3_condition'] = True
    return group

然后，在函数中应用这个分组处理：

df = df.groupby(['公司简称', '股东']).apply(check_condition)

但这种方法可能效率较低，特别是对于大数据集。此外，如何确定减持协议转让导致身份变化可能需要更精确的条件。

或者，可以简化条件：只要减持方式为协议转让，并且该行的股东身份是控股股东或实际控制人，并且在减持后的六个月内，该股东的身份变为非控股股东或实际控制人，则condition为True。

但如何确定身份变化的时间点呢？可能需要找到该股东最后一次作为控股股东或实际控制人的日期，然后检查该日期是否在减持协议转让之后的六个月内。

或者，假设在减持协议转让的日期之后，该股东的身份立即变为非控股股东或实际控制人，因此触发日期即为该减持日期，之后的六个月内都满足condition。

这可能是一个简化的处理方式，但可能不符合实际情况，但根据数据中的信息，可能只能这样处理。

例如，对于每个行，如果减持方式为协议转让，并且股东身份是控股股东或实际控制人，并且该行的日期之后，该股东的身份变为非控股股东或实际控制人，则触发日期为该行的日期，之后的六个月内condition为True。

但如何确定身份变化的时间点呢？可能需要按分组找到该股东最后一次作为控股股东或实际控制人的日期，然后检查该日期是否在协议转让减持之后。

这可能比较复杂，但可以尝试以下步骤：

对于每个分组（公司简称，股东）：

1. 找到所有减持方式为协议转让的行，按日期排序。
2. 对于每个这样的行，检查该行之后是否存在该股东身份变为非控股股东或实际控制人的情况。
3. 如果存在，则记录该减持日期作为触发点。
4. 对于每个触发点，生成六个月的时间窗口，标记该窗口内的行condition为True。

但如何高效地实现这一点呢？

可能需要在每个分组中，遍历所有协议转让的日期，并检查后续行中的身份变化。

例如：

def check_condition(group):
    # 初始化condition列为False
    group['meu_13_3_condition'] = False
    # 找到所有协议转让的日期，且股东身份是控股股东或实际控制人
    protocol_mask = (group['减持方式'] == '协议转让') & (group['股东身份'].isin(['控股股东', '实际控制人']))
    protocol_dates = group.loc[protocol_mask, '日期'].tolist()
    # 对于每个协议转让日期，检查后续是否有身份变化
    for date in protocol_dates:
        # 找到该日期之后的行
        subsequent = group[group['日期'] > date]
        if not subsequent.empty:
            # 检查后续行中的股东身份是否不再是控股股东或实际控制人
            # 取后续行的第一个日期
            first_subsequent = subsequent.iloc[0]
            if first_subsequent['股东身份'] not in ['控股股东', '实际控制人']:
                # 该协议转让导致身份变化，触发点date
                start = date
                end = date + pd.DateOffset(months=6)
                # 标记该时间段内的行condition为True
                mask = (group['日期'] >= start) & (group['日期'] <= end)
                group.loc[mask, 'meu_13_3_condition'] = True
    return group

然后，应用这个函数到每个分组：

df = df.groupby(['公司简称', '股东'], group_keys=False).apply(check_condition)

这可能是一个可行的方法，但需要注意，如果后续行中的第一个行就发生了身份变化，则认为该协议转让导致了身份变化。这可能不完全准确，但可能是一个合理的简化。

接下来，处理constraint部分。约束条件是应当继续遵守第十二条的相关规定。假设第十二条的规定可能包括在减持后的六个月内不得减持，或者需要满足某些披露要求。例如，假设约束条件是在减持后的六个月内不得减持，因此需要检查该期间内是否有减持行为。

因此，对于每个触发点（导致身份变化的协议转让日期），在触发点之后的六个月内，如果该股东有减持行为（当日减持比例>0），则constraint为False，否则为True。

但如何实现这一点呢？可能需要按分组处理，找到触发点，然后检查该期间内的减持行为。

例如，在check_condition函数中，同时记录触发点，然后在每个触发点的六个月内，检查是否有减持行为。

或者，在标记condition的同时，检查该期间内的减持行为，并标记constraint。

例如，在check_condition函数中，当标记condition为True时，同时检查该行是否有减持行为（当日减持比例>0），如果有，则constraint为False，否则为True。

但这样可能不准确，因为约束条件可能要求在整个六个月内都没有减持行为，而不仅仅是当天的减持。

例如，如果在触发点后的六个月内，任何一天有减持行为，则该期间的constraint都为False。

因此，可能需要对于每个触发点，检查该期间内是否存在减持行为，如果存在，则整个期间的constraint为False，否则为True。

这可能需要在分组处理中，对于每个触发点，检查该期间内的所有行是否有当日减持比例>0的情况。

例如，在check_condition函数中，当处理触发点时，检查该期间内的所有行是否有减持行为：

def check_condition_and_constraint(group):
    group['meu_13_3_condition'] = False
    group['meu_13_3_constraint'] = None  # 初始化为None
    protocol_mask = (group['减持方式'] == '协议转让') & (group['股东身份'].isin(['控股股东', '实际控制人']))
    protocol_dates = group.loc[protocol_mask, '日期'].tolist()
    for date in protocol_dates:
        subsequent = group[group['日期'] > date]
        if not subsequent.empty:
            first_subsequent = subsequent.iloc[0]
            if first_subsequent['股东身份'] not in ['控股股东', '实际控制人']:
                start = date
                end = date + pd.DateOffset(months=6)
                # 标记condition为True
                mask_condition = (group['日期'] >= start) & (group['日期'] <= end)
                group.loc[mask_condition, 'meu_13_3_condition'] = True
                # 检查该期间内是否有减持行为
                mask_constraint = mask_condition & (group['当日减持比例'] > 0)
                if mask_constraint.any():
                    # 如果有减持行为，整个期间的constraint为False
                    group.loc[mask_condition, 'meu_13_3_constraint'] = False
                else:
                    group.loc[mask_condition, 'meu_13_3_constraint'] = True
    return group

这可能是一个可行的方法，但需要注意，如果在触发点的六个月内存在任何减持行为，则整个期间的constraint都被标记为False，否则为True。

但这样处理可能不够精确，因为约束条件可能要求在整个期间内都遵守，而不仅仅是某一天。例如，如果某一天有减持，则违反约束条件，因此该期间的constraint为False。

因此，在触发点的六个月内，只要存在任何减持行为，该期间的constraint都为False，否则为True。

因此，在代码中，对于每个触发点的六个月内，检查是否存在当日减持比例>0的行。如果存在，则标记该期间的所有行的constraint为False，否则为True。

这可能是一个合理的方法，尽管可能有些粗糙，但根据现有数据，可能只能这样处理。

最后，将subject、condition、constraint的标记结果写入dataframe。

总结整个函数的步骤：

1. 初始化三个列：meu_13_3_subject、meu_13_3_condition、meu_13_3_constraint。
2. 标记subject：股东身份是控股股东或实际控制人。
3. 分组处理每个公司和股东，找到触发点（协议转让导致身份变化的日期），并标记condition为True的期间。
4. 在标记condition的同时，检查该期间内是否有减持行为，并标记constraint为False或True。
5. 返回处理后的dataframe。

现在，将这些步骤转化为代码：

首先，初始化列：

df['meu_13_3_subject'] = df['股东身份'].isin(['控股股东', '实际控制人'])
df['meu_13_3_condition'] = False
df['meu_13_3_constraint'] = None  # 初始化为None，后续根据条件填充

然后，分组处理：

def check_meu_13_3_group(group):
    # 获取所有协议转让且subject为True的行
    protocol_mask = (group['减持方式'] == '协议转让') & (group['meu_13_3_subject'])
    protocol_dates = group.loc[protocol_mask, '日期'].tolist()
    
    for date in protocol_dates:
        # 找到该日期之后的行
        subsequent = group[group['日期'] > date]
        if not subsequent.empty:
            # 检查后续第一个行是否身份变化
            first_subsequent = subsequent.iloc[0]
            if not first_subsequent['meu_13_3_subject']:
                # 触发点date，计算六个月后的日期
                end_date = date + pd.DateOffset(months=6)
                # 确定时间窗口
                time_window = (group['日期'] >= date) & (group['日期'] <= end_date)
                # 标记condition为True
                group.loc[time_window, 'meu_13_3_condition'] = True
                # 检查该窗口内是否有减持行为
                has_dissolution = (group.loc[time_window, '当日减持比例'] > 0).any()
                # 标记constraint
                if has_dissolution:
                    group.loc[time_window, 'meu_13_3_constraint'] = False
                else:
                    group.loc[time_window, 'meu_13_3_constraint'] = True
    return group

df = df.groupby(['公司简称', '股东'], group_keys=False).apply(check_meu_13_3_group)

最后，将constraint列中未被处理的行的值设为False，或者保持原样。但根据代码逻辑，未被触发的行的constraint可能仍为None，需要处理。例如，对于不满足condition的行，constraint可能不需要检查，但根据任务要求，三个条件的检查是独立的，所以需要为所有行标记constraint是否满足，不管subject和condition是否满足。但根据MEU的约束条件，可能只有在subject和condition都满足时才需要检查constraint。但根据用户的要求，对于不需要调用llm_content_check()的情况，三个条件的检查是独立的。因此，可能需要独立检查constraint，不管subject和condition是否满足。

但根据MEU的约束条件，约束条件可能只有在subject和condition都满足时才适用。因此，在示例中，约束条件的检查是独立的，但可能在实际中，约束条件的检查需要结合其他条件。但根据用户的要求，对于简单操作dataframe的情况，三个条件的检查是独立的。因此，可能需要独立检查constraint，不管subject和condition是否满足。

但在这个MEU的情况下，约束条件可能只有在subject和condition都满足时才需要遵守。因此，正确的做法是，只有当subject和condition都满足时，才检查constraint。但根据用户的要求，对于不需要调用llm_content_check()的情况，三个条件的检查是独立的。因此，可能需要独立检查constraint，不管其他条件是否满足。

但根据示例中的处理，约束条件的检查是独立的，例如，在示例中，valid_constraint是根据交易日差和存在减持计划来判断的，而不管subject和condition是否满足。因此，可能需要在此任务中，同样独立检查constraint。

但在这个MEU的情况下，约束条件可能只有在subject和condition都满足时才适用。因此，正确的做法是，只有当subject和condition都满足时，才需要检查constraint。但根据用户的要求，对于简单操作dataframe的情况，三个条件的检查是独立的。因此，可能需要独立检查constraint，不管其他条件是否满足。

这可能导致矛盾，但根据用户提供的示例，约束条件的检查是独立进行的，因此可能需要在此任务中同样处理。

例如，约束条件可能涉及其他行为，如是否提前公告，因此需要检查所有行是否满足该条件，不管subject和condition是否满足。但在这个MEU的情况下，约束条件可能只有在subject和condition都满足时才适用，因此可能需要仅在满足subject和condition的行中检查constraint。但根据用户的要求，对于不需要调用llm_content_check()的情况，三个条件的检查是独立的，因此需要分别标记每个条件是否满足，不管其他条件是否满足。

这可能需要重新审视用户的任务要求：

用户的任务要求中说明：

“对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)”

因此，对于当前任务，三个条件的检查是各自独立的，即不管其他条件是否满足，都要检查每个条件是否满足。因此，在标记constraint时，需要独立检查，不管subject和condition是否满足。

但在这个MEU的情况下，约束条件“应当继续遵守本指引第十二条第一款第二、三项规定”可能只有在subject和condition都满足时才适用。因此，正确的逻辑是，只有当subject和condition都满足时，才需要检查constraint。但根据用户的任务要求，对于简单操作dataframe的情况，三个条件的检查是独立的，因此需要分别标记每个条件是否满足，不管其他条件是否满足。

这可能导致标记错误，但必须按照用户的要求处理。

因此，可能需要重新考虑约束条件的检查方式，即独立于subject和condition。

例如，约束条件可能要求所有股东在减持后的六个月内遵守某些规定，不管他们是否是控股股东或实际控制人，或者是否通过协议转让减持。因此，需要独立检查所有行是否满足约束条件。

但根据MEU的描述，约束条件仅在subject和condition满足时才适用。因此，这可能与用户的任务要求相矛盾。但根据用户的要求，必须按照独立检查的方式处理。

因此，可能需要将约束条件的检查独立处理，例如，检查所有减持后的六个月内是否遵守了规定，不管subject和condition是否满足。

但如何实现这一点呢？可能需要重新分析约束条件。

例如，约束条件可能要求所有股东在减持后的六个月内遵守某些规定，不管他们的身份或减持方式。因此，需要检查所有减持行为后的六个月内是否满足约束条件。

但根据MEU的描述，约束条件仅在subject和condition满足时才适用。因此，这可能无法独立检查，但根据用户的任务要求，必须独立检查。

这可能意味着，当前任务中的约束条件无法正确检查，但必须按照用户的要求编写代码。

因此，可能需要重新审视约束条件的检查方式，假设约束条件独立于subject和condition，例如，检查所有股东在减持后的六个月内是否遵守了某些规定，不管他们的身份或减持方式。

例如，假设约束条件要求所有股东在减持后的六个月内不得减持，因此需要检查每个减持日期后的六个月内是否有减持行为。这可能与MEU的约束条件无关，但根据用户的要求，必须独立检查。

但根据MEU的约束条件，可能无法这样处理。因此，可能需要重新考虑。

可能用户的任务中存在矛盾，但必须按照用户的要求处理。因此，可能需要将约束条件的检查独立于subject和condition，例如，检查所有行是否满足某些条件，如减持后的六个月内没有减持行为。

例如，对于每个行，如果该行是减持行为（当日减持比例>0），则检查该日期之后的六个月内是否有其他减持行为。如果有，则约束条件不满足。但这可能不符合MEU的约束条件，但根据用户的要求，必须独立检查。

这可能非常复杂，但根据用户提供的示例，可能约束条件的检查是独立进行的，例如，在示例中，检查是否存在减持计划以及交易日差是否足够。

因此，可能需要在此任务中，独立检查约束条件，例如，检查减持后的六个月内是否遵守了某些规定，不管subject和condition是否满足。

例如，假设约束条件要求减持后的六个月内不得减持，因此需要检查每个减持日期后的六个月内是否有减持行为。这可能与MEU的约束条件无关，但根据用户的要求，必须独立处理。

但如何实现这一点呢？可能需要按股东和公司分组，找到每个减持日期，然后标记该日期之后的六个月内所有行的constraint为False，如果存在减持行为。

这可能非常复杂，但根据用户的要求，必须编写代码。

但考虑到时间和复杂度，可能需要简化处理。例如，对于每个行，如果该行是减持行为（当日减持比例>0），则检查该日期之后的六个月内是否有其他减持行为。如果有，则约束条件不满足。

但这可能无法在dataframe中高效实现，可能需要使用滚动窗口或分组处理。

但根据用户提供的示例，可能约束条件的检查是基于当前行的某些列，例如，在示例中，valid_constraint是基于计划开始日和计划披露日的差值。因此，可能需要在此任务中，找到与约束条件相关的列，并独立检查。

例如，假设约束条件要求减持后的六个月内不得减持，因此需要检查该股东在减持后的六个月内是否有减持行为。这可能涉及到：

对于每个行，如果该行是减持行为（当日减持比例>0），则检查该股东在该日期之后的六个月内是否有其他减持行为。如果有，则约束条件不满足。

但如何标记所有行的constraint呢？这可能非常复杂，因为每个减持行为都可能影响后续六个月的constraint。

但根据用户的任务要求，可能需要独立检查每个行是否满足约束条件，不管其他条件如何。因此，可能需要将约束条件的检查留空，或者无法处理，但根据示例，必须编写代码。

因此，可能需要重新考虑，假设约束条件的检查与subject和condition无关，例如，检查所有股东在减持后的六个月内是否没有减持行为。这可能与MEU的约束条件无关，但必须编写代码。

例如，对于每个行，如果该股东在过去的六个月内有过减持行为，则约束条件不满足。但这可能不符合MEU的约束条件，但根据用户的要求，必须独立检查。

这可能无法正确反映MEU的要求，但根据用户的任务要求，必须编写代码。

综上所述，可能无法正确实现约束条件的检查，但必须按照用户的要求编写代码。因此，可能需要假设约束条件的检查是独立进行的，例如，检查所有股东在减持后的六个月内是否没有减持行为，不管他们的身份或减持方式。

例如，对于每个行，如果该行是减持行为（当日减持比例>0），则检查该日期之后的六个月内是否有其他减持行为。如果有，则约束条件不满足。

但如何实现这一点呢？可能需要按股东和公司分组，然后对于每个减持日期，标记该日期之后的六个月内所有行的constraint为False。

这可能是一个可行的方法，但需要分组处理：

def check_constraint(group):
    group['meu_13_3_constraint'] = True  # 初始化为True
    # 找到所有减持行为的日期
    dissolution_dates = group[group['当日减持比例'] > 0]['日期']
    for date in dissolution_dates:
        # 计算六个月后的日期
        end_date = date + pd.DateOffset(months=6)
        # 标记该期间内的行constraint为False
        mask = (group['日期'] > date) & (group['日期'] <= end_date)
        group.loc[mask, 'meu_13_3_constraint'] = False
    return group

df = df.groupby(['公司简称', '股东'], group_keys=False).apply(check_constraint)

这可能是一个独立于subject和condition的约束条件检查，即所有股东在减持后的六个月内不得减持，如果有，则constraint为False。

但这样处理可能不符合MEU的约束条件，但根据用户的要求，必须独立检查。

因此，最终的代码可能如下：

import pandas as pd

def check_meu_13_3(df):
    '''
    检查MEU_13_3的合规性：
    subject: 控股股东 | 实际控制人
    condition: 通过协议转让减持导致失去身份，且在减持后的6个月内
    constraint: 继续遵守第十二条相关规定（假设检查减持后的六个月内是否有减持行为）
    '''
    df = df.copy()
    
    # 初始化标记列
    df['meu_13_3_subject'] = df['股东身份'].isin(['控股股东', '实际控制人'])
    df['meu_13_3_condition'] = False
    df['meu_13_3_constraint'] = True  # 初始假设为True
    
    # 处理condition和constraint
    # 分组处理每个公司和股东
    def process_group(group):
        # 找到所有协议转让且subject为True的行
        protocol_mask = (group['减持方式'] == '协议转让') & (group['meu_13_3_subject'])
        protocol_dates = group.loc[protocol_mask, '日期'].tolist()
        
        # 检查每个协议转让日期是否导致身份变化
        for date in protocol_dates:
            # 找到该日期之后的行
            subsequent = group[group['日期'] > date]
            if not subsequent.empty:
                # 检查后续第一个行是否身份变化
                first_subsequent = subsequent.iloc[0]
                if not first_subsequent['meu_13_3_subject']:
                    # 触发点date，计算六个月后的日期
                    end_date = date + pd.DateOffset(months=6)
                    # 标记condition为True
                    condition_mask = (group['日期'] >= date) & (group['日期'] <= end_date)
                    group.loc[condition_mask, 'meu_13_3_condition'] = True
        
        # 独立处理constraint：检查所有减持后的六个月内是否有减持行为
        dissolution_dates = group[group['当日减持比例'] > 0]['日期']
        for date in dissolution_dates:
            end_date = date + pd.DateOffset(months=6)
            constraint_mask = (group['日期'] > date) & (group['日期'] <= end_date)
            group.loc[constraint_mask, 'meu_13_3_constraint'] = False
        
        return group
    
    df = df.groupby(['公司简称', '股东'], group_keys=False).apply(process_group)
    
    return df
","CompletionUsage(completion_tokens=9385, prompt_tokens=1723, total_tokens=11108, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=8838, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_12_1
法律的最小可执行单元内容: {""subject"": ""公开发行股票并上市时的控股股东 | 公开发行股票并上市时的实际控制人"", ""condition"": ""计划通过集中竞价交易或大宗交易减持股份且首次披露减持计划, 且不存在已经按照本指引第四条披露减持计划，或者中国证监会另有规定的情况的"", ""constraint"": ""不得存在下列情形：最近20个交易日内任一交易日股票收盘价低于公开发行股票并上市的发行价格"", ""contextual_info"": ""股票收盘价以公开发行股票并上市之日为基准向后复权计算""}
必要的额外信息: 不考虑中国证监会另有规定的情况


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_12_1(df):
    '''
    检查MEU_12_1合规性：
    subject: 公开发行股票并上市时的控股股东 | 实际控制人
    condition: 计划通过集中竞价或大宗交易减持股份且首次披露减持计划
    constraint: 最近20个交易日内任一交易日复权收盘价不低于发行价
    contextual_info: 复权计算以发行日为准
    '''
    df = df.copy()

    # 初始化标记列
    df['meu_12_1_subject'] = False
    df['meu_12_1_condition'] = False
    df['meu_12_1_constraint'] = None

    # 处理subject部分
    # 获取各公司上市日期（首个非空收盘价日期）
    def get_ipo_date(group):
        valid_dates = group[group['收盘价'].notna()]['日期']
        return valid_dates.min() if not valid_dates.empty else pd.NaT
    company_ipo_dates = df.groupby('公司简称').apply(get_ipo_date).reset_index(name='公司上市日期')
    
    # 合并上市日期并筛选上市当日股东身份
    df = df.merge(company_ipo_dates, on='公司简称', how='left')
    ipo_day_mask = (df['日期'] == df['公司上市日期']) & df['股东身份'].isin(['控股股东', '实际控制人'])
    valid_subjects = df[ipo_day_mask][['公司简称', '股东']].drop_duplicates()
    
    # 标记subject合规
    df['meu_12_1_subject'] = df.apply(
        lambda x: (x['公司简称'], x['股东']) in valid_subjects.values, 
        axis=1
    )

    # 处理condition部分
    # 获取首次减持计划披露日
    has_plan = df[df['存在减持计划']]
    first_disclosure = has_plan.groupby(['公司简称', '股东'])['日期'].min().reset_index(name='首次披露日')
    
    # 合并首次披露日并验证条件
    df = df.merge(first_disclosure, on=['公司简称', '股东'], how='left')
    valid_condition = (
        df['减持方式'].isin(['竞价交易', '大宗交易']) & 
        df['存在减持计划'] & 
        (df['日期'] == df['首次披露日'])
    )
    df['meu_12_1_condition'] = valid_condition

    # 处理constraint部分
    # 计算复权价格并标记价格违规
    df['复权收盘价'] = df['收盘价'] * df['复权因子']
    df['价格违规'] = df['复权收盘价'] < df['发行价格']
    
    # 按公司滚动检查20日窗口
    def check_price_violation(group):
        group = group.sort_values('日期')
        group['20日违规标记'] = group['价格违规'].rolling(20, min_periods=1).apply(any, raw=True)
        return group
    
    df = df.groupby('公司简称', group_keys=False).apply(check_price_violation)
    df['meu_12_1_constraint'] = ~df['20日违规标记']

    # 清理中间列
    df.drop([
        '公司上市日期', '首次披露日', 
        '复权收盘价', '价格违规', '20日违规标记'
    ], axis=1, errors='ignore', inplace=True)

    return df
</CODE>","好的，我现在需要处理这个MEU_12_1的合规检查问题。首先，我得仔细理解这个MEU的具体内容。根据提供的JSON，MEU_12_1的subject是公开发行股票并上市时的控股股东或实际控制人。condition是计划通过集中竞价或大宗交易减持股份，并且是首次披露减持计划，同时不存在已经按照第四条披露的情况，或者证监会另有规定的情况。不过根据额外信息，这里可以忽略证监会的情况。constraint是最近20个交易日内任一交易日的收盘价不能低于发行价，且收盘价要复权计算。

接下来，我需要根据这些条件来编写对应的代码。首先，处理subject部分。根据附加信息，公司上市时的控股股东或实际控制人是指上市当天的股东身份。所以，我需要确定每个股东在上市时是否是控股股东或实际控制人。这里可能需要按公司和股东分组，检查他们在上市当天的身份。

然后是condition部分。减持方式必须是集中竞价或大宗交易，并且是首次披露减持计划。这里需要检查减持方式是否符合，同时是否存在减持计划，并且是否是首次披露。首次披露可能需要按股东和公司分组，找到每个减持计划的首次披露日，然后判断当前行是否是该首次披露日。

constraint部分需要检查最近20个交易日内是否有收盘价低于发行价。这里需要注意的是，收盘价需要复权计算，以公开发行日后的复权因子调整。可能需要计算复权后的价格，并与发行价比较。同时，这个检查是针对每个交易日，检查前20个交易日内是否有任何一天满足条件。

现在，我需要考虑如何将这些逻辑转化为代码。首先，处理subject：

1. 确定每个公司的上市日期，即发行日期。根据附加信息，发行价格是公司最早的非空收盘价对应的日期。所以，对于每个公司，找到其上市日期（即第一个非空的收盘价日期）。
2. 对于每个股东，检查他们在该上市日期是否是控股股东或实际控制人。这可能需要分组处理，每个公司每个股东在上市当天的身份是否为控股股东或实际控制人。如果该股东在上市当天是这两个身份之一，则他们在后续的所有交易日都属于subject有效的情况。

接下来处理condition：

1. 减持方式必须是竞价交易或大宗交易。
2. 存在减持计划，并且是首次披露。首次披露需要按股东和公司分组，找到每个减持计划的首次披露日。如果当前行的日期是该股东和公司的首次披露日，并且减持方式正确，则condition为真。

对于constraint：

1. 对于每个交易日，检查该股东所在公司的最近20个交易日内是否有收盘价（复权后的）低于发行价。需要计算复权后的收盘价，即收盘价乘以复权因子，然后与发行价比较。如果存在任一交易日满足，则constraint不满足，即标记为False。

现在，具体步骤：

首先，处理subject：

- 确定每个公司的上市日期。可以通过groupby公司，然后找到每个公司的最早非空收盘价的日期。
- 对于每个股东，在该上市日期时的身份是否是控股股东或实际控制人。需要将每个股东在该日期的身份提取出来，并判断是否为subject。例如，对于每个公司，找到上市日期，然后在该日期下，该股东的身份是否为控股股东或实际控制人。如果是，则之后的所有交易日该股东的subject标记为True。

然后，处理condition：

- 减持方式是否是竞价或大宗交易。
- 存在减持计划为True。
- 是否是首次披露。这需要按公司和股东分组，找到每个减持计划的首次披露日。例如，对于每个公司和股东，找到存在减持计划为True的最早日期，即计划披露日的最小值。如果当前行的日期等于该首次披露日，并且减持方式正确，则condition为True。

最后，处理constraint：

- 对于每个交易日，检查该公司的最近20个交易日内是否有收盘价（复权后的）低于发行价。需要计算复权后的价格，即收盘价 * 复权因子。然后比较复权后的价格是否低于发行价。如果存在任一交易日满足，则constraint为False，否则为True。注意，这里需要按公司分组，每个交易日检查前20个交易日的窗口。

但这里可能有个问题：复权因子如何处理？根据contextual_info，收盘价以公开发行日后的复权因子计算。可能需要将复权因子应用到每个交易日，得到复权后的价格。例如，复权后的收盘价 = 收盘价 * 复权因子。然后比较复权后的价格是否低于发行价。

另外，发行价是每个公司的发行价格，可能存储在发行价格列中。每个公司的发行价格应该是在上市当天的发行价格，所以可以按公司分组，取发行价格列中的第一个非空值作为发行价。

现在，代码步骤：

1. 处理subject：

   a. 对每个公司，找到上市日期（即第一个非空收盘价的日期）。
   
   b. 对每个股东，在该上市日期时的身份是否为控股股东或实际控制人。
   
   c. 如果该股东在上市日期是这两个身份之一，则其所有行的subject标记为True。

2. 处理condition：

   a. 减持方式是否是竞价或大宗交易。
   
   b. 存在减持计划为True。
   
   c. 是否是首次披露减持计划。这需要按公司和股东分组，找到每个减持计划的首次披露日。例如，对于每个公司和股东，找到存在减持计划为True的最早日期。如果当前行的日期等于该日期，并且减持方式正确，则condition为True。

3. 处理constraint：

   a. 对每个公司的每个交易日，计算复权后的收盘价（收盘价 * 复权因子）。
   
   b. 比较复权后的收盘价是否低于发行价。
   
   c. 对于每个交易日，检查前20个交易日内是否有任一交易日的复权收盘价低于发行价。如果有，则constraint为False，否则为True。
   
   d. 注意，这里需要按公司分组，每个交易日计算窗口内的结果。

现在，将这些步骤转化为代码：

首先，处理subject：

需要为每个公司找到上市日期，然后在该日期下，每个股东的身份是否为控股股东或实际控制人。然后，将这些股东的所有行的subject标记为True。

例如：

- 按公司分组，找到每个公司的上市日期（即第一个收盘价非空的日期）。
- 对于每个公司，在上市日期时，筛选出股东身份为控股股东或实际控制人的股东。
- 这些股东在所有日期中的行，其subject标记为True。

代码实现：

# 找到每个公司的上市日期（第一个收盘价非空的日期）
df['上市日期'] = df.groupby('公司简称')['收盘价'].transform(lambda x: x.first_valid_index().date() if x.first_valid_index() is not None else None)
# 或者更准确的方式：
# 按公司分组，找到每个公司的最早非空收盘价的日期
company_ipo_date = df.groupby('公司简称')['收盘价'].apply(lambda x: x.dropna().index.min())
# 然后，将每个公司的上市日期合并到原df中
df = df.merge(company_ipo_date.rename('公司上市日期'), on='公司简称', how='left')

# 然后，筛选出每个股东在各自公司上市日期当天的身份
# 需要按公司和股东分组，找到该股东在公司上市日期当天的记录
# 这可能比较复杂，因为原数据是按日期、公司、股东组织的。可能需要创建一个临时DataFrame，其中每个公司、股东的组合，在上市日期当天的记录。

# 例如：
# 创建一个多索引，包含公司简称、股东和日期
# 但可能更有效的方法是，对于每个公司，找到其上市日期，然后对于每个股东，在该日期下的记录中的股东身份是否为控股股东或实际控制人。

# 可能需要使用merge来获取每个公司的上市日期，然后筛选出该日期下的股东身份。

# 步骤：
# 1. 获取每个公司的上市日期
company_ipo_dates = df.groupby('公司简称')['收盘价'].apply(lambda x: x.first_valid_index()).reset_index()
company_ipo_dates.columns = ['公司简称', '公司上市日期']

# 2. 将公司上市日期合并到原df中
df = df.merge(company_ipo_dates, on='公司简称', how='left')

# 3. 筛选出每个股东在公司上市日期当天的记录
# 这里需要将日期转换为日期类型，可能原数据中的日期已经是datetime类型，所以比较时需要注意类型一致。
# 创建临时df，仅包含公司上市日期当天的数据
temp_subject = df[df['日期'] == df['公司上市日期']]

# 4. 对于这些记录，判断股东身份是否是控股股东或实际控制人
valid_subject_mask = temp_subject['股东身份'].isin(['控股股东', '实际控制人'])

# 5. 获取这些符合条件的股东列表（公司简称和股东）
valid_subjects = temp_subject[valid_subject_mask][['公司简称', '股东']].drop_duplicates()

# 6. 在原df中标记这些股东的所有记录的subject为True
df['meu_12_1_subject'] = df.apply(lambda row: (row['公司简称'], row['股东']) in valid_subjects[['公司简称', '股东']].itertuples(index=False, name=None)), axis=1)

这可能是一个方法。但需要注意，如果原数据中没有该股东在公司上市日期的记录，那么可能无法正确标记。但根据数据描述，数据是日频的面板数据，所以每个公司上市当天的股东记录应该存在？

或者，可能每个股东在上市当天的记录可能不存在，比如某些股东可能在之后才成为股东。但根据附加信息中的说明，“持股比例全部是公开上市前取得的股份”，所以可能股东在上市时就已经存在。因此，每个股东在上市当天的记录应该存在。

接下来处理condition：

condition的条件是：减持方式是集中竞价或大宗交易，存在减持计划，并且是首次披露减持计划。

首先，减持方式是否正确：

valid_condition_method = df['减持方式'].isin(['竞价交易', '大宗交易'])

存在减持计划：

valid_condition_plan = df['存在减持计划'] == True

首次披露：对于每个公司和股东，找到其首次披露减持计划的日期。即，对于每个公司和股东，存在减持计划为True的最早日期。如果当前行的日期等于该日期，则视为首次披露。

因此，需要按公司和股东分组，找到每个组的首次披露日：

首次披露日 = df[df['存在减持计划']].groupby(['公司简称', '股东'])['日期'].min().reset_index()
首次披露日.columns = ['公司简称', '股东', '首次披露日']

然后，将首次披露日合并到原df中：

df = df.merge(首次披露日, on=['公司简称', '股东'], how='left')

然后，判断当前行的日期是否等于首次披露日，并且减持方式正确，存在减持计划：

valid_condition = (
    (df['日期'] == df['首次披露日']) &
    valid_condition_method &
    valid_condition_plan
)

但需要注意，如果首次披露日不存在（即该股东从未有减持计划），则这部分条件为False。

因此，condition的标记为：

df['meu_12_1_condition'] = valid_condition

最后处理constraint：

constraint是最近20个交易日内任一交易日的收盘价（复权后）低于发行价。需要按公司分组，每个交易日检查前20个交易日的窗口。

首先，计算复权后的收盘价：

复权后的收盘价 = 收盘价 * 复权因子

然后，比较复权后的收盘价是否低于发行价。发行价是每个公司的发行价格，可能存储在发行价格列中。根据附加信息，发行价格是公司上市当天的发行价格，即每个公司的发行价格列中的第一个非空值？

或者，根据附加信息中的说明：“公司上市发行价就是最早的非空的收盘价”，所以发行价格可能等于上市当天的收盘价。或者，可能发行价格列已经正确存储了发行价。需要确认。

根据附加信息中的“发行价格”列的描述，假设该列已经正确存储了每个公司的发行价格。因此，每个公司的发行价是固定的，即该公司的发行价格列中的值（可能每个公司的发行价格是相同的，或者可能有变化？但根据问题描述，可能每个公司的发行价格是上市时的价格，所以每个公司的发行价格列中的值应该是同一值）。

因此，复权后的收盘价 = 收盘价 * 复权因子。然后比较复权后的收盘价是否小于发行价。

接下来，对于每个公司的每个交易日，检查前20个交易日内是否有任一交易日的复权收盘价低于发行价。

这需要按公司分组，然后对每个交易日，计算窗口内的最小值，或者是否存在满足条件的交易日。

例如，对于每个公司，按日期排序，然后计算每个交易日的前20个交易日的窗口，检查其中是否有复权收盘价 < 发行价。

这可以通过rolling窗口实现，但需要注意交易日可能不连续，所以需要确保窗口是自然日的20个交易日。或者，因为数据中的日期已经是交易日，所以每个日期都是连续的交易日，所以窗口可以直接用20行。

但实际情况中，数据可能包含非连续的日期，比如节假日。因此，正确的做法是按时间序列排序，然后对于每个日期，找到前20个交易日内的数据。

这可能比较复杂，但根据问题描述，输入的dataframe的日期列已经是交易日，所以每个日期都是连续的。或者，可能数据中的日期是自然日，但需要处理为交易日。但根据附加信息中的说明：“所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日”，所以数据中的日期是连续的交易日，没有间隔。

因此，可以按公司分组，然后对每个公司按日期排序，使用rolling窗口，窗口大小为20，min_periods=1，然后检查每个窗口内是否有复权收盘价 < 发行价。

但rolling窗口是基于行数的，而不是时间差。因此，假设数据已经按日期排序，每个公司的数据按日期升序排列，那么对于每个行，前20行即为前20个交易日的数据。

但需要注意，每个公司可能有不同的日期范围，所以必须按公司分组处理。

具体步骤：

1. 对每个公司，按日期排序。
2. 计算复权后的收盘价：df['复权收盘价'] = df['收盘价'] * df['复权因子']
3. 比较复权收盘价是否低于发行价：df['是否低于发行价'] = df['复权收盘价'] < df['发行价格']
4. 对每个公司，按日期排序后，计算每个行的前20个交易日内是否有至少一个True的“是否低于发行价”。
5. 如果有，则constraint不满足，标记为False；否则为True。

代码实现：

# 按公司分组，处理每个公司的数据
def check_constraint(group):
    # 按日期排序
    group = group.sort_values('日期')
    # 计算复权收盘价
    group['复权收盘价'] = group['收盘价'] * group['复权因子']
    # 是否低于发行价
    group['是否低于发行价'] = group['复权收盘价'] < group['发行价格']
    # 计算过去20个交易日内是否有任一True
    # 使用rolling窗口，window=20，min_periods=1，然后any()
    group['最近20日有低于发行价'] = group['是否低于发行价'].rolling(window=20, min_periods=1).apply(lambda x: x.any(), raw=True)
    # 如果最近20日有低于发行价，则constraint不满足，即False
    group['meu_12_1_constraint'] = ~group['最近20日有低于发行价']
    return group

# 应用分组处理
df = df.groupby('公司简称', group_keys=False).apply(check_constraint)

但这样处理可能会比较耗时，特别是数据量大的时候。但根据问题描述，这是可行的。

最后，将这三个条件的标记合并到dataframe中。

现在，综合所有步骤，编写代码：

注意，在代码中需要初始化三个列：meu_12_1_subject, meu_12_1_condition, meu_12_1_constraint，并分别标记True或False。

现在，将所有步骤整合到函数中：

import pandas as pd

def check_meu_12_1(df):
    '''
    检查MEU_12_1的合规性：
    subject: 公开发行股票并上市时的控股股东 | 实际控制人
    condition: 计划通过集中竞价或大宗交易减持股份且首次披露减持计划，且不存在已披露的情况
    constraint: 最近20个交易日内任一交易日复权收盘价不低于发行价
    contextual_info: 复权计算以发行日为准
    '''
    df = df.copy()

    # 初始化标记列
    df['meu_12_1_subject'] = False
    df['meu_12_1_condition'] = False
    df['meu_12_1_constraint'] = None  # 先初始化为None，后续填充布尔值

    # 处理subject
    # 步骤1：找到每个公司的上市日期（第一个收盘价非空的日期）
    company_ipo_dates = df.groupby('公司简称')['收盘价'].apply(lambda x: x.first_valid_index())
    company_ipo_dates = company_ipo_dates.reset_index()
    company_ipo_dates.columns = ['公司简称', '公司上市日期']

    # 将上市日期合并到原df
    df = df.merge(company_ipo_dates, on='公司简称', how='left')

    # 步骤2：筛选出每个公司上市日期当天的股东身份为控股股东或实际控制人的记录
    # 创建临时df，仅包含上市日期的数据
    mask_ipo_date = df['日期'] == df['公司上市日期']
    temp_subject = df[mask_ipo_date].copy()
    valid_subjects = temp_subject[temp_subject['股东身份'].isin(['控股股东', '实际控制人'])][['公司简称', '股东']].drop_duplicates()

    # 标记subject为True的条件：公司和股东在valid_subjects中
    df['meu_12_1_subject'] = df.apply(
        lambda row: (row['公司简称'], row['股东']) in valid_subjects[['公司简称', '股东']].itertuples(index=False, name=None),
        axis=1
    )

    # 处理condition
    # 条件1：减持方式为竞价交易或大宗交易
    valid_method = df['减持方式'].isin(['竞价交易', '大宗交易'])
    # 条件2：存在减持计划
    valid_plan = df['存在减持计划']
    # 条件3：首次披露减持计划
    # 找到每个公司和股东的首次披露日
    first_disclosure = df[df['存在减持计划']].groupby(['公司简称', '股东'])['日期'].min().reset_index()
    first_disclosure.rename(columns={'日期': '首次披露日'}, inplace=True)
    # 合并到原df
    df = df.merge(first_disclosure, on=['公司简称', '股东'], how='left')
    # 判断当前日期是否为首次披露日
    valid_first = df['日期'] == df['首次披露日']
    # 综合条件
    df['meu_12_1_condition'] = valid_method & valid_plan & valid_first

    # 处理constraint
    # 步骤：计算每个公司每个交易日的最近20个交易日内是否有复权收盘价低于发行价
    # 先计算复权收盘价
    df['复权收盘价'] = df['收盘价'] * df['复权因子']
    # 比较是否低于发行价
    df['是否低于发行价'] = df['复权收盘价'] < df['发行价格']

    # 按公司分组，计算每个行的最近20个交易日内是否有任一低于发行价
    def check_constraint(group):
        group = group.sort_values('日期')
        # 使用rolling窗口，window=20，min_periods=1，计算any()
        group['最近20日有低于'] = group['是否低于发行价'].rolling(window=20, min_periods=1).apply(lambda x: x.any(), raw=True)
        group['meu_12_1_constraint'] = ~group['最近20日有低于']
        return group

    df = df.groupby('公司简称', group_keys=False).apply(check_constraint)

    # 清理临时列
    df.drop(columns=['公司上市日期', '首次披露日', '复权收盘价', '是否低于发行价', '最近20日有低于'], inplace=True, errors='ignore')

    return df

但可能需要注意以下几点：

1. 在计算公司上市日期时，df.groupby('公司简称')['收盘价'].apply(lambda x: x.first_valid_index())可能返回的是索引，而不是日期。因为如果原df的索引是日期的话，但原df的索引可能不是日期。例如，原df的日期列是普通的列，所以x.first_valid_index()可能返回的是该公司的第一个非空收盘价的行索引，而不是日期值。这会导致错误。

因此，正确的做法应该是找到每个公司的最早非空收盘价的日期。例如：

company_ipo_dates = df.groupby('公司简称')['日期'].min()

或者，更准确的是，找到每个公司的最早非空收盘价的日期：

def get_ipo_date(group):
    valid = group['收盘价'].notna()
    if valid.any():
        return group.loc[valid, '日期'].min()
    else:
        return pd.NaT

company_ipo_dates = df.groupby('公司简称').apply(get_ipo_date).reset_index()
company_ipo_dates.columns = ['公司简称', '公司上市日期']

这样，company_ipo_dates中的公司上市日期是每个公司的最早非空收盘价的日期。

然后，在合并到原df后，mask_ipo_date应该是df['日期'] == df['公司上市日期']，这样就能筛选出每个公司上市当天的记录。

另外，在计算valid_subjects时，需要确保在上市当天的记录中，股东身份是控股股东或实际控制人。

接下来，在标记subject时，使用apply可能会比较慢，可以考虑使用merge来标记。例如，将valid_subjects添加一个标记列，然后与原df合并：

valid_subjects['valid_subject'] = True
df = df.merge(valid_subjects, on=['公司简称', '股东'], how='left')
df['meu_12_1_subject'] = df['valid_subject'].fillna(False)
df.drop(columns='valid_subject', inplace=True)

这可能更高效。

对于condition部分，合并首次披露日后，判断当前日期是否等于首次披露日，并且减持方式正确，存在减持计划。

对于constraint部分，按公司分组，计算每个交易日的前20个交易日的窗口，是否有任何复权收盘价低于发行价。这里需要注意，rolling的窗口是基于行数的，所以必须确保每个公司的数据按日期升序排列，并且每个日期都是连续的。否则，窗口可能不准确。但根据问题描述，日期已经是连续的交易日，所以可以这样做。

最后，在constraint标记中，如果最近20日有任一低于发行价，则constraint为False，否则为True。

综上，修正后的代码可能如下：

import pandas as pd

def check_meu_12_1(df):
    df = df.copy()

    # 初始化标记列
    df['meu_12_1_subject'] = False
    df['meu_12_1_condition'] = False
    df['meu_12_1_constraint'] = None

    # 处理subject
    # 获取每个公司的上市日期（最早非空收盘价的日期）
    def get_ipo_date(group):
        valid = group['收盘价'].notna()
        if valid.any():
            return group.loc[valid, '日期'].min()
        else:
            return pd.NaT
    company_ipo_dates = df.groupby('公司简称').apply(get_ipo_date).reset_index()
    company_ipo_dates.columns = ['公司简称', '公司上市日期']

    # 合并到原df
    df = df.merge(company_ipo_dates, on='公司简称', how='left')

    # 筛选出上市当天的记录，并标记符合条件的股东
    mask_ipo = df['日期'] == df['公司上市日期']
    ipo_records = df[mask_ipo].copy()
    valid_subjects = ipo_records[ipo_records['股东身份'].isin(['控股股东', '实际控制人'])][['公司简称', '股东']].drop_duplicates()
    valid_subjects['valid_subject'] = True

    # 合并valid_subjects到原df，标记subject
    df = df.merge(valid_subjects, on=['公司简称', '股东'], how='left')
    df['meu_12_1_subject'] = df['valid_subject'].fillna(False)
    df.drop(columns='valid_subject', inplace=True)

    # 处理condition
    # 条件：减持方式正确，存在减持计划，且是首次披露
    valid_method = df['减持方式'].isin(['竞价交易', '大宗交易'])
    valid_plan = df['存在减持计划']

    # 找到每个公司和股东的首次披露日
    first_disclosure = df[valid_plan].groupby(['公司简称', '股东'])['日期'].min().reset_index()
    first_disclosure.rename(columns={'日期': '首次披露日'}, inplace=True)
    df = df.merge(first_disclosure, on=['公司简称', '股东'], how='left')
    valid_first = df['日期'] == df['首次披露日']

    df['meu_12_1_condition'] = valid_method & valid_plan & valid_first

    # 处理constraint
    # 计算复权收盘价
    df['复权收盘价'] = df['收盘价'] * df['复权因子']
    # 判断是否低于发行价
    df['是否低于发行价'] = df['复权收盘价'] < df['发行价格']

    # 按公司分组，计算每个交易日的前20个交易日内是否有任一低于
    def check_constraint(group):
        group = group.sort_values('日期')
        # 使用rolling窗口，window=20，min_periods=1，计算any()
        group['最近20日有低于'] = group['是否低于发行价'].rolling(window=20, min_periods=1).apply(lambda x: x.any(), raw=True)
        group['meu_12_1_constraint'] = ~group['最近20日有低于']
        return group

    df = df.groupby('公司简称', group_keys=False).apply(check_constraint)

    # 清理临时列
    df.drop(columns=['公司上市日期', '首次披露日', '复权收盘价', '是否低于发行价', '最近20日有低于'], inplace=True, errors='ignore')

    return df

这样应该能正确标记各条件。需要注意的是，在计算首次披露日时，可能有的股东从未有减持计划，此时首次披露日会是NaN，对应的valid_first为False，因此condition标记为False。

最后，constraint的标记是针对所有行的，但根据问题要求，三元组的检查是各自独立的，所以即使subject或condition不满足，constraint的检查仍然进行。但根据附加信息中的说明：“对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查。” 因此，constraint的检查是独立进行的，不管subject和condition是否满足，都需要标记。

但在上述代码中，constraint的标记是针对所有行的，即每个交易日每个股东的constraint条件是否满足。这可能与MEU的要求不符，因为MEU的constraint可能仅在subject和condition满足时才需要检查。但根据问题中的要求，对于简单操作，三元组的检查是独立的，所以即使subject或condition不满足，constraint的检查仍然进行。因此，上述代码是正确的。

综上，最终的代码应该如上述所示。
","CompletionUsage(completion_tokens=6948, prompt_tokens=1778, total_tokens=8726, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=6155, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 
 - 注意: 对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查. 对于需要调用llm_content_check()函数的项目, 只对符合<subject, conditon>的constrain进行检查. (本任务列表中没有需要用到llm_content_check()函数的项目)

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df = df.copy()

    df['meu_4_2_subject'] = False  # subject需要初始化为False
    df['meu_4_2_condition'] = False  # condition需要初始化为False
    df['meu_4_2_constrain'] = None  # constrain需要初始化为None

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    # 注意constrain是独立检查的, 并非是只检查subject和condition都符合的行
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True
    df.loc[~valid_constraint, 'meu_4_1_constraint'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_10_2
法律的最小可执行单元内容: {""subject"": ""上市公司大股东"", ""condition"": ""因涉嫌与本上市公司有关的证券期货违法犯罪被中国证监会及其派出机构立案调查或者被司法机关立案侦查，在行政处罚决定、刑事判决作出之后未满6个月"", ""constraint"": ""不得减持其所持有的本公司股份"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '日收益率', '收盘价', '前收盘价', '上市日期', '发行价格', '净资产增长率', '净利润增长率', '净资产',
'净利润', '总股本', '每股净资产', '每股净利润', '公告类型', '公告日期', '复权因子', '收盘价减每股净资产',
'收盘价减每股净利润', '公司涉嫌证券期货违法犯罪事件', '持股比例', '持股数量', '股东身份', '减持方式', '拟减持原因',
'存在减持计划', '计划减持比例', '计划价格下限', '计划价格上限', '当日减持比例', '累计减持比例', '计划披露日',
'计划开始日', '计划结束日', '离任日期', '公司简称', '股东', '股东涉嫌证券期货违法犯罪事件']

## 其中: 
- 所有公司均为在本交易所上市的上市公司
- 所有日期相关的列都已经是pd.datetime格式, ['日期']列本身就是交易日, 不需要额外计算交易日, 但是自然日需要计算. 
- 所有价格的单位都是元而非万元, 千元或百万元; 所有的比例都是小数而非百分数
- 这是一个二维的面板数据, 根据['日期', '公司简称', '股东']可以定位到特定公司的特定股东在特定交易日的状态, 以及公司在该日的状态. 如果你要分公司和股东地考虑一些合规要求, 需要考虑按照 ['公司简称', '股东']分组并在组内完成. 
- 交易方式有['竞价交易', '大宗交易', '融券卖出'], 竞价交易包括集中竞价. 
- ['公司/股东涉嫌证券期货违法犯罪事件'] 有['被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责']
- ['股东身份'] 有 ['董监高', '离任董监高', '控股股东', '实际控制人', '持股5%以上股东', '普通股东'], 这些标签不会并列出现, 因此有时候董监高/离任董监高持股在5%以上但并没有标明'持股5%以上股东', 你需要从['持股比例']手动筛选. 
- ['存在减持计划']是一个布尔值，表示该股东当天是否有减持计划
- 假设公司上市发行价就是最早的非空的收盘价, 公司发行时的控股股东和实际控制人就是第一个非空的收盘价的同一天的控股股东和实际控制人. 
- ['持股比例'] 全部是公开上市前取得的股份. 不考虑承诺和限制出售的股份. 

","

<CODE>
import pandas as pd

def check_meu_10_2(df):
    '''
    验证MEU_10_2合规性：
    - subject: 上市公司大股东（控股股东/实际控制人/持股5%以上股东）
    - condition: 因证券违法被调查且在处罚后6个月内
    - constraint: 不得减持股份
    '''
    df = df.copy()

    # 初始化合规标记列
    df['meu_10_2_subject'] = False
    df['meu_10_2_condition'] = False
    df['meu_10_2_constraint'] = False

    # 1. 验证责任主体（上市公司大股东）
    subject_mask = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) | 
        (df['持股比例'] >= 0.05)
    )
    df.loc[subject_mask, 'meu_10_2_subject'] = True

    # 2. 验证触发条件（分组处理时间序列数据）
    # 预处理调查状态
    investigated_mask = df['股东涉嫌证券期货违法犯罪事件'].isin([
        '被中国证监会及其派出机构立案调查',
        '被司法机关立案侦查'
    ])
    has_investigated = df[investigated_mask].groupby(['公司简称', '股东']).size().reset_index()
    has_investigated['has_investigated'] = True

    # 预处理处罚时间点
    penalty_dates = df[df['股东涉嫌证券期货违法犯罪事件'].isin([
        '行政处罚决定作出',
        '司法机关立案侦查结束'
    ])].groupby(['公司简称', '股东'])['日期'].apply(list).reset_index()

    # 合并特征数据
    df = df.merge(has_investigated[['公司简称', '股东', 'has_investigated']], 
                on=['公司简称', '股东'], how='left')
    df = df.merge(penalty_dates.rename(columns={'日期': 'penalty_dates'}),
                on=['公司简称', '股东'], how='left')
    
    # 处理空值
    df['has_investigated'] = df['has_investigated'].fillna(False)
    df['penalty_dates'] = df['penalty_dates'].apply(lambda x: x if isinstance(x, list) else [])

    # 条件验证函数
    def check_condition(row):
        if not row['has_investigated']:
            return False
        for penalty_date in row['penalty_dates']:
            if (row['日期'] - penalty_date).days >= 0 and \
               (row['日期'] - penalty_date).days <= 180:
                return True
        return False

    df['meu_10_2_condition'] = df.apply(check_condition, axis=1)

    # 3. 验证约束条件（独立检查）
    df['meu_10_2_constraint'] = df['当日减持比例'] == 0

    # 清理中间列
    df.drop(columns=['has_investigated', 'penalty_dates'], inplace=True, errors='ignore')

    return df
</CODE>","好的，我现在需要处理这个MEU_10_2的合规性检查问题。首先，我得仔细理解这个MEU的具体内容。根据给定的信息，MEU_10_2的subject是“上市公司大股东”，condition是“因涉嫌与本上市公司有关的证券期货违法犯罪被中国证监会及其派出机构立案调查或者被司法机关立案侦查，在行政处罚决定、刑事判决作出之后未满6个月”，而constraint是“不得减持其所持有的本公司股份”。

接下来，我需要将这些条件转化为代码，检查数据框中的每一行是否符合这三个条件。根据任务要求，我需要分别标记subject、condition和constraint的满足情况，每个都是独立的检查，除了当需要调用LLM的时候，但这里不需要。

首先处理subject部分。根据附加信息中的股东身份列，可能的取值包括'控股股东', '实际控制人', '持股5%以上股东'等。但MEU中的subject是“上市公司大股东”，这可能对应数据中的控股股东、实际控制人或持股5%以上的股东。因此，我需要检查股东身份是否是这些中的一个，或者持股比例是否大于等于5%。但根据附加信息中的说明，股东身份列中的标签不会并列出现，所以可能需要结合持股比例来判断。例如，即使股东身份是董监高，但持股比例超过5%，也可能属于大股东。不过，MEU的subject是“上市公司大股东”，可能指的是控股股东、实际控制人或持股5%以上的股东。因此，判断subject的条件应该是股东身份列中的值属于['控股股东', '实际控制人', '持股5%以上股东']，或者持股比例>=5%。不过，根据附加信息中的说明，股东身份列中的标签不会同时存在，所以可能需要同时检查这两个条件。例如，如果股东身份是普通股东，但持股比例>=5%，那么也应该视为大股东。因此，subject的条件应该是：

valid_subject = (df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东'])) | (df['持股比例'] >= 0.05)

接下来是condition部分。condition的条件是股东因涉嫌与本公司有关的证券期货违法犯罪被立案调查或侦查，并且在行政处罚或刑事判决作出后未满6个月。这里需要检查两个时间点：行政处罚决定或刑事判决的日期，以及当前行的日期是否在该日期之后的6个月内。

数据中的相关列是'股东涉嫌证券期货违法犯罪事件'，可能的取值包括被立案调查、调查结束、行政处罚决定作出、被立案侦查、侦查结束等。因此，需要确定该股东是否有被立案调查或侦查的事件，并且之后有行政处罚或刑事判决作出，且当前日期在该事件后的6个月内。

但数据框中的每一行代表一个交易日的情况，所以需要跟踪每个股东的相关事件时间。例如，假设某股东在某个日期被立案调查，之后在某个日期有行政处罚决定作出，那么从行政处罚决定作出的日期开始计算6个月，期间该股东的所有交易日行都需要满足condition条件。

这里可能需要按公司和股东分组，记录每个股东最近的行政处罚或刑事判决的日期，然后计算当前行的日期是否在该日期之后的6个月内。

但数据框中的列可能没有直接记录这些事件的日期，而是以事件类型和发生日期的方式存在。例如，'股东涉嫌证券期货违法犯罪事件'列可能记录了事件类型和对应的日期？或者可能每个事件都有对应的日期列？

根据提供的可用列，有一个列是'股东涉嫌证券期货违法犯罪事件'，可能的取值包括'被中国证监会及其派出机构立案调查'、'行政处罚决定作出'等。但如何确定这些事件的发生日期呢？可能该列是一个事件类型，而对应的日期需要从其他列获取？或者可能该列是一个时间序列的事件记录？

这里可能需要进一步分析数据结构。例如，假设每一行代表某一天的情况，如果某股东在某天发生了某个事件，比如被立案调查，那么在该行的'股东涉嫌证券期货违法犯罪事件'列会有对应的值。例如，如果某行中该列的值为'被中国证监会及其派出机构立案调查'，则表示该股东在该日期被立案调查。同样，如果该列的值为'行政处罚决定作出'，则表示在该日期作出了行政处罚决定。

因此，为了确定condition是否满足，需要找到该股东最近一次的行政处罚决定或刑事判决作出的日期，然后检查当前行的日期是否在该日期之后的6个月内。

但这里的数据结构可能比较复杂，因为每个事件可能分布在不同的行中。例如，一个股东可能在多个日期有不同的事件发生。例如，某行可能记录被立案调查，另一行可能记录行政处罚决定作出。

因此，需要按股东分组，找到每个股东最近一次的行政处罚决定或刑事判决作出的日期，然后对于每一行，判断当前日期是否在该日期之后的6个月内。

但如何从数据框中提取这些信息呢？可能需要遍历每个股东的事件记录，找到最近的行政处罚或刑事判决日期。

例如，对于每个股东，找到所有事件类型为'行政处罚决定作出'或'刑事判决作出'（但根据提供的可能取值，可能只有'行政处罚决定作出'，而刑事判决可能对应其他事件类型？比如被司法机关立案侦查，但可能没有对应的刑事判决事件？需要看数据中的具体事件类型。）

根据给定的'股东涉嫌证券期货违法犯罪事件'的可能取值，包括'被中国证监会及其派出机构立案调查', '中国证监会及其派出机构立案调查结束', '行政处罚决定作出', '被司法机关立案侦查', '司法机关立案侦查结束', '被本所公开谴责'。所以，行政处罚决定作出的日期是存在的，而刑事判决可能对应的是司法机关的立案侦查结束吗？或者是否有其他事件？

可能刑事判决作出的事件没有被明确列出，但根据MEU的条件，可能当股东被司法机关立案侦查后，如果有刑事判决作出，那么对应的日期就是刑事判决作出的日期。但数据中是否有这样的记录呢？可能没有直接的'刑事判决作出'事件，而是以'司法机关立案侦查结束'来代表？

这可能需要进一步澄清，但根据问题描述，可能假设当存在'被司法机关立案侦查'的事件，并且后续有'司法机关立案侦查结束'，并且该结束事件可能对应刑事判决作出的日期？或者可能'司法机关立案侦查结束'的日期即为刑事判决作出的日期？

或者，可能数据中的'行政处罚决定作出'和'司法机关立案侦查结束'分别对应行政处罚和刑事判决的日期。因此，condition的条件是：股东被立案调查或侦查，并且在行政处罚决定作出或司法机关立案侦查结束后的6个月内。

或者，可能刑事判决作出的日期需要从其他事件推断。例如，当'司法机关立案侦查结束'的事件发生时，可能意味着刑事判决已经作出？

这里可能存在数据与条件之间的不匹配，需要根据问题描述进行合理的假设。根据MEU的条件，condition是“因涉嫌...被立案调查或者被立案侦查，在行政处罚决定、刑事判决作出之后未满6个月”。因此，需要两个条件：一是被调查或侦查，二是行政处罚或刑事判决作出后的6个月内。

因此，对于每个股东，需要找到其被调查或侦查的事件，然后找到对应的行政处罚决定或刑事判决作出的日期，然后判断当前行的日期是否在该日期之后的6个月内。

但如何关联被调查/侦查的事件与后续的行政处罚/判决呢？例如，一个股东可能被调查，之后有行政处罚决定，或者被侦查后，有刑事判决。这可能需要在数据中跟踪每个案件的流程。

但根据现有的数据列，可能无法直接关联这些事件，因为每个事件是独立记录的。例如，某股东在某天被立案调查，之后在另一天被行政处罚决定作出，这两个事件可能没有直接的关联记录。因此，可能需要假设，只要股东有行政处罚决定作出或被司法机关立案侦查结束（假设为刑事判决作出），并且当前日期在该事件后的6个月内，则condition满足。

或者，可能只要股东曾经被立案调查或侦查，并且在之后有行政处罚决定或刑事判决作出，且在作出后的6个月内，则condition满足。

因此，处理condition的步骤可能如下：

1. 检查该股东是否曾经被中国证监会或其派出机构立案调查，或者被司法机关立案侦查。

2. 检查该股东是否有对应的行政处罚决定作出或刑事判决作出的日期。

3. 对于当前行的日期，判断是否在该日期之后的6个月内。

但如何从数据中提取这些日期呢？例如，对于每个股东，找到最近的行政处罚决定作出的日期，或者刑事判决作出的日期（可能对应司法机关立案侦查结束的日期？或者是否有其他事件？）

例如，当'股东涉嫌证券期货违法犯罪事件'列的值是'行政处罚决定作出'时，该行的日期即为行政处罚决定的日期。同样，如果事件是'司法机关立案侦查结束'，可能视为刑事判决作出的日期？

或者，可能刑事判决作出的日期需要另一个事件类型，但数据中没有，所以可能无法处理这种情况。因此，可能只能处理行政处罚决定的情况，而无法处理刑事判决的情况，除非假设'被司法机关立案侦查'后，在某个日期有'司法机关立案侦查结束'，并且该结束日期视为刑事判决作出的日期。

这可能是一个合理的假设，但需要根据问题描述进行判断。根据MEU的条件，condition包括两种情况：被调查后行政处罚决定作出，或被侦查后刑事判决作出。因此，在数据中，需要能够识别这两种情况的日期。

假设：

- 当'股东涉嫌证券期货违法犯罪事件'为'行政处罚决定作出'时，该行的日期是行政处罚决定的日期。

- 当'股东涉嫌证券期货违法犯罪事件'为'司法机关立案侦查结束'时，该行的日期视为刑事判决作出的日期。

因此，对于每个股东，需要收集这两个事件的日期，然后取最近的日期，判断当前行的日期是否在该日期之后的6个月内。

因此，处理步骤：

对于每个股东，找到所有行政处罚决定作出的日期和司法机关立案侦查结束的日期，取其中最大的日期作为最近的相关事件日期。然后，当前行的日期是否在该日期之后的6个月内？

或者，可能每个行政处罚或刑事判决事件都需要单独处理，但可能一个股东可能有多个这样的日期，需要取最近的？

例如，假设某股东在多个时间点被处罚，那么每个处罚后的6个月都需要被考虑。但根据MEU的条件，只要在任何一个处罚后的6个月内，都满足condition。

因此，对于每一行，需要检查该股东是否有任何行政处罚决定或刑事判决作出的日期，使得当前行的日期在该日期之后且未满6个月。

因此，处理步骤可能如下：

对于每个股东，收集所有行政处罚决定作出的日期和司法机关立案侦查结束的日期（视为刑事判决作出的日期）。然后，对于当前行的日期，检查是否存在这样的日期，使得当前日期在该日期之后，并且两者之间的时间差小于等于180天（假设6个月按自然日计算）。

但如何将这些信息整合到数据框中呢？可能需要为每个股东预先计算这些日期，然后在每一行中进行比较。

这可能需要分组操作。例如，按['公司简称', '股东']分组，然后对于每个组，找到所有行政处罚决定作出的日期和司法机关立案侦查结束的日期，合并成一个列表，然后对于每个行的日期，检查是否存在该列表中的某个日期，使得当前日期在该日期之后且未满6个月。

但如何高效地实现这一点呢？可能需要在数据框中为每个股东记录这些日期，然后在每一行中进行比较。

例如，首先为每个股东创建一个列，记录其所有的行政处罚决定日期和司法机关立案侦查结束日期。然后，对于每一行，检查该行的日期是否在任何一个这些日期的6个月内。

但如何实现这一点呢？可能需要使用groupby和transform方法，或者创建辅助的DataFrame来存储这些信息。

例如，步骤：

1. 筛选出所有事件为'行政处罚决定作出'或'司法机关立案侦查结束'的行，提取对应的公司简称、股东和日期。

2. 对于每个公司简称和股东，收集这些日期，形成一个列表。

3. 在原始数据框中，为每一行查找对应的公司简称和股东，获取所有相关日期，并检查当前行的日期是否在任何一个日期之后的6个月内。

这可能需要使用merge或transform方法。

或者，可以创建一个辅助的DataFrame，其中每个公司简称和股东对应一个列表的日期，然后在原始数据框中通过merge操作将这些日期列表合并进去，然后应用一个函数检查当前日期是否满足条件。

但处理起来可能比较复杂，尤其是在数据量大的情况下。不过，根据问题描述，这可能是一个必要的过程。

现在，具体到代码实现：

首先，处理subject：

valid_subject = (df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东'])) | (df['持股比例'] >= 0.05)

但根据附加信息中的说明，股东身份列中的标签不会并列出现，所以即使股东身份是普通股东，只要持股比例>=5%，也属于大股东。因此，这个条件是正确的。

接下来处理condition：

需要确定股东是否因涉嫌与本公司有关的证券期货违法犯罪被立案调查或侦查，并且在行政处罚决定或刑事判决作出后的6个月内。

首先，需要确定股东是否被立案调查或侦查。这可能对应事件类型为'被中国证监会及其派出机构立案调查'或'被司法机关立案侦查'。

然后，需要确定是否有对应的行政处罚决定或刑事判决作出，并且当前行的日期在该事件后的6个月内。

因此，对于每个股东，需要收集所有行政处罚决定作出的日期和司法机关立案侦查结束的日期（假设为刑事判决作出的日期）。

步骤：

1. 创建一个辅助的DataFrame，包含每个股东的所有相关事件日期：

   a. 筛选出事件类型为'行政处罚决定作出'或'司法机关立案侦查结束'的行，提取公司简称、股东和日期。

   b. 对于每个公司简称和股东，收集这些日期，形成列表。

2. 对于原始数据框中的每一行，检查是否存在这样的日期，使得当前行的日期在该日期之后，并且日期差<=180天。

此外，还需要确保该股东之前被立案调查或侦查过。例如，被立案调查或侦查是前提条件，之后才有行政处罚或刑事判决。

但MEU的条件是“因涉嫌...被立案调查或者被立案侦查”，所以只要被调查或侦查过，并且在处罚或判决后的6个月内，就满足condition。

因此，可能不需要检查是否确实被调查或侦查过，只要处罚或判决存在即可？或者，是否必须是因为被调查或侦查而导致处罚或判决？

根据MEU的条件，处罚或判决必须是因为之前的被调查或侦查。因此，需要确保在处罚或判决之前，该股东曾被调查或侦查。

这可能增加了复杂性，因为需要确认处罚或判决事件是否与被调查或侦查事件相关联。例如，处罚决定作出之前必须有对应的调查事件。

但根据数据中的事件记录，可能无法直接关联这两个事件，因此可能需要假设，只要存在处罚或判决事件，就视为满足被调查或侦查的条件。

或者，可能必须同时存在被调查或侦查的事件，并且处罚或判决事件是在之后发生的。

这可能需要更复杂的处理，例如，对于每个处罚或判决事件，检查该股东是否在之前被调查或侦查过。

这可能超出了当前数据结构的处理能力，因此可能需要简化处理，假设只要存在处罚或判决事件，就视为满足被调查或侦查的条件。

或者，根据MEU的条件，只要处罚或判决作出后的6个月内，无论是否被调查或侦查，都满足condition？这可能不符合法律条文的本意，但根据问题描述，可能需要根据现有数据进行处理。

在这种情况下，可能简化处理，只要存在处罚或判决事件，并且当前日期在该事件后的6个月内，则condition满足。

但这样可能不符合MEU的条件，因为MEU的条件是“因涉嫌...被立案调查或者被立案侦查”，之后才有处罚或判决。因此，必须确保处罚或判决是由于之前的调查或侦查。

因此，正确的处理步骤应该是：

1. 对于每个股东，检查是否存在被调查或侦查的事件（事件类型为'被中国证监会及其派出机构立案调查'或'被司法机关立案侦查'）。

2. 对于这些事件，之后是否有对应的处罚或判决事件（行政处罚决定作出或司法机关立案侦查结束）。

3. 如果存在这样的处罚或判决事件，并且当前行的日期在该事件后的6个月内，则condition满足。

这可能需要按股东分组，跟踪每个调查或侦查事件的后续处罚或判决事件。

但这样的处理在数据框中可能非常复杂，因为需要处理事件的时间顺序和关联性。

例如，对于每个被调查或侦查的事件，需要找到后续的处罚或判决事件，并计算时间差。

这可能超出了当前数据结构的处理能力，因此可能需要简化处理，假设只要存在处罚或判决事件，并且当前日期在该事件后的6个月内，则condition满足，而不检查是否之前有调查或侦查事件。

或者，可能必须存在至少一个调查或侦查事件在处罚或判决事件之前。

这可能比较复杂，但根据问题描述，可能需要尽可能准确地模拟法律要求。

假设我们只能处理处罚或判决事件的日期，而无法关联之前的调查或侦查事件，那么代码可能无法完全准确，但根据给定的数据列，这可能只能如此处理。

因此，处理condition的步骤如下：

对于每个股东，收集所有行政处罚决定作出的日期和司法机关立案侦查结束的日期（视为刑事判决作出的日期）。然后，对于当前行的日期，检查是否存在这样的日期，使得当前日期在该日期之后，并且两者之间的天数<=180天。

同时，需要确保该股东曾经被立案调查或侦查过。例如，该股东在之前的任何时间点有过被调查或侦查的事件。

因此，步骤：

1. 对于每个股东，是否有被调查或侦查的事件（事件类型为'被中国证监会及其派出机构立案调查'或'被司法机关立案侦查'）。

2. 对于每个股东，收集所有处罚或判决事件的日期（行政处罚决定作出或司法机关立案侦查结束）。

3. 对于当前行的日期，如果该股东有至少一个处罚或判决日期，并且当前日期在该日期之后且未满6个月，并且该股东曾经被调查或侦查过，则condition满足。

这可能需要分组处理，例如：

首先，为每个股东计算两个标志：

- has_been_investigated: 是否曾经被调查或侦查过。

- relevant_dates: 所有处罚或判决的日期。

然后，对于每一行，检查：

has_been_investigated为True，并且存在relevant_dates中的某个日期，使得当前行的日期在该日期之后，并且日期差<=180天。

现在，如何在代码中实现这一点？

首先，创建两个辅助的DataFrame：

1. 计算每个股东是否曾经被调查或侦查：

investigated = df[df['股东涉嫌证券期货违法犯罪事件'].isin(['被中国证监会及其派出机构立案调查', '被司法机关立案侦查'])]
has_been_investigated = investigated.groupby(['公司简称', '股东']).size().reset_index(name='count')
has_been_investigated['has_been_investigated'] = has_been_investigated['count'] > 0
has_been_investigated = has_been_investigated[['公司简称', '股东', 'has_been_investigated']]

然后，将has_been_investigated合并到原始df中：

df = df.merge(has_been_investigated, on=['公司简称', '股东'], how='left')
df['has_been_investigated'] = df['has_been_investigated'].fillna(False)

2. 收集每个股东的处罚或判决日期：

penalty_dates = df[df['股东涉嫌证券期货违法犯罪事件'].isin(['行政处罚决定作出', '司法机关立案侦查结束'])]
penalty_dates = penalty_dates[['公司简称', '股东', '日期']]
penalty_dates = penalty_dates.groupby(['公司简称', '股东'])['日期'].apply(list).reset_index(name='penalty_dates')

然后，将penalty_dates合并到原始df中：

df = df.merge(penalty_dates, on=['公司简称', '股东'], how='left')

现在，对于每一行，检查是否存在至少一个日期在penalty_dates中，使得当前行的日期在该日期之后，并且日期差<=180天。

这可以通过apply函数实现：

def check_condition(row):
    if not row['has_been_investigated']:
        return False
    if not isinstance(row['penalty_dates'], list):
        return False
    for date in row['penalty_dates']:
        delta = (row['日期'] - date).days
        if delta >= 0 and delta <= 180:
            return True
    return False

df['valid_condition'] = df.apply(check_condition, axis=1)

但这样处理可能效率较低，尤其是当数据量很大时。但根据问题描述，这可能是一个可行的方法。

最后，处理constraint部分。constraint是“不得减持其所持有的本公司股份”，即在该情况下，股东不得减持。因此，需要检查该股东在当天的减持行为是否发生。例如，如果当日减持比例>0，则违反constraint，因此constraint的条件是当日减持比例<=0，或者没有减持行为。

但根据数据中的列，可能有'当日减持比例'列。如果该列的值>0，则表示当天有减持，此时如果constraint要求不得减持，则违反，因此constraint的条件是当日减持比例<=0。

但需要注意，constraint的检查是独立进行的，即不管subject和condition是否满足，都需要检查。例如，即使subject或condition不满足，只要该股东当天减持了股份，constraint的条件是否满足？

根据MEU的constraint是“不得减持”，所以当subject和condition都满足时，减持是违规的。但根据任务要求，对于三元组的检查是各自独立的，因此constraint的检查是独立于subject和condition的。因此，无论subject和condition是否满足，只要该股东当天没有减持，则constraint满足；如果减持了，则constraint不满足。

但根据法律条文，constraint仅在subject和condition满足的情况下才适用。但根据任务要求中的说明：“对于简单操作dataframe就可以处理的项目, 对三元组<subject, conditon, constrain>的检查是各自独立的, 你需要分别标记三元组的True和False. 并不是只对符合subject和condition进行检查.” 因此，constraint的检查是独立的，不管subject和condition是否满足，都要检查。

因此，constraint的条件是：该股东当天没有减持股份。即，当日减持比例等于0，或者减持数量为0。

根据数据中的列，可能使用'当日减持比例'来判断。如果该列的值>0，则减持了，此时constraint为False；否则为True。

因此，valid_constraint = df['当日减持比例'] <= 0

但需要注意，可能该列存在NaN的情况，需要处理。例如，如果该股东当天没有减持，则'当日减持比例'可能为0或NaN？假设当没有减持时，该列的值为0，则valid_constraint = (df['当日减持比例'] <= 0) | df['当日减持比例'].isna()

或者，可能该列在无减持时为0，因此valid_constraint = df['当日减持比例'] == 0

需要根据数据的具体情况处理。假设当没有减持时，'当日减持比例'为0，则valid_constraint的条件是当日减持比例等于0。

综上，constraint的检查是：

valid_constraint = df['当日减持比例'] == 0

现在，将这些条件整合到代码中：

首先，初始化三个新列：

df['meu_10_2_subject'] = False
df['meu_10_2_condition'] = False
df['meu_10_2_constraint'] = False

然后，填充这些列：

df.loc[valid_subject, 'meu_10_2_subject'] = True
df.loc[valid_condition, 'meu_10_2_condition'] = True
df.loc[valid_constraint, 'meu_10_2_constraint'] = True

但根据任务要求，constraint的检查是独立的，所以不管其他条件如何，只要当天没有减持，就标记为True。

现在，将上述步骤整合到代码中：

需要注意的是，处理condition的部分需要分组处理，并且可能比较耗时。此外，合并后的列可能需要处理NaN的情况。

现在，编写代码：

首先，处理subject：

valid_subject = (df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东'])) | (df['持股比例'] >= 0.05)

然后，处理condition：

需要分组处理，收集每个股东的处罚或判决日期，并检查当前日期是否在任何一个日期后的6个月内。

步骤：

1. 筛选出被调查或侦查的事件，并标记这些股东。

investigated = df[df['股东涉嫌证券期货违法犯罪事件'].isin(['被中国证监会及其派出机构立案调查', '被司法机关立案侦查'])]
has_been_investigated = investigated.groupby(['公司简称', '股东']).any().reset_index()
has_been_investigated['has_been_investigated'] = True

然后，合并到原df中：

df = df.merge(has_been_investigated[['公司简称', '股东', 'has_been_investigated']], on=['公司简称', '股东'], how='left')
df['has_been_investigated'] = df['has_been_investigated'].fillna(False)

2. 收集处罚或判决的日期：

penalty_dates = df[df['股东涉嫌证券期货违法犯罪事件'].isin(['行政处罚决定作出', '司法机关立案侦查结束'])]
penalty_dates_grouped = penalty_dates.groupby(['公司简称', '股东'])['日期'].apply(list).reset_index(name='penalty_dates')

合并到原df中：

df = df.merge(penalty_dates_grouped, on=['公司简称', '股东'], how='left')

3. 对于每一行，检查是否存在处罚日期，并且当前日期在该日期后的6个月内：

def check_condition(row):
    if not row['has_been_investigated']:
        return False
    if not isinstance(row['penalty_dates'], list):
        return False
    for date in row['penalty_dates']:
        delta = (row['日期'] - date).days
        if delta >= 0 and delta <= 180:
            return True
    return False

df['valid_condition_temp'] = df.apply(check_condition, axis=1)
valid_condition = df['valid_condition_temp']
df.drop(columns=['valid_condition_temp'], inplace=True)

最后，处理constraint：

valid_constraint = df['当日减持比例'] == 0

然后，将这三个条件分别赋值到对应的列：

df['meu_10_2_subject'] = valid_subject
df['meu_10_2_condition'] = valid_condition
df['meu_10_2_constraint'] = valid_constraint

但需要注意，在合并过程中可能会引入很多辅助列，如'has_been_investigated'和'penalty_dates'，这些列在最终返回的df中需要被删除吗？根据任务要求，函数需要返回标注后的dataframe，但可能不需要保留中间列。因此，在代码中可能需要删除这些辅助列。

此外，处理日期时需要注意，日期列已经是pd.datetime格式，因此可以直接计算差值。

现在，将所有步骤整合到函数中：

import pandas as pd

def check_meu_10_2(df):
    df = df.copy()

    # 初始化结果列
    df['meu_10_2_subject'] = False
    df['meu_10_2_condition'] = False
    df['meu_10_2_constraint'] = False

    # 处理subject
    valid_subject = (df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东'])) | (df['持股比例'] >= 0.05)
    df.loc[valid_subject, 'meu_10_2_subject'] = True

    # 处理condition
    # 步骤1：标记是否被调查或侦查过
    investigated = df[df['股东涉嫌证券期货违法犯罪事件'].isin(['被中国证监会及其派出机构立案调查', '被司法机关立案侦查'])]
    has_been_investigated = investigated.groupby(['公司简称', '股东']).size().reset_index(name='count')
    has_been_investigated['has_been_investigated'] = has_been_investigated['count'] > 0
    has_been_investigated = has_been_investigated[['公司简称', '股东', 'has_been_investigated']]

    # 合并到原df
    df = df.merge(has_been_investigated, on=['公司简称', '股东'], how='left')
    df['has_been_investigated'] = df['has_been_investigated'].fillna(False)

    # 步骤2：收集处罚或判决日期
    penalty_dates = df[df['股东涉嫌证券期货违法犯罪事件'].isin(['行政处罚决定作出', '司法机关立案侦查结束'])]
    penalty_dates_grouped = penalty_dates.groupby(['公司简称', '股东'])['日期'].apply(list).reset_index(name='penalty_dates')

    # 合并到原df
    df = df.merge(penalty_dates_grouped, on=['公司简称', '股东'], how='left')

    # 步骤3：检查每个日期是否在处罚后的6个月内
    def check_condition(row):
        if not row['has_been_investigated']:
            return False
        if not isinstance(row['penalty_dates'], list):
            return False
        for date in row['penalty_dates']:
            delta = (row['日期'] - date).days
            if 0 <= delta <= 180:
                return True
        return False

    df['meu_10_2_condition'] = df.apply(check_condition, axis=1)

    # 处理constraint
    valid_constraint = df['当日减持比例'] == 0
    df['meu_10_2_constraint'] = valid_constraint

    # 删除辅助列
    df.drop(columns=['has_been_investigated', 'penalty_dates'], inplace=True, errors='ignore')

    return df

但这里可能存在一个问题：在步骤2中，合并penalty_dates_grouped时，如果某个股东没有处罚或判决事件，则penalty_dates列将为NaN，而不是空列表。因此，在check_condition函数中，需要处理这种情况。例如：

if not isinstance(row['penalty_dates'], list) or len(row['penalty_dates']) == 0:
    return False

或者，在合并时，将NaN替换为空列表：

df['penalty_dates'] = df['penalty_dates'].apply(lambda x: x if isinstance(x, list) else [])

这可能需要在合并后进行处理。

因此，在合并penalty_dates_grouped后，处理：

df['penalty_dates'] = df['penalty_dates'].apply(lambda x: x if isinstance(x, list) else [])

这样，在check_condition函数中，即使没有处罚日期，penalty_dates将是一个空列表，循环不会执行，返回False。

因此，修改后的check_condition函数：

def check_condition(row):
    if not row['has_been_investigated']:
        return False
    for date in row['penalty_dates']:
        delta = (row['日期'] - date).days
        if 0 <= delta <= 180:
            return True
    return False

同时，在合并后处理penalty_dates列：

df['penalty_dates'] = df['penalty_dates'].apply(lambda x: x if isinstance(x, list) else [])

这样，可以确保penalty_dates是列表类型。

综上，修改后的代码：

import pandas as pd

def check_meu_10_2(df):
    df = df.copy()

    # 初始化结果列
    df['meu_10_2_subject'] = False
    df['meu_10_2_condition'] = False
    df['meu_10_2_constraint'] = False

    # 处理subject
    valid_subject = (df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东'])) | (df['持股比例'] >= 0.05)
    df.loc[valid_subject, 'meu_10_2_subject'] = True

    # 处理condition
    # 步骤1：标记是否被调查或侦查过
    investigated = df[df['股东涉嫌证券期货违法犯罪事件'].isin(['被中国证监会及其派出机构立案调查', '被司法机关立案侦查'])]
    has_been_investigated = investigated.groupby(['公司简称', '股东']).size().reset_index(name='count')
    has_been_investigated['has_been_investigated'] = has_been_investigated['count'] > 0
    has_been_investigated = has_been_investigated[['公司简称', '股东', 'has_been_investigated']]

    # 合并到原df
    df = df.merge(has_been_investigated, on=['公司简称', '股东'], how='left')
    df['has_been_investigated'] = df['has_been_investigated'].fillna(False)

    # 步骤2：收集处罚或判决日期
    penalty_dates = df[df['股东涉嫌证券期货违法犯罪事件'].isin(['行政处罚决定作出', '司法机关立案侦查结束'])]
    penalty_dates_grouped = penalty_dates.groupby(['公司简称', '股东'])['日期'].apply(list).reset_index(name='penalty_dates')

    # 合并到原df
    df = df.merge(penalty_dates_grouped, on=['公司简称', '股东'], how='left')
    # 将NaN替换为空列表
    df['penalty_dates'] = df['penalty_dates'].apply(lambda x: x if isinstance(x, list) else [])

    # 步骤3：检查每个日期是否在处罚后的6个月内
    def check_condition(row):
        if not row['has_been_investigated']:
            return False
        for date in row['penalty_dates']:
            delta = (row['日期'] - date).days
            if 0 <= delta <= 180:
                return True
        return False

    df['meu_10_2_condition'] = df.apply(check_condition, axis=1)

    # 处理constraint
    valid_constraint = df['当日减持比例'] == 0
    df['meu_10_2_constraint'] = valid_constraint

    # 删除辅助列
    df.drop(columns=['has_been_investigated', 'penalty_dates'], inplace=True, errors='ignore')

    return df

这样，代码应该能够正确标记各条件的情况。

最后，测试代码是否满足所有要求：

- subject是否正确标记大股东。
- condition是否正确标记在处罚后的6个月内，并且该股东曾被调查或侦查。
- constraint是否正确标记当日是否减持。

可能还需要处理自然日与交易日的问题，但根据问题描述中的说明，日期列已经是交易日，而MEU中的6个月可能指自然日。因此，在计算日期差时使用自然日是正确的。
","CompletionUsage(completion_tokens=8204, prompt_tokens=1722, total_tokens=9926, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=7500, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
