prompt,response,reasoning_content,api_usage
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 5. 计算整体的违约情况并标记在dataframe上(meu_n_k_compliance). 

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df['meu_4_2_subject'] = False  # 初始化subject列
    df['meu_4_2_condition'] = False  # 初始化condition列
    df['meu_4_2_constrain'] = False  # 初始化constrain列

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True

    # 判断违规情况：满足主体和条件但不满足约束
    is_violation = (
        valid_subject & 
        valid_condition & 
        (~valid_constraint)
    )

    # 标记违规行
    df.loc[is_violation, 'meu_4_1_compliance'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_15_3
法律的最小可执行单元内容: {""subject"": ""上市公司"", ""condition"": ""报告期末资产负债率超过80%且当期经营活动产生的现金流量净额为负，且现金分红金额超过当期净利润50%的"", ""constraint"": ""应当根据公司盈利能力、融资能力及其成本、偿债能力及现金流等情况披露现金分红方案的合理性，是否导致公司营运资金不足或者影响公司正常生产经营"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '财务数据日期', '公告日期', '公告类型', '审计意见', '总资产', '总负债', '净资产', '资产负债率',
'交易性金融资产', '衍生金融资产', '债权投资', '其他债权投资', '其他权益工具投资', '其他非流动金融资产',
'其他流动资产', '金融资产总额', '总股本', '每股净资产', '合并报表未分配利润', '母公司报表未分配利润', '净利润',
'每股净利润', '母公司报表净利润', '经营活动现金流量净额', '投资活动现金流量净额', '筹资活动现金流量净额',
'现金及现金等价物净增加额', '净资产增长率', '净利润增长率', '资产负债率变化', '金融资产增长率',
'是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划', '现金分红金额', '送股比例', '转增比例', '是否进行权益分派', '权益分派方案文本', '公司简称']

## 其中: 
- 这是一个二维的面板数据, 根据['日期', '公司简称']可以定位到特定公司在特定日期的状态. 数据已经按照公司简称和日期排序. 
- 我们的'日期'并非连续的自然日或者交易日, 而是固定的季报/半年报/年报披露后三个月内的某一个自然日, 例如'2020-05-30', '2020-09-29', ...等, 我们假定公司在这一天发布了权益分派公告(或者决定了不进行权益分派). 每个季报/半年报/年报后只会跟随一个'日期'来决定是否进行权益分派, 如何进行分派. 
- 数据的每一行包含了两个部分的数据, 分别是当时最新的财务数据和当时最新的权益分派情况. 例如, '2020-09-17'这一行可能对应了公告日期为'2020-08-27'的截至'2020-06-30'的半年报财务报告['审计意见', '总资产', ..., '现金及现金等价物净增加额'], 以及在'2020-09-17'当天公告的权益分派信息['是否进行权益分派', ..., '现金分红金额', ...]
- 所有财务数据都是以单季度的形式记录的, 不需要考虑利润表科目在半年报和年报中逐渐累加的问题. 所有的增长率都是单季的. 
- 所有资产/价格的单位都是元而非万元, 千元或百万元; 所有的比例/比率都是小数而非百分数, 除了['送股比例', '转增比例']是""每10股送n股""的格式. 
- ['审计意见']的值有""无保留意见"", ""非标准无保留意见"", ""保留意见"". 
- 这些列为布尔值: ['是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划']

- 如果希望检查权益分派方案中是否披露了特定内容, 可以使用环境中会提供的函数`llm_content_check()`, 但非披露类的合规检查中禁止使用这个函数. 
    描述: 使用LLM检查公告中是否包含特定内容
        参数:
            announcement_text: 公告全文
            traget_content: 需要检查的内容描述
        返回:
            bool: 公告中是否包含特定内容
    调用示例: 
        ```python
        from utils.tool_for_agents import llm_content_check

        constraint_description = ""为增强投资者回报水平拟采取的措施"" # 请完整描述需要检查的内容, 不得简化
        df['meu_4_1_constraint'] = df['权益分派方案文本'].apply(
            lambda text: llm_content_check(text, constraint_description)
        )
        ```

note:
 - 理论上你撰写合规检验代码所需要的数据都可以从一致的数据中得到, 对于没有直接对应的数据你需要自己计算得到, 不要简单地认为无法完成. 
 - 除非材料提供, 否则不要主动进行简化的假设. 如果你认为所给的信息不足以判断案例的合规性, 可以在函数的结尾进行注释说明. 但这种情况应该很少出现. 

","

<CODE>
import pandas as pd
from utils.tool_for_agents import llm_content_check

def check_meu_15_3(df):
    '''
    验证MEU_15_3合规性：
    ""subject"": ""上市公司"",
    ""condition"": ""报告期末资产负债率超过80%且当期经营活动产生的现金流量净额为负，且现金分红金额超过当期净利润50%的"",
    ""constraint"": ""应当根据公司盈利能力、融资能力及其成本、偿债能力及现金流等情况披露现金分红方案的合理性，是否导致公司营运资金不足或者影响公司正常生产经营""
    '''
    
    # 初始化标记列
    df['meu_15_3_subject'] = True  # 所有记录主体均为上市公司
    df['meu_15_3_condition'] = False
    df['meu_15_3_constraint'] = False
    df['meu_15_3_compliance'] = True  # 默认合规

    # 1. 验证condition条件
    cond_leverage = df['资产负债率'] > 0.8  # 资产负债率超过80%
    cond_cashflow = df['经营活动现金流量净额'] < 0  # 经营活动现金流为负
    cond_dividend = df['现金分红金额'] > (df['净利润'] * 0.5)  # 分红超净利润50%
    
    valid_condition = cond_leverage & cond_cashflow & cond_dividend
    df.loc[valid_condition, 'meu_15_3_condition'] = True

    # 2. 验证constraint条件（仅当condition满足时检查）
    constraint_desc = '''披露现金分红方案的合理性，是否导致公司营运资金不足或者影响公司正常生产经营，
                         包括对公司盈利能力、融资能力及其成本、偿债能力及现金流等情况的说明'''
    
    # 仅对触发条件的记录进行内容检查
    mask = valid_condition & df['是否实施现金分红']
    df.loc[mask, 'meu_15_3_constraint'] = df[mask].apply(
        lambda x: llm_content_check(x['权益分派方案文本'], constraint_desc), 
        axis=1
    )

    # 3. 判断违规：主体和条件满足但约束不满足
    violation_mask = valid_condition & (~df['meu_15_3_constraint'])
    df.loc[violation_mask, 'meu_15_3_compliance'] = False

    return df
</CODE>","好的，我现在需要处理这个MEU_15_3的合规性检查。首先，我得仔细理解这个MEU的内容。根据提供的JSON，MEU_15_3的subject是“上市公司”，condition是当报告期末资产负债率超过80%、当期经营活动产生的现金流量净额为负，并且现金分红金额超过当期净利润的50%时，触发约束条件。而约束是公司需要披露现金分红方案的合理性，是否导致营运资金不足或影响正常生产经营。

接下来，我需要根据给定的数据框中的列来编写代码。数据框的列包括财务数据和权益分派信息。首先，处理subject部分。因为subject是上市公司，所以每一行都代表上市公司的情况，所以可能所有行的subject都是有效的。但需要确认是否有例外情况，比如是否有可能存在非上市公司的情况？根据数据描述，数据是关于上市公司的，所以可能所有行的subject都是符合条件的。但可能需要检查是否有其他条件，比如是否被ST或者退市等，但数据中没有提供这些信息，所以暂时假设所有行的subject都是有效的。不过，根据任务要求，可能需要显式标记subject的有效性。所以这里可能直接标记为True，因为所有行都是上市公司的情况。

接下来是condition部分。需要满足三个条件：资产负债率>80%，经营活动现金流量净额为负，现金分红金额超过当期净利润的50%。这三个条件需要同时满足。所以需要从数据框中提取这三个指标：

1. 资产负债率：数据框中有“资产负债率”列，单位是小数，所以检查是否大于0.8。
2. 经营活动现金流量净额：对应的列是“经营活动现金流量净额”，是否为负数。
3. 现金分红金额是否超过当期净利润的50%。这里需要比较“现金分红金额”和“净利润”列。注意，净利润可能有多个列，比如“净利润”和“母公司报表净利润”，但MEU中提到的“当期净利润”应该是指合并报表中的净利润，所以使用“净利润”列。计算现金分红金额是否大于净利润的0.5倍。

这三个条件同时满足时，condition才为True。

然后是constraint部分。约束条件是公司需要披露现金分红方案的合理性，是否导致营运资金不足或影响正常生产经营。这里需要检查权益分派方案文本中是否包含这些披露内容。根据附加信息，可以使用llm_content_check函数来检查公告文本是否包含特定内容。因此，需要调用这个函数，传入“权益分派方案文本”和对应的约束描述。约束描述应该是“披露现金分红方案的合理性，是否导致公司营运资金不足或者影响公司正常生产经营”。所以，在代码中，需要构造这个描述，并应用llm_content_check函数到每一行的“权益分派方案文本”上，得到是否满足约束条件。

现在，将这些步骤转化为代码：

首先，初始化三个标记列：meu_15_3_subject，meu_15_3_condition，meu_15_3_constraint，初始值设为False。

处理subject：因为所有行都是上市公司，所以直接标记为True。所以df['meu_15_3_subject'] = True。

处理condition：

condition的三个条件：

cond1 = df['资产负债率'] > 0.8

cond2 = df['经营活动现金流量净额'] < 0

cond3 = df['现金分红金额'] > (df['净利润'] * 0.5)

valid_condition = cond1 & cond2 & cond3

然后，标记meu_15_3_condition列为valid_condition的值。

处理constraint：

需要检查权益分派方案文本是否包含披露内容。使用llm_content_check函数。约束描述是“应当根据公司盈利能力、融资能力及其成本、偿债能力及现金流等情况披露现金分红方案的合理性，是否导致公司营运资金不足或者影响公司正常生产经营”。所以，将这段描述作为target_content传入函数。

所以，df['meu_15_3_constraint'] = df['权益分派方案文本'].apply(lambda x: llm_content_check(x, constraint_description))，其中constraint_description是上述内容。

但需要注意，只有当公司确实进行了现金分红时，才需要检查这个约束。即，当“是否实施现金分红”为True时，才需要检查。否则，可能不需要。例如，如果公司没有分红，那么可能不需要披露。但MEU的condition中已经包含了现金分红金额超过净利润50%的条件，所以只有当condition为True时，才会触发约束条件。因此，在condition为True的情况下，才需要检查约束是否满足。但根据MEU的结构，约束是否满足的条件是当subject和condition都满足时，是否满足约束。所以，在代码中，可能不需要额外处理，因为当condition为True时，必然已经满足现金分红的条件，所以此时需要检查约束。

不过，在应用llm_content_check时，如果公司没有进行现金分红（即“是否实施现金分红”为False），那么现金分红金额可能为0，此时condition中的cond3可能不满足，所以condition为False，此时约束条件不会被触发。因此，在condition为True的情况下，必然已经进行了现金分红，所以此时需要检查约束。因此，在代码中，可以直接对所有行的权益分派方案文本进行检查，但只有当condition为True时，约束是否满足才有意义。不过，根据MEU的约束，只要满足subject和condition，就必须满足约束。所以，不管是否实施现金分红，只要condition的三个条件满足，就需要检查约束是否满足。例如，如果公司虽然满足资产负债率、现金流量净额和分红金额超过净利润50%，但可能因为某种原因没有实施现金分红，但根据数据中的“是否实施现金分红”列是否为True，这可能影响condition中的cond3。例如，如果现金分红金额超过净利润的50%，但“是否实施现金分红”为True，那么cond3才成立。或者，是否实施现金分红可能由“是否实施现金分红”列决定，而现金分红金额可能只有在实施的情况下才有值。需要看数据中的具体逻辑。

根据数据中的列，“是否实施现金分红”是布尔值，而“现金分红金额”可能只有在“是否实施现金分红”为True时才有非零值。因此，cond3中的现金分红金额是否超过净利润的50%可能只有在实施现金分红的情况下才可能成立。因此，当condition为True时，必然已经实施了现金分红，所以此时需要检查约束条件是否满足。因此，在应用llm_content_check时，可能不需要额外处理，因为当condition为True时，必然已经实施了现金分红，所以权益分派方案文本应该存在，并且需要检查是否包含约束条件中的内容。

综上，处理constraint的代码应该是：

constraint_description = ""应当根据公司盈利能力、融资能力及其成本、偿债能力及现金流等情况披露现金分红方案的合理性，是否导致公司营运资金不足或者影响公司正常生产经营""

df['meu_15_3_constraint'] = df.apply(lambda row: llm_content_check(row['权益分派方案文本'], constraint_description) if row['meu_15_3_condition'] else False, axis=1)

或者，更简单的方式是，只有当condition为True时，才进行检查。否则，约束条件不适用，所以标记为True或者False？根据合规性逻辑，只有当subject和condition都满足时，才需要满足约束。因此，当subject和condition都满足时，如果约束满足，则合规，否则违规。所以，在标记constraint时，只有当condition为True时，才需要检查约束是否满足。否则，约束条件不适用，所以可能不需要标记为True或False。但根据示例中的处理方式，可能将constraint标记为True或False，不管condition是否满足。例如，在示例中，valid_constraint的计算可能包括了所有行，但只有当subject和condition都满足时，才会被检查是否合规。因此，在MEU_15_3的情况下，可能应该对所有行计算constraint是否满足，但只有当condition为True时，才需要满足约束。因此，在代码中，可以这样处理：

valid_constraint = df.apply(lambda row: llm_content_check(row['权益分派方案文本'], constraint_description) if row['meu_15_3_condition'] else True, axis=1)

或者，当condition不满足时，约束条件不适用，所以视为满足约束？或者，只有当subject和condition都满足时，约束才需要满足。因此，在计算合规性时，只有当subject和condition都满足时，才需要检查约束是否满足。否则，合规性为True。例如，在示例中，合规性判断是当subject和condition满足，但约束不满足时，违规。其他情况视为合规。因此，在MEU_15_3的情况下，合规性为：当subject和condition都为True时，必须constraint为True，否则违规。其他情况下，合规。

因此，在代码中，合规性标记为：

is_violation = (df['meu_15_3_subject'] & df['meu_15_3_condition']) & (~df['meu_15_3_constraint'])

然后，将is_violation的行标记为合规性False，否则为True。

现在，将这些步骤整合到代码中：

首先，导入必要的库：

import pandas as pd
from utils.tool_for_agents import llm_content_check

然后，定义函数：

def check_meu_15_3(df):
    # 初始化标记列
    df['meu_15_3_subject'] = True  # 所有行都是上市公司
    df['meu_15_3_condition'] = False
    df['meu_15_3_constraint'] = False

    # 计算condition的条件
    cond1 = df['资产负债率'] > 0.8
    cond2 = df['经营活动现金流量净额'] < 0
    cond3 = df['现金分红金额'] > (df['净利润'] * 0.5)
    valid_condition = cond1 & cond2 & cond3
    df.loc[valid_condition, 'meu_15_3_condition'] = True

    # 计算constraint的条件
    constraint_description = ""披露现金分红方案的合理性，是否导致公司营运资金不足或者影响公司正常生产经营""
    # 只有当condition为True时，才需要检查约束
    mask = df['meu_15_3_condition']
    df.loc[mask, 'meu_15_3_constraint'] = df[mask].apply(
        lambda row: llm_content_check(row['权益分派方案文本'], constraint_description), 
        axis=1
    )

    # 计算合规性：当subject和condition都满足时，必须constraint满足，否则违规
    df['meu_15_3_compliance'] = True  # 默认合规
    violation_mask = (df['meu_15_3_subject'] & df['meu_15_3_condition']) & (~df['meu_15_3_constraint'])
    df.loc[violation_mask, 'meu_15_3_compliance'] = False

    return df

需要注意的问题：

1. 在计算cond3时，是否应该考虑净利润为负的情况？例如，如果净利润为负，那么现金分红金额超过净利润的50%可能没有意义。但根据MEU的描述，无论净利润是否为负，只要现金分红金额超过当期净利润的50%就触发条件。例如，如果净利润为-100万，现金分红金额为-60万，这可能不符合实际情况，但根据条件，只要现金分红金额>净利润*0.5，即-60万 > -100万*0.5 → -60万 > -50万 → 不成立。所以在这种情况下，cond3不会成立。因此，代码中的处理是正确的，无需额外处理。

2. 在计算constraint时，是否应该检查公司是否实际进行了现金分红？例如，如果condition满足，但公司没有实施现金分红，那么可能不需要披露。但根据MEU的condition，现金分红金额超过净利润的50%意味着已经进行了分红，所以“是否实施现金分红”应该为True。因此，在数据中，当condition为True时，“是否实施现金分红”列应该为True。因此，在代码中不需要额外检查该列，因为cond3已经隐含了现金分红金额的存在。

3. 在调用llm_content_check时，如果权益分派方案文本为空或者未披露，那么可能返回False。因此，当condition为True时，必须存在权益分派方案文本，否则约束条件不满足。

综上，代码应该如上述所示。现在，检查是否有遗漏的步骤，比如是否需要处理其他情况，或者是否需要处理数据中的其他列。例如，是否需要考虑财务数据的日期是否对应正确的报告期？例如，假设财务数据日期是报告期末的日期，而权益分派是在之后进行的。根据数据描述，每一行的财务数据是当时最新的，例如，在公告日期对应的财务数据是截至报告期末的。因此，在计算资产负债率等指标时，使用的是正确的财务数据。因此，代码中的处理是正确的。
","CompletionUsage(completion_tokens=3297, prompt_tokens=2040, total_tokens=5337, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=2756, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 

# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 5. 计算整体的违约情况并标记在dataframe上(meu_n_k_compliance). 

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df['meu_4_2_subject'] = False  # 初始化subject列
    df['meu_4_2_condition'] = False  # 初始化condition列
    df['meu_4_2_constrain'] = False  # 初始化constrain列

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True

    # 判断违规情况：满足主体和条件但不满足约束
    is_violation = (
        valid_subject & 
        valid_condition & 
        (~valid_constraint)
    )

    # 标记违规行
    df.loc[is_violation, 'meu_4_1_compliance'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_19_3
法律的最小可执行单元内容: {""subject"": ""上市公司"", ""condition"": ""净利润同比下降50%以上"", ""constraint"": ""不得披露高送转方案"", ""contextual_info"": NaN}
必要的额外信息: nan

你被分配的MEU coding任务存在refer_to关系, 你需要参考下面这个MEU的必要内容来完成你被安排的任务, 但你不需要直接执行下面的MEU: 
【MEU_17_1】
subject: nan
condition: nan
constrain: nan
contextual_info: 本指引所称高送转，是指公司每十股送红股与公积金转增股本，合计达到或者超过五股


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '财务数据日期', '公告日期', '公告类型', '审计意见', '总资产', '总负债', '净资产', '资产负债率',
'交易性金融资产', '衍生金融资产', '债权投资', '其他债权投资', '其他权益工具投资', '其他非流动金融资产',
'其他流动资产', '金融资产总额', '总股本', '每股净资产', '合并报表未分配利润', '母公司报表未分配利润', '净利润',
'每股净利润', '母公司报表净利润', '经营活动现金流量净额', '投资活动现金流量净额', '筹资活动现金流量净额',
'现金及现金等价物净增加额', '净资产增长率', '净利润增长率', '资产负债率变化', '金融资产增长率',
'是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划', '现金分红金额', '送股比例', '转增比例', '是否进行权益分派', '权益分派方案文本', '公司简称']

## 其中: 
- 这是一个二维的面板数据, 根据['日期', '公司简称']可以定位到特定公司在特定日期的状态. 数据已经按照公司简称和日期排序. 
- 我们的'日期'并非连续的自然日或者交易日, 而是固定的季报/半年报/年报披露后三个月内的某一个自然日, 例如'2020-05-30', '2020-09-29', ...等, 我们假定公司在这一天发布了权益分派公告(或者决定了不进行权益分派). 每个季报/半年报/年报后只会跟随一个'日期'来决定是否进行权益分派, 如何进行分派. 
- 数据的每一行包含了两个部分的数据, 分别是当时最新的财务数据和当时最新的权益分派情况. 例如, '2020-09-17'这一行可能对应了公告日期为'2020-08-27'的截至'2020-06-30'的半年报财务报告['审计意见', '总资产', ..., '现金及现金等价物净增加额'], 以及在'2020-09-17'当天公告的权益分派信息['是否进行权益分派', ..., '现金分红金额', ...]
- 所有财务数据都是以单季度的形式记录的, 不需要考虑利润表科目在半年报和年报中逐渐累加的问题. 所有的增长率都是单季的. 
- 所有资产/价格的单位都是元而非万元, 千元或百万元; 所有的比例/比率都是小数而非百分数, 除了['送股比例', '转增比例']是""每10股送n股""的格式. 
- ['审计意见']的值有""无保留意见"", ""非标准无保留意见"", ""保留意见"". 
- 这些列为布尔值: ['是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划']

- 如果希望检查权益分派方案中是否披露了特定内容, 可以使用环境中会提供的函数`llm_content_check()`, 但非披露类的合规检查中禁止使用这个函数. 
    描述: 使用LLM检查公告中是否包含特定内容
        参数:
            announcement_text: 公告全文
            traget_content: 需要检查的内容描述
        返回:
            bool: 公告中是否包含特定内容
    调用示例: 
        ```python
        from utils.tool_for_agents import llm_content_check

        constraint_description = ""为增强投资者回报水平拟采取的措施"" # 请完整描述需要检查的内容, 不得简化
        df['meu_4_1_constraint'] = df['权益分派方案文本'].apply(
            lambda text: llm_content_check(text, constraint_description)
        )
        ```

note:
 - 理论上你撰写合规检验代码所需要的数据都可以从一致的数据中得到, 对于没有直接对应的数据你需要自己计算得到, 不要简单地认为无法完成. 
 - 除非材料提供, 否则不要主动进行简化的假设. 如果你认为所给的信息不足以判断案例的合规性, 可以在函数的结尾进行注释说明. 但这种情况应该很少出现. 

","

<CODE>
import pandas as pd

def check_meu_19_3(df):
    '''
    验证MEU_19_3合规性:
    - subject: 上市公司（所有记录默认满足）
    - condition: 净利润同比下降50%以上（净利润增长率<=-0.5）
    - constraint: 不得披露高送转方案（送股+转增<5股）
    '''

    # 初始化标记列
    df['meu_19_3_subject'] = True  # 所有记录主体均为上市公司
    df['meu_19_3_condition'] = False
    df['meu_19_3_constraint'] = True
    df['meu_19_3_compliance'] = True

    # 标记条件满足情况
    # 1. 验证净利润同比下降50%以上（单季度同比）
    df['meu_19_3_condition'] = df['净利润增长率'] <= -0.5

    # 2. 验证高送转约束（仅当主体和条件同时满足时检查）
    # 计算送转总和（处理可能的NaN值）
    send_ratio = df['送股比例'].fillna(0)
    transfer_ratio = df['转增比例'].fillna(0)
    high_send = (send_ratio + transfer_ratio) >= 5

    # 确定需要检查约束的有效范围
    mask = df['meu_19_3_subject'] & df['meu_19_3_condition']
    # 在约束范围内标记违规（存在高送转）
    df.loc[mask, 'meu_19_3_constraint'] = ~high_send[mask]

    # 计算整体合规性（满足主体条件但违反约束即为违规）
    violation_mask = mask & high_send
    df.loc[violation_mask, 'meu_19_3_compliance'] = False

    return df
</CODE>","好的，我现在需要编写一个函数来检查MEU_19_3的合规性。首先，我得仔细理解这个MEU的内容。MEU_19_3的subject是“上市公司”，condition是“净利润同比下降50%以上”，constraint是“不得披露高送转方案”。此外，参考MEU_17_1中的高送转定义，即每十股送红股与公积金转增股本合计达到或超过五股。

接下来，我需要确定如何用给定的DataFrame列来验证这三个部分。首先处理subject。这里subject是上市公司，所以每一行都代表上市公司的情况，所以可能所有行的subject都是有效的。但可能需要确认是否有其他条件，比如是否存在某些特殊情况导致公司不被视为有效主体。但根据问题描述，可能所有行的subject都是有效的，所以这一步可能直接标记为True。不过需要确认是否有例外情况，比如如果公司被退市了？但数据中没有提到这种情况，所以可能直接标记所有行的subject为True。

然后是condition部分，即净利润同比下降50%以上。这里需要比较当前期间的净利润与上一期的净利润。例如，如果当前季度的净利润比去年同期下降了50%或更多。但数据中的财务数据是单季度的，所以可能需要计算同比。例如，假设当前行的财务数据日期是2020年6月30日，那么需要比较2020年第二季度的净利润与2019年第二季度的净利润。如果（当前净利润 - 去年同期净利润）/ 去年同期净利润 <= -0.5，则满足条件。但如何获取去年的数据呢？因为DataFrame是按日期和公司简称排列的，可能需要使用shift或者groupby来获取每个公司前一年的数据。例如，对于每个公司，按财务数据日期排序，找到同一季度的前一年数据进行比较。这可能比较复杂，但假设DataFrame中已经包含了每个季度的净利润，并且可以通过某种方式获取同比数据。或者，可能数据中的“净利润增长率”列已经提供了这个信息。例如，如果净利润增长率是当前季度与去年同期相比的增长率，那么当该增长率小于等于-0.5时，条件满足。例如，净利润增长率列的值如果为-0.6，则同比下降60%，满足条件。因此，可能可以直接使用“净利润增长率”列来判断。所以，valid_condition的条件是df['净利润增长率'] <= -0.5。

接下来是constraint部分，即不得披露高送转方案。根据MEU_17_1的定义，高送转是指每十股送红股和公积金转增合计达到或超过五股。所以需要检查公司的权益分派方案中的送股比例和转增比例之和是否>=5。例如，送股比例是每10股送n股，转增比例是每10股转增m股，那么n + m >=5的话，就属于高送转。因此，需要将这两个比例相加，判断是否>=5。在数据中，送股比例和转增比例可能分别存储在“送股比例”和“转增比例”列中。例如，如果送股比例是2，转增比例是3，那么总和是5，符合高送转。因此，valid_constraint的条件是当公司进行了高送转时，即当（送股比例 + 转增比例）>=5时，是否没有披露该方案。但MEU_19_3的constraint是“不得披露高送转方案”，所以如果公司满足condition（净利润下降50%以上），那么他们不能披露高送转方案。因此，当condition满足时，如果公司披露了高送转方案（即送股和转增总和>=5），则违反约束。因此，在constraint的验证中，需要判断是否在满足condition的情况下，没有进行高送转。或者，正确的逻辑是：当公司满足condition时，他们必须不披露高送转方案。因此，在满足condition的情况下，如果公司进行了高送转（即送股+转增>=5），则违反约束。因此，valid_constraint应为：当condition为True时，是否没有进行高送转。或者，更准确地说，当subject和condition都满足时，必须满足constraint。因此，在计算合规性时，如果subject和condition都满足，但constraint不满足（即存在高送转），则违规。

现在，具体到代码：

首先，标记subject。因为subject是上市公司，所有行都是上市公司的情况，所以可能直接标记为True。但需要确认是否有例外情况。例如，可能某些行可能不是上市公司？但根据问题描述，数据中的每一行都是上市公司的情况，所以可以直接将meu_19_3_subject列设为True。

然后，标记condition。使用净利润增长率是否<=-0.5。例如，df['净利润增长率'] <= -0.5。但需要注意，净利润可能为负，但同比下降50%的计算方式是否正确。例如，如果去年同期的净利润是-100万，而当前是-200万，那么同比下降了100%，即（-200 - (-100))/(-100) = -100%的增长率，即下降了100%。所以，当净利润增长率为<=-0.5时，条件满足。因此，valid_condition = df['净利润增长率'] <= -0.5。

接下来，标记constraint。需要检查是否披露了高送转方案。高送转的定义是送股比例+转增比例>=5。因此，高送转的条件是（df['送股比例'] + df['转增比例']） >=5。而constraint是不得披露高送转方案，所以当公司进行了高送转（即送股+转增>=5）时，是否在满足condition的情况下。因此，valid_constraint应为：当subject和condition都满足时，是否没有进行高送转。或者，正确的逻辑是，当subject和condition都满足时，必须不进行高送转。因此，在标记constraint时，可能应该检查是否在满足subject和condition的情况下，高送转的情况是否存在。或者，在标记constraint列时，是否满足约束的条件是：如果subject和condition都满足，那么是否没有进行高送转。或者，可能constraint的valid_constraint列应该标记为：当subject和condition都满足时，是否没有进行高送转。或者，可能constraint的valid_constraint列是：是否没有进行高送转。但MEU的约束是“不得披露高送转方案”，所以无论是否满足condition，只要披露了高送转，就违反约束？或者，只有当满足condition时，才需要遵守这个约束。例如，当公司净利润同比下降50%以上时，才被禁止披露高送转方案。否则，他们可以披露。因此，constraint的约束仅在subject和condition都满足的情况下才适用。因此，在标记valid_constraint时，只有当subject和condition都满足时，才需要检查是否没有进行高送转。否则，constraint是否满足无关紧要。因此，valid_constraint的计算应该是：在subject和condition都满足的情况下，是否没有进行高送转。或者，可能constraint的valid_constraint列是：当subject和condition都满足时，是否没有进行高送转。因此，在代码中，valid_constraint = ~((df['送股比例'] + df['转增比例']) >=5)。但需要结合subject和condition的条件。或者，可能constraint的valid情况是：当subject和condition都满足时，必须满足不进行高送转。因此，在标记constraint列时，只有当subject和condition都为True时，才需要检查是否满足约束。否则，该行的约束条件可能不适用。因此，valid_constraint的计算可能应该是：在subject和condition都为True的情况下，是否没有进行高送转。否则，该行的约束条件视为满足？或者，可能约束条件是否满足，只有在subject和condition都满足的情况下才需要检查。否则，约束条件不适用，视为满足。因此，在代码中，valid_constraint列的值应该是：当subject和condition都为True时，是否没有进行高送转。否则，视为满足约束。例如：

valid_constraint = ~((df['送股比例'] + df['转增比例']) >=5) | (~ (valid_subject & valid_condition))

或者，更准确地说，只有当valid_subject和valid_condition都为True时，才需要检查是否满足约束。否则，约束条件不适用，视为满足。因此，valid_constraint的值应为：

当valid_subject和valid_condition都为True时，检查是否没有高送转；否则，视为满足约束。

因此，在代码中：

high_send = (df['送股比例'] + df['转增比例']) >=5

valid_constraint = ~high_send | (~ (valid_subject & valid_condition))

或者，更简单的方式是，只有当valid_subject和valid_condition都为True时，才需要满足约束。因此，在这些情况下，如果high_send为False，则valid_constraint为True，否则为False。其他情况下，valid_constraint为True（因为约束不适用）。

因此，valid_constraint = ((valid_subject & valid_condition) & (~high_send)) | (~ (valid_subject & valid_condition))

这可能比较复杂。或者，在标记constraint列时，valid_constraint列的值是True，当且仅当：如果subject和condition都满足，那么没有进行高送转。否则，视为满足约束。因此：

valid_constraint = (~high_send) | (~ (valid_subject & valid_condition))

这可能更简单。例如，当subject和condition都满足时，必须没有高送转，否则valid_constraint为False。其他情况下，valid_constraint为True。

或者，在代码中，valid_constraint的标记可能应该直接是：是否没有进行高送转。但只有当subject和condition都满足时，这个约束才生效。因此，在标记constraint列时，只有当subject和condition都满足时，才检查是否没有高送转。否则，该行的约束视为满足。例如：

valid_constraint = True  # 默认情况下为True

mask = valid_subject & valid_condition
valid_constraint[mask] = ~high_send[mask]

这可能更准确。因此，在代码中：

high_send = (df['送股比例'] + df['转增比例']) >=5
valid_constraint = pd.Series(True, index=df.index)  # 初始化为True
valid_constraint[mask] = ~high_send[mask]

其中mask是valid_subject和valid_condition同时满足的情况。

现在，将这些步骤转化为代码：

首先，初始化各列：

df['meu_19_3_subject'] = True  # 因为subject是上市公司，所有行都满足

valid_subject = df['meu_19_3_subject']  # 所有都是True

valid_condition = df['净利润增长率'] <= -0.5

high_send = (df['送股比例'] + df['转增比例']) >=5

mask = valid_subject & valid_condition

valid_constraint = pd.Series(True, index=df.index)
valid_constraint.loc[mask] = ~high_send.loc[mask]

然后，将这三个条件标记到对应的列：

df['meu_19_3_subject'] = valid_subject
df['meu_19_3_condition'] = valid_condition
df['meu_19_3_constraint'] = valid_constraint

最后，判断合规性。违规的情况是当subject和condition都满足，但constraint不满足。即：

is_violation = valid_subject & valid_condition & (~valid_constraint)

或者，因为valid_constraint在mask的情况下已经是~high_send，所以当valid_subject和valid_condition都满足时，如果high_send为True，则valid_constraint为False，导致is_violation为True。

因此，合规性列meu_19_3_compliance应标记为True，当不违规时，否则False。或者，合规性列是True表示合规，False表示违规。因此：

df['meu_19_3_compliance'] = True
df.loc[is_violation, 'meu_19_3_compliance'] = False

或者，更直接的方式：

df['meu_19_3_compliance'] = ~is_violation

现在，将这些步骤整合到函数中。需要注意，送股比例和转增比例可能为NaN，比如当公司没有进行送股或转增时。例如，如果公司只进行现金分红，那么送股比例和转增比例可能为0或者NaN？需要看数据中的情况。假设当没有送股或转增时，这两个列的值为0。例如，如果公司没有进行股票股利或公积金转增，那么送股比例和转增比例都是0，所以它们的和为0，不会触发高送转。因此，在计算high_send时，需要处理可能的NaN。例如，将NaN视为0？或者，数据中的这两个列是否总是有数值？

根据问题描述中的列说明，送股比例和转增比例是“每10股送n股”的格式，可能当没有送股或转增时，它们的值为0。因此，可以安全地相加。

综上，函数的大致结构如下：

def check_meu_19_3(df):
    # 初始化各列
    df['meu_19_3_subject'] = True  # 所有行都是上市公司
    df['meu_19_3_condition'] = df['净利润增长率'] <= -0.5
    
    # 计算高送转
    high_send = (df['送股比例'] + df['转增比例']) >=5
    # 确定需要检查约束的行
    mask = df['meu_19_3_subject'] & df['meu_19_3_condition']
    # 初始化constraint列为True
    df['meu_19_3_constraint'] = True
    # 对于需要检查的行，判断是否没有高送转
    df.loc[mask, 'meu_19_3_constraint'] = ~high_send[mask]
    
    # 判断违规情况：满足subject和condition但不满足constraint
    is_violation = mask & (~df['meu_19_3_constraint'])
    df['meu_19_3_compliance'] = ~is_violation
    
    return df

但需要处理可能的NaN值。例如，净利润增长率可能为NaN，此时valid_condition会变成False吗？因为NaN <= -0.5的结果是False？或者，需要处理NaN的情况。例如，如果净利润增长率为NaN，那么条件不满足。这可能合理，因为无法比较的情况下，条件不成立。

此外，送股比例和转增比例可能为NaN的情况如何处理？例如，如果公司没有进行送股或转增，这两个列可能为0，或者可能为NaN？根据问题描述中的列说明，这些列是存在的，所以可能不会有NaN，而是0。例如，当公司没有进行送股或转增时，送股比例和转增比例都是0。因此，high_send的计算是正确的。

现在，测试这个函数是否符合要求。例如，当某行的净利润增长率是-0.6，那么condition为True。如果此时送股+转增是5，则high_send为True，mask为True，所以constraint列为False。因此，is_violation为True，compliance为False。这符合预期，即当净利润下降超过50%时，如果进行了高送转，则违规。

另一个情况，净利润增长率是-0.4，则condition为False，此时即使有高送转，也不影响，因为约束不适用。此时，constraint列会被标记为True，所以合规性为True。

综上，这个函数应该能够正确标记各条件，并判断合规性。
","CompletionUsage(completion_tokens=3810, prompt_tokens=2083, total_tokens=5893, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=3383, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 5. 计算整体的违约情况并标记在dataframe上(meu_n_k_compliance). 

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df['meu_4_2_subject'] = False  # 初始化subject列
    df['meu_4_2_condition'] = False  # 初始化condition列
    df['meu_4_2_constrain'] = False  # 初始化constrain列

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True

    # 判断违规情况：满足主体和条件但不满足约束
    is_violation = (
        valid_subject & 
        valid_condition & 
        (~valid_constraint)
    )

    # 标记违规行
    df.loc[is_violation, 'meu_4_1_compliance'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_15_2
法律的最小可执行单元内容: {""subject"": ""上市公司"", ""condition"": ""最近一个会计年度的财务会计报告被出具非无保留意见的审计报告或者带与持续经营相关的重大不确定性段落的无保留意见的审计报告，且实施现金分红的"", ""constraint"": ""应当根据公司盈利能力、融资能力及其成本、偿债能力及现金流等情况披露现金分红方案的合理性，是否导致公司营运资金不足或者影响公司正常生产经营"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '财务数据日期', '公告日期', '公告类型', '审计意见', '总资产', '总负债', '净资产', '资产负债率',
'交易性金融资产', '衍生金融资产', '债权投资', '其他债权投资', '其他权益工具投资', '其他非流动金融资产',
'其他流动资产', '金融资产总额', '总股本', '每股净资产', '合并报表未分配利润', '母公司报表未分配利润', '净利润',
'每股净利润', '母公司报表净利润', '经营活动现金流量净额', '投资活动现金流量净额', '筹资活动现金流量净额',
'现金及现金等价物净增加额', '净资产增长率', '净利润增长率', '资产负债率变化', '金融资产增长率',
'是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划', '现金分红金额', '送股比例', '转增比例', '是否进行权益分派', '权益分派方案文本', '公司简称']

## 其中: 
- 这是一个二维的面板数据, 根据['日期', '公司简称']可以定位到特定公司在特定日期的状态. 数据已经按照公司简称和日期排序. 
- 我们的'日期'并非连续的自然日或者交易日, 而是固定的季报/半年报/年报披露后三个月内的某一个自然日, 例如'2020-05-30', '2020-09-29', ...等, 我们假定公司在这一天发布了权益分派公告(或者决定了不进行权益分派). 每个季报/半年报/年报后只会跟随一个'日期'来决定是否进行权益分派, 如何进行分派. 
- 数据的每一行包含了两个部分的数据, 分别是当时最新的财务数据和当时最新的权益分派情况. 例如, '2020-09-17'这一行可能对应了公告日期为'2020-08-27'的截至'2020-06-30'的半年报财务报告['审计意见', '总资产', ..., '现金及现金等价物净增加额'], 以及在'2020-09-17'当天公告的权益分派信息['是否进行权益分派', ..., '现金分红金额', ...]
- 所有财务数据都是以单季度的形式记录的, 不需要考虑利润表科目在半年报和年报中逐渐累加的问题. 所有的增长率都是单季的. 
- 所有资产/价格的单位都是元而非万元, 千元或百万元; 所有的比例/比率都是小数而非百分数, 除了['送股比例', '转增比例']是""每10股送n股""的格式. 
- ['审计意见']的值有""无保留意见"", ""非标准无保留意见"", ""保留意见"". 
- 这些列为布尔值: ['是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划']

- 如果希望检查权益分派方案中是否披露了特定内容, 可以使用环境中会提供的函数`llm_content_check()`, 但非披露类的合规检查中禁止使用这个函数. 
    描述: 使用LLM检查公告中是否包含特定内容
        参数:
            announcement_text: 公告全文
            traget_content: 需要检查的内容描述
        返回:
            bool: 公告中是否包含特定内容
    调用示例: 
        ```python
        from utils.tool_for_agents import llm_content_check

        constraint_description = ""为增强投资者回报水平拟采取的措施"" # 请完整描述需要检查的内容, 不得简化
        df['meu_4_1_constraint'] = df['权益分派方案文本'].apply(
            lambda text: llm_content_check(text, constraint_description)
        )
        ```

note:
 - 理论上你撰写合规检验代码所需要的数据都可以从一致的数据中得到, 对于没有直接对应的数据你需要自己计算得到, 不要简单地认为无法完成. 
 - 除非材料提供, 否则不要主动进行简化的假设. 如果你认为所给的信息不足以判断案例的合规性, 可以在函数的结尾进行注释说明. 但这种情况应该很少出现. 

","

<CODE>
import pandas as pd
from utils.tool_for_agents import llm_content_check

def check_meu_15_2(df):
    '''
    合规性检验函数：MEU_15_2
    ""subject"": ""上市公司"",
    ""condition"": ""最近一个会计年度的财务会计报告被出具非无保留意见的审计报告或者带与持续经营相关的重大不确定性段落的无保留意见的审计报告，且实施现金分红的"",
    ""constraint"": ""应当根据公司盈利能力、融资能力及其成本、偿债能力及现金流等情况披露现金分红方案的合理性，是否导致公司营运资金不足或者影响公司正常生产经营""
    '''

    # 初始化标记列
    df['meu_15_2_subject'] = True  # 所有行均为上市公司
    df['meu_15_2_condition'] = False
    df['meu_15_2_constraint'] = True  # 默认满足约束（不触发条件时无需约束）
    df['meu_15_2_compliance'] = True  # 默认合规

    # 标记条件1：审计意见类型
    audit_condition = df['审计意见'].isin(['保留意见', '非标准无保留意见'])
    # 标记条件2：实施现金分红
    dividend_condition = df['是否实施现金分红']
    # 合并条件
    valid_condition = audit_condition & dividend_condition
    df['meu_15_2_condition'] = valid_condition

    # 标记约束（仅当满足主体和条件时检查）
    constraint_description = ""根据公司盈利能力、融资能力及其成本、偿债能力及现金流等情况披露现金分红方案的合理性，是否导致公司营运资金不足或者影响公司正常生产经营""
    mask = df['meu_15_2_subject'] & df['meu_15_2_condition']
    
    # 对满足条件的行进行内容检查
    df.loc[mask, 'meu_15_2_constraint'] = df.loc[mask].apply(
        lambda row: llm_content_check(row['权益分派方案文本'], constraint_description) if pd.notna(row['权益分派方案文本']) else False,
        axis=1
    )

    # 判断违规：满足主体和条件但未满足约束
    is_violation = mask & (~df['meu_15_2_constraint'])
    df.loc[is_violation, 'meu_15_2_compliance'] = False

    return df
</CODE>","好的，我现在需要处理这个MEU_15_2的合规性检查。首先，我得仔细理解这个MEU的内容。根据提供的JSON，MEU_15_2的subject是“上市公司”，condition是当最近一个会计年度的财务报告被出具非无保留意见的审计报告或者带与持续经营相关的重大不确定性段落的无保留意见，并且实施了现金分红。constraint是公司需要根据盈利能力、融资能力及其成本、偿债能力及现金流等情况披露现金分红方案的合理性，是否导致营运资金不足或影响正常生产经营。

首先，我需要确定如何标记subject。这里的subject是上市公司，所以每一行的公司都是上市公司，可能不需要特别的条件，但可能需要确认是否有对应的字段。但根据提供的dataframe的列，可能没有直接的“公司类型”字段，但题目中的MEU是针对上市公司的，所以可能默认所有数据行都是上市公司的情况。因此，subject的条件可能总是满足，所以meu_15_2_subject列应该全部为True。或者，是否有其他条件需要考虑？比如是否存在某些情况导致公司不再是上市公司？但根据问题描述，可能假设所有数据行都是上市公司的情况，因此subject部分可以直接标记为True。

接下来是condition部分。condition有两个条件：审计意见类型和是否实施现金分红。审计意见需要是“非无保留意见”或者带有持续经营相关段落的无保留意见。根据提供的列中的['审计意见']的可能值，包括“无保留意见”、“非标准无保留意见”、“保留意见”。这里可能需要明确“非无保留意见”包括哪些。例如，“非标准无保留意见”可能指的是带强调事项段或其他事项段的无保留意见，而“保留意见”则是更严重的。另外，带持续经营相关的重大不确定性的段落可能属于“非标准无保留意见”中的一种。因此，condition中的审计意见条件应该是审计意见为“保留意见”或“非标准无保留意见”，并且同时实施了现金分红（即['是否实施现金分红']为True）。

然后是constraint部分，要求公司必须披露现金分红方案的合理性，是否导致营运资金不足或影响正常生产经营。这部分可能需要检查权益分派方案文本中是否包含这些内容。根据附加信息中的说明，可以使用llm_content_check函数来检查公告文本是否包含相关披露。因此，需要将constraint的条件设置为：当满足subject和condition的情况下，检查权益分派方案文本是否包含对盈利能力、融资能力及其成本、偿债能力、现金流等的分析，以及是否导致营运资金不足或影响生产经营的说明。

现在，我需要将这些逻辑转化为代码。

首先，处理subject。因为subject是上市公司，而数据中的每一行都是上市公司的情况，所以meu_15_2_subject列应该全部为True。但可能需要确认是否有字段表明公司是否是上市公司。但根据问题描述，可能假设所有数据行都是上市公司，所以直接标记为True。

接下来，condition部分。需要满足两个条件：审计意见符合要求，并且实施了现金分红。审计意见的条件是审计意见属于“非无保留意见”或者带有持续经营段落的无保留意见。根据提供的审计意见的可能值，“非标准无保留意见”可能对应带持续经营段落的无保留意见。因此，审计意见的条件是审计意见为“保留意见”或“非标准无保留意见”。然后，是否实施现金分红由['是否实施现金分红']为True来判断。因此，valid_condition = (df['审计意见'].isin(['保留意见', '非标准无保留意见'])) & (df['是否实施现金分红'] == True)。

然后是constraint部分。需要检查权益分派方案文本是否披露了要求的合理性分析。这里需要使用llm_content_check函数。需要构造目标描述字符串，例如：“披露现金分红方案的合理性，包括公司盈利能力、融资能力及其成本、偿债能力及现金流等情况，并说明是否导致公司营运资金不足或者影响公司正常生产经营”。然后，对每一行的权益分派方案文本应用这个检查。因此，valid_constraint = df.apply(lambda row: llm_content_check(row['权益分派方案文本'], constraint_description), axis=1)。但需要注意，只有当满足subject和condition的情况下，才需要检查constraint。不过，在代码中，可能先对所有行进行标记，然后在整体合规性判断时处理。

最后，整体合规性判断：当subject、condition都满足，但constraint不满足时，视为违规。即，合规性为False的情况是subject和condition都为True，但constraint为False。否则，合规性为True或者不适用。

现在，将这些步骤转化为代码：

1. 初始化各列：
df['meu_15_2_subject'] = True （假设所有行都是上市公司）
2. 标记condition：
valid_condition = (df['审计意见'].isin(['保留意见', '非标准无保留意见'])) & df['是否实施现金分红']
3. 标记constraint：
需要调用llm_content_check，检查权益分派方案文本是否包含所需内容。目标描述是“应当根据公司盈利能力、融资能力及其成本、偿债能力及现金流等情况披露现金分红方案的合理性，是否导致公司营运资金不足或者影响公司正常生产经营”。因此，constraint_description = ""根据公司盈利能力、融资能力及其成本、偿债能力及现金流等情况披露现金分红方案的合理性，是否导致公司营运资金不足或者影响公司正常生产经营""。然后，对于每一行，如果满足subject和condition，则检查该内容是否存在。但根据代码框架，constraint的标记可能直接对所有行进行检查，但可能只有在满足subject和condition时才需要应用。不过，在示例代码中，constraint的标记是独立进行的，可能在后续步骤中结合其他条件判断。

但根据示例中的处理方式，可能直接对所有行进行标记，不管是否满足subject和condition。例如，在示例中，valid_constraint的计算可能不考虑其他条件，但最终合规性判断时才会结合subject和condition的条件。因此，在代码中，可能先计算constraint的条件，不管其他条件是否满足。例如：

df['meu_15_2_constraint'] = df.apply(lambda x: llm_content_check(x['权益分派方案文本'], constraint_description) if x['是否实施现金分红'] else False, axis=1)

或者更准确地说，只有当满足condition的情况下，才需要检查constraint。但可能更简单的方式是，无论是否满足condition，都进行检查，但最终合规性判断时，只有当subject和condition都满足时，才需要constraint满足。例如，在示例中，valid_constraint的计算可能不考虑其他条件，但合规性判断时，只有当subject和condition都为True时，才需要constraint为True，否则合规性可能为True或无关。

不过，根据MEU的逻辑，只有当subject和condition都满足时，才需要检查constraint。因此，在计算constraint时，可能只需要在满足subject和condition的情况下进行检查。否则，constraint可能不需要满足，或者标记为True或False不影响最终结果。但为了正确标记constraint列，可能需要仅在满足subject和condition的情况下应用检查，否则可能标记为True或False？

或者，可能更简单的方式是，不管其他条件，只要在实施现金分红的情况下，并且审计意见符合条件，才需要检查constraint。但根据MEU的condition，只有当审计意见符合条件且实施现金分红时，才触发约束条件。因此，在计算constraint时，只有当condition满足时，才需要检查是否满足约束。否则，constraint的满足与否无关紧要。

因此，正确的处理方式应该是：只有当condition满足时，才需要检查constraint是否满足。否则，constraint的标记可能为True或无关。但根据代码框架，可能需要将constraint的valid标记为True或False，不管其他条件。例如，在示例中，valid_constraint的计算可能独立于其他条件，但最终合规性判断时，只有当subject和condition都满足时，才需要constraint满足。

因此，在代码中，可能：

valid_constraint = df.apply(lambda row: llm_content_check(row['权益分派方案文本'], constraint_description) if (row['meu_15_2_subject'] and row['meu_15_2_condition']) else False, axis=1)

或者，更准确地说，只有当subject和condition都满足时，才需要检查constraint。否则，constraint的valid可能标记为True或无关。但根据合规性判断的逻辑，只有当subject和condition都满足时，才需要constraint满足。否则，该行不涉及该MEU的合规性问题。

因此，在代码中，可能：

对于constraint的valid标记，只有当subject和condition都为True时，才需要检查是否满足约束。否则，可能标记为True（因为不需要满足约束）或者不处理。但根据合规性判断的逻辑，只有当subject和condition都满足时，才需要constraint满足，否则该行不违规。因此，在标记constraint时，可能对所有行进行检查，但最终在合规性判断时，只有当subject和condition都满足时，才需要constraint为True，否则合规性为True。

或者，可能更简单的方式是，在计算valid_constraint时，只有当condition和subject满足时，才进行判断，否则标记为True（因为此时不需要满足约束）。例如：

valid_constraint = (df['meu_15_2_subject'] & df['meu_15_2_condition']) ? (检查结果) : True

但这样可能比较复杂。或者，在代码中，先对所有行进行constraint的检查，不管是否满足condition，然后在合规性判断时，只有当subject和condition都满足时，才需要constraint满足。否则，合规性为True。

例如，在示例中，合规性判断是当subject和condition满足，但constraint不满足时，标记为违规。否则，合规。

因此，在代码中：

合规性 = 当subject和condition都为True时，constraint必须为True，否则违规。其他情况不违规。

因此，在代码中：

is_violation = (df['meu_15_2_subject'] & df['meu_15_2_condition'] & (~df['meu_15_2_constraint']))

然后，合规性列标记为False当且仅当is_violation为True，否则为True或者不标记？

或者，合规性列应该标记为True（合规）或False（违规）。因此：

df['meu_15_2_compliance'] = ~is_violation

或者，可能更准确的是，合规性为True的情况是：当subject和condition满足时，constraint也满足；或者当subject或condition不满足时，无需考虑。因此，合规性为True的情况包括：

- 不满足subject或condition，因此无需满足constraint；
- 满足subject和condition，并且满足constraint。

违规的情况是：满足subject和condition，但不满足constraint。

因此，合规性列应标记为True，除非满足subject和condition且不满足constraint，此时标记为False。

现在，将这些逻辑转化为代码：

首先，初始化各列：

df['meu_15_2_subject'] = True  # 假设所有行都是上市公司

然后，标记condition：

valid_condition = (df['审计意见'].isin(['保留意见', '非标准无保留意见'])) & (df['是否实施现金分红'] == True)

df['meu_15_2_condition'] = valid_condition

接下来，标记constraint：

需要检查权益分派方案文本是否包含所需内容。这里需要构造constraint_description，即MEU中的constraint字段的内容。即：

constraint_description = ""应当根据公司盈利能力、融资能力及其成本、偿债能力及现金流等情况披露现金分红方案的合理性，是否导致公司营运资金不足或者影响公司正常生产经营""

然后，对于每一行，如果满足subject和condition，则检查权益分派方案文本是否包含该内容。否则，可能标记为True或者不适用。但根据代码框架，可能对所有行进行标记，不管是否满足条件。例如：

df['meu_15_2_constraint'] = df.apply(lambda row: llm_content_check(row['权益分派方案文本'], constraint_description) if pd.notnull(row['权益分派方案文本']) else False, axis=1)

但需要注意，只有当公司实施了现金分红（即condition满足）时，才会存在权益分派方案文本。或者，可能只有当是否实施现金分红为True时，权益分派方案文本才存在。因此，在应用llm_content_check时，可能需要检查是否实施现金分红，并且权益分派方案文本是否非空。例如：

df['meu_15_2_constraint'] = False  # 默认False

mask = (df['是否实施现金分红'] == True) & (df['权益分派方案文本'].notnull())
df.loc[mask, 'meu_15_2_constraint'] = df.loc[mask].apply(lambda row: llm_content_check(row['权益分派方案文本'], constraint_description), axis=1)

或者，更准确地说，只有当满足subject和condition时，才需要检查constraint。因此，在计算constraint时，只有当subject和condition都为True时，才应用llm_content_check。否则，可能标记为True或False？

或者，可能不管其他条件，只要存在权益分派方案文本，就进行检查。但根据MEU的约束条件，只有当公司实施了现金分红且满足审计意见条件时，才需要披露。因此，在计算constraint的valid时，只有当condition满足时，才需要检查。否则，constraint的valid可能无关紧要。

因此，正确的处理方式应该是：

当condition满足时（即subject和condition都为True），检查constraint是否满足。否则，constraint的valid可能标记为True（因为不需要满足约束），或者不处理。但根据合规性判断的逻辑，只有当condition和subject都满足时，才需要constraint满足。因此，在标记constraint时，可能只对满足condition和subject的行进行检查，其他行标记为True或False？

或者，在代码中，可能对所有行进行constraint的检查，但最终合规性判断时，只有当subject和condition都满足时，才需要constraint满足。否则，合规性为True。

例如：

df['meu_15_2_constraint'] = df.apply(lambda row: llm_content_check(row['权益分派方案文本'], constraint_description) if (row['meu_15_2_subject'] and row['meu_15_2_condition']) else True, axis=1)

这样，当不满足subject或condition时，constraint标记为True，意味着这些行不会触发违规。这可能更合理，因为只有当subject和condition都满足时，才需要constraint满足，否则不需要。因此，在合规性判断时，只有当subject和condition都满足时，才需要检查constraint是否为True。如果constraint在此时为False，则违规。否则，合规。

但这样处理可能比较复杂。或者，在计算constraint时，只有当subject和condition都满足时，才进行实际的检查，否则标记为True。例如：

df['meu_15_2_constraint'] = True  # 默认True

mask = df['meu_15_2_subject'] & df['meu_15_2_condition']
df.loc[mask, 'meu_15_2_constraint'] = df.loc[mask].apply(lambda row: llm_content_check(row['权益分派方案文本'], constraint_description), axis=1)

这样，对于满足subject和condition的行，检查是否满足constraint，其他行标记为True，这样在合规性判断时，只有当subject和condition满足时，才需要constraint为True，否则自动满足，不会触发违规。

这可能更合理，因为对于不满足subject或condition的行，不需要满足constraint，因此constraint的valid标记为True，这样在合规性判断时，这些行不会触发违规。

现在，将这些步骤整合到代码中：

首先，标记subject：

df['meu_15_2_subject'] = True  # 假设所有行都是上市公司

然后，标记condition：

valid_condition = (df['审计意见'].isin(['保留意见', '非标准无保留意见'])) & df['是否实施现金分红']
df['meu_15_2_condition'] = valid_condition

接下来，标记constraint：

constraint_description = ""应当根据公司盈利能力、融资能力及其成本、偿债能力及现金流等情况披露现金分红方案的合理性，是否导致公司营运资金不足或者影响公司正常生产经营""

# 初始化constraint列为True
df['meu_15_2_constraint'] = True

# 仅当满足subject和condition时，检查约束
mask = df['meu_15_2_subject'] & df['meu_15_2_condition']
# 需要确保在这些情况下，权益分派方案文本存在
df.loc[mask, 'meu_15_2_constraint'] = df.loc[mask].apply(
    lambda row: llm_content_check(row['权益分派方案文本'], constraint_description) if pd.notnull(row['权益分派方案文本']) else False,
    axis=1
)

这里，如果权益分派方案文本为空，则标记为False，因为无法检查到所需内容。这可能意味着公司没有披露，因此违反约束。

然后，合规性判断：

is_violation = (df['meu_15_2_subject'] & df['meu_15_2_condition'] & (~df['meu_15_2_constraint']))
df['meu_15_2_compliance'] = ~is_violation

这样，只有当subject和condition都满足，且constraint不满足时，才标记为违规（compliance为False）。

最后，返回处理后的df。

现在，检查可能的错误点：

1. 审计意见的可能值是否正确？根据问题描述，['审计意见']的可能值为“无保留意见”、“非标准无保留意见”、“保留意见”。而MEU中的condition包括“非无保留意见”或带持续经营段落的无保留意见。这里，“非无保留意见”可能包括保留意见、否定意见、无法表示意见等，但根据提供的可能值，只有“保留意见”和“非标准无保留意见”。假设“非标准无保留意见”包括带持续经营段落的无保留意见，因此condition的条件是正确的。

2. 是否实施现金分红的条件是否正确？是的，使用['是否实施现金分红']为True。

3. 在标记constraint时，是否只在满足subject和condition的情况下检查？是的，通过mask筛选这些行。

4. 使用llm_content_check是否正确？是的，当权益分派方案文本存在时，调用该函数检查是否包含所需内容。

5. 如果权益分派方案文本为空，但满足subject和condition，则标记为False，导致违规。这可能正确，因为公司必须披露，如果未披露则违规。

综上，代码应该如下：
","CompletionUsage(completion_tokens=4557, prompt_tokens=2052, total_tokens=6609, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=4011, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 

# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 5. 计算整体的违约情况并标记在dataframe上(meu_n_k_compliance). 

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df['meu_4_2_subject'] = False  # 初始化subject列
    df['meu_4_2_condition'] = False  # 初始化condition列
    df['meu_4_2_constrain'] = False  # 初始化constrain列

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True

    # 判断违规情况：满足主体和条件但不满足约束
    is_violation = (
        valid_subject & 
        valid_condition & 
        (~valid_constraint)
    )

    # 标记违规行
    df.loc[is_violation, 'meu_4_1_compliance'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_19_4
法律的最小可执行单元内容: {""subject"": ""上市公司"", ""condition"": ""送转股后每股收益低于0.2元"", ""constraint"": ""不得披露高送转方案"", ""contextual_info"": NaN}
必要的额外信息: ""每股收益""简化为采用""每股净利润""

你被分配的MEU coding任务存在refer_to关系, 你需要参考下面这个MEU的必要内容来完成你被安排的任务, 但你不需要直接执行下面的MEU: 
【MEU_17_1】
subject: nan
condition: nan
constrain: nan
contextual_info: 本指引所称高送转，是指公司每十股送红股与公积金转增股本，合计达到或者超过五股


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '财务数据日期', '公告日期', '公告类型', '审计意见', '总资产', '总负债', '净资产', '资产负债率',
'交易性金融资产', '衍生金融资产', '债权投资', '其他债权投资', '其他权益工具投资', '其他非流动金融资产',
'其他流动资产', '金融资产总额', '总股本', '每股净资产', '合并报表未分配利润', '母公司报表未分配利润', '净利润',
'每股净利润', '母公司报表净利润', '经营活动现金流量净额', '投资活动现金流量净额', '筹资活动现金流量净额',
'现金及现金等价物净增加额', '净资产增长率', '净利润增长率', '资产负债率变化', '金融资产增长率',
'是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划', '现金分红金额', '送股比例', '转增比例', '是否进行权益分派', '权益分派方案文本', '公司简称']

## 其中: 
- 这是一个二维的面板数据, 根据['日期', '公司简称']可以定位到特定公司在特定日期的状态. 数据已经按照公司简称和日期排序. 
- 我们的'日期'并非连续的自然日或者交易日, 而是固定的季报/半年报/年报披露后三个月内的某一个自然日, 例如'2020-05-30', '2020-09-29', ...等, 我们假定公司在这一天发布了权益分派公告(或者决定了不进行权益分派). 每个季报/半年报/年报后只会跟随一个'日期'来决定是否进行权益分派, 如何进行分派. 
- 数据的每一行包含了两个部分的数据, 分别是当时最新的财务数据和当时最新的权益分派情况. 例如, '2020-09-17'这一行可能对应了公告日期为'2020-08-27'的截至'2020-06-30'的半年报财务报告['审计意见', '总资产', ..., '现金及现金等价物净增加额'], 以及在'2020-09-17'当天公告的权益分派信息['是否进行权益分派', ..., '现金分红金额', ...]
- 所有财务数据都是以单季度的形式记录的, 不需要考虑利润表科目在半年报和年报中逐渐累加的问题. 所有的增长率都是单季的. 
- 所有资产/价格的单位都是元而非万元, 千元或百万元; 所有的比例/比率都是小数而非百分数, 除了['送股比例', '转增比例']是""每10股送n股""的格式. 
- ['审计意见']的值有""无保留意见"", ""非标准无保留意见"", ""保留意见"". 
- 这些列为布尔值: ['是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划']

- 如果希望检查权益分派方案中是否披露了特定内容, 可以使用环境中会提供的函数`llm_content_check()`, 但非披露类的合规检查中禁止使用这个函数. 
    描述: 使用LLM检查公告中是否包含特定内容
        参数:
            announcement_text: 公告全文
            traget_content: 需要检查的内容描述
        返回:
            bool: 公告中是否包含特定内容
    调用示例: 
        ```python
        from utils.tool_for_agents import llm_content_check

        constraint_description = ""为增强投资者回报水平拟采取的措施"" # 请完整描述需要检查的内容, 不得简化
        df['meu_4_1_constraint'] = df['权益分派方案文本'].apply(
            lambda text: llm_content_check(text, constraint_description)
        )
        ```

note:
 - 理论上你撰写合规检验代码所需要的数据都可以从一致的数据中得到, 对于没有直接对应的数据你需要自己计算得到, 不要简单地认为无法完成. 
 - 除非材料提供, 否则不要主动进行简化的假设. 如果你认为所给的信息不足以判断案例的合规性, 可以在函数的结尾进行注释说明. 但这种情况应该很少出现. 

","

<CODE>
import pandas as pd

def check_meu_19_4(df):
    '''
    检查上市公司在送转股后每股收益低于0.2元时是否违规披露高送转方案。
    MEU内容:
    - subject: 上市公司
    - condition: 送转股后每股收益低于0.2元
    - constraint: 不得披露高送转方案
    '''

    # 初始化标记列
    df['meu_19_4_subject'] = True  # 所有行主体均为上市公司
    df['meu_19_4_condition'] = False
    df['meu_19_4_constraint'] = True
    df['meu_19_4_compliance'] = True

    # 计算高送转条件（每10股送转合计≥5股）
    total_sz_ratio = df['送股比例'] + df['转增比例']
    is_high_sz = total_sz_ratio >= 5

    # 计算送转后每股收益（考虑股本扩张效应）
    df['post_eps'] = df['每股净利润'] * 10 / (10 + total_sz_ratio)

    # 条件验证：实际实施高送转且送转后EPS<0.2
    valid_condition = (
        df['是否进行权益分派'] & 
        is_high_sz & 
        (df['post_eps'] < 0.2)
    )
    df['meu_19_4_condition'] = valid_condition

    # 约束验证：当条件成立时不得实施高送转
    df['meu_19_4_constraint'] = ~valid_condition

    # 计算整体合规性（满足主体且违反约束时违规）
    violation = df['meu_19_4_subject'] & valid_condition
    df['meu_19_4_compliance'] = ~violation

    # 清理中间列
    df.drop(columns=['post_eps'], inplace=True, errors='ignore')

    return df
</CODE>","好的，我现在需要为MEU_19_4编写一个合规性检查的函数。首先，我得仔细理解这个MEU的内容。MEU_19_4的subject是“上市公司”，condition是“送转股后每股收益低于0.2元”，constraint是“不得披露高送转方案”。contextual_info是空的，但需要参考MEU_17_1中的高送转定义，即每十股送转合计达到或超过五股。

首先，处理subject部分。这里的主体是上市公司，所以每一行数据都代表公司的行为，所以所有行的subject应该都是符合条件的。因此，meu_19_4_subject列可以直接标记为True，因为每行都是上市公司本身的情况。

接下来是condition条件。条件是送转股后每股收益低于0.2元。这里需要计算送转股后的每股净利润。原来的每股净利润是财务数据中的“每股净利润”列。送转股会导致总股本增加，从而稀释每股收益。例如，如果公司进行每10股转增5股，那么总股本会增加50%。因此，送转后的每股收益应该是原每股净利润除以（1 + 送转比例/10）。比如，转增5股的话，总股本变为原来的1.5倍，所以每股收益变为原来的2/3。

所以，我需要先计算送转股的比例。送股比例和转增比例在数据中是“每10股送n股”和“每10股转增n股”的格式。比如，送股比例如果是1，表示每10股送1股，总股本增加10%？或者需要将送股和转增合并计算？根据MEU_17_1的定义，高送转是每十股合计送转达到或超过五股。所以，送转比例总和是送股比例加上转增比例。例如，送3股转2股，合计5股，符合高送转的条件。

但MEU_19_4的condition是送转股后的每股收益是否低于0.2元。所以，不管是否属于高送转，只要进行了送转股，就需要计算送转后的每股收益。但可能这里的送转股指的是高送转的情况？或者不管送转多少，只要送转后每股收益低于0.2元，就触发条件？

根据MEU_19_4的描述，condition是“送转股后每股收益低于0.2元”，而constraint是“不得披露高送转方案”。所以，可能当公司计划进行高送转时，如果送转后的每股收益会低于0.2元，那么他们就不能披露这个方案。因此，condition的条件是：如果公司计划进行高送转（即送转比例合计>=5股每10股），并且送转后的每股收益低于0.2元，那么触发条件，此时必须满足constraint，即不得披露该方案。

但MEU_19_4的condition是否仅指高送转后的情况？或者任何送转股后的情况？需要仔细看MEU的描述。原MEU的condition是“送转股后每股收益低于0.2元”，而constraint是“不得披露高送转方案”。所以，可能这里的送转股指的是高送转的情况。也就是说，当公司打算进行高送转（根据MEU_17_1的定义，送转合计>=5股），并且送转后的每股收益低于0.2元时，不得披露该方案。

所以，condition的条件应该是：公司的高送转方案（送转合计>=5股）导致送转后的每股收益低于0.2元。这时候，必须满足constraint，即不得披露该方案。

因此，condition的valid条件应该是：公司有高送转方案（送转合计>=5股），并且送转后的每股收益<0.2元。这时候，触发条件，需要检查是否违反constraint。

那如何计算送转后的每股收益呢？

假设原每股净利润是EPS0，送转比例是S（每10股送S股）和Z（每10股转增Z股）。总送转股数为S + Z股每10股，即每10股变为10 + S + Z股。总股本变为原来的 (10 + S + Z)/10 倍。因此，送转后的每股净利润为 EPS0 * 10 / (10 + S + Z)。

例如，原EPS是0.3元，送转合计5股，那么送转后的EPS是0.3 * 10 / 15 = 0.2元。如果原EPS是0.25元，送转合计5股，则送转后的EPS是0.25 * 10/15 ≈0.1667元，低于0.2元，触发条件。

所以，condition的条件是：送转后的EPS = 原EPS * 10 / (10 + S + Z) < 0.2元，并且送转合计>=5股（即属于高送转）。

那如何确定公司是否计划进行高送转？根据数据中的“送股比例”和“转增比例”列。如果送股比例 + 转增比例 >=5，则属于高送转。例如，送股比例是2，转增比例是3，合计5，属于高送转。

所以，condition的valid条件需要同时满足：

1. 公司进行了高送转（送股比例 + 转增比例 >=5）

2. 送转后的每股净利润 <0.2元

这时候，触发条件，此时必须满足constraint，即不得披露该高送转方案。如果此时公司确实披露了高送转方案，则违反constraint，属于违规。

现在，如何将这些条件转化为代码？

首先，处理subject部分：所有行的subject都是上市公司，所以meu_19_4_subject列直接设为True。

然后，condition部分：

- 检查是否属于高送转：送股比例 + 转增比例 >=5。注意，这里的送股比例和转增比例是每10股的数值。例如，送股比例是3，转增比例是2，合计5，符合条件。

- 计算送转后的每股净利润：原每股净利润 * 10 / (10 + 送股比例 + 转增比例)

- 检查送转后的每股净利润是否 <0.2元。

所以，valid_condition的条件是：高送转（送股+转增>=5）且送转后的EPS <0.2。

接下来，constraint部分：不得披露高送转方案。即，如果触发了condition（即高送转且EPS低于0.2），那么公司不能披露该方案。因此，如果此时公司确实有高送转方案（即送股比例+转增比例>=5，并且是否进行权益分派为True，并且送股或转增的比例符合高送转），则违反constraint。

或者，constraint的valid条件是：当触发condition时，公司没有披露高送转方案。即，如果condition为True，那么公司是否进行了高送转？如果此时公司进行了高送转，则违反constraint；如果没有，则符合。

或者，constraint是“不得披露高送转方案”，所以当触发condition时，如果公司披露了高送转方案，则违反。否则，符合。

所以，constraint的valid条件是：当condition为True时，公司没有进行高送转。或者，当公司进行了高送转，并且触发condition时，则违反。

可能更准确的是，当公司的高送转方案会导致送转后的EPS低于0.2元时，他们不得披露该方案。因此，如果公司在这种情况下仍然披露了高送转方案（即送股比例+转增比例>=5，并且是否进行权益分派为True），则违反constraint。

所以，constraint的valid条件是：如果condition为True，那么公司没有进行高送转（即送股比例+转增比例<5，或者没有进行权益分派中的高送转）。

或者，更准确地说，当condition为True时，公司不得披露高送转方案。因此，如果此时公司确实披露了高送转方案（即是否进行权益分派为True，并且送股+转增>=5），则违反constraint。

所以，constraint的valid条件是：当condition为True时，公司没有进行高送转（即送股+转增<5，或者没有进行权益分派中的高送转）。

或者，当condition为True时，公司是否进行了高送转？如果进行了，则违反constraint；否则，符合。

因此，constraint的valid条件可以表示为：当condition为True时，公司没有进行高送转。或者，当公司进行了高送转，并且condition为True时，则违反。

所以，在代码中，constraint的valid条件应该是：当condition为True时，公司没有进行高送转。或者，当公司进行了高送转，并且condition为True时，constraint为False（即违反）。

这可能比较复杂。需要仔细处理。

现在，总结各步骤：

1. 标记subject：所有行都是上市公司，所以meu_19_4_subject = True。

2. 标记condition：

   a. 计算是否高送转：送股比例 + 转增比例 >=5。

   b. 计算送转后的每股净利润：原每股净利润 * 10 / (送股比例 + 转增比例 + 10)。

   c. condition的条件是：高送转，并且送转后的EPS <0.2。

3. 标记constraint：

   a. 当condition为True时，公司是否进行了高送转？即，是否在权益分派中实际执行了高送转？

   这里的数据中的“是否进行权益分派”列可能表示是否进行了分派，而送股比例和转增比例可能只有在进行权益分派时才有效。例如，如果“是否进行权益分派”为True，并且送股比例+转增比例>=5，则公司确实披露了高送转方案。此时，如果condition为True，则违反constraint。

   因此，constraint的valid条件是：当condition为True时，公司没有进行高送转（即，送股比例+转增比例<5，或者“是否进行权益分派”为False）。

或者，更准确地说，当condition为True时，如果公司披露了高送转方案（即“是否进行权益分派”为True，并且送股+转增>=5），则违反constraint，即constraint_valid为False。否则，constraint_valid为True。

所以，constraint的valid条件可以表示为：当condition为True时，公司没有进行高送转（即，不满足高送转的条件，或者没有进行权益分派）。

或者，当condition为True时，如果公司进行了高送转，则违反constraint，否则符合。

因此，在代码中：

valid_constraint = ~(condition & 公司进行了高送转)

或者，当condition为True时，如果公司进行了高送转，则constraint_valid为False，否则为True。

现在，如何判断公司是否进行了高送转？

根据数据中的“是否进行权益分派”列，以及送股比例和转增比例。如果“是否进行权益分派”为True，并且送股比例 + 转增比例 >=5，则公司进行了高送转。

所以，在代码中：

is_high_sz = (df['送股比例'] + df['转增比例'] >=5) & df['是否进行权益分派']

当condition为True时，如果is_high_sz为True，则constraint_valid为False，否则为True。

所以，valid_constraint的条件是：当condition为True时，is_high_sz为False。

因此，valid_constraint = ~(valid_condition & is_high_sz)

或者，更准确地说：

valid_constraint = ~(valid_condition & (df['送股比例'] + df['转增比例'] >=5) & df['是否进行权益分派'])

或者，当valid_condition为True时，如果公司进行了高送转，则constraint_valid为False，否则为True。

所以，在代码中：

valid_constraint = True  # 默认情况下为True

# 当condition为True时，检查是否进行了高送转
mask = valid_condition
is_high_sz = (df['送股比例'] + df['转增比例'] >=5) & df['是否进行权益分派']
valid_constraint[mask] = ~is_high_sz[mask]

或者，在代码中，可以这样处理：

valid_constraint = ~(valid_condition & ((df['送股比例'] + df['转增比例'] >=5) & df['是否进行权益分派']))

这可能更简洁。

现在，将这些步骤转化为代码。

首先，处理subject：

df['meu_19_4_subject'] = True  # 所有行都是上市公司，所以直接设为True

然后，处理condition：

# 计算是否高送转
high_sz = (df['送股比例'] + df['转增比例'] >=5)

# 计算送转后的每股净利润
sz_ratio = df['送股比例'] + df['转增比例']
post_eps = df['每股净利润'] * 10 / (10 + sz_ratio)

# condition的条件：高送转且送转后EPS <0.2
valid_condition = high_sz & (post_eps < 0.2)

然后，处理constraint：

# 当condition为True时，公司是否进行了高送转（即是否进行权益分派且送转比例>=5）
is_high_sz_implemented = (df['送股比例'] + df['转增比例'] >=5) & df['是否进行权益分派']

# constraint的valid条件是：当condition为True时，没有进行高送转
valid_constraint = ~(valid_condition & is_high_sz_implemented)

或者，更准确地说，当condition为True时，如果公司进行了高送转，则constraint不满足，否则满足。所以：

valid_constraint = True  # 默认情况下为True

# 当condition为True时，检查是否进行了高送转
valid_constraint[valid_condition] = ~is_high_sz_implemented[valid_condition]

这可能更正确。

现在，将这些条件标记到对应的列：

df['meu_19_4_condition'] = valid_condition
df['meu_19_4_constraint'] = valid_constraint

最后，判断整体合规性：

# 违规情况：满足subject和condition，但不满足constraint
is_violation = df['meu_19_4_subject'] & df['meu_19_4_condition'] & (~df['meu_19_4_constraint'])

df['meu_19_4_compliance'] = ~is_violation

或者，可能更准确的是，当subject、condition为True，而constraint为False时，违规。

现在，将这些步骤整合到函数中。

需要注意的是，在计算post_eps时，如果送股比例和转增比例都是0，那么分母是10，这时候post_eps等于原每股净利润。但此时，high_sz条件不满足，所以valid_condition为False，不影响结果。

另外，当公司没有进行权益分派时，送股比例和转增比例可能为0，或者可能没有填写？需要看数据中的情况。例如，如果“是否进行权益分派”为False，那么送股比例和转增比例可能为0，或者可能为其他值？但根据数据描述，这些列可能只有在进行权益分派时才有有效值。或者，不管是否进行权益分派，送股比例和转增比例可能都有数值，但只有当“是否进行权益分派”为True时，这些比例才实际生效。

例如，如果公司没有进行权益分派，那么即使送股比例和转增比例很高，也不会实际执行，所以此时即使high_sz为True，但因为没有进行权益分派，所以condition中的高送转是否成立？

根据MEU_19_4的condition是“送转股后每股收益低于0.2元”，这里的送转股是否指实际执行的送转股？或者计划中的？

根据数据中的情况，每一行对应的是公司在某个日期决定是否进行权益分派，并公告相关方案。所以，如果公司在该日期公告了高送转方案（即送股比例+转增比例>=5，并且“是否进行权益分派”为True），那么此时需要计算送转后的EPS是否低于0.2元。如果公司没有进行权益分派，或者送转比例不足5，则condition不成立。

所以，在计算condition时，是否应该考虑“是否进行权益分派”为True的情况？

例如，只有当公司进行权益分派（即“是否进行权益分派”为True），并且送转比例>=5，才可能触发condition。否则，即使送转比例>=5，但公司没有进行权益分派，那么condition不成立。

或者，condition的条件是“送转股后”，即假设公司执行了送转股，那么EPS是否低于0.2元。不管公司是否实际执行，只要在公告中计划执行，就需要检查。

这可能取决于具体的法律条文。根据MEU_19_4的描述，condition是“送转股后每股收益低于0.2元”，而constraint是“不得披露高送转方案”。所以，当公司计划进行高送转（即披露方案）时，如果送转后的EPS低于0.2元，则不得披露。因此，condition的条件是：公司计划进行高送转（即披露了高送转方案），并且送转后的EPS低于0.2元。

因此，在计算condition时，需要同时满足：

1. 公司进行了权益分派（即“是否进行权益分派”为True）

2. 送股比例+转增比例>=5

3. 送转后的EPS <0.2元

这样，condition的valid条件应为：

valid_condition = (df['是否进行权益分派'] == True) & (high_sz) & (post_eps <0.2)

这可能更准确。因为如果公司没有进行权益分派，那么即使送股比例+转增比例>=5，也不属于计划中的送转股，所以condition不成立。

所以，之前的condition计算可能存在问题，需要修正。

因此，正确的condition条件应该是：

公司进行了权益分派（即“是否进行权益分派”为True），并且送股比例+转增比例>=5，并且送转后的EPS <0.2元。

这样，valid_condition的条件是这三个条件的交集。

因此，在代码中：

high_sz = (df['送股比例'] + df['转增比例'] >=5)

implemented = df['是否进行权益分派']

post_eps = df['每股净利润'] * 10 / (10 + df['送股比例'] + df['转增比例'])

valid_condition = implemented & high_sz & (post_eps <0.2)

这样，只有当公司实际进行了权益分派，并且是高送转，并且送转后的EPS低于0.2元时，condition才为True。

此时，constraint的条件是：当condition为True时，公司不得披露高送转方案。但此时公司已经进行了权益分派中的高送转，所以违反了constraint。因此，constraint的valid条件是：当condition为True时，公司没有进行高送转。但此时，如果condition为True，说明公司已经进行了高送转，所以constraint必然为False。这似乎矛盾。

或者，可能我的理解有误。MEU_19_4的constraint是“不得披露高送转方案”，当公司计划的高送转会导致EPS低于0.2元时，他们不能披露该方案。因此，如果公司在这种情况下仍然披露了高送转方案（即“是否进行权益分派”为True，并且送转比例>=5），则违反constraint。

所以，condition的条件是：公司披露了高送转方案（即“是否进行权益分派”为True，送转比例>=5），并且送转后的EPS <0.2元。此时，constraint要求公司不得披露该方案，所以如果此时公司确实披露了，则违反。

因此，当condition为True时，公司已经披露了高送转方案，所以constraint的valid条件为False，即违反。

所以，在代码中，constraint的valid条件应该是：当condition为True时，是否没有进行高送转？但此时condition为True的条件是公司进行了高送转，所以这不可能。因此，当condition为True时，constraint必然为False，即违规。

这可能意味着，当condition为True时，公司已经进行了高送转，此时违反constraint。因此，constraint的valid条件为False。

因此，在代码中，constraint的valid条件可以简化为：当condition为True时，是否没有进行高送转？但此时condition为True的条件是公司进行了高送转，所以这不可能。因此，当condition为True时，constraint_valid必然为False。因此，constraint_valid = ~valid_condition ?

这显然不对。或者，可能我的逻辑有误。

重新梳理：

MEU_19_4的约束是：当公司送转股后每股收益低于0.2元时，不得披露高送转方案。因此，如果公司在这种情况下仍然披露了高送转方案，则违规。

所以，违规的情况是：公司披露了高送转方案（即进行了权益分派，送转比例>=5），并且送转后的EPS <0.2元。

此时，condition的条件是：送转后的EPS <0.2元，并且公司进行了高送转（即披露了方案）。

因此，condition的valid条件就是违规的条件，此时constraint的valid条件应为False。因此，当condition为True时，constraint_valid为False，否则为True。

因此，在代码中：

valid_condition = (high_sz & implemented) & (post_eps <0.2)

valid_constraint = ~valid_condition

这可能吗？或者，constraint的valid条件是：当公司的高送转方案导致EPS低于0.2元时，不得披露该方案。因此，如果公司的高送转方案导致EPS低于0.2元，并且公司披露了该方案，则违反constraint。否则，符合。

所以，违规的条件是：valid_condition为True，并且公司披露了高送转方案。但valid_condition的条件已经包含了公司披露了高送转方案。因此，当valid_condition为True时，公司已经披露了高送转方案，此时违反constraint。因此，constraint的valid条件为False。

因此，valid_constraint = ~valid_condition

这可能吗？例如，当valid_condition为True时，constraint_valid为False，否则为True。

这可能正确。因为当valid_condition为True时，公司已经进行了高送转，并且送转后的EPS低于0.2元，此时违反constraint。因此，constraint_valid的条件是：当valid_condition为True时，为False，否则为True。

因此，在代码中：

valid_constraint = ~valid_condition

这可能简化了处理。但这样是否正确？

例如，当公司没有进行高送转，或者虽然进行了高送转但EPS不低于0.2元，那么valid_condition为False，此时constraint_valid为True，即符合约束。当valid_condition为True时，constraint_valid为False，即违反。

这可能正确，因为constraint是“不得披露高送转方案”当送转后的EPS低于0.2元。因此，只有当公司在这种情况下披露了方案，才违反约束。而valid_condition的条件正是这种情况，所以当valid_condition为True时，违反约束，即constraint_valid为False。

因此，constraint的valid条件可以直接取反valid_condition。

这可能是一个简化的方式，但需要确认逻辑是否正确。

例如，假设公司进行了高送转（送转比例>=5，并且进行了权益分派），并且送转后的EPS <0.2元，此时valid_condition为True，constraint_valid为False，即违规。

如果公司进行了高送转，但送转后的EPS >=0.2元，则valid_condition为False，constraint_valid为True，即不违规。

如果公司没有进行高送转（送转比例<5，或者没有进行权益分派），则valid_condition为False，constraint_valid为True，即不违规。

这似乎符合MEU_19_4的要求。因此，constraint的valid条件可以简化为~valid_condition。

因此，在代码中：

valid_constraint = ~valid_condition

这可能更简单，但需要确保valid_condition的条件正确。

现在，重新定义valid_condition：

valid_condition = (df['是否进行权益分派'] == True) & (high_sz) & (post_eps <0.2)

其中，high_sz是送股比例+转增比例 >=5。

这样，当valid_condition为True时，公司确实进行了高送转，并且送转后的EPS低于0.2元，此时constraint_valid为False，即违反约束。

因此，最终的合规性判断是：当subject为True（总是True），并且condition为True，并且constraint为False时，违规。

或者，合规性为True当且仅当不违规。所以，合规性标记为是否不违规。

所以，合规性列的计算：

df['meu_19_4_compliance'] = ~ (df['meu_19_4_subject'] & df['meu_19_4_condition'] & (~df['meu_19_4_constraint']))

或者，因为meu_19_4_subject总是True，可以简化为：

df['meu_19_4_compliance'] = ~ (df['meu_19_4_condition'] & (~df['meu_19_4_constraint']))

但根据之前的分析，当valid_condition为True时，constraint_valid为False，所以合规性为False。

因此，合规性列可以直接设置为 ~valid_condition，因为当valid_condition为True时，违规，即compliance为False。

或者，合规性列等于constraint_valid，因为当constraint_valid为True时，符合约束，即合规。

所以，合规性列可以直接设置为 constraint_valid的值，即 ~valid_condition。

这可能更直接。

现在，将这些步骤整合到代码中：

import pandas as pd

def check_meu_19_4(df):
    '''
    检查上市公司在送转股后每股收益低于0.2元时是否违规披露高送转方案。
    MEU内容:
    - subject: 上市公司
    - condition: 送转股后每股收益低于0.2元
    - constraint: 不得披露高送转方案
    '''
    # 初始化标记列
    df['meu_19_4_subject'] = True  # 所有行主体均为上市公司
    df['meu_19_4_condition'] = False
    df['meu_19_4_constraint'] = True  # 默认符合约束
    
    # 计算是否属于高送转（每10股送转合计>=5股）
    high_sz = (df['送股比例'] + df['转增比例'] >= 5)
    # 公司是否实际进行了权益分派
    implemented = df['是否进行权益分派']
    # 计算送转后的每股净利润
    sz_total = df['送股比例'] + df['转增比例']
    post_eps = df['每股净利润'] * 10 / (10 + sz_total)
    
    # 条件判断：进行权益分派且属于高送转且送转后EPS<0.2
    valid_condition = implemented & high_sz & (post_eps < 0.2)
    df['meu_19_4_condition'] = valid_condition
    
    # 约束判断：当条件满足时不得披露高送转方案，即条件成立时约束不满足
    df['meu_19_4_constraint'] = ~valid_condition
    
    # 计算合规性：当主体、条件满足且约束不满足时违规
    df['meu_19_4_compliance'] = ~ (df['meu_19_4_subject'] & df['meu_19_4_condition'] & (~df['meu_19_4_constraint']))
    
    return df

但这里可能存在错误，因为合规性列的计算可能过于复杂。根据之前的分析，当valid_condition为True时，constraint_valid为False，此时合规性为False。其他情况下为True。因此，合规性列可以直接设置为 ~valid_condition，因为当valid_condition为True时，违规，即compliance为False。

或者，合规性列等于constraint_valid，因为constraint_valid已经处理了当condition为True时的情况。

例如：

df['meu_19_4_compliance'] = df['meu_19_4_constraint']

因为当constraint_valid为True时，合规，否则违规。

因此，在代码中：

df['meu_19_4_compliance'] = df['meu_19_4_constraint']

这可能更简单。

现在，测试这个函数：

假设有一行数据：

送股比例=3，转增比例=2，是否进行权益分派=True，每股净利润=0.18元。

high_sz = 3+2=5 >=5 → True

implemented=True

post_eps = 0.18 *10/(10+5) = 0.18 *10/15=0.12 <0.2 → valid_condition=True

constraint_valid= ~True → False

合规性列= False → 违规，正确。

另一情况：

送股比例=4，转增比例=1 → 合计5，是否进行权益分派=True，每股净利润=0.25元。

post_eps=0.25*10/(15)=0.1667 <0.2 → valid_condition=True → constraint_valid=False → compliance=False → 违规。但此时送转后的EPS是0.1667，确实低于0.2，所以公司不得披露该方案，但公司确实披露了，所以违规。

另一个情况：

送股比例=2，转增比例=2 → 合计4 <5 → high_sz=False → valid_condition=False → constraint_valid=True → compliance=True.

即使每股净利润很低，但因为不是高送转，所以不触发条件，合规。

另一个情况：

送股比例=5，转增比例=0 → 合计5，是否进行权益分派=True，每股净利润=0.3 → post_eps=0.3*10/15=0.2 → 不小于0.2 → valid_condition=False → constraint_valid=True → compliance=True.

此时，送转后的EPS等于0.2，不触发条件，所以合规。

另一个情况：

送股比例=5，转增比例=0 → 合计5，是否进行权益分派=True，每股净利润=0.19 → post_eps=0.19*10/15≈0.1267 <0.2 → valid_condition=True → constraint_valid=False → compliance=False → 违规。

正确。

当公司没有进行权益分派时，即使送股比例+转增比例>=5，valid_condition=False → constraint_valid=True → 合规。

综上，这个函数应该能正确处理各种情况。
","CompletionUsage(completion_tokens=7258, prompt_tokens=2098, total_tokens=9356, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=6800, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 

# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 5. 计算整体的违约情况并标记在dataframe上(meu_n_k_compliance). 

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df['meu_4_2_subject'] = False  # 初始化subject列
    df['meu_4_2_condition'] = False  # 初始化condition列
    df['meu_4_2_constrain'] = False  # 初始化constrain列

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True

    # 判断违规情况：满足主体和条件但不满足约束
    is_violation = (
        valid_subject & 
        valid_condition & 
        (~valid_constraint)
    )

    # 标记违规行
    df.loc[is_violation, 'meu_4_1_compliance'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_19_5
法律的最小可执行单元内容: {""subject"": ""上市公司"", ""condition"": ""相关股东在前三个月存在减持情形"", ""constraint"": ""不得披露高送转方案"", ""contextual_info"": ""相关股东指公司的提议股东和控股股东及其一致行动人、董事、监事及高级管理人员""}
必要的额外信息: nan

你被分配的MEU coding任务存在refer_to关系, 你需要参考下面这个MEU的必要内容来完成你被安排的任务, 但你不需要直接执行下面的MEU: 
【MEU_17_1】
subject: nan
condition: nan
constrain: nan
contextual_info: 本指引所称高送转，是指公司每十股送红股与公积金转增股本，合计达到或者超过五股


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '财务数据日期', '公告日期', '公告类型', '审计意见', '总资产', '总负债', '净资产', '资产负债率',
'交易性金融资产', '衍生金融资产', '债权投资', '其他债权投资', '其他权益工具投资', '其他非流动金融资产',
'其他流动资产', '金融资产总额', '总股本', '每股净资产', '合并报表未分配利润', '母公司报表未分配利润', '净利润',
'每股净利润', '母公司报表净利润', '经营活动现金流量净额', '投资活动现金流量净额', '筹资活动现金流量净额',
'现金及现金等价物净增加额', '净资产增长率', '净利润增长率', '资产负债率变化', '金融资产增长率',
'是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划', '现金分红金额', '送股比例', '转增比例', '是否进行权益分派', '权益分派方案文本', '公司简称']

## 其中: 
- 这是一个二维的面板数据, 根据['日期', '公司简称']可以定位到特定公司在特定日期的状态. 数据已经按照公司简称和日期排序. 
- 我们的'日期'并非连续的自然日或者交易日, 而是固定的季报/半年报/年报披露后三个月内的某一个自然日, 例如'2020-05-30', '2020-09-29', ...等, 我们假定公司在这一天发布了权益分派公告(或者决定了不进行权益分派). 每个季报/半年报/年报后只会跟随一个'日期'来决定是否进行权益分派, 如何进行分派. 
- 数据的每一行包含了两个部分的数据, 分别是当时最新的财务数据和当时最新的权益分派情况. 例如, '2020-09-17'这一行可能对应了公告日期为'2020-08-27'的截至'2020-06-30'的半年报财务报告['审计意见', '总资产', ..., '现金及现金等价物净增加额'], 以及在'2020-09-17'当天公告的权益分派信息['是否进行权益分派', ..., '现金分红金额', ...]
- 所有财务数据都是以单季度的形式记录的, 不需要考虑利润表科目在半年报和年报中逐渐累加的问题. 所有的增长率都是单季的. 
- 所有资产/价格的单位都是元而非万元, 千元或百万元; 所有的比例/比率都是小数而非百分数, 除了['送股比例', '转增比例']是""每10股送n股""的格式. 
- ['审计意见']的值有""无保留意见"", ""非标准无保留意见"", ""保留意见"". 
- 这些列为布尔值: ['是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划']

- 如果希望检查权益分派方案中是否披露了特定内容, 可以使用环境中会提供的函数`llm_content_check()`, 但非披露类的合规检查中禁止使用这个函数. 
    描述: 使用LLM检查公告中是否包含特定内容
        参数:
            announcement_text: 公告全文
            traget_content: 需要检查的内容描述
        返回:
            bool: 公告中是否包含特定内容
    调用示例: 
        ```python
        from utils.tool_for_agents import llm_content_check

        constraint_description = ""为增强投资者回报水平拟采取的措施"" # 请完整描述需要检查的内容, 不得简化
        df['meu_4_1_constraint'] = df['权益分派方案文本'].apply(
            lambda text: llm_content_check(text, constraint_description)
        )
        ```

note:
 - 理论上你撰写合规检验代码所需要的数据都可以从一致的数据中得到, 对于没有直接对应的数据你需要自己计算得到, 不要简单地认为无法完成. 
 - 除非材料提供, 否则不要主动进行简化的假设. 如果你认为所给的信息不足以判断案例的合规性, 可以在函数的结尾进行注释说明. 但这种情况应该很少出现. 

","

<CODE>
import pandas as pd

def check_meu_19_5(df):
    '''
    验证MEU_19_5合规性:
    - subject: 上市公司
    - condition: 相关股东前三个月存在减持情形
    - constraint: 不得披露高送转方案
    '''

    # 初始化标记列
    df['meu_19_5_subject'] = True  # 所有记录主体均为上市公司
    df['meu_19_5_condition'] = df['相关股东前三个月内存在减持情形']
    df['meu_19_5_constraint'] = False
    df['meu_19_5_compliance'] = True

    # 计算高送转方案指标（每10股合计送转≥5股）
    total_distribution = df['送股比例'] + df['转增比例']
    is_high_send = total_distribution >= 5
    
    # 判断是否实际披露高送转（需同时满足权益分派和送转比例条件）
    has_high_send_plan = df['是否进行权益分派'] & is_high_send
    df['meu_19_5_constraint'] = ~has_high_send_plan

    # 标记违规情况（主体和条件满足但约束不满足）
    violation_mask = (
        df['meu_19_5_subject'] & 
        df['meu_19_5_condition'] & 
        (~df['meu_19_5_constraint'])
    )
    df.loc[violation_mask, 'meu_19_5_compliance'] = False

    return df
</CODE>","好的，我现在需要处理MEU_19_5的合规性检查。首先，我得仔细理解这个MEU的内容。MEU_19_5的subject是“上市公司”，condition是“相关股东在前三个月存在减持情形”，constraint是“不得披露高送转方案”。contextual_info里说明相关股东包括提议股东、控股股东及其一致行动人、董监高。

首先，我需要确定如何标记这三个条件：subject、condition、constraint。然后根据这三个条件的满足情况来判断是否违规。

关于subject，这里的主体是上市公司本身。所以每一行的主体是否有效应该直接是True，因为每一行都是针对特定公司的记录。但可能需要确认是否有其他条件，比如公司是否处于特定状态。不过根据MEU的描述，只要主体是上市公司就满足，所以可能直接标记为True。不过需要看数据中的列是否有相关字段。例如，可能所有行都是上市公司，所以可以直接设置meu_19_5_subject列为True。或者是否有字段标识公司类型？比如数据中的列可能没有明确的是否上市公司的字段，但题目中给出的dataframe的每一行都是上市公司的情况，所以可能不需要额外判断，直接标记为True。

接下来是condition：“相关股东在前三个月存在减持情形”。数据中有一个布尔列叫做“相关股东前三个月内存在减持情形”，这个应该可以直接用来判断condition是否满足。所以valid_condition就是该列是否为True。因此，meu_19_5_condition列的值可以直接取自该列。

然后是constraint：“不得披露高送转方案”。这里需要判断公司是否披露了高送转方案。根据MEU_17_1的contextual_info，高送转是指每十股送红股与公积金转增股本合计达到或超过五股。所以需要检查公司的送股比例和转增比例之和是否≥5股每10股。数据中有“送股比例”和“转增比例”两列，都是每10股的数值。例如，如果送股是2股，转增是3股，合计5股，就属于高送转。因此，计算这两个列的和是否≥5，如果是的话，说明披露了高送转方案，此时constraint的条件是不得披露，所以如果存在高送转方案，则constraint不满足（即valid_constraint为False）。反之，如果未披露高送转，则valid_constraint为True。

但需要注意，是否进行权益分派可能由“是否进行权益分派”列决定。如果该列为False，那么送股和转增比例可能为0，此时自然不涉及高送转。如果该列为True，则需要检查送股和转增比例之和是否≥5。

所以，步骤应该是：

1. 标记subject：所有行的meu_19_5_subject为True，因为主体是上市公司，而数据中的每一行都是针对上市公司的记录。

2. 标记condition：当“相关股东前三个月内存在减持情形”为True时，meu_19_5_condition为True。

3. 标记constraint：当公司披露了高送转方案时，即送股比例+转增比例≥5，并且“是否进行权益分派”为True，此时constraint的条件是不得披露，所以valid_constraint应为False。否则，valid_constraint为True。

但需要明确，只有当公司实际进行了权益分派且方案是高送转时，才违反constraint。例如，如果公司没有进行权益分派，或者分派方案不是高送转，则constraint满足。

所以，valid_constraint的条件应该是：如果公司进行了权益分派，并且是高送转，则constraint不满足（即valid_constraint为False）。否则，valid_constraint为True。或者，更准确地说，constraint是“不得披露高送转方案”，所以如果公司披露了高送转方案（即存在这样的方案），则违反constraint。因此，当“是否进行权益分派”为True，并且送股+转增≥5时，valid_constraint为False，否则为True。

现在，将这些逻辑转化为代码：

对于subject列，直接设为True：

df['meu_19_5_subject'] = True

对于condition列：

df['meu_19_5_condition'] = df['相关股东前三个月内存在减持情形']

对于constraint：

需要计算送股比例 + 转增比例是否≥5。注意这两个列的数据类型，比如是否是整数。例如，如果送股比例是每10股送3股，那么该列的值是3。转增比例同理。所以，sum_ = df['送股比例'] + df['转增比例']，然后判断sum_ >=5。同时，只有当公司进行了权益分派（即“是否进行权益分派”为True）时，才需要检查。否则，如果公司没有进行权益分派，那么自然没有高送转方案，所以constraint满足。

所以，valid_constraint的条件是：

如果（是否进行权益分派为True）并且（送股+转增≥5），则constraint不满足（valid_constraint为False）；否则，valid_constraint为True。

因此：

valid_constraint = ~ ( (df['是否进行权益分派'] == True) & ( (df['送股比例'] + df['转增比例']) >=5 ) )

或者，更准确地说，当公司进行了权益分派，并且方案是高送转时，constraint被违反。此时，valid_constraint应为False，否则为True。

所以，在代码中：

sum_high = df['送股比例'] + df['转增比例']
high_send = sum_high >=5
has_high_send_plan = df['是否进行权益分派'] & high_send
valid_constraint = ~has_high_send_plan

所以，meu_19_5_constraint列的值是valid_constraint的值。

然后，整体的合规性判断是：当subject、condition都满足，但constraint不满足时，即违规。也就是：

is_violation = (df['meu_19_5_subject'] == True) & (df['meu_19_5_condition'] == True) & (df['meu_19_5_constraint'] == False)

此时，meu_19_5_compliance列为False表示违规，否则为True。或者，合规性列应该标记为是否满足所有条件。根据MEU的要求，当subject和condition都满足时，必须满足constraint。否则视为违规。所以，合规的情况是：当subject和condition都为True时，constraint必须为True。否则，如果subject和condition都为True，但constraint为False，则违规。

所以，合规性列的计算：

df['meu_19_5_compliance'] = True  # 默认合规

violation = (df['meu_19_5_subject']) & (df['meu_19_5_condition']) & (~df['meu_19_5_constraint'])
df.loc[violation, 'meu_19_5_compliance'] = False

或者，更直接的方式：

df['meu_19_5_compliance'] = ~ ( (df['meu_19_5_subject'] & df['meu_19_5_condition']) & (~df['meu_19_5_constraint']) )

现在，将这些步骤整合到代码中：

首先，初始化各列：

df['meu_19_5_subject'] = True  # 所有行都是上市公司

df['meu_19_5_condition'] = df['相关股东前三个月内存在减持情形']

sum_high = df['送股比例'] + df['转增比例']
high_send = sum_high >=5
has_high_send_plan = df['是否进行权益分派'] & high_send
df['meu_19_5_constraint'] = ~has_high_send_plan

然后计算合规性：

violation = df['meu_19_5_subject'] & df['meu_19_5_condition'] & (~df['meu_19_5_constraint'])
df['meu_19_5_compliance'] = True
df.loc[violation, 'meu_19_5_compliance'] = False

或者，可能更简洁的方式：

df['meu_19_5_compliance'] = ~ (df['meu_19_5_subject'] & df['meu_19_5_condition'] & (~df['meu_19_5_constraint']))

但这样可能更直观：只有当主体和条件都满足时，才需要检查约束是否满足。如果约束不满足，则违规。

现在，将这些步骤写成代码：

def check_meu_19_5(df):
    # 初始化各列
    df['meu_19_5_subject'] = True  # 所有行都是上市公司
    df['meu_19_5_condition'] = df['相关股东前三个月内存在减持情形']
    
    # 计算高送转情况
    sum_high = df['送股比例'] + df['转增比例']
    high_send = sum_high >= 5
    has_high_send_plan = df['是否进行权益分派'] & high_send
    df['meu_19_5_constraint'] = ~has_high_send_plan
    
    # 判断合规性
    violation = df['meu_19_5_subject'] & df['meu_19_5_condition'] & (~df['meu_19_5_constraint'])
    df['meu_19_5_compliance'] = True
    df.loc[violation, 'meu_19_5_compliance'] = False
    
    return df

但需要检查是否有错误。例如，当公司没有进行权益分派时，是否进行权益分派为False，此时即使送股和转增比例之和≥5，也不会被算作高送转。因为只有当是否进行权益分派为True时，才会检查送股和转增比例。所以这部分是正确的。

另外，关于subject的判断是否正确？题目中的MEU的subject是上市公司，而数据中的每一行都是上市公司的记录，所以直接标记为True是正确的。

现在，测试一下可能的案例：

案例1：相关股东前三个月存在减持（condition为True），公司进行了权益分派，送股3，转增3，合计6。此时，high_send为True，has_high_send_plan为True，所以constraint列为False。此时，subject和condition都为True，constraint为False，所以合规性为False，即违规。

案例2：相关股东减持，公司未进行权益分派。此时，condition为True，subject为True，但是否进行权益分派为False，所以has_high_send_plan为False，constraint列为True。合规性为True，不违规。

案例3：相关股东减持，公司进行权益分派，送股2，转增2，合计4。此时，high_send为False，has_high_send_plan为False，constraint列为True。合规性为True，不违规。

案例4：相关股东没有减持，condition为False。此时无论其他条件如何，合规性为True，因为只有当subject和condition都满足时才需要检查。

综上，代码逻辑正确。
","CompletionUsage(completion_tokens=2801, prompt_tokens=2105, total_tokens=4906, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=2436, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 5. 计算整体的违约情况并标记在dataframe上(meu_n_k_compliance). 

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df['meu_4_2_subject'] = False  # 初始化subject列
    df['meu_4_2_condition'] = False  # 初始化condition列
    df['meu_4_2_constrain'] = False  # 初始化constrain列

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True

    # 判断违规情况：满足主体和条件但不满足约束
    is_violation = (
        valid_subject & 
        valid_condition & 
        (~valid_constraint)
    )

    # 标记违规行
    df.loc[is_violation, 'meu_4_1_compliance'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_13_3
法律的最小可执行单元内容: {""subject"": ""上市公司"", ""condition"": ""合并资产负债表、母公司资产负债表中本年末未分配利润均为正值且报告期内盈利，未进行现金分红或最近三年现金分红总额低于最近三年年均净利润30%"", ""constraint"": ""应当在权益分派方案中披露：公司在相应期间是否按照中国证券监督管理委员会相关规定为中小股东参与现金分红决策提供了便利"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '财务数据日期', '公告日期', '公告类型', '审计意见', '总资产', '总负债', '净资产', '资产负债率',
'交易性金融资产', '衍生金融资产', '债权投资', '其他债权投资', '其他权益工具投资', '其他非流动金融资产',
'其他流动资产', '金融资产总额', '总股本', '每股净资产', '合并报表未分配利润', '母公司报表未分配利润', '净利润',
'每股净利润', '母公司报表净利润', '经营活动现金流量净额', '投资活动现金流量净额', '筹资活动现金流量净额',
'现金及现金等价物净增加额', '净资产增长率', '净利润增长率', '资产负债率变化', '金融资产增长率',
'是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划', '现金分红金额', '送股比例', '转增比例', '是否进行权益分派', '权益分派方案文本', '公司简称']

## 其中: 
- 这是一个二维的面板数据, 根据['日期', '公司简称']可以定位到特定公司在特定日期的状态. 数据已经按照公司简称和日期排序. 
- 我们的'日期'并非连续的自然日或者交易日, 而是固定的季报/半年报/年报披露后三个月内的某一个自然日, 例如'2020-05-30', '2020-09-29', ...等, 我们假定公司在这一天发布了权益分派公告(或者决定了不进行权益分派). 每个季报/半年报/年报后只会跟随一个'日期'来决定是否进行权益分派, 如何进行分派. 
- 数据的每一行包含了两个部分的数据, 分别是当时最新的财务数据和当时最新的权益分派情况. 例如, '2020-09-17'这一行可能对应了公告日期为'2020-08-27'的截至'2020-06-30'的半年报财务报告['审计意见', '总资产', ..., '现金及现金等价物净增加额'], 以及在'2020-09-17'当天公告的权益分派信息['是否进行权益分派', ..., '现金分红金额', ...]
- 所有财务数据都是以单季度的形式记录的, 不需要考虑利润表科目在半年报和年报中逐渐累加的问题. 所有的增长率都是单季的. 
- 所有资产/价格的单位都是元而非万元, 千元或百万元; 所有的比例/比率都是小数而非百分数, 除了['送股比例', '转增比例']是""每10股送n股""的格式. 
- ['审计意见']的值有""无保留意见"", ""非标准无保留意见"", ""保留意见"". 
- 这些列为布尔值: ['是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划']

- 如果希望检查权益分派方案中是否披露了特定内容, 可以使用环境中会提供的函数`llm_content_check()`, 但非披露类的合规检查中禁止使用这个函数. 
    描述: 使用LLM检查公告中是否包含特定内容
        参数:
            announcement_text: 公告全文
            traget_content: 需要检查的内容描述
        返回:
            bool: 公告中是否包含特定内容
    调用示例: 
        ```python
        from utils.tool_for_agents import llm_content_check

        constraint_description = ""为增强投资者回报水平拟采取的措施"" # 请完整描述需要检查的内容, 不得简化
        df['meu_4_1_constraint'] = df['权益分派方案文本'].apply(
            lambda text: llm_content_check(text, constraint_description)
        )
        ```

note:
 - 理论上你撰写合规检验代码所需要的数据都可以从一致的数据中得到, 对于没有直接对应的数据你需要自己计算得到, 不要简单地认为无法完成. 
 - 除非材料提供, 否则不要主动进行简化的假设. 如果你认为所给的信息不足以判断案例的合规性, 可以在函数的结尾进行注释说明. 但这种情况应该很少出现. 

","

<CODE>
import pandas as pd
from utils.tool_for_agents import llm_content_check

def check_meu_13_3(df):
    '''
    验证上市公司在满足特定利润条件和分红限制时是否披露中小股东参与决策便利
    ""subject"": ""上市公司"",
    ""condition"": ""合并及母公司未分配利润为正+报告期盈利+未分红或三年分红不足净利润30%"",
    ""constraint"": ""需在权益分派方案中披露中小股东参与决策便利条款""
    '''
    
    # 初始化合规标记列
    df['meu_13_3_subject'] = True  # 所有行默认符合主体要求
    df['meu_13_3_condition'] = False
    df['meu_13_3_constraint'] = True
    df['meu_13_3_compliance'] = True

    # 预处理财务日期并筛选年报数据
    df['财务数据日期'] = pd.to_datetime(df['财务数据日期'])
    annual_mask = df['财务数据日期'].dt.month == 12
    annual_df = df[annual_mask].copy()

    if not annual_df.empty:
        # 按公司分组计算三年滚动指标
        annual_df = annual_df.sort_values(by=['公司简称', '财务数据日期'])
        
        # 计算三年现金分红总和
        annual_df['cash_div_3yr'] = annual_df.groupby('公司简称')['现金分红金额']\
            .transform(lambda s: s.rolling(3, min_periods=3).sum())
        
        # 计算三年平均净利润
        annual_df['net_profit_3yr_avg'] = annual_df.groupby('公司简称')['净利润']\
            .transform(lambda s: s.rolling(3, min_periods=3).sum() / 3)
        
        # 将计算结果合并回原数据框
        df = df.merge(
            annual_df[['cash_div_3yr', 'net_profit_3yr_avg']],
            how='left', left_index=True, right_index=True
        )

        # 条件验证逻辑
        profit_condition = (
            (df['合并报表未分配利润'] > 0) &
            (df['母公司报表未分配利润'] > 0) &
            (df['净利润'] > 0)
        )
        
        dividend_condition = (
            (~df['是否实施现金分红']) |  # 未分红情形
            (df['cash_div_3yr'] < df['net_profit_3yr_avg'] * 0.3)  # 分红不足情形
        )
        
        # 综合条件标记（仅限年报数据）
        df['meu_13_3_condition'] = annual_mask & profit_condition & dividend_condition
        
        # 约束条件验证（仅当满足主体和条件时触发）
        need_check_mask = df['meu_13_3_subject'] & df['meu_13_3_condition']
        df.loc[need_check_mask, 'meu_13_3_constraint'] = df.loc[need_check_mask, '权益分派方案文本'].apply(
            lambda text: llm_content_check(
                text, 
                ""公司在相应期间是否按照中国证券监督管理委员会相关规定为中小股东参与现金分红决策提供了便利""
            )
        )

        # 计算最终合规状态
        violation_mask = need_check_mask & (~df['meu_13_3_constraint'])
        df.loc[violation_mask, 'meu_13_3_compliance'] = False

    return df
</CODE>","好的，我现在需要为MEU_13_3编写合规性检查的代码。首先，我得仔细理解这个MEU的内容。MEU的subject是“上市公司”，所以每一行的主体都是公司本身，不需要特别的条件，可能只需要确认公司是否存在，但这里可能所有行都是上市公司，所以可能直接标记subject为True？不过可能需要确认是否有其他条件，比如是否被ST等，但根据提供的列，可能没有这些信息，所以暂时假设所有行的subject都是有效的。

接下来是condition部分。条件是合并资产负债表和母公司资产负债表中本年末未分配利润均为正值，且报告期内盈利，同时未进行现金分红或最近三年现金分红总额低于最近三年年均净利润的30%。这里需要拆解条件：

1. 合并报表未分配利润和母公司报表未分配利润均为正值。对应的列应该是['合并报表未分配利润', '母公司报表未分配利润']，需要检查这两个值是否都大于0。
2. 报告期内盈利：可能是指最近一个报告期的净利润为正。这里要看净利润是否为正值，可能用['净利润']列，或者可能要看母公司报表净利润？可能需要确认。根据MEU的描述，可能合并和母公司都要盈利？或者只要合并报表盈利？这里可能需要更仔细的分析。MEU的条件是“报告期内盈利”，可能指的是合并报表的净利润为正，或者母公司？或者两者都要？根据MEU的condition中的描述，可能是指合并和母公司资产负债表中的未分配利润为正，而报告期内盈利可能指的是合并或母公司的净利润？或者可能是指整个报告期的净利润为正？需要仔细看条件。

原MEU的condition是：“合并资产负债表、母公司资产负债表中本年末未分配利润均为正值且报告期内盈利，未进行现金分红或最近三年现金分红总额低于最近三年年均净利润30%”。所以这里的“报告期内盈利”可能指的是合并报表和母公司报表的净利润均为正？或者只是合并报表？或者整个公司的净利润？比如，合并报表的净利润是否为正，或者母公司的净利润是否为正？

假设这里的“报告期内盈利”指的是合并报表的净利润为正，因为合并报表反映整个集团的盈利情况。或者可能同时需要合并和母公司的净利润为正？但MEU的condition中并没有明确说明这一点。可能需要进一步分析。

例如，假设“报告期内盈利”指的是合并报表的净利润为正，那么需要检查['净利润']是否大于0。同时，合并和母公司的未分配利润是否为正。

然后，未进行现金分红，或者最近三年现金分红总额低于最近三年年均净利润的30%。这里需要计算最近三年的现金分红总额，以及最近三年的年均净利润，然后比较。

但问题在于，提供的dataframe中的每一行可能对应不同的报告期，比如每个季度或年度。如何获取最近三年的数据？例如，当前行的财务数据日期是某个时间点，需要找到过去三年的现金分红金额，并计算总和，以及这三年的年均净利润。

但根据提供的列，可能每一行只包含当期的财务数据，而没有历史数据。这可能是一个问题，因为无法直接获取过去三年的数据。这时候可能需要假设dataframe已经包含了足够的历史数据，或者需要用户预处理数据，比如在每一行中包含最近三年的现金分红总额和年均净利润。但根据当前提供的列，可能无法直接计算，因为每一行只包含当期的现金分红金额，而无法获取过去三年的数据。这可能是一个难点。

例如，当前行的现金分红金额是当期的，但需要最近三年的总和。如果没有历史数据，可能需要依赖其他列，或者假设该行所在的dataframe已经包含了足够的历史数据，可以通过groupby公司简称，然后rolling窗口来计算过去三年的总和。但编写这样的代码可能需要处理时间序列数据，按公司分组，并计算每个时间点的过去三年的总和。

但根据用户提供的附加信息中的dataframe的列，可能没有足够的历史数据。例如，每一行可能只包含当期的现金分红金额，而无法回溯过去三年的数据。这可能意味着当前的MEU的条件无法直接验证，因为缺乏必要的历史数据。这时候可能需要用户补充数据，或者在代码中进行假设，比如假设存在其他列如过去三年的现金分红金额，或者需要预处理数据。

但根据用户提供的列，确实存在['现金分红金额']这一列，但每一行的这个金额可能对应的是当期的分红。例如，如果当前行是2023年的年报，那么现金分红金额是该年度的分红。要计算最近三年的总和，需要将过去两年的分红金额加上当前年的。但如何获取过去两年的数据呢？

这可能意味着，在当前的dataframe结构中，无法直接计算最近三年的现金分红总额，因为每一行只包含当期的数据。因此，这可能是一个无法满足的条件，需要用户提供更多的数据，或者在代码中进行假设。或者，可能用户提供的dataframe已经按时间排序，并且每个公司的数据按时间排列，因此可以使用rolling窗口来计算过去三年的总和。

例如，对于每个公司，按日期排序，然后计算每个时间点的现金分红金额在过去三年的总和。这需要确保dataframe已经按公司分组并按日期排序，然后使用rolling窗口。例如：

df.groupby('公司简称')['现金分红金额'].rolling(window=3).sum()

但需要注意，这里的window是三个年度报告期，比如年报的数据。但用户的数据中的日期是季报、半年报、年报后的某个日期，每个报告期可能对应不同的时间跨度。例如，年报后的日期可能对应一年的数据，而季报后的日期对应一个季度的数据。因此，如何确定“最近三年”可能比较复杂。

或者，可能这里的“最近三年”指的是三个完整的会计年度，例如，当前行如果是2023年的年报，则最近三年是2021、2022、2023年，需要这三年的现金分红金额总和。但如何从dataframe中提取这三年的数据？

这可能超出了当前dataframe的结构，因为每一行可能对应不同的报告期类型（季报、半年报、年报），而只有年报才会涉及分红。因此，可能需要假设只有年报的行才会有现金分红金额，并且每个公司的年报数据按年份排列，从而可以提取最近三年的年报数据来计算总和。

例如，对于每个公司，筛选出年报对应的行（可能根据公告类型或其他列），然后按年份排序，取最近三年的现金分红金额，计算总和，以及这三年的年均净利润。

但根据用户提供的列，可能没有明确的列来区分报告期类型（如年报、季报等），但可能有财务数据日期，例如，财务数据日期可能为2023-12-31（年报）、2023-06-30（半年报）等。因此，可以通过财务数据日期来判断是否为年报。例如，财务数据日期为年末的（如12月31日）的行，视为年报数据，其他为季报或半年报。

因此，在代码中，可能需要先筛选出年报的数据，然后按公司分组，找到当前行对应的年报的最近三年的年报数据，计算现金分红总和和年均净利润。

但这个过程可能比较复杂，需要处理每个公司的年报数据的时间序列。例如，对于当前行的财务数据日期，如果是年报（如2023-12-31），则最近三年是2021、2022、2023年的年报数据。需要找到这三年的现金分红金额，并计算总和。同时，这三年的净利润总和除以3，得到年均净利润，然后比较现金分红总和是否低于年均净利润的30%。

但如何实现这一点呢？在pandas中，可能需要为每个公司维护一个时间序列，然后对于每一行，如果是年报数据，则获取过去三年的年报数据，并计算总和。这可能需要在代码中使用groupby和shift操作，或者使用rolling窗口。

但根据用户提供的dataframe结构，可能每一行对应不同的报告期，所以需要先筛选出年报的数据，然后进行处理。例如：

对于每个公司，创建一个只包含年报数据的子dataframe，按财务数据日期排序。然后，对于每个年报行，取当前行和前两行的现金分红金额，计算总和。同样，取这三年的净利润，计算年均值。

但如何确保这三年的数据存在？例如，如果当前行是2023年的年报，但之前的2022和2021年的年报数据不存在于dataframe中，那么无法计算。这可能意味着，只有当公司有至少三年的年报数据时，才能进行判断，否则条件可能不满足？

这可能比较复杂，但根据用户提供的列，可能无法直接处理。因此，这可能是一个需要用户提供更多数据或预处理的情况。或者，可能用户希望简化处理，假设当前行的现金分红金额是最近三年的总和，或者有其他列可用？

或者，可能这里的“最近三年”指的是当前行所在的报告期之前的三个完整年度。例如，如果当前行的财务数据日期是2023-06-30（半年报），则最近三年可能指2020、2021、2022年？或者可能根据报告期的类型来判断？

这可能变得非常复杂，而用户提供的列中可能没有足够的信息来处理。因此，这可能是一个需要进一步澄清的问题，或者需要假设某些条件。

在这种情况下，可能需要用户提供更多的数据列，或者假设某些条件。例如，假设存在一个列['报告期类型']，可以区分年报、季报等。或者，假设每个公司的年报数据在dataframe中按时间顺序排列，并且可以通过财务数据日期的月份是否为12月来判断是否为年报。

例如，可以筛选出财务数据日期的月份为12月的行，视为年报数据。然后，对于每个公司，按年份排序，并计算每个年报行的过去三年的现金分红总和。

但如果没有这样的列，可能需要根据财务数据日期的月份来判断。例如：

df['财务数据日期'] = pd.to_datetime(df['财务数据日期'])
df['year'] = df['财务数据日期'].dt.year
df['month'] = df['财务数据日期'].dt.month
# 年报通常在12月
annual_reports = df[df['month'] == 12]

然后，对于每个公司，按年份排序，并为每个年报行计算过去三年的现金分红总和。

这可能是一个可行的方法，但需要确保每个公司的年报数据在dataframe中存在，并且按时间排序。

但根据用户提供的附加信息，数据已经按照公司简称和日期排序，而日期是季报/半年报/年报披露后的三个月内的某个自然日。例如，年报可能在3月、4月等披露，对应的财务数据日期是12月31日。因此，可以通过财务数据日期是否为年末来判断是否为年报。

因此，在代码中，可能需要先筛选出年报的数据行，然后处理每个公司的年报数据，计算最近三年的现金分红总和和年均净利润。

但如何将这些计算结果与原始dataframe中的每一行对应起来呢？例如，原始dataframe中的每一行可能对应不同的报告期类型，但只有年报的行需要处理MEU_13_3的条件？

或者，可能MEU_13_3的条件只适用于年报的情况，因为分红通常是在年报时决定的。因此，可能只需要处理年报对应的行，其他行的condition可能不满足？

这可能是一个合理的假设。因此，在代码中，可能需要首先确定当前行是否为年报数据，如果是，则进行条件判断，否则可能不满足condition。

但根据MEU的condition，是否进行现金分红或最近三年现金分红总额的条件，可能只有在年报时才会触发，因为分红通常是在年报时决定的。因此，可能只有年报对应的行需要处理。

因此，在代码中，可能需要：

1. 确定当前行是否为年报数据：财务数据日期是否为年末（如12月31日）。
2. 如果是年报数据，则检查合并和母公司未分配利润是否为正，报告期内盈利（净利润是否为正）。
3. 然后检查是否未进行现金分红，或者最近三年现金分红总额低于最近三年年均净利润的30%。

对于步骤3，需要计算最近三年的现金分红总额和年均净利润。

假设当前行是年报数据，财务数据日期为2023-12-31。那么最近三年是2021、2022、2023年。需要找到这三年的年报数据中的现金分红金额，并计算总和。同时，这三年的净利润总和除以3得到年均净利润，然后比较现金分红总和是否小于年均净利润的30%。

但如何获取这三年的数据？在代码中，可能需要为每个公司维护一个按年份排序的年报数据列表，然后对于当前行，找到前三年的数据。

例如，对于每个公司，按财务数据日期排序，然后对于当前行，取前两行的数据（假设当前行是第三年）。或者，使用rolling窗口。

这可能比较复杂，但假设dataframe已经按公司分组并按财务数据日期排序，那么可以使用groupby和rolling来获取过去三年的数据。

例如：

对于每个公司，筛选出年报数据，按年份排序，然后计算现金分红金额的滚动总和：

annual_reports = df[df['财务数据日期'].dt.month == 12].sort_values(by='财务数据日期')

然后，对于每个公司，计算过去三年的现金分红总和：

annual_reports['三年现金分红总和'] = annual_reports.groupby('公司简称')['现金分红金额'].rolling(window=3, min_periods=3).sum().reset_index(level=0, drop=True)

同样，计算过去三年的净利润总和，然后除以3得到年均净利润：

annual_reports['三年净利润总和'] = annual_reports.groupby('公司简称')['净利润'].rolling(window=3, min_periods=3).sum().reset_index(level=0, drop=True)
annual_reports['年均净利润'] = annual_reports['三年净利润总和'] / 3

然后，比较三年现金分红总和是否小于年均净利润的30%：

condition_part2 = (annual_reports['现金分红金额'] == 0) | (annual_reports['三年现金分红总和'] < annual_reports['年均净利润'] * 0.3)

但需要注意，这里的三年现金分红总和是当前年加上前两年的总和吗？或者，是前三年（不包括当前年）？例如，如果当前年是2023年，那么三年总和是2021、2022、2023年的现金分红总和？

是的，假设当前行是2023年的年报，那么三年总和包括2021、2022、2023年的现金分红。但如果是这样，那么当处理2023年的年报时，需要这三年的数据。如果公司只有2023年的数据，而没有前两年的，则无法计算，此时条件可能不满足？

这可能需要在代码中处理缺失值，例如，如果无法获取过去三年的数据，则条件不成立。

但根据用户提供的示例代码中的处理方式，可能假设数据已经足够，或者用户会处理缺失值。

现在，将这些条件组合起来：

condition = (合并和母公司未分配利润均为正) & (报告期内盈利) & (未进行现金分红或最近三年现金分红总额低于最近三年年均净利润的30%)

接下来是constraint部分：应当在权益分派方案中披露特定内容。即，如果满足condition，那么必须披露相关内容。因此，constraint的检查是：是否在权益分派方案中披露了相应的内容。

因此，constraint的valid条件是：如果满足subject和condition，则必须检查权益分派方案文本是否包含特定内容。否则，constraint可能不适用。

具体来说，当subject有效（上市公司）且condition满足时，必须满足constraint（披露相关内容）。否则，constraint是否满足无关紧要。

因此，在代码中，当subject和condition都为True时，需要检查constraint是否满足。否则，constraint可能标记为True或不需要检查。

但根据MEU的结构，只有当subject和condition都满足时，才需要满足constraint。因此，在代码中，constraint的valid条件是在这种情况下是否满足。

因此，在代码中，需要：

valid_constraint = 当满足subject和condition时，权益分派方案文本是否包含特定内容。

根据MEU的constraint描述，需要披露的内容是：“公司在相应期间是否按照中国证券监督管理委员会相关规定为中小股东参与现金分红决策提供了便利”。

因此，需要使用llm_content_check函数来检查权益分派方案文本是否包含该内容。

因此，在代码中，当满足subject和condition时，调用llm_content_check函数，否则constraint标记为True或False？

或者，只有当subject和condition都满足时，才需要检查constraint，否则constraint可能不适用，所以标记为True？

例如，在代码中：

valid_constraint = 当subject和condition都满足时，检查是否披露了相关内容。否则，constraint视为满足（因为不适用）。

因此，在代码中：

对于所有行，如果subject和condition都为True，则检查constraint是否满足（即披露了内容），否则constraint视为True。

这可能更合理，因为只有当触发条件时，才需要满足约束。否则，约束不适用，所以视为满足。

因此，在代码中：

valid_constraint = ~ (valid_subject & valid_condition) | (披露内容为True)

或者，更具体地说：

valid_constraint = True  # 默认情况下为True
mask = valid_subject & valid_condition
valid_constraint[mask] = df.loc[mask, '权益分派方案文本'].apply(lambda x: llm_content_check(x, ""公司在相应期间是否按照中国证券监督管理委员会相关规定为中小股东参与现金分红决策提供了便利""))

这可能更准确。

现在，将这些步骤转化为代码：

首先，处理subject：

subject是“上市公司”，所以所有行的subject都是有效的？或者是否需要检查某些条件？例如，是否退市？但根据提供的列，可能没有相关信息，所以假设所有行的subject都是有效的。因此，valid_subject = True在所有行。

但可能需要确认，例如，是否某些公司可能被标记为非上市公司？但根据问题描述，dataframe中的每一行都是针对上市公司的，所以valid_subject列可以直接标记为True。

因此：

df['meu_13_3_subject'] = True

接下来处理condition：

condition分为几个部分：

1. 合并和母公司资产负债表的未分配利润均为正值：
   (df['合并报表未分配利润'] > 0) & (df['母公司报表未分配利润'] > 0)

2. 报告期内盈利：可能指合并报表的净利润为正？或者母公司报表的净利润？或者两者？

根据MEU的condition描述，“报告期内盈利”可能指的是合并报表的净利润为正，因为这是整个公司的盈利情况。或者，可能同时需要合并和母公司的净利润为正？但MEU的condition中并没有明确说明。例如，原条件中的“合并资产负债表、母公司资产负债表中本年末未分配利润均为正值”已经检查了未分配利润，而“报告期内盈利”可能指的是合并报表的净利润为正，或者母公司报表的净利润为正？

假设这里的“报告期内盈利”指的是合并报表的净利润为正，即['净利润'] > 0。或者，可能同时需要合并和母公司的净利润为正？

例如，原条件中的“合并资产负债表、母公司资产负债表中本年末未分配利润均为正值”可能意味着这两个报表的未分配利润为正，而“报告期内盈利”可能指的是合并报表的净利润为正。或者，可能同时需要合并和母公司的净利润为正？

这可能需要更仔细的分析。例如，假设“报告期内盈利”指的是合并报表的净利润为正，那么条件为：

(df['净利润'] > 0)

或者，如果指的是母公司报表的净利润，则为：

(df['母公司报表净利润'] > 0)

或者，两者都需要？

根据MEU的condition的原文：“合并资产负债表、母公司资产负债表中本年末未分配利润均为正值且报告期内盈利”，这里的“报告期内盈利”可能指的是合并报表和母公司报表的净利润均为正？或者只是合并报表？

可能这里的“报告期内盈利”指的是合并报表的净利润为正，而母公司报表的净利润可能无关。或者，可能两者都需要？

这可能需要根据法律条文的理解，但作为程序员，可能需要根据MEU的描述来推断。例如，原条件中的“合并资产负债表、母公司资产负债表中本年末未分配利润均为正值”是两个条件，而“报告期内盈利”可能是一个单独的条件，可能指的是合并报表的净利润为正。因此，可能：

report_profit = (df['净利润'] > 0)

或者，可能同时需要合并和母公司的净利润为正？

例如，如果报告期内盈利指的是合并和母公司都盈利，则：

report_profit = (df['净利润'] > 0) & (df['母公司报表净利润'] > 0)

但根据MEU的condition的原文，可能“报告期内盈利”是单独的条件，可能指的是合并报表的净利润。因此，暂时假设为：

report_profit = df['净利润'] > 0

接下来是现金分红的条件：

未进行现金分红，或者最近三年现金分红总额低于最近三年年均净利润的30%。

未进行现金分红的条件是：df['是否实施现金分红'] == False

或者，现金分红金额为0？

根据提供的列，有['是否实施现金分红']是布尔值，所以可以检查该列是否为False。

或者，可能同时检查现金分红金额是否为0？例如，可能存在是否实施现金分红为True，但金额为0的情况？但根据常规逻辑，如果实施现金分红，金额应该大于0。但为了保险，可能需要同时检查。

但根据提供的列，可能直接使用['是否实施现金分红']来判断是否进行了现金分红。因此，未进行现金分红的条件是：

no_cash_dividend = ~df['是否实施现金分红']

而最近三年现金分红总额低于最近三年年均净利润的30%的条件则需要计算。

这里的问题是如何获取最近三年的现金分红总额和年均净利润。

假设当前行是年报数据，财务数据日期为年末，那么需要找到过去三年的年报数据中的现金分红金额，并计算总和。同时，这三年的净利润总和除以3得到年均净利润，然后比较现金分红总和是否小于年均净利润的30%。

因此，在代码中，需要：

1. 筛选出年报数据。
2. 对每个公司，按时间排序，计算每个年报行的过去三年的现金分红总和和年均净利润。
3. 比较现金分红总和是否小于年均净利润的30%。

但如何实现这一点？

例如，对于每个公司，按财务数据日期排序，然后计算滚动总和：

# 筛选年报数据
annual_mask = df['财务数据日期'].dt.month == 12
annual_df = df[annual_mask].copy()

# 按公司分组，按日期排序
annual_df.sort_values(by=['公司简称', '财务数据日期'], inplace=True)

# 计算过去三年的现金分红总和
annual_df['cash_dividend_3yr_sum'] = annual_df.groupby('公司简称')['现金分红金额'].rolling(window=3, min_periods=3).sum().reset_index(level=0, drop=True)

# 计算过去三年的净利润总和
annual_df['net_profit_3yr_sum'] = annual_df.groupby('公司简称')['净利润'].rolling(window=3, min_periods=3).sum().reset_index(level=0, drop=True)
annual_df['net_profit_3yr_avg'] = annual_df['net_profit_3yr_sum'] / 3

# 条件：现金分红总和 < 年均净利润的30%
cash_dividend_condition = annual_df['cash_dividend_3yr_sum'] < (annual_df['net_profit_3yr_avg'] * 0.3)

然后，将annual_df中的条件合并回原始df中。因为原始df中的行可能包含非年报数据，所以需要将annual_df中的计算结果合并到原始df中，可能通过merge操作。

但这样处理可能比较复杂，因为需要将annual_df中的计算结果与原df合并。例如：

# 在原df中创建新列，初始为NaN
df['cash_dividend_3yr_sum'] = np.nan
df['net_profit_3yr_avg'] = np.nan

# 将annual_df中的计算结果填充到原df中
df.loc[annual_mask, 'cash_dividend_3yr_sum'] = annual_df['cash_dividend_3yr_sum']
df.loc[annual_mask, 'net_profit_3yr_avg'] = annual_df['net_profit_3yr_avg']

然后，现金分红条件为：

cash_dividend_condition = (df['cash_dividend_3yr_sum'] < df['net_profit_3yr_avg'] * 0.3) | (~df['是否实施现金分红'])

但需要注意，当最近三年的现金分红总和无法计算（如数据不足三年）时，cash_dividend_3yr_sum可能为NaN，此时条件可能不成立。因此，在这种情况下，可能视为不满足条件？

例如，如果公司只有两年的数据，无法计算三年总和，则现金分红条件中的第二部分（最近三年总和 < 30%）不成立，因此整个条件是否成立取决于是否未进行现金分红。

但根据MEU的条件，如果未进行现金分红，则条件成立。否则，如果进行了现金分红，则需要满足最近三年总和的条件。如果无法计算三年总和（如数据不足），则视为不满足条件？

这可能是一个问题，但根据用户提供的列，可能无法处理这种情况，因此代码中可能需要假设数据足够。

综上，condition的各个部分：

condition_part1 = (df['合并报表未分配利润'] > 0) & (df['母公司报表未分配利润'] > 0) & (df['净利润'] > 0)

condition_part2 = (~df['是否实施现金分红']) | (df['cash_dividend_3yr_sum'] < df['net_profit_3yr_avg'] * 0.3)

valid_condition = condition_part1 & condition_part2

但需要注意，cash_dividend_3yr_sum和net_profit_3yr_avg仅在年报数据中存在，其他行的valid_condition可能为False。

现在，将这些步骤整合到代码中：

首先，处理年报数据，计算三年总和和年均净利润：

# 转换财务数据日期为datetime类型
df['财务数据日期'] = pd.to_datetime(df['财务数据日期'])

# 筛选年报数据（假设财务数据日期的月份为12月）
annual_mask = df['财务数据日期'].dt.month == 12
annual_df = df[annual_mask].copy()

# 按公司分组并按财务数据日期排序
annual_df.sort_values(by=['公司简称', '财务数据日期'], inplace=True)

# 计算过去三年的现金分红总和和净利润总和
annual_df['cash_dividend_3yr_sum'] = annual_df.groupby('公司简称')['现金分红金额'].rolling(window=3, min_periods=3).sum().reset_index(level=0, drop=True)
annual_df['net_profit_3yr_sum'] = annual_df.groupby('公司简称')['净利润'].rolling(window=3, min_periods=3).sum().reset_index(level=0, drop=True)
annual_df['net_profit_3yr_avg'] = annual_df['net_profit_3yr_sum'] / 3

# 将计算结果合并回原df
df = df.merge(annual_df[['cash_dividend_3yr_sum', 'net_profit_3yr_avg']], how='left', left_index=True, right_index=True, suffixes=('', '_y'))

# 可能合并后需要处理重复的列，但假设此处正确合并

然后，处理condition_part2：

# 未进行现金分红或三年总和条件
condition_part2 = (~df['是否实施现金分红']) | (df['cash_dividend_3yr_sum'] < df['net_profit_3yr_avg'] * 0.3)

但需要注意，当cash_dividend_3yr_sum或net_profit_3yr_avg为NaN时，例如非年报数据或数据不足三年，此时条件可能为False。例如，对于非年报数据，condition_part2可能为False，因为是否实施现金分红可能为False，但年报数据才需要处理。

但根据MEU的条件，可能只有年报数据才会触发condition，因此非年报数据的valid_condition可能为False。

现在，整合condition：

valid_condition = (
    (df['合并报表未分配利润'] > 0) & 
    (df['母公司报表未分配利润'] > 0) & 
    (df['净利润'] > 0) & 
    condition_part2
) & annual_mask  # 仅年报数据需要满足条件？

或者，是否年报数据是condition的前提？例如，只有年报数据才可能满足condition？

是的，因为现金分红通常是在年报时决定的，所以MEU的条件可能只适用于年报数据。因此，valid_condition仅在年报数据中可能为True，其他行自动为False。

因此，在代码中，valid_condition的计算应仅在年报数据中进行：

valid_condition = (
    (df['合并报表未分配利润'] > 0) & 
    (df['母公司报表未分配利润'] > 0) & 
    (df['净利润'] > 0) & 
    condition_part2
) & annual_mask

或者，更准确地说，annual_mask已经筛选了年报数据，所以：

valid_condition = (
    (df['合并报表未分配利润'] > 0) & 
    (df['母公司报表未分配利润'] > 0) & 
    (df['净利润'] > 0) & 
    condition_part2
) 

并且，只有年报数据才会被考虑，其他行的valid_condition自动为False。

现在，处理constraint：

当subject和condition都为True时，需要检查权益分派方案文本是否包含特定内容。否则，constraint视为满足。

因此：

mask = valid_subject & valid_condition

df.loc[mask, 'meu_13_3_constraint'] = df.loc[mask, '权益分派方案文本'].apply(
    lambda x: llm_content_check(x, ""公司在相应期间是否按照中国证券监督管理委员会相关规定为中小股东参与现金分红决策提供了便利"")
)

对于不满足mask的行，constraint标记为True，因为不适用：

df['meu_13_3_constraint'] = True
df.loc[mask, 'meu_13_3_constraint'] = ...  # 上面的结果

或者，初始化为True，然后更新mask部分：

df['meu_13_3_constraint'] = True
df.loc[mask, 'meu_13_3_constraint'] = ... 

最后，计算整体的合规性：

只有当subject、condition都满足，但constraint不满足时，才违规。即：

is_violation = valid_subject & valid_condition & (~df['meu_13_3_constraint'])

df['meu_13_3_compliance'] = ~is_violation

或者，合规性为True，当不违规时：

df['meu_13_3_compliance'] = True
df.loc[is_violation, 'meu_13_3_compliance'] = False

现在，将这些步骤整合到代码中：

import pandas as pd

def check_meu_13_3(df):
    # 初始化标记列
    df['meu_13_3_subject'] = True  # 所有行都是上市公司
    df['meu_13_3_condition'] = False
    df['meu_13_3_constraint'] = True  # 默认视为满足，除非需要检查
    
    # 转换财务数据日期为datetime
    df['财务数据日期'] = pd.to_datetime(df['财务数据日期'])
    
    # 筛选年报数据（财务数据日期为12月）
    annual_mask = df['财务数据日期'].dt.month == 12
    annual_df = df[annual_mask].copy()
    
    if not annual_df.empty:
        # 按公司分组并按财务数据日期排序
        annual_df.sort_values(by=['公司简称', '财务数据日期'], inplace=True)
        
        # 计算过去三年的现金分红总和和年均净利润
        annual_df['cash_dividend_3yr_sum'] = annual_df.groupby('公司简称')['现金分红金额'].rolling(window=3, min_periods=3).sum().reset_index(level=0, drop=True)
        annual_df['net_profit_3yr_sum'] = annual_df.groupby('公司简称')['净利润'].rolling(window=3, min_periods=3).sum().reset_index(level=0, drop=True)
        annual_df['net_profit_3yr_avg'] = annual_df['net_profit_3yr_sum'] / 3
        
        # 合并回原df
        df = df.merge(annual_df[['cash_dividend_3yr_sum', 'net_profit_3yr_avg']], 
                      how='left', left_index=True, right_index=True, suffixes=('', '_annual'))
        
        # 处理条件部分
        # 未分配利润均为正且报告期内盈利
        condition_part1 = (
            (df['合并报表未分配利润'] > 0) & 
            (df['母公司报表未分配利润'] > 0) & 
            (df['净利润'] > 0)
        )
        
        # 现金分红条件
        condition_part2 = (
            (~df['是否实施现金分红']) | 
            (df['cash_dividend_3yr_sum'] < df['net_profit_3yr_avg'] * 0.3)
        )
        
        # 年报数据才可能满足条件
        valid_condition = condition_part1 & condition_part2 & annual_mask
        df['meu_13_3_condition'] = valid_condition
        
        # 处理constraint：满足subject和condition时需要检查披露内容
        mask = df['meu_13_3_subject'] & df['meu_13_3_condition']
        df.loc[mask, 'meu_13_3_constraint'] = df.loc[mask, '权益分派方案文本'].apply(
            lambda x: llm_content_check(x, ""公司在相应期间是否按照中国证券监督管理委员会相关规定为中小股东参与现金分红决策提供了便利"")
        )
    else:
        # 没有年报数据，条件不满足
        df['meu_13_3_condition'] = False
    
    # 计算合规性：当subject和condition满足但constraint不满足时违规
    is_violation = df['meu_13_3_subject'] & df['meu_13_3_condition'] & (~df['meu_13_3_constraint'])
    df['meu_13_3_compliance'] = ~is_violation
    
    return df

但需要注意，在合并annual_df时，可能因为索引问题导致错误。例如，如果原df和annual_df的索引不一致，merge操作可能不正确。因此，可能需要使用其他方法，如将计算结果作为新列添加到原df中。

或者，使用transform方法：

在annual_df中计算cash_dividend_3yr_sum和net_profit_3yr_avg，然后将其合并回原df：

annual_df['cash_dividend_3yr_sum'] = annual_df.groupby('公司简称')['现金分红金额'].transform(lambda x: x.rolling(3, min_periods=3).sum())
annual_df['net_profit_3yr_avg'] = annual_df.groupby('公司简称')['净利润'].transform(lambda x: x.rolling(3, min_periods=3).sum()) / 3

然后，将这两个列合并到原df中：

df = df.merge(annual_df[['cash_dividend_3yr_sum', 'net_profit_3yr_avg']], left_index=True, right_index=True, how='left', suffixes=('', '_annual'))

这可能更有效，但需要确保annual_df的索引与原df中的年报行对应。

此外，处理cash_dividend_3yr_sum和net_profit_3yr_avg的NaN值。例如，在非年报行中，这些列可能为NaN，此时condition_part2中的现金分红条件可能为False，除非未进行现金分红。

例如，在非年报行中，是否实施现金分红可能为False，此时condition_part2为True。但根据MEU的条件，可能只有年报行才需要处理，因此非年报行的valid_condition可能为False。

综上，代码的大致结构如上，但可能需要进一步调试和测试。
","CompletionUsage(completion_tokens=8462, prompt_tokens=2043, total_tokens=10505, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=7680, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 5. 计算整体的违约情况并标记在dataframe上(meu_n_k_compliance). 

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df['meu_4_2_subject'] = False  # 初始化subject列
    df['meu_4_2_condition'] = False  # 初始化condition列
    df['meu_4_2_constrain'] = False  # 初始化constrain列

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True

    # 判断违规情况：满足主体和条件但不满足约束
    is_violation = (
        valid_subject & 
        valid_condition & 
        (~valid_constraint)
    )

    # 标记违规行
    df.loc[is_violation, 'meu_4_1_compliance'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_13_2
法律的最小可执行单元内容: {""subject"": ""上市公司"", ""condition"": ""合并资产负债表、母公司资产负债表中本年末未分配利润均为正值且报告期内盈利，未进行现金分红或最近三年现金分红总额低于最近三年年均净利润30%"", ""constraint"": ""应当在权益分派方案中披露：留存未分配利润的预计用途以及收益情况"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '财务数据日期', '公告日期', '公告类型', '审计意见', '总资产', '总负债', '净资产', '资产负债率',
'交易性金融资产', '衍生金融资产', '债权投资', '其他债权投资', '其他权益工具投资', '其他非流动金融资产',
'其他流动资产', '金融资产总额', '总股本', '每股净资产', '合并报表未分配利润', '母公司报表未分配利润', '净利润',
'每股净利润', '母公司报表净利润', '经营活动现金流量净额', '投资活动现金流量净额', '筹资活动现金流量净额',
'现金及现金等价物净增加额', '净资产增长率', '净利润增长率', '资产负债率变化', '金融资产增长率',
'是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划', '现金分红金额', '送股比例', '转增比例', '是否进行权益分派', '权益分派方案文本', '公司简称']

## 其中: 
- 这是一个二维的面板数据, 根据['日期', '公司简称']可以定位到特定公司在特定日期的状态. 数据已经按照公司简称和日期排序. 
- 我们的'日期'并非连续的自然日或者交易日, 而是固定的季报/半年报/年报披露后三个月内的某一个自然日, 例如'2020-05-30', '2020-09-29', ...等, 我们假定公司在这一天发布了权益分派公告(或者决定了不进行权益分派). 每个季报/半年报/年报后只会跟随一个'日期'来决定是否进行权益分派, 如何进行分派. 
- 数据的每一行包含了两个部分的数据, 分别是当时最新的财务数据和当时最新的权益分派情况. 例如, '2020-09-17'这一行可能对应了公告日期为'2020-08-27'的截至'2020-06-30'的半年报财务报告['审计意见', '总资产', ..., '现金及现金等价物净增加额'], 以及在'2020-09-17'当天公告的权益分派信息['是否进行权益分派', ..., '现金分红金额', ...]
- 所有财务数据都是以单季度的形式记录的, 不需要考虑利润表科目在半年报和年报中逐渐累加的问题. 所有的增长率都是单季的. 
- 所有资产/价格的单位都是元而非万元, 千元或百万元; 所有的比例/比率都是小数而非百分数, 除了['送股比例', '转增比例']是""每10股送n股""的格式. 
- ['审计意见']的值有""无保留意见"", ""非标准无保留意见"", ""保留意见"". 
- 这些列为布尔值: ['是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划']

- 如果希望检查权益分派方案中是否披露了特定内容, 可以使用环境中会提供的函数`llm_content_check()`, 但非披露类的合规检查中禁止使用这个函数. 
    描述: 使用LLM检查公告中是否包含特定内容
        参数:
            announcement_text: 公告全文
            traget_content: 需要检查的内容描述
        返回:
            bool: 公告中是否包含特定内容
    调用示例: 
        ```python
        from utils.tool_for_agents import llm_content_check

        constraint_description = ""为增强投资者回报水平拟采取的措施"" # 请完整描述需要检查的内容, 不得简化
        df['meu_4_1_constraint'] = df['权益分派方案文本'].apply(
            lambda text: llm_content_check(text, constraint_description)
        )
        ```

note:
 - 理论上你撰写合规检验代码所需要的数据都可以从一致的数据中得到, 对于没有直接对应的数据你需要自己计算得到, 不要简单地认为无法完成. 
 - 除非材料提供, 否则不要主动进行简化的假设. 如果你认为所给的信息不足以判断案例的合规性, 可以在函数的结尾进行注释说明. 但这种情况应该很少出现. 

","

<CODE>
import pandas as pd
from utils.tool_for_agents import llm_content_check

def check_meu_13_2(df):
    '''
    检验MEU_13_2合规性：
    subject: 上市公司
    condition: 合并及母公司资产负债表未分配利润均为正且报告期盈利，且未分红或近三年分红低于年均净利30%
    constraint: 需在权益分派方案中披露留存利润用途及收益
    '''
    
    # 初始化标记列
    df['meu_13_2_subject'] = True  # 所有行主体均为上市公司
    df['meu_13_2_condition'] = False
    df['meu_13_2_constraint'] = False
    
    # 条件判断预处理
    is_annual_report = df['财务数据日期'].dt.month == 12  # 年报标识
    
    # 条件1: 合并及母公司未分配利润均为正
    profit_condition = (df['合并报表未分配利润'] > 0) & (df['母公司报表未分配利润'] > 0)
    
    # 条件2: 报告期盈利
    profit_report = df['净利润'] > 0
    
    # 条件3: 未分红或近三年分红低于年均净利30% (仅年报处理)
    df['cash_dividend_3y_sum'] = pd.NA
    df['avg_net_profit_3y'] = pd.NA
    
    # 年报数据处理
    annual_mask = is_annual_report & profit_condition & profit_report
    annual_df = df[annual_mask].copy()
    
    if not annual_df.empty:
        # 按公司分组计算三年滚动指标
        annual_df.sort_values(['公司简称', '财务数据日期'], inplace=True)
        
        # 计算三年现金分红总和
        annual_df['cash_dividend_3y_sum'] = annual_df.groupby('公司简称')['现金分红金额']\
            .transform(lambda s: s.rolling(3, min_periods=3).sum())
        
        # 计算三年平均净利润
        annual_df['net_profit_3y_sum'] = annual_df.groupby('公司简称')['净利润']\
            .transform(lambda s: s.rolling(3, min_periods=3).sum())
        annual_df['avg_net_profit_3y'] = annual_df['net_profit_3y_sum'] / 3
        
        # 合并计算结果
        df.update(annual_df[['cash_dividend_3y_sum', 'avg_net_profit_3y']])
        
        # 条件3判断
        cond3 = (
            (~annual_df['是否实施现金分红']) | 
            (annual_df['cash_dividend_3y_sum'] < annual_df['avg_net_profit_3y'] * 0.3)
        )
        df.loc[annual_df.index, 'meu_13_2_condition'] = cond3
    
    # 约束条件检查
    constraint_mask = df['meu_13_2_condition'] & df['meu_13_2_subject']
    df.loc[constraint_mask, 'meu_13_2_constraint'] = df.loc[constraint_mask, '权益分派方案文本'].apply(
        lambda x: llm_content_check(x, ""留存未分配利润的预计用途以及收益情况"") if pd.notna(x) else False
    )
    
    # 综合合规判断
    violation_mask = (df['meu_13_2_condition'] & df['meu_13_2_subject']) & ~df['meu_13_2_constraint']
    df['meu_13_2_compliance'] = True
    df.loc[violation_mask, 'meu_13_2_compliance'] = False
    
    # 清理中间列
    df.drop(columns=['cash_dividend_3y_sum', 'avg_net_profit_3y'], inplace=True, errors='ignore')
    
    return df
</CODE>","好的，我现在需要处理这个MEU_13_2的合规性检查任务。首先，我得仔细理解这个MEU的内容。根据给定的信息，MEU_13_2的条件是当上市公司在合并资产负债表和母公司资产负债表中，本年末未分配利润均为正值，并且报告期内盈利，同时未进行现金分红或最近三年现金分红总额低于最近三年年均净利润的30%时，必须在权益分派方案中披露留存未分配利润的预计用途及收益情况。

首先，我需要拆分出subject、condition和constraint三个部分。Subject是上市公司，所以这一步可能比较简单，因为每一行数据都是针对上市公司的，所以可能所有行的subject都是有效的？不过可能需要确认是否有其他条件限制，但根据MEU的描述，subject就是上市公司，所以可能直接标记为True。不过可能需要检查公司是否处于正常状态，比如是否有有效的审计意见？比如审计意见是否为无保留意见？但MEU中没有提到这一点，所以可能不需要考虑。所以可能所有行的subject都是有效的，但需要确认。

接下来是condition部分。Condition分为几个部分：合并和母公司资产负债表中的未分配利润均为正值，报告期内盈利，并且未进行现金分红或最近三年现金分红总额低于最近三年年均净利润的30%。这里需要将这些条件拆解成代码逻辑。

首先，合并报表未分配利润和母公司报表未分配利润是否均为正值？对应的列应该是'合并报表未分配利润'和'母公司报表未分配利润'，检查这两个值是否都大于0。

然后，报告期内盈利，即净利润是否大于0？对应的列是'净利润'，需要检查是否大于0。

接下来，未进行现金分红或者最近三年现金分红总额低于最近三年年均净利润的30%。这里有两个条件，满足其中一个即可。未进行现金分红对应的是'是否实施现金分红'为False。而最近三年的情况可能需要计算。但这里的数据结构可能有问题，因为当前数据是日频的，每个日期对应的是当时的财务数据和分派情况。如何获取最近三年的现金分红总额和年均净利润呢？

比如，假设当前行的财务数据日期是2023年的年报，那么最近三年就是2021、2022、2023年。但数据中的每一行可能只包含当前报告期的数据，比如每个季度的数据。所以可能需要跨行数据来获取三年的总和。但根据用户提供的附加信息，数据中的财务数据是单季度的，所以这可能存在困难。或者，可能这里的“最近三年”指的是当前财务数据日期所在年及其前两年？例如，如果当前行的财务数据日期是2023年12月31日，那么最近三年是2021、2022、2023年。但如何从当前数据中获取这三年的现金分红金额和净利润？

这可能是一个挑战。因为当前数据可能只包含当前报告期的数据，而无法直接获取前三年的总和。例如，每一行可能代表一个季度或年度的数据，但如何跨行聚合三年的数据？

根据附加信息中的说明，数据中的每一行对应的是某个季报/半年报/年报后的权益分派决定。例如，某一行可能对应2020年半年报后的分派情况。但每个季度的数据可能单独存在。因此，可能需要计算每个公司在过去三年内的现金分红总额，以及这三年的年均净利润。

但如何从当前行的数据中获取这些历史数据呢？比如，当前行的财务数据日期是某个时间点，需要找到该公司在此日期前三年的现金分红金额和净利润。这可能涉及到对同一公司的其他行进行聚合计算。例如，对于当前行，需要找到该公司在过去三年内的所有现金分红金额的总和，以及这三年的净利润总和的平均值。

但根据用户提供的dataframe的列，当前行可能只有当前报告期的现金分红金额，而没有历史数据。这可能意味着，当前数据不足以直接计算最近三年的现金分红总额和年均净利润。这可能是一个问题，导致无法正确判断条件是否满足。

这时候可能需要用户提供更多的数据或者假设。但根据任务要求，用户可能期望我们利用现有的列进行计算。或者，可能这里的“最近三年”指的是当前财务数据日期所在年度的前三年？例如，如果当前行的财务数据日期是2023年的年报，那么最近三年是2020、2021、2022年？但这样可能无法包括当前年度的数据？

或者，可能这里的“最近三年”指的是当前报告期之前的三个完整年度？例如，如果当前报告期是2023年半年报，那么最近三年可能是2020、2021、2022年？

这可能需要更明确的定义。但根据MEU的描述，条件中的“最近三年现金分红总额”和“最近三年年均净利润”可能需要当前行所在年度的前三年数据。例如，假设当前行的财务数据日期是2023年12月31日（年报），那么最近三年是2021、2022、2023年。但如何从当前行的数据中获取这三年的分红和净利润？

这可能无法完成，因为当前行可能只包含当前报告期的数据，而其他年份的数据可能在其他行中。因此，可能需要跨行聚合同一公司的数据，找到过去三年的数据总和。

但根据用户提供的dataframe的结构，每一行对应的是某个日期（如季报/年报后的某个时间点）的财务数据和权益分派情况。例如，每个公司每年可能有多个行，对应不同的报告期。例如，年报后的行可能包含全年的财务数据，而季报后的行可能包含当季的数据。

因此，要计算最近三年的现金分红总额，可能需要找到同一公司过去三年内的所有现金分红金额的总和。同样，最近三年的年均净利润需要这三年的净利润总和除以3。

但如何从当前行的数据中获取这些信息呢？可能需要遍历该公司的所有历史行，找到最近三年的数据。这可能涉及到对dataframe进行groupby操作，按公司分组，然后对于每一行，计算过去三年的累计值。

例如，对于每一行，确定其财务数据日期（比如'财务数据日期'列），然后找到该公司在财务数据日期前三年的所有现金分红金额的总和，以及这三年的净利润总和的平均值。

这可能需要使用到pandas的rolling或groupby操作。例如，按公司分组后，对每个公司的现金分红金额进行滚动窗口计算，窗口大小为三年。但具体实现可能比较复杂，特别是如果数据中的日期不是按年排列的话。

或者，可能用户的数据中，每个年报后的行会记录当年的现金分红金额，而其他季度的行可能不涉及分红。例如，现金分红通常是在年报后进行的，所以可能每个公司的年报行会记录当年的分红金额。因此，对于当前行，如果是年报后的行，那么可以获取该公司的前两年的年报行中的现金分红金额，加上当前行的分红金额，来计算最近三年的总和。

但如何确定当前行是否是年报后的行？可能需要根据财务数据日期的月份来判断，比如年报通常在12月31日。或者，可能根据公告类型来判断，但用户提供的列中没有公告类型的具体内容，只有'公告类型'列，但可能该列的值例如“年报”、“半年报”等。

但根据用户提供的列，确实存在'财务数据日期'列，这可能是一个日期类型的列，比如每个季度的结束日期，如2023-03-31（一季度）、2023-06-30（半年报）、2023-09-30（三季度）、2023-12-31（年报）。因此，年报的财务数据日期是每年的12月31日。

因此，对于每个公司的年报行，可以获取该年的现金分红金额，而其他季度的行可能没有分红。因此，要计算最近三年的现金分红总额，可能需要找到该公司最近三个年报行的现金分红金额之和。

例如，当前行的财务数据日期是2023-12-31，那么最近三年是2021、2022、2023年，对应的年报行的现金分红金额总和。如果当前行是2023年的年报行，那么需要找到该公司在2021、2022、2023年的年报行中的现金分红金额，并求和。

同样，最近三年的年均净利润是这三年的净利润总和除以3。净利润可能来自年报行的'净利润'列，因为年报的净利润是全年的，而季报的净利润是单季度的，可能无法直接相加得到全年数据。因此，可能需要只考虑年报行的净利润数据。

因此，在代码中，可能需要按公司分组，然后对于每个公司的年报行，计算过去三年的现金分红总额和年均净利润。

但如何实现这一点呢？例如，对于每一行，如果是年报行（财务数据日期的月份为12月），则获取该公司过去三年的年报行的现金分红金额，并计算总和。同时，获取这三年的净利润总和，计算年均值。

这可能需要使用到shift或rolling窗口函数，按公司分组后，对年报行进行处理。例如，按公司分组后，对每个公司的年报行按时间排序，然后计算过去三年的总和。

但具体实现可能比较复杂。例如，假设当前行是某公司的2023年年报行，那么需要找到该公司2021、2022、2023年的年报行中的现金分红金额，并求和。如果这三年的年报行存在的话。

这可能涉及到对每个公司的年报行进行时间排序，并取最近三年的数据。例如，对于每个公司的年报行，按财务数据日期降序排列，然后取前三年的数据。

但如何确保每个年报行都有前三年的数据？如果公司上市不足三年，可能无法满足条件，此时最近三年的现金分红总额可能不存在，或者需要处理缺失值。

这可能是一个挑战。例如，如果公司只有两年的年报数据，那么无法计算最近三年的总和，此时条件中的“最近三年现金分红总额”可能无法满足，因此该条件可能不适用？

或者，可能在这种情况下，条件中的“最近三年”指的是存在的年份，但MEU中的条件可能需要满足最近三年存在的情况下才能触发。或者，可能当公司存在至少三年的数据时，才进行判断，否则该条件不适用？

这可能需要更明确的规则，但根据MEU的描述，可能需要假设公司存在最近三年的数据。否则，可能无法满足条件，因此该条件不会被触发。

综上，处理condition部分的条件可能需要以下步骤：

1. 检查合并和母公司报表的未分配利润是否均为正值。
2. 检查报告期内是否盈利（净利润>0）。
3. 检查是否未进行现金分红，或者最近三年现金分红总额低于最近三年年均净利润的30%。

其中，第三个条件的计算较为复杂，需要跨行数据。

现在，我需要考虑如何用现有的数据列来实现这些条件。

首先，合并和母公司未分配利润是否正值：

valid_condition_part1 = (df['合并报表未分配利润'] > 0) & (df['母公司报表未分配利润'] > 0)

然后，报告期内盈利：

valid_condition_part2 = df['净利润'] > 0

接下来，第三个条件：

未进行现金分红：即'是否实施现金分红'为False。

或者，如果当前行对应的权益分派中未进行现金分红，那么满足条件的一部分。

或者，最近三年现金分红总额 < 最近三年年均净利润 * 0.3。

这里需要计算最近三年的现金分红总额和年均净利润。

假设当前行是年报行，那么需要找到该公司前三年的年报行的现金分红金额之和，以及这三年的净利润之和的平均值。

例如，对于当前行（年报行），现金分红金额是该年度的分红，而前三年的年报行中的现金分红金额总和即为最近三年的总和。同样，这三年的净利润总和除以3即为年均净利润。

因此，在代码中，可能需要按公司分组，并对每个公司的年报行进行处理，计算每个年报行对应的最近三年的现金分红总和和年均净利润。

但如何实现这一点呢？

可能需要以下步骤：

1. 筛选出所有年报行（财务数据日期的月份为12月）。
2. 按公司分组，并按财务数据日期排序。
3. 对于每个年报行，计算过去三年的现金分红金额总和和年均净利润。
4. 将计算结果合并回原始数据中。

但原始数据中的每一行可能包含年报行和非年报行。例如，有些行是季报后的权益分派决定，可能没有现金分红。因此，可能需要先筛选出年报行，然后处理这些行的条件。

但MEU的条件是否只适用于年报后的权益分派？例如，只有当公司发布年报时，才会进行现金分红，因此该条件可能只在年报行中被触发？

或者，可能不管是否是年报行，只要满足条件就需要检查？

根据MEU的描述，条件中的“本年末未分配利润”可能指的是年度末的情况，因此可能只有年报行才会有本年末的数据。因此，可能该条件只适用于年报行。

因此，在代码中，可能需要先筛选出年报行，然后对这些行进行处理。

但用户提供的dataframe中的每一行可能对应不同的报告期，比如季报、半年报、年报。因此，需要确定当前行是否是年报行，即财务数据日期是否为年末（如12月31日）。

因此，在代码中，可以添加一个条件，判断财务数据日期是否为年末：

is_annual_report = df['财务数据日期'].dt.month == 12

然后，只有年报行才需要处理该MEU的条件？

或者，可能其他报告期也可能有未分配利润的数据？例如，半年报可能也有合并和母公司报表的未分配利润数据，但年末的数据可能更准确？

根据MEU的条件中的“本年末未分配利润”，所以可能只有年报行才有“本年末”的数据。因此，其他季度的行可能不适用该条件。因此，在代码中，可能只需要处理年报行，其他行的condition部分自动为False。

因此，在代码中，可以首先筛选出年报行，然后在这些行中处理条件。

现在，针对年报行，处理第三个条件：

未进行现金分红：即该行的'是否实施现金分红'为False。

或者，最近三年现金分红总额 < 最近三年年均净利润的30%。

对于年报行，需要计算该公司过去三年的现金分红总额和年均净利润。

例如，当前行的财务数据日期是2023-12-31，那么需要找到该公司在2021、2022、2023年的年报行中的现金分红金额，并求和。同时，这三年的净利润总和除以3得到年均净利润，然后乘以0.3，比较现金分红总额是否小于这个值。

因此，在代码中，可能需要按公司分组，并对每个公司的年报行进行滚动计算，获取过去三年的数据。

这可以通过groupby和rolling窗口来实现。例如：

对于每个公司，按财务数据日期排序，然后使用rolling窗口大小为3，计算现金分红金额的总和，以及净利润的总和。

但需要注意，rolling窗口是基于时间的，但可能每个公司的年报行是按年递增的，所以窗口大小为3，表示最近的三个年报行。

例如，对于某公司的年报行序列：

年份：2020, 2021, 2022, 2023

当处理2023年的年报行时，rolling窗口包含2021, 2022, 2023这三年的数据？

或者，窗口是连续的三个年份？例如，窗口大小为3，表示当前行加上前两行？

这可能需要将数据按时间升序排列，然后使用rolling(3, min_periods=3)来计算总和，但这样可能无法正确获取最近三年的数据，因为如果数据是按时间降序排列的话，窗口可能不正确。

因此，可能需要将每个公司的年报行按财务数据日期升序排列，然后使用rolling窗口，计算每个行的过去三年的总和。

例如，对于2023年的年报行，窗口包括2021、2022、2023年，如果窗口大小为3，并且数据是按升序排列的话，那么窗口的最后一行是当前行，前两行是前两年的数据。但这样，rolling(3)会包括当前行和前两行，即三年的数据。总和即为这三年的总和。

但这样，每个年报行的rolling窗口将包含当前行和前两年的数据，总和即为最近三年的总和。

因此，在代码中，可以按公司分组，然后对每个公司的年报行按财务数据日期升序排列，然后计算现金分红金额的rolling总和，窗口大小为3，min_periods=3。同样，计算净利润的rolling总和，然后除以3得到年均净利润。

例如：

grouped = df[is_annual_report].groupby('公司简称', group_keys=False)

# 按财务数据日期升序排列
grouped_sorted = grouped.apply(lambda x: x.sort_values('财务数据日期'))

# 计算过去三年的现金分红总和
cash_dividend_sum = grouped_sorted['现金分红金额'].rolling(window=3, min_periods=3).sum()

# 计算过去三年的净利润总和，然后除以3得到年均
net_profit_sum = grouped_sorted['净利润'].rolling(window=3, min_periods=3).sum()
avg_net_profit = net_profit_sum / 3

然后，将这两个计算结果合并回原始dataframe中。但需要注意，原始dataframe中的行可能不是按顺序排列的，或者可能包含非年报行。因此，可能需要将计算结果与原数据合并，例如使用merge或join操作。

或者，可能需要在原dataframe中创建新列，例如'cash_dividend_3y_sum'和'avg_net_profit_3y'，然后填充这些值。

但这个过程可能比较复杂，特别是如何处理每个公司的年报行，并确保正确的rolling计算。

此外，如果某个公司的年报行不足三年，则min_periods=3会导致这些行的cash_dividend_sum和avg_net_profit为NaN，此时对应的条件无法满足，因此该行的condition部分可能为False。

综上，处理第三个条件的步骤可能如下：

对于每个年报行：

- 检查是否未进行现金分红（'是否实施现金分红'为False），或者最近三年现金分红总额 < 最近三年年均净利润 * 0.3。

如果满足其中一个条件，则condition的第三部分为True。

现在，将这些步骤转化为代码：

首先，标记subject。因为subject是上市公司，所以所有行的subject都是有效的？或者是否需要其他条件？

根据MEU的描述，subject是“上市公司”，所以所有行的subject都应该标记为True。但可能需要确认是否该行对应的公司确实是上市公司。但根据数据描述，数据中的公司都是上市公司，所以可能所有行的subject都是有效的。因此，在代码中：

df['meu_13_2_subject'] = True

但可能需要确认是否存在其他条件，比如公司是否处于退市状态等，但数据中没有相关列，所以可能无法判断。因此，假设所有行的subject都是有效的。

接下来，处理condition部分：

condition分为三个部分：

1. 合并和母公司未分配利润均为正值。
2. 报告期内盈利（净利润>0）。
3. 未进行现金分红，或最近三年现金分红总额 < 最近三年年均净利润的30%。

因此，valid_condition = (part1) & (part2) & (part3)

其中，part3是 (未分红) | (现金分红总额 < 年均净利润 * 0.3)

现在，如何计算part3？

首先，筛选年报行：

is_annual_report = df['财务数据日期'].dt.month == 12

然后，对于年报行，计算现金分红总额和年均净利润：

对于每个公司的年报行，按时间排序，计算过去三年的总和。

在代码中，可能需要：

# 筛选年报行
annual_reports = df[is_annual_report].copy()

# 按公司分组，并按财务数据日期排序
annual_reports_sorted = annual_reports.sort_values(['公司简称', '财务数据日期'])

# 计算每个公司的现金分红金额的三年滚动总和
annual_reports_sorted['cash_dividend_3y_sum'] = annual_reports_sorted.groupby('公司简称')['现金分红金额'].transform(lambda x: x.rolling(window=3, min_periods=3).sum())

# 计算三年净利润总和，然后年均
annual_reports_sorted['net_profit_3y_sum'] = annual_reports_sorted.groupby('公司简称')['净利润'].transform(lambda x: x.rolling(window=3, min_periods=3).sum())
annual_reports_sorted['avg_net_profit_3y'] = annual_reports_sorted['net_profit_3y_sum'] / 3

# 计算条件3：未分红或现金分红总额 < 年均净利润 * 0.3
condition3 = (~annual_reports_sorted['是否实施现金分红']) | (annual_reports_sorted['cash_dividend_3y_sum'] < annual_reports_sorted['avg_net_profit_3y'] * 0.3)

# 将condition3合并回原dataframe
# 这里需要将annual_reports_sorted中的计算结果合并到原df中
# 使用merge或者 join，但需要确保索引正确

# 假设原df有一个唯一索引，可以先将annual_reports_sorted的索引保存，然后合并
# 例如，将计算结果保存到临时列，然后合并到原df

# 创建临时DataFrame，只包含需要的列
temp_df = annual_reports_sorted[['cash_dividend_3y_sum', 'avg_net_profit_3y']].copy()

# 合并到原df，使用左连接，这样非年报行的这些列将为NaN
df = df.merge(temp_df, left_index=True, right_index=True, how='left', suffixes=('', '_temp'))

# 现在，对于年报行，condition3为计算后的值，其他行则为NaN
# 因此，在计算part3时，非年报行的条件3自动为False？

或者，可能更简单的方式是，在原始df中创建这些列，初始为NaN，然后在年报行中填充计算后的值。

但无论如何，最终在计算condition3时，非年报行的条件3部分可能不满足，因此整个condition部分为False。

现在，将这三个部分组合起来：

part1 = (df['合并报表未分配利润'] > 0) & (df['母公司报表未分配利润'] > 0)
part2 = df['净利润'] > 0
part3 = (~df['是否实施现金分红']) | (df['cash_dividend_3y_sum'] < df['avg_net_profit_3y'] * 0.3)

但需要注意，cash_dividend_3y_sum和avg_net_profit_3y仅在年报行中存在有效值，其他行可能为NaN。因此，在非年报行中，part3的条件可能为False，因为：

(~df['是否实施现金分红']) 可能为True或False，但另一个条件可能为NaN，导致整个表达式为False？

或者，在非年报行中，是否实施现金分红可能为False，但此时是否满足条件？

例如，如果某行是非年报行，但未实施现金分红，那么是否满足条件？

根据MEU的条件，是否只有在年报行中才需要检查这些条件？

可能MEU的条件中的“本年末未分配利润”指的是年报的数据，因此非年报行可能不适用。因此，在代码中，可能只有年报行需要处理condition部分，其他行的condition自动为False。

因此，在代码中，可以将condition的valid_condition设置为：

valid_condition = is_annual_report & part1 & part2 & part3

但如何确保part3仅在年报行中计算？

或者，将valid_condition分解为：

valid_condition = (is_annual_report) & (part1) & (part2) & (part3)

其中，part3在年报行中计算，其他行为False。

现在，处理constraint部分：

constraint是“应当在权益分派方案中披露：留存未分配利润的预计用途以及收益情况”。

因此，需要检查权益分派方案文本中是否包含这些内容。根据用户提供的附加信息，可以使用llm_content_check函数。

因此，在代码中，对于满足subject和condition的行，需要检查其权益分派方案文本是否包含所需内容。

具体来说，当valid_subject和valid_condition都为True时，需要检查constraint是否满足。

因此，在代码中：

valid_constraint = df['权益分派方案文本'].apply(lambda x: llm_content_check(x, ""留存未分配利润的预计用途以及收益情况""))

但需要仅在满足subject和condition的情况下进行此检查。或者，不管是否满足，只要存在权益分派方案文本，就进行检查？

根据MEU的约束条件，只有当条件满足时，才需要披露。因此，只有当valid_condition为True时，才需要检查constraint是否满足。

因此，在代码中，可以：

mask = valid_subject & valid_condition
df.loc[mask, 'meu_13_2_constraint'] = df.loc[mask, '权益分派方案文本'].apply(lambda x: llm_content_check(x, ""留存未分配利润的预计用途以及收益情况""))

对于其他行，constraint可能不需要检查，因此标记为False或者保持原初始值。

现在，整合所有步骤：

1. 标记subject为True。
2. 处理condition的三个部分，仅在年报行中计算。
3. 处理constraint，使用llm_content_check函数。
4. 计算整体的合规性：当subject和condition为True，但constraint为False时，标记为违规。

现在，编写代码：

首先，初始化各列：

df['meu_13_2_subject'] = True  # 所有行的subject都是上市公司，所以直接为True
df['meu_13_2_condition'] = False
df['meu_13_2_constraint'] = False

然后，处理condition部分：

is_annual_report = df['财务数据日期'].dt.month == 12

# 计算part1和part2
part1 = (df['合并报表未分配利润'] > 0) & (df['母公司报表未分配利润'] > 0)
part2 = df['净利润'] > 0

# 处理part3，需要计算年报行的现金分红总和和年均净利润
# 筛选年报行，并按公司分组处理
annual_reports = df[is_annual_report].copy()

# 按公司分组，并按财务数据日期排序
annual_reports_sorted = annual_reports.sort_values(['公司简称', '财务数据日期'])

# 计算过去三年的现金分红总和和年均净利润
annual_reports_sorted['cash_dividend_3y_sum'] = annual_reports_sorted.groupby('公司简称')['现金分红金额'].transform(
    lambda x: x.rolling(window=3, min_periods=3).sum()
)
annual_reports_sorted['net_profit_3y_sum'] = annual_reports_sorted.groupby('公司简称')['净利润'].transform(
    lambda x: x.rolling(window=3, min_periods=3).sum()
)
annual_reports_sorted['avg_net_profit_3y'] = annual_reports_sorted['net_profit_3y_sum'] / 3

# 将计算结果合并回原df
# 使用索引来更新原df中的列
df.update(annual_reports_sorted[['cash_dividend_3y_sum', 'avg_net_profit_3y']])

# 计算part3
# 对于年报行，计算是否未分红或现金分红总额 < 年均净利润的30%
part3 = (~annual_reports['是否实施现金分红']) | (annual_reports_sorted['cash_dividend_3y_sum'] < annual_reports_sorted['avg_net_profit_3y'] * 0.3)

# 合并part3到原df中
# 这里可能需要将part3的Series与原df对齐
# 假设annual_reports_sorted的索引与原df中的年报行索引一致
df.loc[is_annual_report, 'part3_temp'] = part3.values

# 组合condition的条件
valid_condition = is_annual_report & part1 & part2 & df['part3_temp'].fillna(False)

# 标记condition列
df['meu_13_2_condition'] = valid_condition

接下来，处理constraint部分：

from utils.tool_for_agents import llm_content_check

# 仅当subject和condition都为True时，检查constraint
mask = df['meu_13_2_subject'] & df['meu_13_2_condition']
df.loc[mask, 'meu_13_2_constraint'] = df.loc[mask, '权益分派方案文本'].apply(
    lambda x: llm_content_check(x, ""留存未分配利润的预计用途以及收益情况"") if pd.notnull(x) else False
)

最后，计算合规性：

# 违约情况：满足subject和condition，但不满足constraint
is_violation = (df['meu_13_2_subject'] & df['meu_13_2_condition']) & (~df['meu_13_2_constraint'])
df['meu_13_2_compliance'] = True
df.loc[is_violation, 'meu_13_2_compliance'] = False

但需要注意，可能有些行没有权益分派方案文本，例如未进行权益分派。此时，如果condition被触发（即需要披露），但权益分派方案文本不存在，则constraint不满足，导致违约。

例如，如果公司满足condition，但未进行权益分派（'是否进行权益分派'为False），则可能没有权益分派方案文本，此时无法满足constraint，导致违约。

因此，在代码中，可能需要检查是否进行了权益分派。如果未进行权益分派，但需要披露，则可能违约。

但根据MEU的约束条件，当公司满足condition时，必须披露。因此，如果公司满足condition，但未进行权益分派（即未披露），则constraint不满足。

例如，如果公司满足condition，但未进行权益分派，那么权益分派方案文本可能为空，此时llm_content_check返回False，导致constraint不满足。

因此，代码中的处理是正确的。

综上，最终的代码可能如下：
","CompletionUsage(completion_tokens=7261, prompt_tokens=2034, total_tokens=9295, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=6371, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 

# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 5. 计算整体的违约情况并标记在dataframe上(meu_n_k_compliance). 

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df['meu_4_2_subject'] = False  # 初始化subject列
    df['meu_4_2_condition'] = False  # 初始化condition列
    df['meu_4_2_constrain'] = False  # 初始化constrain列

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True

    # 判断违规情况：满足主体和条件但不满足约束
    is_violation = (
        valid_subject & 
        valid_condition & 
        (~valid_constraint)
    )

    # 标记违规行
    df.loc[is_violation, 'meu_4_1_compliance'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_19_6
法律的最小可执行单元内容: {""subject"": ""上市公司"", ""condition"": ""相关股东在后三个月存在减持计划"", ""constraint"": ""不得披露高送转方案"", ""contextual_info"": ""相关股东指公司的提议股东和控股股东及其一致行动人、董事、监事及高级管理人员""}
必要的额外信息: nan

你被分配的MEU coding任务存在refer_to关系, 你需要参考下面这个MEU的必要内容来完成你被安排的任务, 但你不需要直接执行下面的MEU: 
【MEU_17_1】
subject: nan
condition: nan
constrain: nan
contextual_info: 本指引所称高送转，是指公司每十股送红股与公积金转增股本，合计达到或者超过五股


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '财务数据日期', '公告日期', '公告类型', '审计意见', '总资产', '总负债', '净资产', '资产负债率',
'交易性金融资产', '衍生金融资产', '债权投资', '其他债权投资', '其他权益工具投资', '其他非流动金融资产',
'其他流动资产', '金融资产总额', '总股本', '每股净资产', '合并报表未分配利润', '母公司报表未分配利润', '净利润',
'每股净利润', '母公司报表净利润', '经营活动现金流量净额', '投资活动现金流量净额', '筹资活动现金流量净额',
'现金及现金等价物净增加额', '净资产增长率', '净利润增长率', '资产负债率变化', '金融资产增长率',
'是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划', '现金分红金额', '送股比例', '转增比例', '是否进行权益分派', '权益分派方案文本', '公司简称']

## 其中: 
- 这是一个二维的面板数据, 根据['日期', '公司简称']可以定位到特定公司在特定日期的状态. 数据已经按照公司简称和日期排序. 
- 我们的'日期'并非连续的自然日或者交易日, 而是固定的季报/半年报/年报披露后三个月内的某一个自然日, 例如'2020-05-30', '2020-09-29', ...等, 我们假定公司在这一天发布了权益分派公告(或者决定了不进行权益分派). 每个季报/半年报/年报后只会跟随一个'日期'来决定是否进行权益分派, 如何进行分派. 
- 数据的每一行包含了两个部分的数据, 分别是当时最新的财务数据和当时最新的权益分派情况. 例如, '2020-09-17'这一行可能对应了公告日期为'2020-08-27'的截至'2020-06-30'的半年报财务报告['审计意见', '总资产', ..., '现金及现金等价物净增加额'], 以及在'2020-09-17'当天公告的权益分派信息['是否进行权益分派', ..., '现金分红金额', ...]
- 所有财务数据都是以单季度的形式记录的, 不需要考虑利润表科目在半年报和年报中逐渐累加的问题. 所有的增长率都是单季的. 
- 所有资产/价格的单位都是元而非万元, 千元或百万元; 所有的比例/比率都是小数而非百分数, 除了['送股比例', '转增比例']是""每10股送n股""的格式. 
- ['审计意见']的值有""无保留意见"", ""非标准无保留意见"", ""保留意见"". 
- 这些列为布尔值: ['是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划']

- 如果希望检查权益分派方案中是否披露了特定内容, 可以使用环境中会提供的函数`llm_content_check()`, 但非披露类的合规检查中禁止使用这个函数. 
    描述: 使用LLM检查公告中是否包含特定内容
        参数:
            announcement_text: 公告全文
            traget_content: 需要检查的内容描述
        返回:
            bool: 公告中是否包含特定内容
    调用示例: 
        ```python
        from utils.tool_for_agents import llm_content_check

        constraint_description = ""为增强投资者回报水平拟采取的措施"" # 请完整描述需要检查的内容, 不得简化
        df['meu_4_1_constraint'] = df['权益分派方案文本'].apply(
            lambda text: llm_content_check(text, constraint_description)
        )
        ```

note:
 - 理论上你撰写合规检验代码所需要的数据都可以从一致的数据中得到, 对于没有直接对应的数据你需要自己计算得到, 不要简单地认为无法完成. 
 - 除非材料提供, 否则不要主动进行简化的假设. 如果你认为所给的信息不足以判断案例的合规性, 可以在函数的结尾进行注释说明. 但这种情况应该很少出现. 

","

<CODE>
import pandas as pd

def check_meu_19_6(df):
    '''
    验证上市公司在相关股东存在未来三个月减持计划时是否违规披露高送转方案
    MEU_19_6参数:
    - subject: 上市公司
    - condition: 相关股东在后三个月存在减持计划
    - constraint: 不得披露高送转方案
    - contextual_info: 相关股东定义及高送转标准参考
    '''

    # 初始化合规标记列
    df['meu_19_6_subject'] = True  # 数据源默认均为上市公司
    df['meu_19_6_condition'] = False
    df['meu_19_6_constraint'] = False
    df['meu_19_6_compliance'] = True  # 默认状态为合规

    # 1. 标记valid的subject（所有行默认满足）
    # 根据数据特性，假设所有记录主体均为上市公司

    # 2. 标记valid的condition
    df['meu_19_6_condition'] = df['相关股东后三个月存在减持计划']

    # 3. 标记valid的constraint
    # 计算高送转标准（每10股合计≥5股）
    high_song_zhuan = (df['送股比例'] + df['转增比例']) >= 5
    # 结合权益分派实施状态
    high_song_zhuan = df['是否进行权益分派'] & high_song_zhuan
    # 约束有效性判断：当condition为True时不得存在高送转
    df['meu_19_6_constraint'] = (~high_song_zhuan) | (~df['meu_19_6_condition'])

    # 4. 标记违规情况（同时满足主体/条件但违反约束）
    is_violation = df['meu_19_6_condition'] & high_song_zhuan
    df.loc[is_violation, 'meu_19_6_compliance'] = False

    return df
</CODE>","好的，我现在需要为MEU_19_6编写一个合规性检查的函数。首先，我得仔细理解这个MEU的内容。根据提供的描述，MEU_19_6的subject是“上市公司”，condition是“相关股东在后三个月存在减持计划”，constraint是“不得披露高送转方案”，而contextual_info解释了相关股东的范围。

接下来，我需要确定如何根据给定的数据框中的列来验证这三个部分。首先，subject是上市公司，这里的数据框每一行应该代表一个公司的某一天的情况，所以可能不需要特别的检查，因为数据本身可能都是针对上市公司的。但可能需要确认是否存在其他情况，比如非上市公司，但根据问题描述，数据框中的公司都是上市公司，所以可能直接标记subject为True。不过可能需要确认是否有列可以明确这一点，比如是否有“是否上市公司”这样的列。但根据提供的列列表，没有这样的列。所以可能假设所有行都是上市公司，因此subject条件总是满足。但需要再仔细看问题中的附加信息。

附加信息中的列包括“公司简称”等，但没有明确的是否上市公司的列。可能这里的上市公司是前提，所以所有数据中的公司都是上市公司。因此，在代码中，所有行的subject条件都满足，所以meu_19_6_subject列可以直接设为True。

接下来是condition部分：“相关股东在后三个月存在减持计划”。根据提供的列，有一个布尔列叫做“相关股东后三个月存在减持计划”。所以，condition是否满足可以直接用这个列的值。如果该列为True，则condition满足。因此，valid_condition就是df['相关股东后三个月存在减持计划'] == True。

然后是constraint部分：“不得披露高送转方案”。这里需要确定公司是否披露了高送转方案。根据MEU_17_1的contextual_info，高送转是指每十股送红股与公积金转增股本合计达到或超过五股。所以，需要检查公司的权益分派方案中是否包含这样的高送转。

根据数据框中的列，有“送股比例”和“转增比例”这两个列，它们的格式是“每10股送n股”和“每10股转增n股”。所以，计算高送转的条件是：送股比例 + 转增比例 >=5。例如，如果送股是3股，转增是2股，合计5股，就属于高送转。因此，当这两个列的和大于等于5时，视为存在高送转方案。

但需要注意，是否实际披露了高送转方案可能要看是否进行了相应的权益分派。例如，如果公司进行了送股或转增，并且总和达到条件，那么就是披露了高送转。因此，constraint的条件是：当公司披露了高送转方案时，是否违反了不得披露的规定。也就是说，如果相关股东存在减持计划（condition满足），同时公司披露了高送转方案（即送股比例+转增比例>=5），则违反constraint，即constraint的valid是当condition满足时，是否没有披露高送转。

所以，valid_constraint应该是：当condition满足时，公司没有进行高送转。即，如果condition为True，那么高送转方案是否存在？如果存在，则constraint不满足（因为不得披露），所以valid_constraint应为（送股比例 + 转增比例 <5）或者没有进行送股或转增。

但需要看数据中的列。例如，是否有“是否公积金转增股本”和“是否实施股票股利”这样的布尔列。根据提供的列，有“是否实施股票股利”和“是否公积金转增股本”这两个布尔列。此外，还有“送股比例”和“转增比例”的具体数值。所以，判断是否进行了高送转需要同时检查这两个比例的总和是否>=5，并且是否实际实施了这些分派。

例如，如果公司实施了股票股利或公积金转增，并且两者的比例之和>=5，则视为高送转。因此，计算高送转的条件是：

高送转 = (送股比例 + 转增比例) >=5，并且（是否实施股票股利为True 或者 是否公积金转增股本为True）？

或者，可能这两个比例只有在实际实施的情况下才会有数值。例如，如果公司没有实施股票股利，那么送股比例可能为0。因此，只要送股比例和转增比例之和>=5，就说明存在高送转方案，无论是否实施？

但根据问题中的附加信息，这些列是权益分派的信息，例如“是否进行权益分派”可能表示是否实际进行了分派。所以，可能只有当公司实际进行了分派（即“是否进行权益分派”为True），并且送股和转增的比例之和>=5时，才视为披露了高送转方案。

或者，可能即使公司只是公告了计划，但尚未实施，也需要视为披露。例如，在公告中提出高送转方案，但还未实施，是否属于“披露”？

根据MEU_19_6的constraint是“不得披露高送转方案”，所以只要在公告中存在高送转方案，无论是否实施，都算作披露。因此，需要检查权益分派方案中是否包含高送转的内容。

根据数据中的列，有“送股比例”和“转增比例”这两个数值列。因此，只要这两个比例之和>=5，就说明存在高送转方案。例如，送股比例是每10股送3股，转增比例是每10股转增3股，总和是6，满足条件。因此，高送转的条件是：

high_song_zhuan = (df['送股比例'] + df['转增比例']) >=5

但需要确认这两个列的数据类型是否为整数或浮点数。根据附加信息，这两个列是“每10股送n股”的格式，所以应该是数值类型，例如送股比例是3，转增比例是2，总和是5。

因此，当high_song_zhuan为True时，视为存在高送转方案。此时，如果condition满足（相关股东后三个月存在减持计划），则constraint要求不得披露，所以valid_constraint应为：当condition为True时，high_song_zhuan为False。

所以，valid_constraint的计算应该是：当condition为True时，high_song_zhuan为False。否则，constraint自动满足？

或者，constraint的valid是：当subject和condition都满足时，是否满足constraint。即，当subject和condition都为True时，必须没有高送转方案。否则，其他情况下，constraint是否满足可能不需要考虑？

因此，在代码中，valid_constraint的计算应该是：在condition为True的情况下，是否没有高送转方案。即：

valid_constraint = ~high_song_zhuan

但需要结合condition的情况。例如，只有当condition为True时，才需要检查constraint。否则，constraint是否满足可能无关紧要？

或者，不管condition是否满足，只要存在高送转方案，并且condition满足，则违反constraint？

正确的逻辑应该是：当subject和condition都满足时，必须满足constraint。否则，如果subject或condition不满足，则不需要检查constraint。因此，在代码中，valid_constraint的计算应该是在subject和condition都满足的情况下，是否满足constraint的条件。

但根据问题中的框架，需要分别标记subject、condition、constraint的valid情况，然后整体判断是否违规。违规的情况是当subject和condition都满足，但constraint不满足。

因此，在代码中，首先标记subject、condition、constraint各自的valid情况，然后判断是否同时满足subject和condition，但constraint不满足。

现在，具体到各个步骤：

1. 标记subject：上市公司。根据数据中的公司是否都是上市公司，假设所有行的subject都是True。因此，df['meu_19_6_subject'] = True。

2. 标记condition：相关股东后三个月存在减持计划。对应的列是“相关股东后三个月存在减持计划”，布尔型。因此，valid_condition = df['相关股东后三个月存在减持计划']。

3. 标记constraint：不得披露高送转方案。即，当condition为True时，是否没有高送转方案。高送转的条件是送股比例+转增比例>=5。因此，high_song_zhuan = (df['送股比例'] + df['转增比例']) >=5。此时，valid_constraint应为~high_song_zhuan。但需要结合是否实际进行了权益分派。例如，如果公司没有进行权益分派（即“是否进行权益分派”为False），那么即使送股比例和转增比例之和>=5，可能也不存在披露的情况。或者，是否进行权益分派可能决定了是否披露了方案？

例如，如果公司进行了权益分派，并且方案中包含高送转，则视为披露。否则，如果没有进行权益分派，那么即使送股比例和转增比例有数值，可能属于其他情况？

或者，可能“送股比例”和“转增比例”这两个列只有在公司实际进行分派时才会有数值，否则为0。例如，当“是否进行权益分派”为True时，这两个列才会有数值。否则，可能为0？

或者，可能这两个列的值是公司公告的权益分派方案中的数值，无论是否实施。例如，公司可能在公告中提出高送转方案，但可能还未实施。此时，只要公告中存在这样的方案，就视为披露了高送转。

因此，不管是否实际实施，只要在公告中存在高送转方案，就视为披露。因此，计算high_song_zhuan的条件是送股比例+转增比例>=5，并且可能“是否进行权益分派”为True？

或者，是否进行权益分派可能无关，只要公告中有这个方案，就视为披露？

根据问题中的附加信息，数据中的每一行对应的是公司在某一天发布的权益分派公告（或决定不进行分派）。例如，在“是否进行权益分派”为True的情况下，才会有具体的送股比例和转增比例。否则，这些比例可能为0？

或者，可能“送股比例”和“转增比例”这两个列的值只有在公司进行分派时才会有数值，否则为0。例如，如果公司没有进行分派，这两个列的值是0。因此，当公司进行分派时，这两个列的值可能大于等于0，并且总和可能>=5。

因此，high_song_zhuan的条件是：

high_song_zhuan = (df['送股比例'] + df['转增比例']) >=5

并且，只有当公司进行了权益分派（即“是否进行权益分派”为True）时，才需要考虑这些比例。否则，如果公司没有进行权益分派，那么即使这两个比例的总和>=5，也不存在高送转方案？

或者，是否进行权益分派可能不影响，只要在公告中提出高送转方案，就视为披露？

例如，公司可能在公告中提出高送转方案，但可能还未实施。此时，是否属于披露？

根据法律要求，MEU_19_6的constraint是“不得披露高送转方案”，所以只要在公告中存在这样的方案，无论是否实施，都属于披露。因此，只要送股比例和转增比例之和>=5，就视为存在高送转方案，无论是否实际进行分派？

或者，是否进行分派由“是否进行权益分派”决定。例如，如果公司公告了高送转方案，但之后可能取消，但根据数据中的列，可能“是否进行权益分派”为True时，才表示实际进行了分派。或者，可能“是否进行权益分派”表示是否在公告中决定进行分派，而送股比例和转增比例是分派方案的内容。因此，当“是否进行权益分派”为True时，才需要检查送股和转增的比例。

因此，正确的逻辑应该是：当公司进行了权益分派（即“是否进行权益分派”为True），并且送股比例+转增比例>=5时，视为披露了高送转方案。否则，视为没有披露。

因此，high_song_zhuan的条件是：

high_song_zhuan = df['是否进行权益分派'] & ((df['送股比例'] + df['转增比例']) >=5)

这样，只有当公司进行了权益分派，并且方案中包含高送转时，才视为存在高送转方案。

因此，valid_constraint的条件是：当condition为True时，high_song_zhuan为False。即，当相关股东存在减持计划时，公司不得披露高送转方案。因此，valid_constraint是：

valid_constraint = ~high_song_zhuan

但需要结合condition的情况。例如，只有当condition为True时，才需要检查constraint。否则，constraint是否满足可能无关紧要？

根据问题中的框架，需要分别标记subject、condition、constraint的valid情况。因此，constraint的valid标记应该是在满足subject和condition的情况下，是否满足constraint。或者，是否无论subject和condition是否满足，都标记constraint的valid？

根据示例中的代码，比如MEU_4_1的代码中，valid_constraint的计算可能独立于subject和condition。例如，在示例中，valid_constraint是计算是否满足约束条件，不管subject和condition是否满足。然后，在最后判断是否同时满足subject和condition，但constraint不满足。

因此，在MEU_19_6的情况下，constraint的valid标记应该是：是否满足“不得披露高送转方案”这一条件。即，当公司没有披露高送转方案时，constraint为True；否则为False。无论subject和condition是否满足。

但根据法律条文，只有当相关股东存在减持计划（condition满足）时，才需要遵守不得披露高送转方案的约束。因此，当condition不满足时，公司可以披露高送转方案，此时constraint的valid应为True，因为约束条件不适用。或者，是否只有当condition满足时，才需要检查constraint？

这可能需要更仔细的分析。根据法律条文，约束是“当相关股东在后三个月存在减持计划时，不得披露高送转方案”。因此，只有当condition满足时，才需要满足constraint。如果condition不满足，公司可以自由披露高送转方案，此时constraint自动满足。

因此，在标记constraint的valid时，应该是在condition为True的情况下，是否没有披露高送转方案。如果condition为False，则constraint自动视为满足（valid为True）。

因此，valid_constraint的计算应该是：

valid_constraint = (~high_song_zhuan) | (~condition)

即，当condition为False时，无论是否披露高送转，constraint都视为满足。当condition为True时，必须没有高送转。

或者，更准确地说，当condition为True时，valid_constraint是~high_song_zhuan；当condition为False时，valid_constraint为True。

因此，在代码中，可以这样计算：

valid_constraint = (df['相关股东后三个月存在减持计划'] == False) | (~high_song_zhuan)

或者：

valid_constraint = np.where(condition, ~high_song_zhuan, True)

但需要确保正确性。

现在，总结各个步骤：

1. 标记subject：所有行都是上市公司，所以meu_19_6_subject = True。

2. 标记condition：相关股东后三个月存在减持计划，即df['相关股东后三个月存在减持计划']为True。

3. 标记constraint：当condition为True时，不得披露高送转方案。高送转的条件是公司进行了权益分派，并且送股比例+转增比例>=5。因此：

high_song_zhuan = df['是否进行权益分派'] & ((df['送股比例'] + df['转增比例']) >=5)

valid_constraint = ~high_song_zhuan | (df['相关股东后三个月存在减持计划'] == False)

或者，更准确地说：

valid_constraint = np.where(df['相关股东后三个月存在减持计划'], ~high_song_zhuan, True)

这样，当condition为True时，检查是否没有高送转；否则，视为满足。

然后，在dataframe中记录这三个条件的情况。

最后，判断是否违规：当subject、condition都满足，但constraint不满足时，即：

is_violation = (valid_subject) & (valid_condition) & (~valid_constraint)

但根据之前的分析，valid_subject可能总是True，所以可以简化为：

is_violation = valid_condition & (~valid_constraint)

但需要确认valid_subject是否可能为False。根据问题中的MEU，subject是上市公司，而数据中的公司都是上市公司，所以valid_subject总是True。因此，在代码中，可以直接将meu_19_6_subject设为True。

现在，编写代码：

首先，初始化各列：

df['meu_19_6_subject'] = True

df['meu_19_6_condition'] = df['相关股东后三个月存在减持计划']

计算高送转：

high_song_zhuan = df['是否进行权益分派'] & ((df['送股比例'] + df['转增比例']) >=5)

valid_constraint = ~high_song_zhuan | (~df['相关股东后三个月存在减持计划'])

或者，更准确：

valid_constraint = np.where(df['相关股东后三个月存在减持计划'], ~high_song_zhuan, True)

但使用numpy可能需要导入numpy，但问题中没有说明是否允许。或者，可以用布尔运算：

valid_constraint = (~high_song_zhuan) | (~df['相关股东后三个月存在减持计划'])

因为当condition为True时，右边的~condition为False，所以整个表达式变为~high_song_zhuan | False，即~high_song_zhuan。当condition为False时，右边的~condition为True，所以整个表达式为True，无论high_song_zhuan的值。

因此，valid_constraint可以这样计算：

valid_constraint = (~high_song_zhuan) | (~df['相关股东后三个月存在减持计划'])

然后，将valid_constraint赋值给df['meu_19_6_constraint']。

最后，判断违规情况：

is_violation = df['meu_19_6_condition'] & (~df['meu_19_6_constraint'])

或者，因为当condition为True时，valid_constraint是~high_song_zhuan。所以，当condition为True且high_song_zhuan为True时，valid_constraint为False，此时违规。

因此，is_violation = (df['meu_19_6_condition']) & (high_song_zhuan)

然后，将违规情况标记在meu_19_6_compliance列，其中合规为True，违规为False。或者，根据示例中的代码，可能将合规情况标记为False当存在违规。

例如，在示例中，违规情况是满足subject和condition但不满足constraint，此时meu_4_1_compliance被标记为False。其他情况下，可能默认为True？

或者，可能meu_19_6_compliance列是True表示合规，False表示违规。因此：

df['meu_19_6_compliance'] = True

df.loc[is_violation, 'meu_19_6_compliance'] = False

或者，根据示例中的代码，可能直接标记违规行：

df.loc[is_violation, 'meu_19_6_compliance'] = False

其他行可能保持NaN？或者初始化为True？

在示例中，代码初始化了各列，然后标记违规行。例如：

df.loc[is_violation, 'meu_4_1_compliance'] = False

但可能其他行没有被标记为True。因此，可能需要先初始化为True，然后将违规行设为False。或者，初始化为True，然后根据条件修改。

例如：

df['meu_19_6_compliance'] = True

df.loc[is_violation, 'meu_19_6_compliance'] = False

这样，所有行默认合规，只有当违规时才标记为False。

现在，将这些步骤整合到代码中：

函数名为check_meu_19_6，参数为df。

首先，初始化各列：

df['meu_19_6_subject'] = True

df['meu_19_6_condition'] = df['相关股东后三个月存在减持计划']

计算高送转：

high_song_zhuan = df['是否进行权益分派'] & ((df['送股比例'] + df['转增比例']) >=5)

valid_constraint = (~high_song_zhuan) | (~df['相关股东后三个月存在减持计划'])

df['meu_19_6_constraint'] = valid_constraint

然后，判断违规情况：

is_violation = df['meu_19_6_condition'] & (~valid_constraint)

或者，等价于：

is_violation = df['相关股东后三个月存在减持计划'] & high_song_zhuan

因为当condition为True时，valid_constraint是~high_song_zhuan。所以，~valid_constraint就是high_song_zhuan。因此，is_violation等于condition为True且high_song_zhuan为True。

因此，可以简化为：

is_violation = df['相关股东后三个月存在减持计划'] & high_song_zhuan

然后，在df中标记meu_19_6_compliance列为False当is_violation为True，否则为True。

因此，代码的大致结构如下：

import pandas as pd

def check_meu_19_6(df):
    # 初始化各列
    df['meu_19_6_subject'] = True  # 假设所有公司都是上市公司
    df['meu_19_6_condition'] = df['相关股东后三个月存在减持计划']
    
    # 计算高送转
    high_song_zhuan = df['是否进行权益分派'] & ((df['送股比例'] + df['转增比例']) >= 5)
    # 计算valid_constraint：当condition为True时，不得有高送转；否则自动满足
    df['meu_19_6_constraint'] = (~high_song_zhuan) | (~df['相关股东后三个月存在减持计划'])
    
    # 判断违规情况：condition为True且存在高送转
    is_violation = df['相关股东后三个月存在减持计划'] & high_song_zhuan
    df['meu_19_6_compliance'] = True  # 默认合规
    df.loc[is_violation, 'meu_19_6_compliance'] = False
    
    return df

但需要检查是否正确。例如，当condition为True时，valid_constraint是~high_song_zhuan。此时，如果high_song_zhuan为True，则valid_constraint为False，导致is_violation为True。这符合要求。

此外，当condition为False时，valid_constraint为True，无论是否有高送转，此时不会触发违规。

因此，这样的代码是正确的。
","CompletionUsage(completion_tokens=5459, prompt_tokens=2105, total_tokens=7564, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=4995, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 5. 计算整体的违约情况并标记在dataframe上(meu_n_k_compliance). 

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df['meu_4_2_subject'] = False  # 初始化subject列
    df['meu_4_2_condition'] = False  # 初始化condition列
    df['meu_4_2_constrain'] = False  # 初始化constrain列

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True

    # 判断违规情况：满足主体和条件但不满足约束
    is_violation = (
        valid_subject & 
        valid_condition & 
        (~valid_constraint)
    )

    # 标记违规行
    df.loc[is_violation, 'meu_4_1_compliance'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_13_1
法律的最小可执行单元内容: {""subject"": ""上市公司"", ""condition"": ""合并资产负债表、母公司资产负债表中本年末未分配利润均为正值且报告期内盈利，未进行现金分红或最近三年现金分红总额低于最近三年年均净利润30%"", ""constraint"": ""应当在权益分派方案中披露：结合所处行业特点、发展阶段和自身经营模式、盈利水平、偿债能力、资金需求等因素，未进行现金分红或现金分红水平较低原因的说明"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '财务数据日期', '公告日期', '公告类型', '审计意见', '总资产', '总负债', '净资产', '资产负债率',
'交易性金融资产', '衍生金融资产', '债权投资', '其他债权投资', '其他权益工具投资', '其他非流动金融资产',
'其他流动资产', '金融资产总额', '总股本', '每股净资产', '合并报表未分配利润', '母公司报表未分配利润', '净利润',
'每股净利润', '母公司报表净利润', '经营活动现金流量净额', '投资活动现金流量净额', '筹资活动现金流量净额',
'现金及现金等价物净增加额', '净资产增长率', '净利润增长率', '资产负债率变化', '金融资产增长率',
'是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划', '现金分红金额', '送股比例', '转增比例', '是否进行权益分派', '权益分派方案文本', '公司简称']

## 其中: 
- 这是一个二维的面板数据, 根据['日期', '公司简称']可以定位到特定公司在特定日期的状态. 数据已经按照公司简称和日期排序. 
- 我们的'日期'并非连续的自然日或者交易日, 而是固定的季报/半年报/年报披露后三个月内的某一个自然日, 例如'2020-05-30', '2020-09-29', ...等, 我们假定公司在这一天发布了权益分派公告(或者决定了不进行权益分派). 每个季报/半年报/年报后只会跟随一个'日期'来决定是否进行权益分派, 如何进行分派. 
- 数据的每一行包含了两个部分的数据, 分别是当时最新的财务数据和当时最新的权益分派情况. 例如, '2020-09-17'这一行可能对应了公告日期为'2020-08-27'的截至'2020-06-30'的半年报财务报告['审计意见', '总资产', ..., '现金及现金等价物净增加额'], 以及在'2020-09-17'当天公告的权益分派信息['是否进行权益分派', ..., '现金分红金额', ...]
- 所有财务数据都是以单季度的形式记录的, 不需要考虑利润表科目在半年报和年报中逐渐累加的问题. 所有的增长率都是单季的. 
- 所有资产/价格的单位都是元而非万元, 千元或百万元; 所有的比例/比率都是小数而非百分数, 除了['送股比例', '转增比例']是""每10股送n股""的格式. 
- ['审计意见']的值有""无保留意见"", ""非标准无保留意见"", ""保留意见"". 
- 这些列为布尔值: ['是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划']

- 如果希望检查权益分派方案中是否披露了特定内容, 可以使用环境中会提供的函数`llm_content_check()`, 但非披露类的合规检查中禁止使用这个函数. 
    描述: 使用LLM检查公告中是否包含特定内容
        参数:
            announcement_text: 公告全文
            traget_content: 需要检查的内容描述
        返回:
            bool: 公告中是否包含特定内容
    调用示例: 
        ```python
        from utils.tool_for_agents import llm_content_check

        constraint_description = ""为增强投资者回报水平拟采取的措施"" # 请完整描述需要检查的内容, 不得简化
        df['meu_4_1_constraint'] = df['权益分派方案文本'].apply(
            lambda text: llm_content_check(text, constraint_description)
        )
        ```

note:
 - 理论上你撰写合规检验代码所需要的数据都可以从一致的数据中得到, 对于没有直接对应的数据你需要自己计算得到, 不要简单地认为无法完成. 
 - 除非材料提供, 否则不要主动进行简化的假设. 如果你认为所给的信息不足以判断案例的合规性, 可以在函数的结尾进行注释说明. 但这种情况应该很少出现. 

","

<CODE>
import pandas as pd
from utils.tool_for_agents import llm_content_check

def check_meu_13_1(df):
    '''
    检查MEU_13_1合规性：
    subject: 上市公司
    condition: 1.合并/母公司资产负债表未分配利润均为正值 2.报告期盈利 3.未分红或三年分红低于三年均利30%
    constraint: 需在权益分派方案中披露分红原因说明
    '''
    
    # 初始化合规列
    df['meu_13_1_subject'] = True  # 所有记录主体均为上市公司
    df['meu_13_1_condition'] = False
    df['meu_13_1_constraint'] = False
    df['meu_13_1_compliance'] = True

    # 条件验证（分三步处理复杂逻辑）
    # 1. 资产负债表校验
    balance_condition = (
        (df['合并报表未分配利润'] > 0) &
        (df['母公司报表未分配利润'] > 0)
    )

    # 2. 盈利能力校验
    profitability_condition = (df['净利润'] > 0)

    # 3. 分红比例校验（需跨期计算）
    def check_dividend_ratio(row):
        try:
            # 获取当前财务年度
            current_year = row['财务数据日期'].year
            
            # 筛选公司近三年年报
            mask = (
                (df['公司简称'] == row['公司简称']) &
                (df['财务数据日期'].dt.year.between(current_year-2, current_year)) &
                (df['财务数据日期'].dt.month == 12)
            )
            annual_data = df[mask].sort_values('财务数据日期')
            
            # 需要完整三年数据
            if len(annual_data) < 3:
                return False
                
            # 计算分红总额和净利润均值
            total_dividend = annual_data['现金分红金额'].sum()
            avg_profit = annual_data['净利润'].mean()
            
            # 判断分红比例条件
            return (total_dividend == 0) or (avg_profit != 0 and total_dividend < avg_profit * 0.3)
        except:
            return False

    df['dividend_condition'] = df.apply(check_dividend_ratio, axis=1)
    
    # 综合条件判断
    df['meu_13_1_condition'] = (
        balance_condition &
        profitability_condition &
        df['dividend_condition']
    )

    # 约束条件验证（使用LLM内容检查）
    constraint_desc = '''结合所处行业特点、发展阶段和自身经营模式、盈利水平、
    偿债能力、资金需求等因素，未进行现金分红或现金分红水平较低原因的说明'''
    
    df.loc[df['meu_13_1_condition'], 'meu_13_1_constraint'] = df[
        df['meu_13_1_condition']
    ]['权益分派方案文本'].apply(
        lambda x: llm_content_check(x, constraint_desc) if pd.notna(x) else False
    )

    # 综合合规判断
    violation_mask = (
        df['meu_13_1_subject'] &
        df['meu_13_1_condition'] &
        ~df['meu_13_1_constraint']
    )
    df.loc[violation_mask, 'meu_13_1_compliance'] = False

    # 清理中间列
    df.drop(columns=['dividend_condition'], inplace=True)
    
    return df
</CODE>","好的，我现在需要处理这个MEU_13_1的合规性检查。首先，我得仔细理解这个MEU的内容。根据提供的MEU信息，责任主体是上市公司，触发条件是合并资产负债表和母公司资产负债表中本年末未分配利润均为正值，且报告期内盈利，同时未进行现金分红或最近三年现金分红总额低于最近三年年均净利润的30%。约束条件是必须在权益分派方案中披露相关原因说明。

接下来，我需要将这些条件转化为代码，检查数据框中的每一行是否符合这些条件。首先，处理subject部分。这里的主体是上市公司，所以每一行都代表上市公司的情况，所以可能所有行的subject都是有效的？或者是否需要检查某些特定字段？比如，可能数据框中每个公司都是上市公司，所以无需额外判断。但可能需要确认，比如是否存在非上市公司的情况？但根据问题描述，数据框中的公司都是上市公司，所以可能直接标记subject为True。不过可能需要确认是否有字段能表明是否是上市公司，比如公司简称是否存在或者是否有其他标识。但根据提供的列，没有这样的字段，所以可能假设所有行的主体都是上市公司，因此subject列直接设为True。

接下来是条件部分。条件分为几个部分：合并和母公司资产负债表的未分配利润均为正值，报告期内盈利，且未进行现金分红或最近三年现金分红总额低于最近三年年均净利润的30%。这里需要分步骤处理。

首先，检查合并报表未分配利润（合并报表未分配利润列）和母公司报表未分配利润是否均为正值。即这两个字段的值是否大于0。然后，报告期内盈利，可能是指净利润是否为正？或者要看合并报表的净利润还是母公司报表的净利润？MEU中的条件是“报告期内盈利”，所以可能需要检查合并报表的净利润是否为正，或者母公司报表的净利润？或者两者都要？根据MEU的描述，可能是指合并报表的净利润为正，因为合并报表反映整个公司的盈利情况。或者需要同时满足合并和母公司报表的净利润均为正？这里可能需要仔细分析条件。

MEU的条件是“合并资产负债表、母公司资产负债表中本年末未分配利润均为正值且报告期内盈利”，这里的“报告期内盈利”可能指的是合并报表的净利润为正，或者母公司报表的净利润为正？或者两者都要？例如，假设报告期内盈利是指合并报表的净利润为正，而母公司报表的净利润可能不一定。但根据条件中的“合并资产负债表、母公司资产负债表中本年末未分配利润均为正值”，所以可能报告期内盈利指的是合并报表的净利润为正，或者母公司报表的净利润？或者两者都要？

这里可能需要明确。例如，假设“报告期内盈利”指的是合并报表的净利润为正，而母公司报表的净利润是否为正可能不影响？或者是否两者都需要？例如，如果合并报表净利润为正，但母公司报表净利润为负，是否满足条件？这可能取决于法律的具体要求。但根据MEU的条件，可能要求合并和母公司的未分配利润均为正，并且报告期内盈利（可能合并报表的净利润为正）。或者，可能“报告期内盈利”指的是合并报表的净利润为正，而母公司的净利润是否为正可能不影响？或者是否两者都需要？

这里可能需要进一步分析。例如，假设“报告期内盈利”指的是合并报表的净利润为正，而母公司报表的净利润是否为正可能不影响。或者，可能要求合并和母公司的净利润均为正？这点需要根据法律条文的理解。但MEU的条件中，在条件部分提到的是“合并资产负债表、母公司资产负债表中本年末未分配利润均为正值且报告期内盈利”，所以可能这里的“报告期内盈利”是指合并报表的净利润为正，而母公司报表的净利润是否为正可能不在此条件中？或者是否合并和母公司的净利润都要为正？

这个问题可能需要更仔细的分析。例如，假设“报告期内盈利”指的是合并报表的净利润为正，而母公司的净利润是否为正可能不影响。或者，可能这里的“报告期内盈利”指的是合并报表和母公司报表的净利润均为正？例如，如果合并报表盈利但母公司亏损，是否满足条件？

根据MEU的条件描述，可能这里的“报告期内盈利”指的是合并报表的净利润为正，而母公司报表的净利润是否为正可能不影响。或者，可能这里的“报告期内盈利”指的是合并报表和母公司报表的净利润均为正？例如，因为条件中已经要求了合并和母公司的未分配利润均为正，这可能意味着两者的净利润累计为正，但报告期内是否盈利可能要看当期净利润。

例如，合并资产负债表的未分配利润为正，可能意味着累计的未分配利润为正，而报告期内盈利可能指当期的净利润为正。所以，需要检查合并报表的净利润是否为正，以及母公司报表的净利润是否为正？

或者，可能“报告期内盈利”仅指合并报表的净利润为正？这点可能需要进一步确认。但根据MEU的条件，可能这里的“报告期内盈利”指的是合并报表的净利润为正，而母公司报表的净利润是否为正可能不影响，因为母公司资产负债表的未分配利润已经为正，可能其当期的净利润是否为正可能不影响，只要未分配利润为正即可？

或者，可能这里的“报告期内盈利”指的是合并报表和母公司报表的净利润均为正？例如，合并报表的净利润为正，同时母公司报表的净利润也为正？

这可能需要更仔细的理解。例如，假设条件中的“报告期内盈利”指的是合并报表的净利润为正，而母公司报表的净利润是否为正可能不影响，因为母公司资产负债表的未分配利润已经为正，可能其当期的盈利情况不影响。或者，可能这里的“报告期内盈利”指的是合并报表和母公司报表的净利润均为正？

这个问题可能需要根据法律条文的理解。例如，假设MEU的条件是合并和母公司的未分配利润均为正，并且报告期内（即当期）合并报表和母公司报表均盈利。这种情况下，需要检查合并报表的净利润和母公司报表的净利润是否均为正。

但根据提供的列，数据中有“净利润”（可能指合并报表的净利润）和“母公司报表净利润”这两个字段。所以，条件中的“报告期内盈利”可能需要这两个净利润都为正？

或者，可能这里的“报告期内盈利”仅指合并报表的净利润为正？例如，合并报表的净利润为正，而母公司报表的净利润可能为负，但未分配利润为正（可能因为以前年度累积的利润）。这种情况下，是否满足条件？

这个问题可能需要根据法律条文的具体要求。例如，如果MEU的条件是合并和母公司的未分配利润均为正，并且合并报表的净利润为正，那么需要检查这两个未分配利润是否为正，以及合并净利润是否为正。而母公司报表的净利润是否为正可能不影响。

或者，可能这里的“报告期内盈利”指的是合并和母公司的净利润均为正？

这可能需要进一步分析。例如，假设MEU的条件是：

1. 合并资产负债表和母公司资产负债表中本年末未分配利润均为正值；
2. 报告期内盈利（可能指合并报表的净利润为正）；
3. 未进行现金分红或最近三年现金分红总额低于最近三年年均净利润的30%。

所以，条件中的“报告期内盈利”可能仅指合并报表的净利润为正。或者，可能同时要求合并和母公司的净利润为正？

这个问题可能需要根据法律条文的具体要求，但根据用户提供的MEU内容，可能需要同时满足合并和母公司报表的净利润为正？

或者，可能这里的“报告期内盈利”指的是合并报表的净利润为正，而母公司报表的净利润是否为正不影响？

例如，假设条件中的“合并资产负债表、母公司资产负债表中本年末未分配利润均为正值”是必须的，而“报告期内盈利”可能指的是合并报表的净利润为正。或者，可能这里的“报告期内盈利”指的是合并和母公司的净利润均为正？

这个问题可能需要更仔细的分析。例如，假设“报告期内盈利”指的是合并报表的净利润为正，而母公司报表的净利润是否为正不影响，只要其未分配利润为正即可。或者，可能这里的“报告期内盈利”指的是合并和母公司的净利润均为正？

根据MEU的条件描述，可能这里的“报告期内盈利”指的是合并报表的净利润为正，而母公司报表的净利润是否为正可能不影响，因为母公司资产负债表的未分配利润已经为正。或者，可能这里的“报告期内盈利”指的是合并和母公司的净利润均为正？

例如，假设合并报表的净利润为正，母公司报表的净利润为负，但母公司资产负债表的未分配利润为正（可能因为以前年度累积的利润），那么是否满足条件？

这种情况下，未分配利润可能为正，但当期母公司报表的净利润为负。此时，是否满足条件中的“报告期内盈利”？

这可能取决于法律条文的具体要求。例如，可能“报告期内盈利”指的是合并报表的净利润为正，而母公司报表的净利润是否为正不影响，只要其未分配利润为正即可。或者，可能要求母公司报表的净利润也必须为正？

由于用户提供的MEU内容中的条件部分为“合并资产负债表、母公司资产负债表中本年末未分配利润均为正值且报告期内盈利”，这里的“报告期内盈利”可能指的是合并报表的净利润为正，而母公司报表的净利润是否为正可能不需要，因为母公司的未分配利润已经为正。或者，可能这里的“报告期内盈利”同时要求合并和母公司的净利润为正？

这个问题可能需要进一步确认，但根据MEU的表述，可能这里的“报告期内盈利”指的是合并报表的净利润为正，而母公司报表的净利润是否为正可能不影响，只要其未分配利润为正即可。或者，可能这里的“报告期内盈利”指的是合并和母公司的净利润均为正？

例如，假设合并报表的净利润为正，母公司报表的净利润为负，但母公司资产负债表的未分配利润为正，那么是否满足条件？

此时，合并和母公司的未分配利润均为正，合并报表的净利润为正，但母公司报表的净利润为负。这种情况下，是否满足条件？

根据MEU的条件，可能满足，因为未分配利润是正值，而报告期内盈利可能仅指合并报表的净利润为正。或者，可能要求母公司报表的净利润也必须为正？

这个问题可能需要根据法律条文的具体要求，但用户没有提供更多信息，所以可能需要根据常规理解来处理。例如，可能这里的“报告期内盈利”指的是合并报表的净利润为正，而母公司报表的净利润是否为正不影响，只要其未分配利润为正即可。或者，可能这里的“报告期内盈利”指的是合并和母公司的净利润均为正？

在这种情况下，可能需要同时检查合并报表和母公司报表的净利润是否为正。例如，合并报表的净利润（“净利润”列）是否大于0，母公司报表的净利润（“母公司报表净利润”列）是否大于0？

或者，可能这里的“报告期内盈利”仅指合并报表的净利润为正？

例如，假设条件中的“报告期内盈利”指的是合并报表的净利润为正，那么需要检查“净利润”列是否大于0。而母公司报表的净利润是否为正可能不影响，只要其未分配利润为正即可？

或者，可能这里的“报告期内盈利”指的是合并和母公司的净利润均为正？

这可能需要更仔细的分析。例如，假设MEU的条件是：

- 合并资产负债表中的未分配利润为正；
- 母公司资产负债表中的未分配利润为正；
- 合并报表在报告期内盈利（净利润为正）；
- 母公司报表在报告期内盈利（净利润为正）。

或者，可能母公司报表的净利润是否为正不影响，只要其未分配利润为正？

这可能需要根据法律条文的理解，但用户没有提供更多信息。因此，可能需要根据常规逻辑来处理。例如，可能这里的“报告期内盈利”仅指合并报表的净利润为正，而母公司报表的净利润是否为正不影响，只要其未分配利润为正即可。或者，可能这里的“报告期内盈利”指的是合并和母公司的净利润均为正？

在这种情况下，可能需要同时检查合并和母公司的净利润是否为正。例如：

合并未分配利润 > 0，母公司未分配利润 > 0，合并净利润 > 0，母公司净利润 > 0？

或者，可能合并未分配利润 >0，母公司未分配利润 >0，合并净利润 >0？

或者，可能合并未分配利润 >0，母公司未分配利润 >0，并且合并净利润 >0？

或者，可能合并未分配利润 >0，母公司未分配利润 >0，并且合并净利润和母公司净利润的总和为正？

这可能需要进一步明确，但根据MEU的条件描述，可能这里的“报告期内盈利”指的是合并报表的净利润为正，而母公司报表的净利润是否为正不影响，只要其未分配利润为正即可。因此，条件中的“报告期内盈利”可能仅指合并报表的净利润为正。

因此，条件部分需要满足：

1. 合并报表未分配利润 > 0；
2. 母公司报表未分配利润 > 0；
3. 合并报表净利润 > 0；
4. 未进行现金分红，或者最近三年现金分红总额 < 最近三年年均净利润的30%。

接下来，处理现金分红的条件。这里有两种情况：未进行现金分红，或者最近三年现金分红总额低于最近三年年均净利润的30%。所以需要检查这两个条件中的任意一个是否成立。

但如何计算最近三年的现金分红总额和最近三年的年均净利润？

例如，假设当前行的财务数据日期是2020年12月31日（年报），那么最近三年可能指2018、2019、2020年的现金分红总额？或者，可能是指过去三个完整的会计年度？

但数据中的每一行对应的是某个季度的财务数据，例如，财务数据日期可能是季度末的日期。例如，2020-03-31（Q1），2020-06-30（半年报），2020-09-30（Q3），2020-12-31（年报）。

因此，需要确定当前行的财务数据日期对应的报告期，并获取最近三年的现金分红数据。例如，如果当前行的财务数据日期是2020-12-31，那么最近三年可能指2018、2019、2020年的现金分红金额总和，以及这三年的年均净利润。

但数据中的每一行可能只包含当前报告期的财务数据，而其他年份的数据可能需要通过历史数据来获取。例如，当前行的现金分红金额可能只是当前年度的分红，而过去两年的分红金额需要从之前的数据行中获取。

但根据问题描述，数据框中的每一行包含了当时最新的财务数据和权益分派情况。例如，每一行可能对应某个季度的报告，并且在该日期公告的权益分派情况。因此，可能需要从数据框中获取同一公司过去三年的现金分红金额，然后计算总和。

这可能需要按公司分组，并计算每个公司在过去三年内的现金分红总额，以及这三年的年均净利润。

例如，对于每一行，需要找到同一公司（公司简称相同）在过去三年内的所有现金分红金额，并求和。同时，需要计算这三年的年均净利润，即这三年的净利润总和除以3，然后比较现金分红总额是否小于年均净利润的30%。

但如何获取过去三年的数据？例如，当前行的财务数据日期是某个日期，比如2020-12-31，那么过去三年可能指2018、2019、2020这三个年度。需要找到这三个年度内的现金分红金额，以及这三年的净利润。

但数据中的财务数据日期可能对应不同的报告期，比如季度、半年报、年报。例如，年报的财务数据日期是每年的12月31日，而季报是3月31日、6月30日、9月30日等。

因此，可能需要将财务数据按年度进行汇总，以获取每年的净利润和现金分红金额。例如，每个年度的年报数据中的净利润是该年度的全年净利润，而现金分红金额可能是在该年度后的权益分派中记录的。

例如，假设某公司在2020年12月31日的年报中，净利润为X元，然后在2021年某个日期公告了现金分红金额Y元（对应2020年度的分红）。因此，现金分红金额可能是在公告日期所在的财务年度之后进行分派的。

这可能比较复杂，因为需要将现金分红金额与对应的净利润年度对应起来。例如，2020年度的分红可能在2021年公告，因此需要将2021年的现金分红金额归属于2020年度的分红。

但根据数据框的结构，每一行包含的是当时最新的财务数据和权益分派情况。例如，某行的财务数据日期是2020-12-31（年报），而公告日期是2021-04-30，该行的现金分红金额对应的是2020年度的分红。因此，可能需要将现金分红金额与对应的财务年度关联起来。

因此，可能需要为每个公司构建一个按年度汇总的净利润和现金分红金额的数据结构，以便计算最近三年的总和。

但根据问题描述，数据框中的列包括“现金分红金额”，这可能指的是当前行对应的权益分派方案中的现金分红金额，即该次分派的金额。例如，某行对应的权益分派方案是在某个日期公告的，其现金分红金额是该次分派的金额，可能对应的是上一个财务年度的分红。

例如，某行的财务数据日期是2020-12-31（年报），公告日期是2021-04-30，该行的现金分红金额是2020年度的分红。因此，该分红金额应归属于2020年度。

因此，为了计算最近三年的现金分红总额，需要收集同一公司在过去三个财务年度内的所有现金分红金额的总和。例如，当前行的财务数据日期是2020-12-31，那么最近三年是2018、2019、2020年，需要找到这三个年度对应的现金分红金额，并求和。

同样，最近三年的年均净利润是这三个年度的净利润总和除以3。每个年度的净利润是该年度的合并报表净利润（“净利润”列）。

因此，对于每一行，需要：

1. 确定当前行的财务数据日期对应的年度。
2. 找到同一公司在该年度及前两个年度的净利润。
3. 计算这三年的年均净利润。
4. 找到同一公司在这三个年度内的所有现金分红金额的总和。
5. 检查现金分红总额是否小于年均净利润的30%。

但如何从数据框中获取这些数据呢？例如，对于当前行的公司，需要筛选出财务数据日期属于最近三年的所有行，并提取这些行的现金分红金额和净利润。

这可能比较复杂，因为数据框中的行是按日期和公司简称排列的，每个公司可能有多个行对应不同的报告期。例如，每个季度都有数据，但只有年报的数据包含全年净利润。

因此，可能需要按公司分组，并按年度筛选出每个年度的年报数据，以获取该年度的净利润和现金分红金额。

例如，对于每个公司，每年的年报对应的财务数据日期是12月31日，因此可以筛选出财务数据日期为每年12月31日的行，以获取该年度的净利润。而现金分红金额可能是在该年报后的权益分派中记录的，即该行的现金分红金额对应的是该年度的分红。

因此，可能需要为每个公司构建一个年度数据字典，记录每个年度的净利润和现金分红金额。例如：

对于公司A，2018年的净利润是X，现金分红金额是Y；2019年的净利润是M，现金分红金额是N；2020年的净利润是P，现金分红金额是Q。

然后，最近三年的现金分红总额是Y + N + Q，年均净利润是(X + M + P)/3，比较现金分红总额是否小于年均净利润的30%。

但如何从数据框中提取这些信息呢？

可能需要按公司分组，然后对于每个公司，按财务数据日期提取每年的年报数据（假设年报的财务数据日期是12月31日），并记录该年度的净利润和现金分红金额。例如，对于每个公司，每年的年报行中的“净利润”是该年度的全年净利润，而该行的“现金分红金额”是该年度的分红金额。

但可能存在一个问题：现金分红可能是在年报公告之后决定的，因此该行的现金分红金额可能对应的是该年度的分红。例如，某行的财务数据日期是2020-12-31，公告日期是2021-04-30，该行的现金分红金额是2020年度的分红。因此，该行的现金分红金额应归属于2020年度。

因此，对于每个公司，每个年度的现金分红金额可以通过筛选财务数据日期为该年度12月31日的行，并取该行的现金分红金额。如果该行的“是否实施现金分红”为True，则现金分红金额为该行的“现金分红金额”列的值，否则为0。

但可能存在多个行对应同一财务年度的情况，例如，可能存在多个公告日期对应同一财务年度的分红。例如，年中可能有中期分红，但通常年度分红是在年报后进行的。因此，可能需要假设每个财务年度的现金分红金额仅记录在年报对应的行中，或者需要累计所有对应该年度的现金分红金额。

这可能比较复杂，但根据问题描述，数据中的每一行对应的是季报/半年报/年报后的权益分派公告。例如，每个财务年度结束后，公司会在一定时间内公告权益分派方案，因此每个年度的现金分红金额可能只出现在该年度年报后的行中。

因此，对于每个公司，每个年度的现金分红金额可以通过该年度年报后的权益分派公告中的现金分红金额来获取。例如，财务数据日期为2020-12-31的行，对应的现金分红金额是2020年度的分红。

因此，处理步骤如下：

对于当前行的公司，确定其财务数据日期对应的年度（例如，2020-12-31对应2020年），然后找到该公司的前两个年度的年报数据（例如，2019年和2018年的年报），获取这三个年度的净利润和现金分红金额。

例如，当前行的财务数据日期是2020-12-31，那么最近三年是2018、2019、2020年。需要检查这三个年度的：

- 现金分红金额的总和；
- 这三个年度的净利润总和，计算年均净利润（总和/3）。

然后，判断现金分红总额是否小于年均净利润的30%。

如果当前行对应的公司在这三年中未进行现金分红（即三个年度的现金分红总和为0），或者现金分红总和小于年均净利润的30%，则触发条件中的现金分红部分。

现在，如何从数据框中获取这三个年度的数据？

可能需要按公司分组，并为每个公司按年度建立索引，以便快速查找过去三年的数据。

例如，对于当前行，公司是A，财务数据日期是2020-12-31。需要找到公司A在2018-12-31、2019-12-31、2020-12-31这三个财务数据日期的行，并提取它们的净利润和现金分红金额。

如果这些行存在，则计算总和。否则，可能无法满足条件，或者需要处理缺失数据的情况。但根据问题描述，数据已经包含必要的财务数据，因此假设这些数据存在。

因此，在代码中，需要为每个公司按年度筛选出对应的行，并提取数据。

这可能通过以下步骤实现：

1. 将数据框按公司简称分组。
2. 对于每个公司的每个行，确定其财务数据日期对应的年度。
3. 找到该公司的前两个年度的财务数据日期（例如，当前年度是2020年，前两年是2019和2018年）。
4. 检查是否存在这三个年度的行，并提取它们的净利润和现金分红金额。
5. 计算现金分红总额和年均净利润。

但如何高效地在pandas中实现这一点呢？例如，对于每一行，需要找到同一公司过去三年的年报数据。

这可能需要使用shift或rolling窗口的方法，或者使用groupby和apply函数。

例如，对于每个公司，按财务数据日期排序，然后对于每个行，检查其是否是年报（财务数据日期的月份是12月），然后获取前两年的年报数据。

这可能比较复杂，但假设数据框中每个公司的年报行都有财务数据日期为12月31日，并且按时间顺序排列，那么可以使用groupby和rolling来获取过去三年的数据。

或者，可以使用merge或条件筛选来找到同一公司过去三年的年报数据。

例如，对于当前行，公司是A，财务数据日期是2020-12-31。需要找到公司A的所有年报行（财务数据日期的月份为12月），然后筛选出年份在2018、2019、2020年的行。

这可能通过以下步骤实现：

- 提取当前行的公司简称和财务数据日期的年份。
- 筛选同一公司，财务数据日期的年份为当前年、前一年、前两年的年报行。
- 提取这些行的现金分红金额和净利润。

例如，当前行的财务数据日期是2020-12-31，年份是2020。前两年是2019和2018年。筛选公司A的财务数据日期为2018-12-31、2019-12-31、2020-12-31的行。

然后，计算这三年的现金分红金额总和，以及这三年的净利润总和。

如果这三年的现金分红总和为0，或者总和 < (年均净利润)*0.3，则满足条件中的现金分红部分。

现在，如何实现这个筛选？

在pandas中，可以使用布尔索引。例如，对于当前行，公司是A，年份是2020：

prev_year = current_year - 1

prev_prev_year = current_year - 2

然后，筛选同一公司，且财务数据日期的年份在[prev_prev_year, prev_year, current_year]的行，并且财务数据日期的月份是12月（即年报）。

这可能通过以下方式实现：

mask = (df['公司简称'] == company) & (df['财务数据日期'].dt.year.isin([prev_prev_year, prev_year, current_year])) & (df['财务数据日期'].dt.month == 12)

然后，选取这些行中的现金分红金额和净利润。

但需要注意的是，每个公司每年可能只有一个年报行，所以这三年的数据应该存在。

但如何处理如果某年的年报数据不存在的情况？例如，公司刚上市两年，只有2019和2020年的年报。此时，无法满足最近三年的条件，因此可能无法触发条件？

这可能需要在代码中进行处理，例如，如果三年的数据不全，则条件不满足。

因此，在代码中，需要确保存在这三年的年报数据，否则条件中的现金分红部分可能不成立。

现在，将这些步骤转化为代码：

首先，处理subject部分，主体是上市公司，假设所有行的公司都是上市公司，因此直接标记subject为True。

然后，处理条件部分：

条件分为四个部分：

1. 合并资产负债表未分配利润 > 0；
2. 母公司资产负债表未分配利润 > 0；
3. 报告期内盈利（合并报表净利润 > 0）；
4. 未进行现金分红或最近三年现金分红总额 < 最近三年年均净利润的30%。

因此，条件的各个部分需要分别计算。

对于条件中的前三部分：

valid_condition_part1 = (df['合并报表未分配利润'] > 0) & (df['母公司报表未分配利润'] > 0) & (df['净利润'] > 0)

然后，处理现金分红部分：

需要计算最近三年的现金分红总额和年均净利润。

这可能需要为每一行计算最近三年的现金分红总和和年均净利润。

这可以通过以下步骤实现：

对于每一行，提取公司简称和财务数据日期的年份。

然后，找到同一公司，财务数据日期为当前年、前一年、前两年的年报行（即财务数据日期为12月31日的行）。

然后，计算这三年的现金分红金额总和，以及这三年的净利润总和，进而计算年均净利润。

例如：

current_year = df_row['财务数据日期'].year
company = df_row['公司简称']

# 筛选同一公司，财务数据日期为最近三年的年报行
mask = (
    (df['公司简称'] == company) &
    (df['财务数据日期'].dt.year.isin([current_year - 2, current_year - 1, current_year])) &
    (df['财务数据日期'].dt.month == 12)  # 年报通常在12月
)
annual_reports = df[mask]

# 确保有三年数据
if len(annual_reports) >= 3:
    # 按年份排序
    annual_reports = annual_reports.sort_values('财务数据日期')
    # 取最近三年的数据
    recent_three = annual_reports.tail(3)
    # 计算现金分红总和
    total_cash_dividends = recent_three['现金分红金额'].sum()
    # 计算年均净利润
    total_net_profit = recent_three['净利润'].sum()
    avg_net_profit = total_net_profit / 3
    # 判断条件
    cash_condition = (total_cash_dividends == 0) or (total_cash_dividends < avg_net_profit * 0.3)
else:
    # 不足三年数据，条件不满足
    cash_condition = False

然后，条件中的现金分红部分是否满足取决于cash_condition是否为True。

因此，整个条件部分需要满足：

valid_condition = valid_condition_part1 & cash_condition_part

但如何将这些步骤应用到每一行呢？

在pandas中，可以使用apply函数逐行处理，但效率可能较低。或者，可以尝试向量化操作。

但考虑到需要跨行获取数据，可能必须使用apply函数。

例如，定义一个函数来处理每一行的现金分红条件：

def check_cash_condition(row, df):
    company = row['公司简称']
    current_date = row['财务数据日期']
    current_year = current_date.year
    # 筛选同一公司，最近三年的年报
    mask = (
        (df['公司简称'] == company) &
        (df['财务数据日期'].dt.year >= current_year - 2) &
        (df['财务数据日期'].dt.year <= current_year) &
        (df['财务数据日期'].dt.month == 12) &
        (df['财务数据日期'].dt.day == 31)
    )
    annual_reports = df[mask].sort_values('财务数据日期')
    # 需要至少三年的数据
    if len(annual_reports) < 3:
        return False
    # 取最近三年
    recent_three = annual_reports.iloc[-3:]
    total_dividends = recent_three['现金分红金额'].sum()
    total_profit = recent_three['净利润'].sum()
    avg_profit = total_profit / 3
    # 判断条件
    if total_dividends == 0:
        return True
    elif avg_profit == 0:
        # 如果年均净利润为0，无法计算比例，可能不满足条件
        return False
    else:
        return total_dividends < avg_profit * 0.3

然后，在代码中应用这个函数：

df['cash_condition'] = df.apply(lambda row: check_cash_condition(row, df), axis=1)

但这样处理可能效率较低，因为对于每一行都要筛选整个数据框。为了提高效率，可以预先按公司分组，并为每个公司建立年度索引。

但考虑到数据量可能不大，可以接受。

现在，将所有这些条件组合起来：

valid_condition_part1 = (df['合并报表未分配利润'] > 0) & (df['母公司报表未分配利润'] > 0) & (df['净利润'] > 0)
valid_cash_condition = df.apply(lambda row: check_cash_condition(row, df), axis=1)
valid_condition = valid_condition_part1 & valid_cash_condition

接下来，处理约束条件：必须在权益分派方案中披露相关原因的说明。这需要使用llm_content_check函数来检查权益分派方案文本是否包含所需内容。

约束条件是“应当在权益分派方案中披露：结合所处行业特点、发展阶段和自身经营模式、盈利水平、偿债能力、资金需求等因素，未进行现金分红或现金分红水平较低原因的说明”。

因此，需要检查权益分派方案文本是否包含这些因素的说明。可以使用llm_content_check函数：

constraint_description = ""结合所处行业特点、发展阶段和自身经营模式、盈利水平、偿债能力、资金需求等因素，未进行现金分红或现金分红水平较低原因的说明""
df['meu_13_1_constraint'] = df['权益分派方案文本'].apply(
    lambda text: llm_content_check(text, constraint_description) if pd.notna(text) else False
)

但需要注意，只有当公司进行了权益分派（即“是否进行权益分派”为True）时，才需要检查约束条件。或者，是否无论是否进行权益分派都需要披露？

根据MEU的约束条件，当触发条件满足时（即公司符合条件中的情况），无论是否进行现金分红，都需要在权益分派方案中披露原因。例如，如果公司未进行现金分红，或者现金分红水平较低，都需要披露原因。

因此，约束条件要求，当触发条件满足时，权益分派方案中必须披露原因。因此，需要检查权益分派方案文本是否包含该说明。

因此，在代码中，只有当触发条件满足时，才需要检查约束条件。或者，无论触发条件是否满足，只要公司进行了权益分派，就需要检查？

根据MEU的约束条件，约束条件仅在触发条件满足时适用。即，当公司满足条件中的情况时，才需要遵守约束条件。因此，只有当valid_condition为True时，才需要检查约束条件。

因此，在代码中，只有当valid_condition为True时，才需要检查权益分派方案文本是否包含所需内容。否则，约束条件不适用。

因此，处理约束条件的步骤如下：

valid_constraint = df.apply(lambda row: 
    llm_content_check(row['权益分派方案文本'], constraint_description) 
    if (row['meu_13_1_condition'] and pd.notna(row['权益分派方案文本'])) 
    else False, axis=1)

或者，更准确地说，只有当触发条件（valid_condition）为True时，才需要检查约束条件。此外，如果公司未进行权益分派（即“是否进行权益分派”为False），那么可能不需要披露，或者是否需要披露？

根据MEU的约束条件，无论公司是否进行权益分派，只要触发条件满足，就需要在权益分派方案中披露。例如，如果公司决定不进行权益分派，但触发条件满足，可能仍然需要披露原因。或者，是否只有在进行权益分派时才需要披露？

这可能需要根据法律条文的具体要求。例如，如果公司未进行现金分红，但触发条件满足，可能需要在权益分派方案中说明原因，即使没有进行分派。或者，可能只有在进行权益分派时才需要披露。

根据MEU的约束条件，约束条件是“应当在权益分派方案中披露”，因此可能只有当公司进行权益分派时，才需要披露。如果公司未进行任何权益分派，可能不需要披露。或者，可能即使不进行分派，也需要披露？

例如，假设公司未进行现金分红，但触发条件满足，是否需要披露？根据约束条件的描述，可能无论是否进行现金分红，只要触发条件满足，就需要在权益分派方案中披露原因。例如，权益分派方案可能包括不进行分派的决定，并说明原因。

因此，无论是否进行权益分派，只要触发条件满足，就需要在权益分派方案中披露原因。因此，需要检查权益分派方案文本是否存在，并且包含所需内容。

因此，在代码中，当valid_condition为True时，检查权益分派方案文本是否包含所需内容。如果公司未进行权益分派（即“是否进行权益分派”为False），则可能没有权益分派方案文本，此时约束条件不满足。

因此，处理约束条件的逻辑如下：

如果valid_condition为True，并且公司进行了权益分派（即“是否进行权益分派”为True），则检查权益分派方案文本是否包含所需内容。否则，约束条件不满足。

或者，可能即使公司未进行权益分派，但触发条件满足，也需要披露原因，此时权益分派方案文本可能为空，导致约束条件不满足。

这可能需要更仔细的分析。例如，如果公司未进行权益分派，但触发条件满足，是否需要发布公告说明原因？如果是，那么权益分派方案文本可能包含该说明，即使没有实际分派。

因此，在代码中，当valid_condition为True时，无论是否进行权益分派，都需要检查权益分派方案文本是否存在并包含所需内容。如果公司未进行权益分派，可能权益分派方案文本为空，此时约束条件不满足。

因此，约束条件的检查逻辑是：

当valid_condition为True时，检查权益分派方案文本是否包含所需内容。如果权益分派方案文本存在（即非空），则使用llm_content_check函数检查；否则，约束条件不满足。

因此，在代码中：

df['meu_13_1_constraint'] = False  # 初始化为False

mask = valid_condition & df['是否进行权益分派']
df.loc[mask, 'meu_13_1_constraint'] = df.loc[mask, '权益分派方案文本'].apply(
    lambda text: llm_content_check(text, constraint_description) if pd.notna(text) else False
)

或者，可能即使未进行权益分派，也需要披露原因，此时权益分派方案文本可能包含该说明。例如，公司可能发布公告说明不进行分派的原因，即使没有实际分派。因此，无论是否进行权益分派，只要触发条件满足，就需要检查权益分派方案文本是否存在并包含所需内容。

因此，约束条件的检查逻辑是：

当valid_condition为True时，检查权益分派方案文本是否存在，并且包含所需内容。如果存在，则检查；否则，约束条件不满足。

因此，代码可能如下：

valid_constraint = valid_condition & df['权益分派方案文本'].apply(
    lambda text: llm_content_check(text, constraint_description) if pd.notna(text) else False
)

但需要确保只有当valid_condition为True时，才进行检查。否则，约束条件不适用。

因此，在代码中：

df['meu_13_1_constraint'] = False

mask = valid_condition
df.loc[mask, 'meu_13_1_constraint'] = df.loc[mask, '权益分派方案文本'].apply(
    lambda text: llm_content_check(text, constraint_description) if pd.notna(text) else False
)

这样，只有当valid_condition为True时，才检查约束条件。如果权益分派方案文本存在，则检查内容；否则，约束条件不满足。

最后，整体的合规性判断是：当subject、condition、constraint都满足时，合规；否则，如果subject和condition满足，但constraint不满足，则违规。

因此，合规性列的计算：

df['meu_13_1_compliance'] = True  # 默认合规

# 当subject和condition满足，但constraint不满足时，违规
violation_mask = (df['meu_13_1_subject'] & df['meu_13_1_condition'] & ~df['meu_13_1_constraint'])
df.loc[violation_mask, 'meu_13_1_compliance'] = False

或者，可能合规性是指是否满足所有条件。即，只有当subject、condition、constraint都满足时，才合规。否则，不合规。

因此，合规性列的计算：

df['meu_13_1_compliance'] = df['meu_13_1_subject'] & df['meu_13_1_condition'] & df['meu_13_1_constraint']

但根据问题描述中的示例，合规性判断是：满足主体和条件但不满足约束时，违规。因此，合规性列应标记为False。

例如，在示例中，合规性列被标记为False当且仅当主体和条件满足，但约束不满足。

因此，合规性列的计算应为：

df['meu_13_1_compliance'] = ~ (df['meu_13_1_subject'] & df['meu_13_1_condition'] & ~df['meu_13_1_constraint'])

或者，更准确地说，合规性为True当且仅当以下情况之一成立：

1. 主体或条件不满足，因此约束不适用；
2. 主体和条件满足，且约束也满足。

因此，合规性列的计算应为：

df['meu_13_1_compliance'] = True  # 默认合规

# 当主体和条件满足，但约束不满足时，违规
violation = df['meu_13_1_subject'] & df['meu_13_1_condition'] & ~df['meu_13_1_constraint']
df.loc[violation, 'meu_13_1_compliance'] = False

这样，只有当主体和条件都满足，但约束不满足时，才标记为不合规。其他情况视为合规。

现在，将这些步骤整合到代码中：

首先，初始化各列：

df['meu_13_1_subject'] = True  # 假设所有行都是上市公司

然后，处理条件部分：

valid_condition_part1 = (df['合并报表未分配利润'] > 0) & (df['母公司报表未分配利润'] > 0) & (df['净利润'] > 0)

然后，处理现金分红条件：

def check_cash_condition(row, df):
    company = row['公司简称']
    current_date = row['财务数据日期']
    current_year = current_date.year
    # 筛选同一公司，最近三年的年报
    mask = (
        (df['公司简称'] == company) &
        (df['财务数据日期'].dt.year >= current_year - 2) &
        (df['财务数据日期'].dt.year <= current_year) &
        (df['财务数据日期'].dt.month == 12) &
        (df['财务数据日期'].dt.day == 31)
    )
    annual_reports = df[mask].sort_values('财务数据日期')
    # 需要至少三年的数据
    if len(annual_reports) < 3:
        return False
    # 取最近三年
    recent_three = annual_reports.iloc[-3:]
    total_dividends = recent_three['现金分红金额'].sum()
    total_profit = recent_three['净利润'].sum()
    avg_profit = total_profit / 3
    # 判断条件
    if total_dividends == 0:
        return True
    elif avg_profit == 0:
        return False
    else:
        return total_dividends < avg_profit * 0.3

df['cash_condition'] = df.apply(lambda row: check_cash_condition(row, df), axis=1)

valid_condition = valid_condition_part1 & df['cash_condition']

然后，标记条件列：

df['meu_13_1_condition'] = valid_condition

接下来，处理约束条件：

constraint_description = ""结合所处行业特点、发展阶段和自身经营模式、盈利水平、偿债能力、资金需求等因素，未进行现金分红或现金分红水平较低原因的说明""

mask = valid_condition
df['meu_13_1_constraint'] = False
df.loc[mask, 'meu_13_1_constraint'] = df.loc[mask, '权益分派方案文本'].apply(
    lambda text: llm_content_check(text, constraint_description) if pd.notna(text) else False
)

最后，计算合规性：

df['meu_13_1_compliance'] = True
violation_mask = df['meu_13_1_subject'] & df['meu_13_1_condition'] & ~df['meu_13_1_constraint']
df.loc[violation_mask, 'meu_13_1_compliance'] = False

现在，将这些步骤整合到代码中：

需要注意的是，在示例中，代码中的列名如meu_4_1_subject等是根据MEU编号来命名的。因此，MEU_13_1对应的列名应为meu_13_1_subject、meu_13_1_condition等。

此外，在现金分红条件的处理中，可能需要对每一行进行判断，但使用apply函数可能效率较低。如果数据量较大，可能需要优化，但根据问题描述，这可能可以接受。

最后，整合所有步骤到代码中：

import pandas as pd
from utils.tool_for_agents import llm_content_check

def check_meu_13_1(df):
    '''
    检查MEU_13_1的合规性：
    subject: 上市公司
    condition: 合并和母公司资产负债表未分配利润均为正值，报告期内盈利，且未进行现金分红或最近三年现金分红总额低于最近三年年均净利润的30%
    constraint: 在权益分派方案中披露原因说明
    '''
    
    # 初始化各列
    df['meu_13_1_subject'] = True  # 所有行均为上市公司
    df['meu_13_1_condition'] = False
    df['meu_13_1_constraint'] = False
    df['meu_13_1_compliance'] = True
    
    # 条件部分1：未分配利润和净利润
    valid_condition_part1 = (
        (df['合并报表未分配利润'] > 0) &
        (df['母公司报表未分配利润'] > 0) &
        (df['净利润'] > 0)
    )
    
    # 条件部分2：现金分红条件
    def check_cash_condition(row):
        company = row['公司简称']
        current_year = row['财务数据日期'].year
        # 筛选最近三年的年报
        mask = (
            (df['公司简称'] == company) &
            (df['财务数据日期'].dt.year >= current_year - 2) &
            (df['财务数据日期'].dt.year <= current_year) &
            (df['财务数据日期'].dt.month == 12) &
            (df['财务数据日期'].dt.day == 31)
        )
        annual_reports = df[mask].sort_values('财务数据日期')
        if len(annual_reports) < 3:
            return False
        recent_three = annual_reports.iloc[-3:]
        total_dividends = recent_three['现金分红金额'].sum()
        total_profit = recent_three['净利润'].sum()
        avg_profit = total_profit / 3
        if total_dividends == 0:
            return True
        elif avg_profit == 0:
            return False
        else:
            return total_dividends < avg_profit * 0.3
    
    df['cash_condition'] = df.apply(check_cash_condition, axis=1)
    valid_condition = valid_condition_part1 & df['cash_condition']
    df['meu_13_1_condition'] = valid_condition
    
    # 约束条件：检查权益分派方案文本
    constraint_description = ""结合所处行业特点、发展阶段和自身经营模式、盈利水平、偿债能力、资金需求等因素，未进行现金分红或现金分红水平较低原因的说明""
    mask = valid_condition
    df.loc[mask, 'meu_13_1_constraint'] = df.loc[mask, '权益分派方案文本'].apply(
        lambda text: llm_content_check(text, constraint_description) if pd.notna(text) else False
    )
    
    # 计算合规性
    violation_mask = (
        df['meu_13_1_subject'] &
        df['meu_13_1_condition'] &
        ~df['meu_13_1_constraint']
    )
    df.loc[violation_mask, 'meu_13_1_compliance'] = False
    
    # 清理临时列
    df.drop(columns=['cash_condition'], inplace=True)
    
    return df

需要注意的是，上述代码中的check_cash_condition函数在apply时可能会比较慢，因为它每次都要筛选整个数据框。为了提高效率，可以预先按公司分组，并为每个公司建立年度索引，但这样会增加代码的复杂性。此外，可能还需要处理财务数据日期不是12月31日的情况，例如，半年报或季报，但根据问题描述，年报的财务数据日期应为12月31日，因此可以假设这些行存在。

此外，在现金分红条件的计算中，假设最近三年的年报数据都存在，否则条件不满足。这可能是一个合理的假设，因为如果公司成立不足三年，可能无法满足条件。

最后，代码中使用了llm_content_check函数来检查权益分派方案文本，这需要确保该函数在环境中可用。
","CompletionUsage(completion_tokens=11085, prompt_tokens=2057, total_tokens=13142, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=10286, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 5. 计算整体的违约情况并标记在dataframe上(meu_n_k_compliance). 

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df['meu_4_2_subject'] = False  # 初始化subject列
    df['meu_4_2_condition'] = False  # 初始化condition列
    df['meu_4_2_constrain'] = False  # 初始化constrain列

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True

    # 判断违规情况：满足主体和条件但不满足约束
    is_violation = (
        valid_subject & 
        valid_condition & 
        (~valid_constraint)
    )

    # 标记违规行
    df.loc[is_violation, 'meu_4_1_compliance'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_13_4
法律的最小可执行单元内容: {""subject"": ""上市公司"", ""condition"": ""合并资产负债表、母公司资产负债表中本年末未分配利润均为正值且报告期内盈利，未进行现金分红或最近三年现金分红总额低于最近三年年均净利润30%"", ""constraint"": ""应当在权益分派方案中披露：公司为增强投资者回报水平拟采取的措施"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '财务数据日期', '公告日期', '公告类型', '审计意见', '总资产', '总负债', '净资产', '资产负债率',
'交易性金融资产', '衍生金融资产', '债权投资', '其他债权投资', '其他权益工具投资', '其他非流动金融资产',
'其他流动资产', '金融资产总额', '总股本', '每股净资产', '合并报表未分配利润', '母公司报表未分配利润', '净利润',
'每股净利润', '母公司报表净利润', '经营活动现金流量净额', '投资活动现金流量净额', '筹资活动现金流量净额',
'现金及现金等价物净增加额', '净资产增长率', '净利润增长率', '资产负债率变化', '金融资产增长率',
'是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划', '现金分红金额', '送股比例', '转增比例', '是否进行权益分派', '权益分派方案文本', '公司简称']

## 其中: 
- 这是一个二维的面板数据, 根据['日期', '公司简称']可以定位到特定公司在特定日期的状态. 数据已经按照公司简称和日期排序. 
- 我们的'日期'并非连续的自然日或者交易日, 而是固定的季报/半年报/年报披露后三个月内的某一个自然日, 例如'2020-05-30', '2020-09-29', ...等, 我们假定公司在这一天发布了权益分派公告(或者决定了不进行权益分派). 每个季报/半年报/年报后只会跟随一个'日期'来决定是否进行权益分派, 如何进行分派. 
- 数据的每一行包含了两个部分的数据, 分别是当时最新的财务数据和当时最新的权益分派情况. 例如, '2020-09-17'这一行可能对应了公告日期为'2020-08-27'的截至'2020-06-30'的半年报财务报告['审计意见', '总资产', ..., '现金及现金等价物净增加额'], 以及在'2020-09-17'当天公告的权益分派信息['是否进行权益分派', ..., '现金分红金额', ...]
- 所有财务数据都是以单季度的形式记录的, 不需要考虑利润表科目在半年报和年报中逐渐累加的问题. 所有的增长率都是单季的. 
- 所有资产/价格的单位都是元而非万元, 千元或百万元; 所有的比例/比率都是小数而非百分数, 除了['送股比例', '转增比例']是""每10股送n股""的格式. 
- ['审计意见']的值有""无保留意见"", ""非标准无保留意见"", ""保留意见"". 
- 这些列为布尔值: ['是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划']

- 如果希望检查权益分派方案中是否披露了特定内容, 可以使用环境中会提供的函数`llm_content_check()`, 但非披露类的合规检查中禁止使用这个函数. 
    描述: 使用LLM检查公告中是否包含特定内容
        参数:
            announcement_text: 公告全文
            traget_content: 需要检查的内容描述
        返回:
            bool: 公告中是否包含特定内容
    调用示例: 
        ```python
        from utils.tool_for_agents import llm_content_check

        constraint_description = ""为增强投资者回报水平拟采取的措施"" # 请完整描述需要检查的内容, 不得简化
        df['meu_4_1_constraint'] = df['权益分派方案文本'].apply(
            lambda text: llm_content_check(text, constraint_description)
        )
        ```

note:
 - 理论上你撰写合规检验代码所需要的数据都可以从一致的数据中得到, 对于没有直接对应的数据你需要自己计算得到, 不要简单地认为无法完成. 
 - 除非材料提供, 否则不要主动进行简化的假设. 如果你认为所给的信息不足以判断案例的合规性, 可以在函数的结尾进行注释说明. 但这种情况应该很少出现. 

","

<CODE>
import pandas as pd
from utils.tool_for_agents import llm_content_check

def check_meu_13_4(df):
    '''
    验证上市公司在特定财务条件下的信息披露合规性
    ""subject"": ""上市公司"",
    ""condition"": ""合并/母公司资产负债表未分配利润正值且盈利，且未分红或三年分红不足"",
    ""constraint"": ""需在权益分派方案中披露投资者回报措施""
    '''
    # 初始化标记列
    df['meu_13_4_subject'] = True  # 假设所有记录均为上市公司
    df['meu_13_4_condition'] = False
    df['meu_13_4_constraint'] = False

    # 条件A: 年末双报表未分配利润正值且当期盈利
    is_year_end = df['财务数据日期'].dt.month == 12
    positive_retained = (df['合并报表未分配利润'] > 0) & (df['母公司报表未分配利润'] > 0)
    profitable = df['净利润'] > 0
    valid_condition_A = is_year_end & positive_retained & profitable

    # 条件B: 未分红或三年分红不足
    # 计算三年分红及利润指标
    annual_mask = df['财务数据日期'].dt.month == 12
    annual_df = df[annual_mask].copy().sort_values(['公司简称', '财务数据日期'])
    
    # 计算滚动三年指标
    annual_df['三年现金分红总额'] = annual_df.groupby('公司简称')['现金分红金额'].transform(
        lambda x: x.rolling(3, min_periods=3).sum())
    annual_df['三年净利润总和'] = annual_df.groupby('公司简称')['净利润'].transform(
        lambda x: x.rolling(3, min_periods=3).sum())
    annual_df['三年年均净利润'] = annual_df['三年净利润总和'] / 3

    # 合并回原始数据
    df = df.merge(
        annual_df[['公司简称', '财务数据日期', '三年现金分红总额', '三年年均净利润']],
        how='left',
        on=['公司简称', '财务数据日期']
    )

    # 构建条件B判断
    no_dividend = ~df['是否实施现金分红']
    insufficient_dividend = (
        df['是否实施现金分红'] & 
        (df['三年现金分红总额'] < df['三年年均净利润'] * 0.3)
    ).fillna(False)
    valid_condition_B = no_dividend | insufficient_dividend

    # 综合条件判断
    df['meu_13_4_condition'] = valid_condition_A & valid_condition_B

    # 约束条件检查
    constraint_desc = ""为增强投资者回报水平拟采取的措施""
    df['meu_13_4_constraint'] = df.apply(
        lambda x: llm_content_check(x['权益分派方案文本'], constraint_desc) 
        if x['meu_13_4_condition'] else False,
        axis=1
    )

    # 计算整体合规性
    violation_mask = df['meu_13_4_condition'] & ~df['meu_13_4_constraint']
    df['meu_13_4_compliance'] = ~violation_mask

    # 清理临时列
    df.drop(columns=['三年现金分红总额', '三年年均净利润'], errors='ignore', inplace=True)

    return df
</CODE>","好的，我现在需要处理这个MEU_13_4的合规性检查。首先，我得仔细理解这个MEU的内容。根据描述，主体是上市公司，条件有两个部分：合并和母公司资产负债表的未分配利润在年末都是正值，并且报告期内盈利，同时公司未进行现金分红或者最近三年现金分红总额低于最近三年年均净利润的30%。约束条件是公司必须在权益分派方案中披露增强投资者回报的措施。

接下来，我需要将这些条件转化为代码逻辑。首先处理subject部分，这里的主体是上市公司，所以每一行数据对应的都是上市公司，所以可能不需要特别的筛选，但可能需要确认是否存在其他情况。不过根据问题描述，数据中的每一行都是针对上市公司的，所以可能直接标记subject为True。不过可能需要确认是否有其他情况，比如是否有可能存在非上市公司的情况？根据提供的列中没有公司类型的信息，可能假设所有行都是上市公司，所以subject列可以直接设为True。或者可能数据中的公司都是上市公司，所以这一步可能不需要复杂的判断，直接标记为True。

接下来是条件部分。条件分为两部分：合并和母公司资产负债表的未分配利润本年末均为正值，且报告期内盈利。同时，未进行现金分红或最近三年现金分红总额低于最近三年年均净利润的30%。

首先，检查合并报表和母公司报表的未分配利润是否正值。对应的列应该是'合并报表未分配利润'和'母公司报表未分配利润'。需要确保这两个值在年末时都是正值。但这里的数据中的财务数据日期可能对应的是报告期，比如年报的年末。例如，假设财务数据日期是年末的日期，比如2023-12-31，那么对应的未分配利润是否为正值。但需要确认数据中的财务数据日期是否对应年末的情况。例如，年报的财务数据日期是年末，而季报可能不是。但MEU中的条件提到的是“本年末”，所以可能需要检查的是年报的数据。但问题中的说明指出，每个季报/半年报/年报后只会有一个日期来决定权益分派。所以可能需要确定当前行的财务数据是否是年末的数据。例如，如果财务数据日期是12月31日，那么对应的就是年末的数据。否则，可能不需要考虑？或者可能条件中的“本年末”指的是最近一年的年末，无论当前是哪个季度？

这里可能需要进一步分析。例如，假设当财务数据日期是年末时（比如12月31日），才需要检查这两个未分配利润是否正值。否则，可能不满足条件？或者，不管财务数据日期是什么时候，只要在年末时的未分配利润是正值？这可能需要更详细的数据结构，但根据提供的列，可能只能根据当前行的财务数据日期来判断是否是年末的数据。例如，如果财务数据日期的月份是12月，那么视为年末的数据。或者可能每个年报对应的财务数据日期是年末，而季报是季度末。因此，在检查条件时，需要确保合并和母公司报表的未分配利润在年末时都是正值，并且报告期内盈利。

另外，报告期内盈利可能指的是净利润为正。对应的列是'净利润'，所以需要净利润>0。

所以条件的第一部分：合并和母公司的未分配利润年末正值，且报告期内盈利。这里的报告期可能指的是当前财务数据的期间，比如年报对应的整个年度。因此，当财务数据日期是年末时，检查这两个未分配利润是否正值，并且净利润是否为正。

然后条件的第二部分是：未进行现金分红，或者最近三年现金分红总额低于最近三年年均净利润的30%。这里需要计算最近三年的现金分红总额，以及最近三年的年均净利润，然后比较是否分红总额低于年均净利润的30%。

但问题中的数据是日频的面板数据，每一行对应的是某个公司某个日期的情况，包括当时的财务数据和权益分派情况。因此，如何获取最近三年的数据呢？可能需要按公司分组，然后对于每一行，找到过去三年的现金分红金额和净利润数据，然后进行计算。

但这里的数据结构可能比较复杂，因为每个公司的数据是按时间排列的。例如，对于某一行，日期是2023-05-30，对应的财务数据日期是2022-12-31（年报），那么需要找到该公司在2020、2021、2022这三年的现金分红金额，以及这三年的净利润，然后计算总和和年均值。

但如何获取这些历史数据呢？在函数中，可能需要按公司分组，然后对于每一行，获取过去三年的数据。例如，对于当前行的财务数据日期，比如2022-12-31，那么最近三年是2020、2021、2022年，对应的年报数据。需要找到这三年的现金分红金额和净利润。

但问题中的dataframe可能包含多个财务数据日期，每个公司可能有多个记录。例如，每个年报、季报都会有一条记录。因此，在计算最近三年的数据时，可能需要按公司分组，然后对于每个记录，找到对应的三个年报的数据。

这可能比较复杂，因为需要跨行处理。例如，对于当前行的公司，需要找到其过去三年的年报数据中的现金分红金额和净利润。

但根据问题中的附加信息，数据已经按公司简称和日期排序。因此，可能需要使用groupby和rolling窗口来处理。

或者，可能每个公司的年报数据对应的财务数据日期是每年的12月31日，而季报是其他日期。因此，对于每个公司的年报数据，可以筛选出财务数据日期为12月31日的记录，然后计算最近三年的数据。

例如，对于当前行的财务数据日期是2022-12-31，那么需要检查该公司在2020、2021、2022这三年的现金分红金额总和，以及这三年的年均净利润。

但如何获取这些数据呢？可能需要按公司分组，然后对于每个公司的记录，找到最近三年的年报数据。

这可能比较复杂，因为需要跨行处理。例如，对于当前行，需要找到同一公司中财务数据日期为过去三年的年报的数据。

这可能需要在函数中使用groupby和shift或者rolling操作来获取过去三年的数据。

但考虑到这可能比较复杂，我需要仔细考虑如何实现。

首先，对于条件中的“最近三年现金分红总额”和“最近三年年均净利润”，这里的“最近三年”应该是指当前财务数据日期所在年度的前三年。例如，如果当前行的财务数据日期是2022-12-31（年报），那么最近三年是2020、2021、2022年。或者，可能是指当前日期（公告日期）的前三年？例如，如果公告日期是2023-05-30，那么最近三年是2020、2021、2022年？

但根据MEU的条件描述，可能这里的“最近三年”是指财务报告对应的年度的最近三年。例如，如果当前行的财务数据日期是2022-12-31（年报），那么最近三年是2020、2021、2022这三个年度。因此，需要获取这三个年度的现金分红金额和净利润。

但如何获取这些数据呢？假设每个公司的年报数据在dataframe中都有对应的行，那么对于当前行，需要找到同一公司中财务数据日期为2020-12-31、2021-12-31、2022-12-31这三年的记录，然后提取它们的现金分红金额和净利润。

但如何实现这一点呢？可能需要按公司分组，然后对于每个公司的每个记录，筛选出财务数据日期在最近三年内的年报数据。

例如，对于当前行的财务数据日期是2022-12-31，那么最近三年是2020、2021、2022年。需要找到这三个年度的年报数据。

但如何跨行获取这些数据？可能需要使用shift或者rolling窗口，但需要确保每个公司的年报数据是按时间排序的。

或者，可以创建一个辅助列，标识该行是否为年报数据（财务数据日期的月份是否为12月）。然后，对于每个公司的年报数据，按年份排序，并计算过去三年的数据。

这可能比较复杂，但或许可以按以下步骤处理：

1. 筛选出每个公司的年报数据（财务数据日期的月份为12月）。
2. 对于每个公司的每个年报数据，获取过去三年的现金分红金额和净利润。
3. 计算这三年的现金分红总额和年均净利润。
4. 判断是否满足条件：现金分红总额 < 年均净利润 * 0.3。

但问题中的dataframe可能包含多个记录，每个记录对应不同的财务数据日期（季报、半年报、年报）。因此，在计算最近三年的数据时，可能需要仅考虑年报的数据。

例如，当前行的财务数据日期是否是年报（比如12月31日）？如果是，则进行条件判断；否则，可能不满足条件？

或者，MEU的条件中的“本年末”可能指的是最近一年的年末，无论当前行是否是年报的数据？这可能不太合理，所以可能需要当前行的财务数据日期是年末的数据，即年报的数据，才能满足条件中的“本年末”。

因此，在条件判断时，首先需要确定当前行的财务数据是否是年报的数据。如果是，则继续判断；否则，条件不满足。

这可能是一个关键点。例如，只有当财务数据日期是年末（如12月31日）时，才需要检查合并和母公司报表的未分配利润是否正值，并且报告期内盈利。否则，该条件不成立，因此整个条件部分为False。

所以，步骤可能如下：

条件部分：

条件分为两个部分：

A. 合并和母公司资产负债表的未分配利润本年末均为正值，且报告期内盈利。

B. 未进行现金分红，或最近三年现金分红总额低于最近三年年均净利润的30%。

首先处理条件A：

1. 检查当前行的财务数据日期是否为年末（如月份为12月）。
2. 如果是，检查合并报表未分配利润和母公司报表未分配利润是否均大于0。
3. 同时，检查净利润是否大于0（报告期内盈利）。

如果以上都满足，则条件A成立。

然后处理条件B：

1. 检查是否未进行现金分红（即'是否实施现金分红'为False）。
2. 或者，如果进行了现金分红，则检查最近三年的现金分红总额是否低于最近三年年均净利润的30%。

对于情况2，需要计算最近三年的现金分红总额和年均净利润。

这里的问题是如何获取最近三年的数据。假设当前行的财务数据日期是2022-12-31（年报），那么需要找到该公司在2020、2021、2022这三年的现金分红金额和净利润。

但如何获取这些数据呢？可能需要按公司分组，然后对于每个公司的年报数据，按时间排序，并获取过去三年的记录。

例如，对于每个公司，筛选出所有年报数据（财务数据日期为12月31日），然后按时间排序。对于每个年报数据，取前两年的年报数据，加上当前年的数据，共三年。

这可能需要在函数中使用groupby和rolling窗口，或者shift操作。

例如，按公司分组后，对每个公司的年报数据按财务数据日期排序，然后计算每个年度的现金分红金额和净利润的总和。

但具体实现可能比较复杂。例如，对于每个公司的年报数据，创建一个新的DataFrame，其中包含每年的现金分红金额和净利润，然后对于每个年度，计算过去三年的总和和均值。

或者，可以按公司分组后，对每个公司的现金分红金额和净利润进行滚动窗口计算，窗口大小为3年，但需要确保窗口内的数据是连续的年报。

这可能比较复杂，但假设数据已经按公司简称和日期排序，那么对于每个公司的年报数据，可以按时间顺序排列，然后使用shift来获取前两年的数据。

例如，对于当前行（年报），同一公司的前两条年报记录可能对应前两年。但需要确保这三年的数据是连续的。

这可能存在一些问题，比如如果某公司某年没有年报数据，或者数据不连续，如何处理？但根据问题描述，数据可能已经处理过，每个季报/年报后有一个记录，所以年报数据可能存在。

假设数据中存在每个公司的年报记录，那么可以按以下步骤处理：

对于每个公司的年报数据，按财务数据日期排序，然后计算每个年度的三年总和：

例如，对于当前行（2022年年报），需要获取2020、2021、2022这三年的现金分红金额和净利润。

那么，可以按公司分组后，对每个公司的现金分红金额和净利润进行滚动窗口求和，窗口大小为3，但需要确保是年度数据。

但如何确保滚动窗口是每年的年报数据呢？可能需要先筛选出年报数据，再进行滚动计算。

例如，对于每个公司，先筛选出财务数据日期为12月31日的记录，并按日期排序。然后，对于每个记录，计算过去三年的现金分红金额总和和净利润总和。

这可能需要在函数中进行以下步骤：

1. 按公司分组。
2. 对每个公司，筛选出年报数据（财务数据日期的月份为12）。
3. 按财务数据日期排序。
4. 计算每个年报记录的现金分红金额和净利润的三年总和。

但如何将这些计算结果合并回原始的dataframe中呢？因为原始dataframe中的每一行可能对应不同的财务数据日期（包括季报、半年报、年报），而只有年报的数据需要处理条件B中的情况。

这可能比较复杂，但或许可以这样做：

在函数中，首先为每个公司生成一个只包含年报数据的子DataFrame，然后计算每个年报记录的三年滚动总和，并将结果合并回原始DataFrame中。

例如：

对于每个公司：

- 创建子df，其中财务数据日期的月份是12月。
- 按财务数据日期排序。
- 计算现金分红金额的滚动三年总和（sum）和净利润的滚动三年总和（sum）。
- 将结果合并回原始df中，使用merge操作，根据公司简称和财务数据日期进行匹配。

这样，在原始df中，只有年报的记录会有对应的三年现金分红总和和净利润总和，其他记录则为NaN。

然后，在条件B的判断中，如果当前行是年报数据，则可以使用这些合并后的字段进行计算。

这可能是一个可行的方案。但具体实现可能需要较多的步骤。

现在，回到代码编写：

首先，处理条件A：

valid_condition_A = (
    (df['财务数据日期'].dt.month == 12) &  # 年末数据
    (df['合并报表未分配利润'] > 0) & 
    (df['母公司报表未分配利润'] > 0) & 
    (df['净利润'] > 0)
)

然后处理条件B：

条件B分为两种情况：

情况1：未进行现金分红（'是否实施现金分红'为False）。

情况2：最近三年现金分红总额 < 最近三年年均净利润 * 0.3。

对于情况2，需要计算：

三年现金分红总额 = sum(现金分红金额_2020, 现金分红金额_2021, 现金分红金额_2022)

三年年均净利润 = (净利润_2020 + 净利润_2021 + 净利润_2022) / 3

然后判断三年现金分红总额 < 三年年均净利润 * 0.3。

因此，需要为每个年报记录计算过去三年的现金分红总额和年均净利润。

这可以通过以下步骤实现：

1. 筛选出年报数据。
2. 按公司分组，按财务数据日期排序。
3. 计算每个年报记录的三年滚动现金分红总和和净利润总和。
4. 将结果合并回原始df。

具体代码可能如下：

# 筛选年报数据
annual_reports = df[df['财务数据日期'].dt.month == 12].copy()

# 按公司分组并按财务数据日期排序
annual_reports_sorted = annual_reports.sort_values(by=['公司简称', '财务数据日期'])

# 计算每个公司的三年滚动现金分红总和和净利润总和
annual_reports_sorted['三年现金分红总额'] = annual_reports_sorted.groupby('公司简称')['现金分红金额'].transform(lambda x: x.rolling(3, min_periods=3).sum())
annual_reports_sorted['三年净利润总和'] = annual_reports_sorted.groupby('公司简称')['净利润'].transform(lambda x: x.rolling(3, min_periods=3).sum())

# 计算年均净利润
annual_reports_sorted['三年年均净利润'] = annual_reports_sorted['三年净利润总和'] / 3

# 将结果合并回原始df
df = df.merge(annual_reports_sorted[['公司简称', '财务数据日期', '三年现金分红总额', '三年年均净利润']], 
              on=['公司简称', '财务数据日期'], how='left')

这样，在原始df中，每个年报记录会有对应的三年现金分红总额和三年年均净利润，而其他记录则为NaN。

然后，条件B的判断可以写为：

# 情况1：未进行现金分红
condition_B_case1 = ~df['是否实施现金分红']

# 情况2：现金分红且三年总和 < 年均净利润 * 0.3
condition_B_case2 = (
    df['是否实施现金分红'] & 
    (df['三年现金分红总额'] < df['三年年均净利润'] * 0.3)
)

valid_condition_B = condition_B_case1 | condition_B_case2

但需要注意，只有当当前行是年报数据时，才需要检查条件B。否则，条件B可能不成立。例如，如果当前行不是年报数据，那么条件B中的“最近三年”可能无法计算，因此条件B不成立。但根据MEU的条件，只有当条件A满足时，才会触发条件B的判断。而条件A只有在年报数据时才可能满足。因此，在条件A满足的情况下，条件B的判断才有意义。

因此，整个条件部分的条件是：

valid_condition = valid_condition_A & valid_condition_B

但需要确保在计算valid_condition_B时，只有年报数据才会被处理。例如，对于非年报数据，valid_condition_B可能为False，因为三年现金分红总额和年均净利润可能为NaN，导致条件B不成立。

但根据条件A的判断，只有当valid_condition_A为True时，才会进入条件B的判断。而valid_condition_A只有在年报数据时才可能为True。因此，在valid_condition_A为True的情况下，当前行是年报数据，因此三年现金分红总额和年均净利润可能已经被计算，或者可能为NaN（例如，如果当前行是第一个或第二个年报记录，无法满足三年的滚动窗口）。

例如，如果当前行是2020年的年报，那么三年滚动窗口需要2018、2019、2020的数据，但可能数据中没有2018年的记录，导致三年总和为NaN。此时，条件B的判断可能无法进行，因此视为不满足条件B，从而导致整个条件部分不成立。

因此，在计算valid_condition_B时，需要处理这种情况。例如，只有当三年现金分红总额和年均净利润存在时，才能进行判断。否则，视为条件B不成立。

因此，在代码中，可能需要将NaN的情况视为不满足条件B的情况。

例如：

condition_B_case2 = (
    df['是否实施现金分红'] & 
    (df['三年现金分红总额'] < df['三年年均净利润'] * 0.3) &
    df['三年现金分红总额'].notna() & 
    df['三年年均净利润'].notna()
)

或者，在计算时，将NaN视为不满足条件。

这可能比较复杂，但根据问题中的描述，可能需要假设数据中存在足够的年报记录来计算三年总和。否则，条件B无法满足，因此整个条件部分不成立。

现在，处理约束条件：公司必须在权益分派方案中披露增强投资者回报的措施。对应的列是'权益分派方案文本'，需要使用提供的llm_content_check函数来检查是否包含特定内容。

约束条件的判断是：如果公司满足条件A和B，那么必须在其权益分派方案中披露相关措施。因此，只有当valid_condition_A和valid_condition_B都为True时，才需要检查约束条件。

约束条件的valid_constraint为：权益分派方案文本中包含“为增强投资者回报水平拟采取的措施”。

因此，代码中：

valid_constraint = df.apply(lambda row: 
    llm_content_check(row['权益分派方案文本'], ""为增强投资者回报水平拟采取的措施"") 
    if (row['meu_13_4_condition'] and row['是否进行权益分派']) else False, axis=1)

或者，更准确地说，当公司满足条件（即valid_condition为True）时，必须进行权益分派，并且在方案中披露措施。或者，可能即使公司不进行权益分派，也需要披露？根据MEU的约束条件，描述是“应当在权益分派方案中披露”，所以只有当公司进行权益分派时，才需要披露。如果公司未进行权益分派，可能不需要披露？或者，是否进行权益分派是另一个条件？

根据MEU的条件，条件部分中的“未进行现金分红或最近三年现金分红总额低于...”可能意味着公司可能未进行现金分红，但可能进行了其他形式的分红，或者未进行任何分红。但约束条件要求的是在权益分派方案中披露，所以只有当公司进行权益分派时，才需要披露。如果公司未进行权益分派，可能不需要披露？

或者，可能不管是否进行权益分派，只要满足条件，就需要在权益分派方案中披露。但权益分派方案是否存在呢？例如，如果公司未进行权益分派，可能没有权益分派方案，因此无法披露。此时，是否需要检查？

这可能是一个问题。根据MEU的约束条件，当公司满足条件时，应当在权益分派方案中披露。因此，如果公司满足条件，但未进行权益分派（即没有权益分派方案），那么是否违反约束条件？

这可能存在歧义。根据法律条文，可能需要公司即使不进行分派，也需要在相关公告中披露措施。或者，可能只有当公司进行权益分派时，才需要披露。这可能需要更详细的法律条文解释，但根据当前MEU的描述，约束条件是“应当在权益分派方案中披露”，因此只有当公司存在权益分派方案时，才需要披露。如果公司未进行权益分派，可能没有方案，因此无需披露，此时约束条件是否满足？

例如，假设公司满足条件A和B，但未进行权益分派（即'是否进行权益分派'为False），那么是否需要检查约束条件？根据约束条件的描述，可能不需要，因为不存在权益分派方案。因此，约束条件是否满足？

这可能比较复杂。根据MEU的约束条件，当公司满足条件时，应当在权益分派方案中披露。因此，如果公司满足条件，并且进行了权益分派，则必须披露；如果满足条件但未进行权益分派，则可能不需要披露，因此约束条件自动满足？

或者，可能无论是否进行权益分派，只要满足条件，就需要在权益分派方案中披露。例如，如果公司决定不进行分派，是否需要在方案中说明原因并披露措施？

这可能需要更详细的法律条文理解，但根据当前MEU的描述，约束条件是“应当在权益分派方案中披露”，因此只有当公司存在权益分派方案时，才需要披露。如果公司未进行权益分派，可能没有方案，因此无需披露，此时约束条件是否自动满足？

或者，可能公司即使不进行分派，也需要发布公告说明，并在其中披露措施。此时，需要检查公告文本是否包含相关内容。

因此，在代码中，可能需要处理两种情况：

1. 公司进行了权益分派（'是否进行权益分派'为True）：需要检查权益分派方案文本是否包含措施。
2. 公司未进行权益分派（'是否进行权益分派'为False）：是否需要检查其他公告中的披露？例如，是否在公告中说明不进行分派的原因，并披露措施？

根据问题中的附加信息，数据中的每一行包含了当时最新的权益分派情况。例如，如果公司未进行分派，则'是否进行权益分派'为False，并且可能没有权益分派方案文本。此时，如何判断是否满足约束条件？

这可能存在歧义。根据MEU的约束条件，可能只有当公司进行权益分派时，才需要披露。因此，如果公司满足条件A和B，并且进行了权益分派，则必须披露；如果未进行，则约束条件自动满足？

或者，可能无论是否进行分派，只要满足条件，就需要在相关公告中披露措施。例如，即使不进行分派，也需要在公告中说明原因并披露措施。此时，需要检查公告文本是否包含措施，不管是否进行分派。

但根据MEU的约束条件描述，是“应当在权益分派方案中披露”，因此可能只有当公司有权益分派方案时，才需要披露。因此，在代码中，当公司满足条件A和B，并且进行了权益分派，则需要检查方案文本；如果未进行分派，则无需检查，约束条件可能自动满足？

或者，可能公司即使未进行分派，也需要在公告中披露措施，此时需要检查其他公告文本。但根据提供的列，只有'权益分派方案文本'可能包含相关信息，而如果未进行分派，该字段可能为空或不存在。因此，这种情况下，约束条件可能无法满足，导致违规。

这可能需要更明确的法律条文解释，但根据当前的信息，可能只能假设当公司满足条件时，如果进行了权益分派，则必须披露；如果未进行，则无需披露，因此约束条件自动满足？

或者，可能无论是否进行分派，只要满足条件，就需要在权益分派相关的公告中披露措施。例如，即使不进行分派，也需要在公告中说明，并披露措施。此时，需要检查公告文本是否包含措施，不管是否进行分派。

在这种情况下，代码中的约束条件判断应为：当公司满足条件A和B时，必须在其权益分派相关的公告中披露措施，无论是否进行分派。因此，需要检查'权益分派方案文本'是否存在该披露，即使公司未进行分派。

但根据数据中的列，'是否进行权益分派'为布尔值，而'权益分派方案文本'可能为空或包含其他内容。例如，如果公司未进行分派，可能该文本字段为空，或者包含不进行分派的说明。此时，需要检查该文本是否包含所需的披露内容。

因此，在代码中，约束条件的判断应为：当公司满足条件A和B时，必须在其权益分派方案文本中披露措施，无论是否进行分派。因此，需要检查该文本是否存在披露。

或者，可能当公司未进行分派时，不需要披露，因此约束条件自动满足？

这可能需要更仔细的法律条文理解。例如，假设公司满足条件A和B，但未进行分派，是否需要披露措施？根据约束条件的描述，可能不需要，因为约束条件仅适用于权益分派方案。因此，只有当公司进行分派时，才需要披露。如果公司未进行分派，则无需披露，此时约束条件自动满足？

或者，可能无论是否进行分派，只要满足条件，就需要在相关公告中披露措施。例如，公司可能发布公告说明不进行分派的原因，并披露措施。此时，需要检查公告文本是否包含该内容。

但根据提供的列，只有'权益分派方案文本'可能包含相关信息，而如果公司未进行分派，该文本可能为空。因此，在这种情况下，约束条件可能无法满足，导致违规。

这可能需要假设，当公司满足条件A和B时，无论是否进行分派，都需要在权益分派相关的公告中披露措施。因此，必须检查'权益分派方案文本'是否包含该内容，即使公司未进行分派。

例如，公司可能发布公告决定不进行分派，但根据MEU的要求，仍需在公告中披露措施。因此，需要检查该文本是否包含相关内容。

因此，在代码中，约束条件的判断应为：当公司满足条件A和B时，必须在其权益分派方案文本中披露措施，无论是否进行分派。因此，需要检查该文本是否存在披露。

因此，valid_constraint的条件是：当valid_condition为True时，权益分派方案文本中包含特定内容。

因此，代码中的约束条件判断可以写为：

valid_constraint = df.apply(lambda row: llm_content_check(row['权益分派方案文本'], ""为增强投资者回报水平拟采取的措施"") if row['meu_13_4_condition'] else False, axis=1)

但需要确保只有当条件满足时，才检查约束条件。否则，约束条件不适用。

现在，将所有这些逻辑整合到代码中：

首先，标记subject。因为主体是上市公司，而数据中的每一行都是上市公司，所以subject列可以直接设为True。或者，可能数据中存在其他类型的公司，但根据问题描述，可能假设所有行都是上市公司。因此：

df['meu_13_4_subject'] = True

但可能需要确认是否存在其他情况。例如，可能数据中的公司可能包括非上市公司，但根据提供的列中没有公司类型的信息，可能无法判断。因此，可能假设所有行都是上市公司，因此subject为True。

接下来，条件部分：

条件A：

valid_condition_A = (
    (df['财务数据日期'].dt.month == 12) &  # 年末数据
    (df['合并报表未分配利润'] > 0) & 
    (df['母公司报表未分配利润'] > 0) & 
    (df['净利润'] > 0)
)

条件B：

需要计算三年现金分红总额和年均净利润。这需要先处理年报数据，并计算滚动总和。

代码步骤：

1. 筛选年报数据。
2. 按公司分组，按财务数据日期排序。
3. 计算三年滚动总和。
4. 合并回原始df。

在代码中：

# 筛选年报数据
annual_reports = df[df['财务数据日期'].dt.month == 12].copy()

# 按公司分组并按财务数据日期排序
annual_reports_sorted = annual_reports.sort_values(by=['公司简称', '财务数据日期'])

# 计算每个公司的三年滚动现金分红总和和净利润总和
annual_reports_sorted['三年现金分红总额'] = annual_reports_sorted.groupby('公司简称')['现金分红金额'].transform(lambda x: x.rolling(3, min_periods=3).sum())
annual_reports_sorted['三年净利润总和'] = annual_reports_sorted.groupby('公司简称')['净利润'].transform(lambda x: x.rolling(3, min_periods=3).sum())

# 计算年均净利润
annual_reports_sorted['三年年均净利润'] = annual_reports_sorted['三年净利润总和'] / 3

# 将结果合并回原始df
df = df.merge(annual_reports_sorted[['公司简称', '财务数据日期', '三年现金分红总额', '三年年均净利润']], 
              on=['公司简称', '财务数据日期'], 
              how='left')

然后，条件B的判断：

# 情况1：未进行现金分红
condition_B_case1 = ~df['是否实施现金分红']

# 情况2：现金分红且三年总和 < 年均净利润 * 0.3
condition_B_case2 = (
    df['是否实施现金分红'] & 
    (df['三年现金分红总额'] < df['三年年均净利润'] * 0.3)
)

# 处理NaN情况，例如，当三年数据不足时，条件B_case2为False
condition_B_case2 = condition_B_case2.fillna(False)

valid_condition_B = condition_B_case1 | condition_B_case2

然后，整个条件部分：

valid_condition = valid_condition_A & valid_condition_B

接下来，约束条件：

valid_constraint = df.apply(lambda row: llm_content_check(row['权益分派方案文本'], ""为增强投资者回报水平拟采取的措施"") if row['meu_13_4_condition'] else False, axis=1)

但需要确保当条件满足时，才检查约束条件。否则，约束条件不适用。

最后，判断违规情况：

is_violation = valid_condition & (~valid_constraint)

将各标记列填充到df中：

df['meu_13_4_subject'] = True  # 假设所有行都是上市公司
df['meu_13_4_condition'] = valid_condition
df['meu_13_4_constraint'] = valid_constraint

# 整体合规情况：当条件满足但约束不满足时为违规
df['meu_13_4_compliance'] = ~is_violation

但可能需要将未满足条件的情况视为合规，因为约束条件仅在条件满足时适用。

综上，将所有步骤整合到函数中：

现在，编写代码：

首先，导入必要的库：

import pandas as pd
from utils.tool_for_agents import llm_content_check

然后，定义函数：

def check_meu_13_4(df):
    # 初始化标记列
    df['meu_13_4_subject'] = True  # 假设所有行都是上市公司
    df['meu_13_4_condition'] = False
    df['meu_13_4_constraint'] = False

    # 标记subject
    # 根据MEU，主体是上市公司，假设所有数据行都是上市公司，因此直接标记为True

    # 标记条件A
    valid_condition_A = (
        (df['财务数据日期'].dt.month == 12) &  # 年末数据
        (df['合并报表未分配利润'] > 0) & 
        (df['母公司报表未分配利润'] > 0) & 
        (df['净利润'] > 0)
    )

    # 处理条件B：计算三年现金分红总额和年均净利润
    # 筛选年报数据
    annual_reports = df[df['财务数据日期'].dt.month == 12].copy()
    annual_reports_sorted = annual_reports.sort_values(by=['公司简称', '财务数据日期'])

    # 计算滚动三年总和
    annual_reports_sorted['三年现金分红总额'] = annual_reports_sorted.groupby('公司简称')['现金分红金额'].transform(
        lambda x: x.rolling(3, min_periods=3).sum()
    )
    annual_reports_sorted['三年净利润总和'] = annual_reports_sorted.groupby('公司简称')['净利润'].transform(
        lambda x: x.rolling(3, min_periods=3).sum()
    )
    annual_reports_sorted['三年年均净利润'] = annual_reports_sorted['三年净利润总和'] / 3

    # 合并回原始df
    df = df.merge(
        annual_reports_sorted[['公司简称', '财务数据日期', '三年现金分红总额', '三年年均净利润']],
        on=['公司简称', '财务数据日期'],
        how='left'
    )

    # 标记条件B
    condition_B_case1 = ~df['是否实施现金分红']
    condition_B_case2 = (
        df['是否实施现金分红'] & 
        (df['三年现金分红总额'] < df['三年年均净利润'] * 0.3)
    )
    # 处理NaN情况
    condition_B_case2 = condition_B_case2.fillna(False)
    valid_condition_B = condition_B_case1 | condition_B_case2

    # 整个条件部分
    valid_condition = valid_condition_A & valid_condition_B
    df['meu_13_4_condition'] = valid_condition

    # 标记约束条件
    # 当条件满足时，检查权益分派方案文本
    df['meu_13_4_constraint'] = df.apply(
        lambda row: llm_content_check(row['权益分派方案文本'], ""为增强投资者回报水平拟采取的措施"") 
        if row['meu_13_4_condition'] else False,
        axis=1
    )

    # 判断违规情况：条件满足但约束不满足
    is_violation = df['meu_13_4_condition'] & (~df['meu_13_4_constraint'])
    df['meu_13_4_compliance'] = ~is_violation

    # 清理临时列
    df.drop(columns=['三年现金分红总额', '三年年均净利润'], inplace=True, errors='ignore')

    return df

但需要注意，在合并回原始df时，可能引入的列需要处理。例如，三年现金分红总额和三年年均净利润可能为NaN，特别是在非年报数据的情况下。

此外，在计算三年滚动总和时，min_periods=3，意味着只有当存在三年的数据时，才会计算总和。否则，结果为NaN。因此，对于前两个年报记录，三年总和为NaN，导致条件B_case2为False，从而valid_condition_B为False，整个条件部分不成立。

这可能符合要求，因为如果公司没有足够的历史数据，无法满足条件B中的“最近三年”要求，因此条件B不成立，整个条件部分不成立。

最后，在约束条件中，只有当条件满足时，才需要检查权益分派方案文本。如果条件不满足，约束条件不适用，因此标记为False，但合规性可能视为True？或者，合规性只有在条件满足且约束不满足时为False，其他情况为True？

根据MEU的合规性逻辑，只有当主体、条件都满足时，才需要满足约束。因此，合规性为True的情况包括：

- 主体或条件不满足，因此约束不适用。
- 主体和条件都满足，且约束满足。

违规情况是主体和条件都满足，但约束不满足。

因此，在代码中，合规性列的计算应为：

df['meu_13_4_compliance'] = ~(valid_subject & valid_condition & ~valid_constraint)

或者，更准确地说：

is_violation = (df['meu_13_4_subject'] & df['meu_13_4_condition'] & ~df['meu_13_4_constraint'])
df['meu_13_4_compliance'] = ~is_violation

但在代码中，subject被标记为True，所以：

is_violation = df['meu_13_4_condition'] & ~df['meu_13_4_constraint']
df['meu_13_4_compliance'] = ~is_violation

因此，合规性为True的情况包括：

- 条件不满足，无论约束如何。
- 条件满足且约束满足。

违规情况是条件满足但约束不满足。

因此，在代码中：

df['meu_13_4_compliance'] = True  # 默认合规
df.loc[is_violation, 'meu_13_4_compliance'] = False

或者，更简洁的方式：

df['meu_13_4_compliance'] = ~is_violation

综上，最终的代码应该包括上述所有步骤。
","CompletionUsage(completion_tokens=9013, prompt_tokens=2033, total_tokens=11046, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=8238, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 

# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 5. 计算整体的违约情况并标记在dataframe上(meu_n_k_compliance). 

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df['meu_4_2_subject'] = False  # 初始化subject列
    df['meu_4_2_condition'] = False  # 初始化condition列
    df['meu_4_2_constrain'] = False  # 初始化constrain列

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True

    # 判断违规情况：满足主体和条件但不满足约束
    is_violation = (
        valid_subject & 
        valid_condition & 
        (~valid_constraint)
    )

    # 标记违规行
    df.loc[is_violation, 'meu_4_1_compliance'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_18_1
法律的最小可执行单元内容: {""subject"": ""上市公司"", ""condition"": ""披露高送转方案且最近两年同期净利润持续增长"", ""constraint"": ""每股送转股比例不得高于上市公司最近两年同期净利润的复合增长率"", ""contextual_info"": NaN}
必要的额外信息: nan

你被分配的MEU coding任务存在refer_to关系, 你需要参考下面这个MEU的必要内容来完成你被安排的任务, 但你不需要直接执行下面的MEU: 
【MEU_31_2】
subject: nan
condition: nan
constrain: nan
contextual_info: 最近两年同期净利润的复合增长率指[第N年净利润/第N-2年净利润的绝对值]1/2-1；若分子采取第N年中期净利润的，分母相应为第N-2年同期的净利润

【MEU_17_1】
subject: nan
condition: nan
constrain: nan
contextual_info: 本指引所称高送转，是指公司每十股送红股与公积金转增股本，合计达到或者超过五股


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '财务数据日期', '公告日期', '公告类型', '审计意见', '总资产', '总负债', '净资产', '资产负债率',
'交易性金融资产', '衍生金融资产', '债权投资', '其他债权投资', '其他权益工具投资', '其他非流动金融资产',
'其他流动资产', '金融资产总额', '总股本', '每股净资产', '合并报表未分配利润', '母公司报表未分配利润', '净利润',
'每股净利润', '母公司报表净利润', '经营活动现金流量净额', '投资活动现金流量净额', '筹资活动现金流量净额',
'现金及现金等价物净增加额', '净资产增长率', '净利润增长率', '资产负债率变化', '金融资产增长率',
'是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划', '现金分红金额', '送股比例', '转增比例', '是否进行权益分派', '权益分派方案文本', '公司简称']

## 其中: 
- 这是一个二维的面板数据, 根据['日期', '公司简称']可以定位到特定公司在特定日期的状态. 数据已经按照公司简称和日期排序. 
- 我们的'日期'并非连续的自然日或者交易日, 而是固定的季报/半年报/年报披露后三个月内的某一个自然日, 例如'2020-05-30', '2020-09-29', ...等, 我们假定公司在这一天发布了权益分派公告(或者决定了不进行权益分派). 每个季报/半年报/年报后只会跟随一个'日期'来决定是否进行权益分派, 如何进行分派. 
- 数据的每一行包含了两个部分的数据, 分别是当时最新的财务数据和当时最新的权益分派情况. 例如, '2020-09-17'这一行可能对应了公告日期为'2020-08-27'的截至'2020-06-30'的半年报财务报告['审计意见', '总资产', ..., '现金及现金等价物净增加额'], 以及在'2020-09-17'当天公告的权益分派信息['是否进行权益分派', ..., '现金分红金额', ...]
- 所有财务数据都是以单季度的形式记录的, 不需要考虑利润表科目在半年报和年报中逐渐累加的问题. 所有的增长率都是单季的. 
- 所有资产/价格的单位都是元而非万元, 千元或百万元; 所有的比例/比率都是小数而非百分数, 除了['送股比例', '转增比例']是""每10股送n股""的格式. 
- ['审计意见']的值有""无保留意见"", ""非标准无保留意见"", ""保留意见"". 
- 这些列为布尔值: ['是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划']

- 如果希望检查权益分派方案中是否披露了特定内容, 可以使用环境中会提供的函数`llm_content_check()`, 但非披露类的合规检查中禁止使用这个函数. 
    描述: 使用LLM检查公告中是否包含特定内容
        参数:
            announcement_text: 公告全文
            traget_content: 需要检查的内容描述
        返回:
            bool: 公告中是否包含特定内容
    调用示例: 
        ```python
        from utils.tool_for_agents import llm_content_check

        constraint_description = ""为增强投资者回报水平拟采取的措施"" # 请完整描述需要检查的内容, 不得简化
        df['meu_4_1_constraint'] = df['权益分派方案文本'].apply(
            lambda text: llm_content_check(text, constraint_description)
        )
        ```

note:
 - 理论上你撰写合规检验代码所需要的数据都可以从一致的数据中得到, 对于没有直接对应的数据你需要自己计算得到, 不要简单地认为无法完成. 
 - 除非材料提供, 否则不要主动进行简化的假设. 如果你认为所给的信息不足以判断案例的合规性, 可以在函数的结尾进行注释说明. 但这种情况应该很少出现. 

","

<CODE>
import pandas as pd
import numpy as np

def check_meu_18_1(df):
    # 创建副本避免修改原数据
    df = df.copy()
    
    # 初始化合规标记列
    df['meu_18_1_subject'] = True  # 所有行均为上市公司主体
    df['meu_18_1_condition'] = False
    df['meu_18_1_constraint'] = False
    df['meu_18_1_compliance'] = True

    # 条件1: 高送转方案判断
    df['送转合计'] = df['送股比例'] + df['转增比例']
    high_send = (df['送转合计'] >= 5) & df['是否进行权益分派']

    # 条件2: 净利润持续增长判断
    # 生成年季信息
    df['year'] = df['财务数据日期'].dt.year
    df['quarter'] = df['财务数据日期'].dt.quarter
    
    # 获取前两年同期数据
    prev_df = df[['公司简称', 'year', 'quarter', '净利润']].copy()
    prev_df['year'] += 1
    prev_df.rename(columns={'净利润': 'prev_net'}, inplace=True)
    df = df.merge(prev_df, on=['公司简称', 'year', 'quarter'], how='left')

    prev_prev_df = df[['公司简称', 'year', 'quarter', '净利润']].copy()
    prev_prev_df['year'] += 2
    prev_prev_df.rename(columns={'净利润': 'prev_prev_net'}, inplace=True)
    df = df.merge(prev_prev_df, on=['公司简称', 'year', 'quarter'], how='left')

    # 计算连续增长条件
    growth_condition = (df['净利润'] > df['prev_net']) & (df['prev_net'] > df['prev_prev_net'])
    df['meu_18_1_condition'] = high_send & growth_condition.fillna(False)

    # 约束条件: 送转比例<=复合增长率
    # 计算复合增长率
    denominator = df['prev_prev_net'].abs().replace(0, np.nan)
    ratio = df['净利润'] / denominator
    compound_growth = np.sqrt(ratio.where(ratio > 0)) - 1
    
    # 计算送转比例
    send_ratio = df['送转合计'] / 10
    
    # 标记约束有效性
    valid_constraint = send_ratio <= compound_growth
    df['meu_18_1_constraint'] = df['meu_18_1_condition'] & valid_constraint.fillna(False)

    # 判断整体合规性
    violation_mask = df['meu_18_1_condition'] & ~df['meu_18_1_constraint']
    df.loc[violation_mask, 'meu_18_1_compliance'] = False

    # 清理中间列
    df.drop(columns=['送转合计', 'year', 'quarter', 'prev_net', 'prev_prev_net'], inplace=True)
    
    return df
</CODE>","好的，我现在需要编写一个函数来检查MEU_18_1的合规性。首先，我得仔细理解这个MEU的内容。MEU_18_1的subject是“上市公司”，condition是“披露高送转方案且最近两年同期净利润持续增长”，constraint是“每股送转股比例不得高于上市公司最近两年同期净利润的复合增长率”。contextual_info是NaN，但可能需要参考其他MEU的信息。

首先，处理subject部分。因为subject是上市公司，所以每一行数据对应的公司都是上市公司，所以可能不需要特别的筛选，直接标记为True？不过可能需要确认是否有其他条件，比如是否存在某些财务指标不达标的情况。但根据MEU的描述，只要主体是上市公司就满足subject，所以这里可能直接标记所有行的subject为True。不过需要确认是否有例外情况，比如退市等情况，但数据中没有相关字段，所以暂时假设所有行的subject都是有效的。

接下来是condition部分。condition有两个条件：披露高送转方案，且最近两年同期净利润持续增长。首先需要确定什么是高送转。根据MEU_17_1的contextual_info，高送转是指每十股送红股与公积金转增股本合计达到或超过五股。所以需要计算送股比例和转增比例的总和是否≥5股每10股。数据中的字段有“送股比例”和“转增比例”，这两个字段应该是以每10股送n股的形式存储的。例如，送股比例是5的话，就是每10股送5股。所以，送股比例加上转增比例的总和是否≥5，如果是的话，就属于高送转。同时，公司必须披露了这样的方案，即“是否进行权益分派”为True，并且送股和转增的比例满足条件。此外，还需要检查是否属于高送转的情况。所以，condition的条件之一是是否属于高送转方案的披露。

另一个条件是最近两年同期净利润持续增长。这里的“同期”可能指的是同一报告期，比如半年报或年报。例如，假设当前财务数据日期是2023年半年报，那么需要比较2023年半年报的净利润与2022年半年报的净利润，以及2022年半年报与2021年半年报的净利润是否都增长。也就是连续两年的同期净利润增长。例如，当前行的财务数据日期是某个季度或半年，需要找到前两年同期的净利润数据，并检查是否连续增长。

但数据中的财务数据可能如何存储呢？比如，每一行的财务数据日期是该行对应的报告期，比如2023-06-30（半年报），而净利润是该期间的数值。所以，要找到同一公司前两年同期的净利润，比如当前行的财务数据日期是2023-06-30，那么需要找到同一公司财务数据日期为2022-06-30和2021-06-30的行的净利润，并检查是否连续增长。如果当前行是年报，比如2023-12-31，则需要比较2022-12-31和2021-12-31的数据。

因此，对于每一行，需要获取当前财务数据日期对应的前两年的同期数据，并检查净利润是否连续增长。例如，当前行的净利润为N，前一年同期为N-1，前两年同期为N-2，需要满足N > N-1且N-1 > N-2吗？或者是否只需要最近两年（比如N和N-1）都增长？MEU中的描述是“最近两年同期净利润持续增长”，所以应该是连续两年的增长，即当前年和前一年都比各自的再前一年增长。例如，假设当前是2023年的半年报，那么2023年半年报的净利润要大于2022年半年报的净利润，而2022年半年报的净利润也要大于2021年半年报的净利润。或者可能只需要最近两年的同期净利润持续增长，即当前年和前一年的同期净利润均增长？比如，当前年比前一年增长，前一年比前前年增长？或者可能只需要最近两年（比如当前年和前一年）的同期净利润均比各自的上一期增长？

这里可能需要更明确的定义。例如，假设当前财务数据日期是2023年Q2，那么需要比较2023Q2 vs 2022Q2，以及2022Q2 vs 2021Q2，是否都增长？或者是否只需要2023Q2和2022Q2的净利润均比各自的前一年同期增长？比如，2023Q2比2022Q2增长，2022Q2比2021Q2增长。这样，连续两年的增长。所以，对于当前行的财务数据日期，需要找到前两年的同期数据，并检查是否连续增长。

因此，在代码中，需要为每一行获取同一公司前两年的同期净利润数据。例如，当前行的财务数据日期是2023-06-30，那么需要找到同一公司财务数据日期为2022-06-30和2021-06-30的行，并检查净利润是否连续增长。如果其中任何一个年份的数据不存在，可能无法计算，此时可能需要标记为不满足条件？

但如何处理这种情况呢？例如，如果公司没有前两年的数据，比如刚上市两年，可能无法获取。这时候可能需要视为不满足条件。或者，是否必须存在两年的数据才能计算？

现在，数据中的每一行包含的是当时的财务数据，所以可能需要按公司分组，然后对于每一行，找到前两年的同期数据。例如，按公司简称分组，并按财务数据日期排序，然后对于每个日期，找到前两年的同一报告期的数据。例如，假设当前行的财务数据日期是2023-06-30，那么同一公司中财务数据日期为2022-06-30和2021-06-30的行是否存在？

这可能需要使用shift或者rolling的方法。例如，按公司分组后，按财务数据日期排序，然后对于每个日期，检查是否存在前两年的同一报告期。例如，如果当前日期是2023-06-30，那么前一年同期是2022-06-30，前两年是2021-06-30。需要确保这两个日期的数据都存在，并且对应的净利润是否连续增长。

但如何实现这一点呢？可能需要为每个公司创建一个时间序列，按财务数据日期排序，然后对于每个日期，找到同一报告期（比如半年报或年报）的前两年的数据。例如，假设财务数据日期是季度性的，比如Q1、Q2、Q3、Q4，那么同一报告期可能指的是同一季度。例如，2023Q1的同期是2022Q1和2021Q1。但数据中的财务数据日期可能包含不同的报告期类型，比如半年报和年报。例如，半年报是6月30日，年报是12月31日。所以，同一报告期可能指的是同一类型的报告期，比如半年报或年报。

因此，对于每一行，需要确定其报告期类型（比如半年报或年报），然后找到同一公司同一报告期类型的前两年的数据。例如，当前行的财务数据日期是2023-06-30（半年报），则前一年同期是2022-06-30，前两年是2021-06-30。如果当前行的财务数据日期是2023-12-31（年报），则前一年同期是2022-12-31，前两年是2021-12-31。

因此，在代码中，需要为每个公司，按财务数据日期排序，并提取同一报告期的前两年数据。例如，对于每个公司，按财务数据日期排序，然后对于每个日期，检查是否是半年报或年报，并找到对应的前两年数据。

这可能比较复杂。例如，如何确定同一报告期？比如，可以按月份和日期来判断。例如，6月30日的报告期是半年报，12月31日是年报。其他季度可能无法构成高送转的条件？或者可能高送转可能在任何报告期后发生？

根据MEU_17_1的描述，高送转可能在任何权益分派中出现，但需要满足每十股送转合计≥5股。所以，不管报告期类型如何，只要送转比例满足条件，就属于高送转。因此，在计算condition时，需要先判断是否属于高送转，然后判断最近两年同期的净利润是否持续增长。

现在，回到净利润持续增长的条件。假设当前行的财务数据日期是某个日期，比如2023-06-30，那么需要找到同一公司同一报告期（半年报）的前两年数据，即2022-06-30和2021-06-30的净利润，并检查是否连续增长。例如，2023年的净利润是否大于2022年的，2022年的净利润是否大于2021年的。如果是，则满足持续增长的条件。

因此，在代码中，需要为每个公司的每个财务数据日期，找到前两年同一报告期的净利润，并检查是否连续增长。这可能需要按公司分组，并为每个日期生成对应的前两年数据。

例如，对于每个公司，按财务数据日期排序，然后对于每个日期，生成一个列，表示前一年同期的净利润和前两年同期的净利润。这可能需要使用groupby和shift操作。例如，按公司分组后，按财务数据日期排序，然后对于每个日期，同一报告期的前一年数据可以通过shift(1)来获取，但前提是shift后的日期的月份和日期相同。例如，半年报的日期是6月30日，年报是12月31日。所以，同一报告期的前一年数据可以通过检查月份和日期是否相同。

这可能比较复杂。例如，假设一个公司的财务数据日期有多个记录，比如2023-06-30、2022-06-30、2021-06-30，那么对于2023-06-30这一行，前一年同期是2022-06-30，前两年是2021-06-30。可以通过groupby后，按日期排序，然后对于每个日期，找到同一月份和日期的前两年数据。

或者，可以将财务数据日期转换为年+报告期类型（如H1、H2、FY），然后按年排序。例如，2023H1对应的净利润是2023年上半年的，2022H1是2022年上半年的，等等。然后，对于每个H1的报告期，前一年是H1的去年，前两年是前年的H1。

这可能更可行。例如，将财务数据日期转换为年份和报告期类型，比如：

- 如果财务数据日期是6月30日，则报告期为H1（半年报）
- 如果是12月31日，则为FY（年报）
- 其他季度可能不涉及高送转，但根据问题描述，权益分派可能在任何报告期后进行，所以可能存在其他报告期的情况？

但根据MEU的condition，只有当公司披露高送转方案时才需要检查，而高送转的条件是每十股送转≥5股。所以，不管报告期类型如何，只要满足高送转的条件，就需要检查净利润增长情况。

因此，对于每个公司的每个财务数据日期，需要找到同一报告期类型的前两年数据。例如，如果当前行的财务数据日期是2023-03-31（Q1），那么报告期类型是Q1，需要找到同一公司Q1的前两年数据，即2022-03-31和2021-03-31的净利润。如果这些数据存在，并且连续增长，则满足条件。

但如何确定同一报告期类型？例如，如何判断两个日期属于同一报告期类型？比如，3月31日可能对应Q1，6月30日对应H1，9月30日对应Q3，12月31日对应FY。或者，可能每个季度的结束日都是一个报告期。因此，可以将财务数据日期转换为季度信息，例如，使用pandas的Period('Q')来获取季度。

例如，将财务数据日期转换为季度，然后同一季度的前两年数据。例如，当前季度是2023Q1，那么前一年同期是2022Q1，前两年是2021Q1。这样，同一季度的数据进行比较。

这可能更合理，因为净利润的同期比较通常是同一季度的比较。例如，2023年Q1的净利润与2022年Q1的比较，以及2022年Q1与2021年Q1的比较。

因此，在代码中，需要为每个公司的每个财务数据日期，找到同一季度的前两年数据，并检查净利润是否连续增长。

现在，如何实现这一点呢？可以使用groupby和shift。例如，按公司分组，并按财务数据日期排序，然后对于每个日期，同一季度的前两年数据可能需要多次shift。例如，对于每个公司，按季度排序，然后每个季度的数据，shift(4)可能得到前一年的同一季度数据（假设每个季度都有数据），但如果有缺失，可能需要处理。

但实际情况可能更复杂，因为公司可能没有每个季度的数据。例如，可能只发布半年报和年报，而没有季度报告。在这种情况下，同一季度的数据可能不存在。例如，如果当前行的财务数据日期是2023-06-30（H1），那么同一季度的前两年数据可能不存在，因为公司可能只发布半年报和年报。或者，可能数据中的财务数据日期仅包含半年报和年报的日期？

根据附加信息中的说明，数据中的财务数据日期是季报/半年报/年报的日期，所以每个季度的数据都可能存在。例如，每个季度结束后，公司会发布季报、半年报或年报。因此，每个季度的数据都可能存在。

因此，可以按季度来处理。例如，将财务数据日期转换为季度，然后按公司分组，按季度排序，然后对于每个季度，找到前两年的同一季度的数据。

例如，对于当前行的季度为2023Q2，需要找到同一公司2022Q2和2021Q2的净利润，并检查是否连续增长。

现在，如何获取这些数据呢？可以使用groupby和shift(4)来获取前一年的同一季度数据，再shift(4)获取前两年的数据。例如，假设每个季度都有数据，那么shift(4)可以得到前一年的同一季度数据。例如，按公司分组后，按季度排序，然后每个季度的数据shift(4)就是前一年的同一季度数据。同理，shift(8)就是前两年的同一季度数据。但这种方法假设每个季度都有数据，否则会出现缺失值。

这可能不现实，因为有些公司可能没有发布某些季度的数据。因此，可能需要另一种方法，即对于每个公司的每个季度，找到对应的前两年同一季度的数据。

例如，对于当前行的财务数据日期，提取年份和季度，然后同一公司中，年份为当前年份-1和当前年份-2，同一季度的数据是否存在。

例如，当前行的财务数据日期是2023-06-30，年份是2023，季度是Q2。那么，前一年同期是2022年的Q2，前两年是2021年的Q2。需要检查同一公司中是否存在这两个季度的数据，并获取对应的净利润。

这可能需要为每个公司创建一个时间索引，然后进行查找。例如，按公司分组后，建立一个以年份和季度为索引的结构，然后对于当前行，查找前两年同一季度的数据。

这可能比较复杂，但可以使用merge或lookup的方法来实现。例如，对于每个公司，生成一个包含所有季度的列表，然后对于每个季度，查找对应的前两年数据。

或者，可以使用pandas的merge_asof函数，按公司分组，按日期排序，然后对于每个日期，找到前两年的日期。但这种方法可能不够精确，因为需要同一季度的日期。

另一种方法是，为每个公司生成一个时间序列，其中每个季度对应一个记录，然后对于每个记录，找到同一季度的前两年记录。

例如，假设当前行的财务数据日期是2023-06-30，对应的季度是Q2 2023。那么，前一年同期是Q2 2022，前两年是Q2 2021。对于同一公司，需要检查是否存在这两个季度的记录，并获取它们的净利润。

因此，在代码中，可能需要为每个公司生成一个DataFrame，其中包含所有季度的数据，然后对于每个季度，获取前两年同一季度的数据。

这可能需要将数据按公司分组，并为每个公司创建一个季度到净利润的映射。例如，使用字典来存储每个公司的季度数据。

例如，对于每个公司，创建一个字典，键为（年份，季度），值为对应的净利润。然后，对于当前行的年份和季度，查找前一年和前两年的净利润。

这可能比较高效。例如，按公司分组后，遍历每个公司的数据，并为每个公司构建一个年份季度到净利润的映射。然后，对于每一行，根据当前年份和季度，计算前一年和前两年的年份，并查找对应的净利润。

现在，如何提取年份和季度呢？可以使用pandas的dt.to_period('Q')来获取季度信息。例如，将财务数据日期转换为季度，如2023Q2。

然后，对于每个公司，建立一个字典，键为季度，值为净利润。例如，对于公司A，2023Q2的净利润是X，2022Q2的净利润是Y，2021Q2的净利润是Z。

然后，对于当前行的季度Q，检查是否存在Q-4（即前一年同一季度）和Q-8（前两年同一季度）的记录？或者，更准确地说，年份减1和减2，季度相同。

例如，当前季度是2023Q2，前一年是2022Q2，前两年是2021Q2。所以，年份减1和减2，季度保持不变。

因此，在代码中，可以提取当前季度的年份和季度部分，然后生成前一年和前两年的年份，保持季度不变。例如：

current_year = row['财务数据日期'].year
current_quarter = (row['财务数据日期'].month - 1) // 3 + 1  # 或者使用dt.quarter
prev_year = current_year - 1
prev_prev_year = current_year - 2

然后，检查公司在该prev_year和prev_prev_year的同一季度是否有数据。

这可能需要为每个公司建立一个DataFrame，其中包含各季度的数据，然后进行查找。

或者，可以使用groupby和shift方法，但需要确保同一季度的数据被正确shift。例如，按公司分组后，按财务数据日期排序，然后对于每个季度，同一季度的前两年数据可能相隔4个季度（每年4个季度）。例如，如果数据是按季度顺序排列的，那么同一季度的前一年数据是shift(4)，前两年是shift(8)。但这种方法假设每个季度都有数据，否则shift可能不正确。

例如，假设公司A的数据如下：

财务数据日期：2021Q1, 2021Q2, 2021Q3, 2021Q4, 2022Q1, 2022Q2, 2022Q3, 2022Q4, 2023Q1, 2023Q2...

那么，对于2023Q2的行，shift(4)就是2022Q2，shift(8)是2021Q2。这样，可以正确获取前两年同一季度的数据。

因此，在代码中，可以按公司分组，按财务数据日期排序，然后计算同一季度的前两年数据。

例如：

df_sorted = df.sort_values(['公司简称', '财务数据日期'])
grouped = df_sorted.groupby('公司简称', group_keys=False)

然后，对于每个公司，计算每个季度的前一年和前两年的净利润：

df['prev_year_net_profit'] = grouped['净利润'].shift(4)
df['prev_prev_year_net_profit'] = grouped['净利润'].shift(8)

然后，检查当前净利润是否大于prev_year_net_profit，且prev_year_net_profit是否大于prev_prev_year_net_profit。如果都满足，则净利润持续增长。

但这种方法假设每个公司都有连续的季度数据，否则shift(4)可能得到错误的数据。例如，如果某个公司缺少某个季度的数据，比如没有2022Q2的数据，那么shift(4)可能得到2021Q2的数据，而不是2022Q2的。这会导致错误。

因此，这种方法可能不可靠。更好的方法是显式地根据年份和季度来查找对应的数据。

因此，可能需要为每个公司建立一个映射表，将年份和季度作为键，存储对应的净利润。然后，对于每一行，根据当前年份和季度，查找前一年和前两年的数据。

例如，可以创建一个新的列，记录年份和季度：

df['year'] = df['财务数据日期'].dt.year
df['quarter'] = df['财务数据日期'].dt.quarter

然后，按公司简称、year、quarter建立索引：

df.set_index(['公司简称', 'year', 'quarter'], inplace=True)

然后，对于每个公司的每一行，查找前一年和前两年的同一季度的数据：

例如，当前行的索引是（公司A，2023，2），那么前一年的索引是（公司A，2022，2），前两年的索引是（公司A，2021，2）。然后，检查这些索引是否存在，并获取对应的净利润。

这可以通过使用df.loc来尝试访问这些索引：

current_company = row['公司简称']
current_year = row['year']
current_quarter = row['quarter']

prev_year = current_year - 1
prev_prev_year = current_year - 2

try:
    prev_net_profit = df.loc[(current_company, prev_year, current_quarter), '净利润']
except KeyError:
    prev_net_profit = None

try:
    prev_prev_net_profit = df.loc[(current_company, prev_prev_year, current_quarter), '净利润']
except KeyError:
    prev_prev_net_profit = None

然后，检查prev_net_profit和prev_prev_net_profit是否存在，并且是否满足连续增长的条件。

但这种方法在代码中如何实现呢？因为需要逐行处理，效率可能较低，但可能更准确。

或者，可以使用merge操作，将当前数据与前一年和前两年的数据合并。例如，为每个公司生成前一年和前两年的数据：

例如，创建两个新的DataFrame，分别代表前一年和前两年的数据：

prev_df = df[['公司简称', 'year', 'quarter', '净利润']].copy()
prev_df['year'] += 1  # 前一年的数据对应的year是当前year-1，所以这里将year加1，以便在merge时匹配
prev_df.rename(columns={'净利润': 'prev_year_net_profit'}, inplace=True)

然后，将当前df与prev_df合并，条件是公司简称、year、quarter相同：

df = df.merge(prev_df, on=['公司简称', 'year', 'quarter'], how='left')

同样的方法处理前两年的数据：

prev_prev_df = df[['公司简称', 'year', 'quarter', '净利润']].copy()
prev_prev_df['year'] += 2
prev_prev_df.rename(columns={'净利润': 'prev_prev_year_net_profit'}, inplace=True)

df = df.merge(prev_prev_df, on=['公司简称', 'year', 'quarter'], how='left')

这样，每个行将包含当前年的净利润，前一年同季度的净利润，前两年同季度的净利润。然后，可以检查是否连续增长：

current_net = df['净利润']
prev_net = df['prev_year_net_profit']
prev_prev_net = df['prev_prev_year_net_profit']

growth_condition = (current_net > prev_net) & (prev_net > prev_prev_net)

但需要注意，如果prev_net或prev_prev_net为NaN，则growth_condition将为False。因此，只有当所有两年的数据都存在且满足增长条件时，才视为满足。

这可能是一个可行的方法。因此，在代码中，可以这样做：

首先，创建year和quarter列：

df['year'] = df['财务数据日期'].dt.year
df['quarter'] = df['财务数据日期'].dt.quarter

然后，生成prev_year和prev_prev_year的净利润：

prev_df = df[['公司简称', 'year', 'quarter', '净利润']].copy()
prev_df['year'] += 1
prev_df = prev_df.rename(columns={'净利润': 'prev_year_net_profit'})

df = df.merge(prev_df, on=['公司简称', 'year', 'quarter'], how='left')

prev_prev_df = df[['公司简称', 'year', 'quarter', '净利润']].copy()
prev_prev_df['year'] += 2
prev_prev_df = prev_prev_df.rename(columns={'净利润': 'prev_prev_year_net_profit'})

df = df.merge(prev_prev_df, on=['公司简称', 'year', 'quarter'], how='left')

然后，检查是否连续增长：

df['growth_condition'] = (df['净利润'] > df['prev_year_net_profit']) & (df['prev_year_net_profit'] > df['prev_prev_year_net_profit'])

但需要注意，如果任何一年的数据缺失，则growth_condition将为False。这可能符合要求，因为如果数据不存在，无法证明连续增长，所以视为不满足条件。

现在，回到condition的判断。condition是“披露高送转方案且最近两年同期净利润持续增长”。因此，condition需要同时满足两个条件：

1. 公司披露了高送转方案；
2. 最近两年同期净利润持续增长。

首先，判断是否披露了高送转方案。根据MEU_17_1的contextual_info，高送转是指每十股送红股与公积金转增股本合计达到或超过五股。因此，送股比例（每10股送n股）加上转增比例（每10股转增m股）的总和是否≥5。数据中的字段是“送股比例”和“转增比例”，例如，如果送股比例是3，转增比例是2，则总和是5，满足条件。

因此，高送转的条件是：

high_send = (df['送股比例'] + df['转增比例']) >= 5

同时，公司必须进行了权益分派，即“是否进行权益分派”为True，并且送股或转增的比例满足条件。或者，是否进行权益分派可能由“是否实施股票股利”或“是否公积金转增股本”决定？例如，如果公司实施了股票股利或公积金转增股本，并且送转比例满足条件，则属于高送转。

根据MEU_17_1的contextual_info，高送转是指送红股与公积金转增股本合计达到或超过五股。因此，需要同时检查是否实施了股票股利（送红股）或公积金转增股本，并且两者的总和≥5股每10股。

因此，高送转的条件是：

has_stock_dividend = df['是否实施股票股利'] | df['是否公积金转增股本']
send_plus_transfer = df['送股比例'] + df['转增比例']
high_send = (send_plus_transfer >= 5) & has_stock_dividend

或者，可能“是否实施股票股利”和“是否公积金转增股本”是分开的布尔值。例如，如果公司实施了股票股利（送股比例>0）或者公积金转增股本（转增比例>0），并且两者的总和≥5，则属于高送转。

或者，可能“是否进行权益分派”为True，并且送股和转增的比例总和≥5。例如：

high_send = (df['是否进行权益分派'] & ((df['送股比例'] + df['转增比例']) >=5)) 

但需要结合MEU_17_1的描述。MEU_17_1的contextual_info指出，高送转是每十股送红股与公积金转增股本合计≥5股。因此，只要送股和转增的总和≥5，并且公司进行了权益分派（即实施了这些送转），则属于高送转。

因此，在数据中，可能“是否进行权益分派”为True时，才可能有送股或转增的比例。因此，高送转的条件是：

high_send = (df['送股比例'] + df['转增比例']) >=5 

并且，公司必须进行了权益分派，即“是否进行权益分派”为True。或者，可能“送股比例”和“转增比例”只有在进行权益分派时才有值，否则为0。因此，需要同时检查是否进行权益分派，并且送转比例满足条件。

例如：

high_send = df['是否进行权益分派'] & ((df['送股比例'] + df['转增比例']) >=5)

这可能更准确，因为如果公司没有进行权益分派，那么送股和转增的比例可能为0，或者不存在。

因此，condition的条件是：

condition_met = high_send & df['growth_condition']

现在，处理constraint部分。constraint是“每股送转股比例不得高于上市公司最近两年同期净利润的复合增长率”。

根据MEU_31_2的contextual_info，复合增长率的计算方式是：

最近两年同期净利润的复合增长率 = (第N年净利润 / 第N-2年净利润的绝对值)^(1/2) -1 

其中，如果分子是中期净利润，分母也是同期的净利润。

例如，当前财务数据日期是2023年6月30日（H1），则第N年是2023H1，第N-2年是2021H1。复合增长率计算为（2023H1净利润 / 2021H1净利润）的平方根减1。

因此，每股送转股比例（每10股送转的股数）转换为每股的比例，即送转比例总和除以10。例如，送股比例+转增比例=5，则每股送转0.5股。因此，每股送转股比例是（送股比例 + 转增比例） / 10。

而约束条件是，这个比例不得高于复合增长率。即：

(send_plus_transfer / 10) <= compound_growth_rate 

因此，需要计算复合增长率，并比较。

复合增长率的计算步骤：

1. 获取当前年的净利润（current_net）和前两年的同期净利润（prev_prev_net）。
2. 计算current_net / abs(prev_prev_net)。注意分母是绝对值。
3. 如果结果≤0，则复合增长率无法计算，视为无效？
4. 否则，计算复合增长率为 (current_net / abs(prev_prev_net)) ** (1/2) -1 

例如，假设current_net是100，prev_prev_net是81，则复合增长率是 (100/81)^0.5 -1 = (1.2345679)^0.5 -1 ≈ 1.1111 -1 = 0.1111，即11.11%。

因此，在代码中，需要计算复合增长率：

current_net = df['净利润']
prev_prev_net = df['prev_prev_year_net_profit']

# 分母取绝对值
denominator = prev_prev_net.abs()

# 计算比率，注意分母不能为0
ratio = current_net / denominator.replace(0, np.nan)  # 避免除以0，设为NaN

# 计算复合增长率
compound_growth = np.sqrt(ratio) - 1

如果current_net或prev_prev_net为NaN，或者分母为0，则compound_growth为NaN，此时视为不满足约束条件？

然后，每股送转比例是（送股比例 + 转增比例） / 10。例如，送股比例是3，转增比例是2，总和是5，每股送转0.5股。

因此，约束条件是：

send_transfer_ratio = (df['送股比例'] + df['转增比例']) / 10 

constraint_met = send_transfer_ratio <= compound_growth 

但需要注意，如果compound_growth是负数，或者无法计算（如NaN），则约束条件可能不满足。例如，如果净利润连续两年增长，但复合增长率为正，则约束条件需要送转比例不超过该增长率。如果复合增长率为负，则送转比例必须≤负值，这显然不可能，因此此时约束条件无法满足，视为违规。

因此，在代码中，需要处理这些情况：

- 如果复合增长率为NaN（例如，前两年的数据缺失，或者分母为0），则无法验证约束条件，视为不满足？
- 如果复合增长率为负，则送转比例必须≤该负值，这不可能，因此约束条件不满足。
- 否则，比较送转比例是否≤复合增长率。

现在，将这些步骤整合到代码中：

首先，标记subject。因为subject是“上市公司”，而数据中的每一行都是上市公司的情况，所以可能所有行的subject都满足。因此，直接标记为True：

df['meu_18_1_subject'] = True 

但需要确认是否有例外情况。例如，如果公司被ST或退市，可能不属于正常上市公司，但数据中没有相关字段，因此假设所有行的subject都满足。

接下来，标记condition：

condition需要同时满足高送转和净利润持续增长。

高送转的条件是：

high_send = df['是否进行权益分派'] & ((df['送股比例'] + df['转增比例']) >=5)

净利润持续增长的条件是：

growth_condition = (df['净利润'] > df['prev_year_net_profit']) & (df['prev_year_net_profit'] > df['prev_prev_year_net_profit'])

因此，condition_met = high_send & growth_condition 

然后，标记constraint：

计算复合增长率：

current_net = df['净利润']
prev_prev_net = df['prev_prev_year_net_profit']

denominator = prev_prev_net.abs().replace(0, np.nan)
ratio = current_net / denominator
ratio = ratio.where(ratio > 0, np.nan)  # 如果ratio是负数，则无法计算平方根，设为NaN

compound_growth = np.sqrt(ratio) - 1

send_transfer_ratio = (df['送股比例'] + df['转增比例']) / 10 

constraint_met = send_transfer_ratio <= compound_growth 

但需要考虑NaN的情况。例如，如果compound_growth是NaN，或者send_transfer_ratio是NaN（例如，没有进行权益分派），则constraint_met为False？

或者，只有当高送转条件满足时，才需要检查约束条件。例如，如果condition不满足，则无需检查constraint。因此，在标记constraint时，可能只需要在condition_met为True的行中进行检查。

因此，在代码中，可能：

valid_constraint = pd.Series(False, index=df.index)

# 仅当condition_met为True时，检查约束条件
mask = condition_met
valid_constraint[mask] = (send_transfer_ratio[mask] <= compound_growth[mask])

但需要处理NaN的情况。例如，如果compound_growth是NaN，则valid_constraint为False。

现在，将这些步骤整合到代码中：

函数的大致步骤如下：

1. 初始化各列。
2. 标记subject为True。
3. 计算高送转条件和净利润增长条件，标记condition。
4. 计算复合增长率和送转比例，标记constraint。
5. 判断是否违规：满足subject和condition，但不满足constraint。

现在，编写代码：

首先，导入必要的库：

import pandas as pd
import numpy as np

然后，定义函数：

def check_meu_18_1(df):
    # 初始化各列
    df['meu_18_1_subject'] = True  # 所有行都是上市公司
    df['meu_18_1_condition'] = False
    df['meu_18_1_constraint'] = False
    df['meu_18_1_compliance'] = True  # 默认合规，除非满足条件但违反约束

    # 计算高送转条件
    # 高送转：每10股送转≥5股，并且公司进行了权益分派
    send_plus_transfer = df['送股比例'] + df['转增比例']
    high_send = (send_plus_transfer >= 5) & df['是否进行权益分派']

    # 计算净利润持续增长条件
    # 需要前两年同期的净利润数据
    # 添加year和quarter列
    df['year'] = df['财务数据日期'].dt.year
    df['quarter'] = df['财务数据日期'].dt.quarter

    # 合并前一年和前两年的净利润数据
    # 前一年
    prev_df = df[['公司简称', 'year', 'quarter', '净利润']].copy()
    prev_df['year'] += 1
    prev_df.rename(columns={'净利润': 'prev_year_net_profit'}, inplace=True)
    df = df.merge(prev_df, on=['公司简称', 'year', 'quarter'], how='left')

    # 前两年
    prev_prev_df = df[['公司简称', 'year', 'quarter', '净利润']].copy()
    prev_prev_df['year'] += 2
    prev_prev_df.rename(columns={'净利润': 'prev_prev_year_net_profit'}, inplace=True)
    df = df.merge(prev_prev_df, on=['公司简称', 'year', 'quarter'], how='left')

    # 检查净利润是否连续增长
    growth_condition = (
        (df['净利润'] > df['prev_year_net_profit']) & 
        (df['prev_year_net_profit'] > df['prev_prev_year_net_profit'])
    )

    # 标记condition
    condition_met = high_send & growth_condition
    df['meu_18_1_condition'] = condition_met

    # 计算复合增长率
    current_net = df['净利润']
    prev_prev_net = df['prev_prev_year_net_profit']

    denominator = prev_prev_net.abs().replace(0, np.nan)
    ratio = current_net / denominator
    ratio = ratio.where(ratio > 0, np.nan)  # 仅处理正数的情况

    compound_growth = np.sqrt(ratio) - 1

    # 计算送转比例
    send_transfer_ratio = (df['送股比例'] + df['转增比例']) / 10

    # 标记constraint
    # 仅当condition_met为True时检查
    valid_constraint = pd.Series(False, index=df.index)
    mask = condition_met
    valid_constraint[mask] = (send_transfer_ratio[mask] <= compound_growth[mask])
    # 处理NaN情况，例如当compound_growth为NaN时，视为不满足约束
    valid_constraint.fillna(False, inplace=True)
    df['meu_18_1_constraint'] = valid_constraint

    # 判断违规情况：满足subject和condition，但不满足constraint
    is_violation = (
        df['meu_18_1_subject'] & 
        df['meu_18_1_condition'] & 
        (~df['meu_18_1_constraint'])
    )
    df.loc[is_violation, 'meu_18_1_compliance'] = False

    # 清理临时列
    df.drop(columns=['year', 'quarter', 'prev_year_net_profit', 'prev_prev_year_net_profit'], inplace=True)

    return df

但需要注意以下几点：

1. 在合并前一年和前两年的数据时，可能因为公司简称、year、quarter的组合不存在而导致prev_year_net_profit或prev_prev_year_net_profit为NaN。此时，growth_condition将为False，因此condition_met也为False，不会进入constraint的检查。

2. 在计算复合增长率时，如果prev_prev_net为0，则分母为0，此时ratio为inf或NaN，处理为NaN。此时，compound_growth为NaN，导致valid_constraint为False。

3. 如果current_net或prev_prev_net为负数，则ratio可能为负数，此时sqrt无法计算，处理为NaN，导致valid_constraint为False。

4. 送转比例的计算是否正确？例如，送股比例和转增比例是每10股的数目，所以每股的比例是总和除以10。例如，送股5股，转增5股，总和是10，每股送转1股，即比例为1。此时，约束条件是该比例≤复合增长率。例如，如果复合增长率是0.1（10%），则1>0.1，不满足约束条件，视为违规。

5. 在函数中，可能需要在合并前确保数据按公司简称和财务数据日期排序，否则shift可能不正确。例如，在合并前，先对数据进行排序：

df = df.sort_values(['公司简称', '财务数据日期'])

否则，merge操作可能无法正确匹配前一年的数据。

因此，在合并前，应该对数据进行排序：

df = df.sort_values(['公司简称', '财务数据日期'])

然后进行merge操作。

但在这个函数中，输入的df可能已经排序，或者需要先排序。根据附加信息中的说明，数据已经按照公司简称和日期排序，所以可能不需要再次排序。但为了确保正确，可能在函数内部进行排序。

因此，在函数开始时，先对df进行排序：

df = df.sort_values(['公司简称', '财务数据日期']).copy()

然后进行后续操作。

此外，在合并prev_df和prev_prev_df时，可能因为重复的列而导致错误。例如，当执行第一个merge时，prev_df的列是['公司简称', 'year', 'quarter', 'prev_year_net_profit']，而原df中可能已经有这些列。但原df中的year和quarter是新增的列，所以merge时不会冲突。

综上，修改后的代码如下：

def check_meu_18_1(df):
    # 复制df以避免修改原数据
    df = df.copy()
    # 初始化各列
    df['meu_18_1_subject'] = True
    df['meu_18_1_condition'] = False
    df['meu_18_1_constraint'] = False
    df['meu_18_1_compliance'] = True

    # 计算高送转条件
    send_plus_transfer = df['送股比例'] + df['转增比例']
    high_send = (send_plus_transfer >= 5) & df['是否进行权益分派']

    # 添加year和quarter列
    df['year'] = df['财务数据日期'].dt.year
    df['quarter'] = df['财务数据日期'].dt.quarter

    # 排序以确保正确的合并
    df.sort_values(['公司简称', '财务数据日期'], inplace=True)

    # 合并前一年的净利润
    prev_df = df[['公司简称', 'year', 'quarter', '净利润']].copy()
    prev_df['year'] += 1
    prev_df.rename(columns={'净利润': 'prev_year_net_profit'}, inplace=True)
    df = df.merge(prev_df, on=['公司简称', 'year', 'quarter'], how='left')

    # 合并前两年的净利润
    prev_prev_df = df[['公司简称', 'year', 'quarter', '净利润']].copy()
    prev_prev_df['year'] += 2
    prev_prev_df.rename(columns={'净利润': 'prev_prev_year_net_profit'}, inplace=True)
    df = df.merge(prev_prev_df, on=['公司简称', 'year', 'quarter'], how='left')

    # 检查净利润持续增长
    growth_condition = (
        (df['净利润'] > df['prev_year_net_profit']) & 
        (df['prev_year_net_profit'] > df['prev_prev_year_net_profit'])
    )
    # 处理NaN情况，假设NaN视为不满足条件
    growth_condition.fillna(False, inplace=True)

    # 标记condition
    condition_met = high_send & growth_condition
    df['meu_18_1_condition'] = condition_met

    # 计算复合增长率
    current_net = df['净利润']
    prev_prev_net = df['prev_prev_year_net_profit']

    denominator = prev_prev_net.abs().replace(0, np.nan)
    ratio = current_net / denominator
    ratio = ratio.where(ratio > 0, np.nan)  # 仅处理正数的情况

    compound_growth = np.sqrt(ratio) - 1

    # 计算送转比例
    send_transfer_ratio = (df['送股比例'] + df['转增比例']) / 10

    # 标记constraint
    valid_constraint = pd.Series(False, index=df.index)
    mask = condition_met
    valid_constraint[mask] = (send_transfer_ratio[mask] <= compound_growth[mask])
    valid_constraint.fillna(False, inplace=True)
    df['meu_18_1_constraint'] = valid_constraint

    # 判断违规情况
    is_violation = (
        df['meu_18_1_subject'] & 
        df['meu_18_1_condition'] & 
        (~df['meu_18_1_constraint'])
    )
    df.loc[is_violation, 'meu_18_1_compliance'] = False

    # 清理临时列
    df.drop(columns=['year', 'quarter', 'prev_year_net_profit', 'prev_prev_year_net_profit'], inplace=True)

    return df

但需要注意，在合并前一年的数据时，可能因为公司没有前一年的数据而导致prev_year_net_profit为NaN，此时growth_condition为False。同样，如果前两年的数据缺失，growth_condition也为False。因此，这些情况会被正确标记为不满足condition。

此外，在计算复合增长率时，如果current_net或prev_prev_net为负数，或者分母为0，则ratio为NaN，导致compound_growth为NaN，此时valid_constraint为False，视为不满足约束条件。

最后，函数返回的dataframe将包含四个新列：meu_18_1_subject、meu_18_1_condition、meu_18_1_constraint、meu_18_1_compliance，分别记录各条件和整体合规情况。
","CompletionUsage(completion_tokens=10773, prompt_tokens=2176, total_tokens=12949, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=10052, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 

# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 5. 计算整体的违约情况并标记在dataframe上(meu_n_k_compliance). 

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df['meu_4_2_subject'] = False  # 初始化subject列
    df['meu_4_2_condition'] = False  # 初始化condition列
    df['meu_4_2_constrain'] = False  # 初始化constrain列

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True

    # 判断违规情况：满足主体和条件但不满足约束
    is_violation = (
        valid_subject & 
        valid_condition & 
        (~valid_constraint)
    )

    # 标记违规行
    df.loc[is_violation, 'meu_4_1_compliance'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_18_2
法律的最小可执行单元内容: {""subject"": ""上市公司"", ""condition"": ""披露高送转方案且在报告期内实施再融资、并购重组等导致净资产有较大变化"", ""constraint"": ""每股送转股比例不得高于上市公司报告期末净资产较之于期初净资产的增长率"", ""contextual_info"": NaN}
必要的额外信息: nan

你被分配的MEU coding任务存在refer_to关系, 你需要参考下面这个MEU的必要内容来完成你被安排的任务, 但你不需要直接执行下面的MEU: 
【MEU_17_1】
subject: nan
condition: nan
constrain: nan
contextual_info: 本指引所称高送转，是指公司每十股送红股与公积金转增股本，合计达到或者超过五股


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '财务数据日期', '公告日期', '公告类型', '审计意见', '总资产', '总负债', '净资产', '资产负债率',
'交易性金融资产', '衍生金融资产', '债权投资', '其他债权投资', '其他权益工具投资', '其他非流动金融资产',
'其他流动资产', '金融资产总额', '总股本', '每股净资产', '合并报表未分配利润', '母公司报表未分配利润', '净利润',
'每股净利润', '母公司报表净利润', '经营活动现金流量净额', '投资活动现金流量净额', '筹资活动现金流量净额',
'现金及现金等价物净增加额', '净资产增长率', '净利润增长率', '资产负债率变化', '金融资产增长率',
'是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划', '现金分红金额', '送股比例', '转增比例', '是否进行权益分派', '权益分派方案文本', '公司简称']

## 其中: 
- 这是一个二维的面板数据, 根据['日期', '公司简称']可以定位到特定公司在特定日期的状态. 数据已经按照公司简称和日期排序. 
- 我们的'日期'并非连续的自然日或者交易日, 而是固定的季报/半年报/年报披露后三个月内的某一个自然日, 例如'2020-05-30', '2020-09-29', ...等, 我们假定公司在这一天发布了权益分派公告(或者决定了不进行权益分派). 每个季报/半年报/年报后只会跟随一个'日期'来决定是否进行权益分派, 如何进行分派. 
- 数据的每一行包含了两个部分的数据, 分别是当时最新的财务数据和当时最新的权益分派情况. 例如, '2020-09-17'这一行可能对应了公告日期为'2020-08-27'的截至'2020-06-30'的半年报财务报告['审计意见', '总资产', ..., '现金及现金等价物净增加额'], 以及在'2020-09-17'当天公告的权益分派信息['是否进行权益分派', ..., '现金分红金额', ...]
- 所有财务数据都是以单季度的形式记录的, 不需要考虑利润表科目在半年报和年报中逐渐累加的问题. 所有的增长率都是单季的. 
- 所有资产/价格的单位都是元而非万元, 千元或百万元; 所有的比例/比率都是小数而非百分数, 除了['送股比例', '转增比例']是""每10股送n股""的格式. 
- ['审计意见']的值有""无保留意见"", ""非标准无保留意见"", ""保留意见"". 
- 这些列为布尔值: ['是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划']

- 如果希望检查权益分派方案中是否披露了特定内容, 可以使用环境中会提供的函数`llm_content_check()`, 但非披露类的合规检查中禁止使用这个函数. 
    描述: 使用LLM检查公告中是否包含特定内容
        参数:
            announcement_text: 公告全文
            traget_content: 需要检查的内容描述
        返回:
            bool: 公告中是否包含特定内容
    调用示例: 
        ```python
        from utils.tool_for_agents import llm_content_check

        constraint_description = ""为增强投资者回报水平拟采取的措施"" # 请完整描述需要检查的内容, 不得简化
        df['meu_4_1_constraint'] = df['权益分派方案文本'].apply(
            lambda text: llm_content_check(text, constraint_description)
        )
        ```

note:
 - 理论上你撰写合规检验代码所需要的数据都可以从一致的数据中得到, 对于没有直接对应的数据你需要自己计算得到, 不要简单地认为无法完成. 
 - 除非材料提供, 否则不要主动进行简化的假设. 如果你认为所给的信息不足以判断案例的合规性, 可以在函数的结尾进行注释说明. 但这种情况应该很少出现. 

","

<CODE>
import pandas as pd

def check_meu_18_2(df):
    '''
    合规性检查函数：MEU_18_2
    subject: 上市公司
    condition: 披露高送转方案且在报告期内实施再融资、并购重组等导致净资产有较大变化
    constraint: 每股送转股比例不得高于上市公司报告期末净资产较之于期初净资产的增长率
    '''
    # 初始化标记列
    df['meu_18_2_subject'] = True  # 所有行均为上市公司
    df['meu_18_2_condition'] = False
    df['meu_18_2_constraint'] = False
    df['meu_18_2_compliance'] = True

    # 条件验证：高送转方案 (每10股送转合计≥5股)
    high_send_condition = (df['送股比例'] + df['转增比例']) >= 5

    # 条件验证：再融资/并购重组事件（通过公告类型判断）
    event_pattern = r'增发|配股|并购|重组|非公开发行|重大资产'
    has_refinance = df['公告类型'].str.contains(event_pattern, case=False, na=False)

    # 合并条件验证结果
    df['meu_18_2_condition'] = high_send_condition & has_refinance

    # 约束验证：计算实际净资产增长率
    df_sorted = df.sort_values(['公司简称', '财务数据日期'])
    df_sorted['prev_净资产'] = df_sorted.groupby('公司简称')['净资产'].shift(1)
    df_sorted['实际净资产增长率'] = (df_sorted['净资产'] - df_sorted['prev_净资产']) / df_sorted['prev_净资产']
    df = df_sorted.reset_index(drop=True)

    # 计算送转股比例约束
    total_send_ratio = (df['送股比例'] + df['转增比例']) / 10
    df['meu_18_2_constraint'] = total_send_ratio <= df['实际净资产增长率']

    # 标记违规情况（满足主体和条件但违反约束）
    violation_mask = df['meu_18_2_subject'] & df['meu_18_2_condition'] & (~df['meu_18_2_constraint'])
    df.loc[violation_mask, 'meu_18_2_compliance'] = False

    # 清理临时列
    df.drop(['prev_净资产', '实际净资产增长率'], axis=1, errors='ignore')
    
    return df
</CODE>","好的，我现在需要为MEU_18_2编写一个合规性检查函数。首先，我得仔细理解这个MEU的内容。MEU_18_2的主题是上市公司，条件是当公司披露高送转方案且在报告期内实施了再融资、并购重组等导致净资产有较大变化的情况，约束是每股送转股比例不得超过报告期末净资产较期初的增长率。

首先，处理subject部分。MEU的subject是“上市公司”，所以所有行都应该满足，因为数据中的每一行都是针对特定公司的。因此，subject列可以直接标记为True，不需要额外条件。

接下来是condition部分。条件有两个部分：披露高送转方案，以及报告期内实施再融资、并购重组导致净资产有较大变化。这里需要明确高送转的定义。根据参考的MEU_17_1，高送转是指每10股送红股和转增合计达到或超过5股。所以需要计算送股比例和转增比例之和是否≥5股每10股。例如，送股比例是每10股送n股，转增是每10股转m股，那么n + m ≥5就满足高送转。

然后，第二部分条件是报告期内实施了再融资或并购重组导致净资产变化较大。这里可能需要查看是否有再融资或并购重组的事件。但给定的数据列中没有直接的字段，比如是否有再融资或并购重组。这时候可能需要通过其他财务数据推断。例如，再融资可能涉及筹资活动现金流量净额的变化，或者查看是否有相关的公告类型。比如，公告类型可能包含增发、配股、并购等信息。假设“公告类型”列中有相关的内容，可以检查是否存在这些类型的公告。或者，如果净资产增长率较大，可能间接反映这些事件的影响。但需要明确如何判断“导致净资产有较大变化”。可能需要结合净资产增长率和是否有相关活动（如再融资、并购）的迹象。例如，如果净资产增长率较高，并且存在再融资或并购的公告，则可能满足条件。但数据中是否有这些信息呢？

根据提供的列，有“公告类型”列，可能包含如“增发”、“并购”等类型。所以可以检查该行对应的公告类型是否属于再融资或并购重组。例如，如果公告类型包含这些关键词，则视为满足条件。或者，如果存在这些事件，可能在财务数据中有所反映，比如筹资活动现金流量净额显著增加，或者总股本变化等。但如果没有直接的字段，可能需要假设这些信息可以通过公告类型来判断。

假设“公告类型”列中有相关信息，那么可以检查该行是否在报告期内有再融资或并购重组的公告。例如，公告类型包含“增发”、“配股”、“并购”等。或者，可能需要结合其他财务指标的变化，比如金融资产总额的变化，或者总资产的突然增加，这可能暗示并购重组。但如果没有明确的字段，这部分可能难以准确判断。可能需要进一步的信息，但根据任务要求，不能做简化假设，必须利用现有数据。

或者，可能“净资产增长率”本身的变化是否较大，但MEU中的条件是“导致净资产有较大变化”，所以需要判断是否在报告期内实施了再融资或并购重组。如果无法直接判断，可能需要用净资产增长率是否显著，比如超过某个阈值，但MEU中没有给出具体数值，所以可能需要认为只要存在再融资或并购重组的事件，无论增长率多少，都算满足条件。但如果没有相关字段，这可能成为问题。

这里可能需要用户澄清，但根据任务要求，必须利用现有数据。可能现有的数据列中没有直接的信息，所以可能需要通过其他方式推断。例如，是否有再融资可能通过筹资活动现金流量净额的大幅增加来判断？或者是否有并购重组可能通过总资产或金融资产的变化？

或者，可能“披露高送转方案且在报告期内实施再融资、并购重组等导致净资产有较大变化”中的“报告期内”指的是财务报告对应的期间。例如，财务数据日期是报告期末的日期，如半年报的6月30日，年报的12月31日。而再融资或并购重组是否发生在该报告期内？

假设在数据中，每一行的财务数据日期对应的是报告期，而该报告期内是否有再融资或并购重组事件，可能需要查看该报告期内的相关活动。例如，筹资活动现金流量净额可能反映再融资的情况。如果筹资活动现金流量净额在该报告期内显著为正，可能表示进行了股权融资或债务融资。或者，总股本的增加可能暗示增发股票。例如，总股本的变化是否在报告期内增加，这可能与再融资有关。

但如何确定这些变化是由于再融资或并购重组导致的？这可能比较复杂。例如，总股本的增加可能由于送转股，也可能由于增发。所以需要区分。例如，如果送转股比例较高，同时总股本增加，但可能送转股导致的股本增加是权益分派的结果，而增发导致的股本增加是再融资的结果。所以可能需要结合送转股比例和总股本的变化来判断。

例如，假设总股本在报告期内增加了，但送转股比例为零，那么股本增加可能来自增发，即再融资。或者，如果送转股比例存在，那么总股本的增加可能部分来自送转股，部分来自其他原因。这可能比较复杂，但如果没有直接的数据字段，可能需要用这种方法来推断。

或者，可能“再融资、并购重组等”的信息可以从公告类型中获取。例如，公告类型可能包含“增发新股”、“发行债券”、“并购”等类型。如果该行的公告类型属于这些类型，则视为满足条件。例如，检查公告类型是否包含相关关键词。

假设“公告类型”列中有这样的信息，那么可以提取出再融资或并购重组的事件。例如：

valid_condition_part2 = df['公告类型'].str.contains('增发|配股|并购重组', case=False, na=False)

但需要确认公告类型列中的内容是否包含这些信息。例如，如果公告类型是“增发新股公告”或“重大资产重组公告”，则可能符合条件。

如果无法直接判断，可能需要假设这些事件的存在，或者可能无法准确判断，但根据任务要求，必须利用现有数据。因此，可能需要结合多个财务指标来推断。

例如，再融资可能导致筹资活动现金流量净额增加，而并购重组可能导致投资活动现金流量净额的大额支出。例如，可以检查筹资活动现金流量净额是否显著为正，或者投资活动现金流量净额是否显著为负，这可能暗示再融资或并购活动。但需要设定一个阈值来判断是否“较大变化”。例如，净资产增长率的绝对值是否超过一定值，比如5%或10%。但MEU中没有给出具体数值，所以可能需要将“较大变化”定义为存在再融资或并购重组的事件，而不管变化的大小。或者，可能这里的“导致净资产有较大变化”是指由于这些事件导致净资产变化，而不管变化的幅度，只要存在这些事件即可。

综上，处理condition部分可能需要：

1. 判断是否披露高送转方案：即送股比例 + 转增比例 ≥5股每10股。
2. 判断在报告期内是否实施了再融资或并购重组，导致净资产有较大变化。

对于第二部分，可能需要：

- 检查是否有再融资或并购重组的事件，这可能需要查看公告类型是否包含相关类型，或者通过财务数据的变化推断。
- 如果没有直接的数据字段，可能需要用其他方式，比如筹资活动或投资活动现金流量净额的变化，或者总资产的变化等。

现在看提供的列，有“公告类型”列，可能包含不同的公告类型。例如，可能有“增发新股”、“并购重组”等。因此，可以检查公告类型是否包含这些关键词，以确定是否存在再融资或并购重组事件。例如：

condition_part2 = df['公告类型'].str.contains('增发|配股|并购|重组', case=False, na=False)

此外，可能还需要考虑报告期内是否有这些事件。例如，财务数据日期对应的报告期是否在该期间内发生了这些事件。例如，如果公告日期在报告期结束后，但在披露权益分派方案时，可能这些事件属于报告期内。

但数据中的每一行对应的是某个日期（如季报/年报后的某个日期），该行的财务数据是报告期末的数据，而公告日期是该行的公告日期。例如，假设财务数据日期是2020-06-30（半年报），公告日期是2020-08-27，那么报告期是截至2020-06-30的期间。再融资或并购重组是否发生在该报告期内？

可能需要假设，在报告期内实施的再融资或并购重组，会在该行的财务数据或公告中有所体现。例如，如果该行的公告类型中包含再融资或并购的公告，或者财务数据中的某些指标（如筹资活动现金流量净额）显示有相关活动。

假设“公告类型”列中记录了该行对应的公告是否属于再融资或并购重组类型。例如，如果公告类型是“增发新股”或“重大资产重组”，则视为满足条件。因此，可以构造条件：

condition_part2 = df['公告类型'].str.contains('增发|配股|并购|重组', case=False, na=False)

但需要确认公告类型中的具体内容。例如，可能有的公告类型是“权益分派方案公告”、“再融资预案公告”等。因此，可能需要更精确的匹配，但如果没有具体数据，可能需要假设这样的匹配是可行的。

接下来，关于净资产的变化。MEU中的条件是“导致净资产有较大变化”，但这里的“较大变化”是否需要量化？例如，净资产增长率是否超过某个阈值？或者只要存在再融资或并购重组，无论变化大小，都视为导致净资产变化？

根据MEU的约束部分，约束是每股送转比例不得超过净资产增长率。这里的净资产增长率是期末较期初的增长率。例如，假设期初净资产为A，期末为B，则增长率为(B - A)/A。

所以，在condition部分，需要判断公司是否在报告期内实施了再融资或并购重组等导致净资产有较大变化的活动。这可能意味着这些活动是导致净资产变化的主要原因，但如果没有具体数据，可能需要认为只要存在这些活动，无论变化大小，都满足条件。

因此，condition的条件可以分为两部分：

1. 披露了高送转方案（送股+转增≥5股每10股）。
2. 在报告期内实施了再融资或并购重组，导致净资产变化。

现在，如何判断第二部分？

假设在报告期内，公司进行了再融资或并购重组，这可能通过公告类型来判断。例如，如果该行的公告类型中包含再融资或并购重组相关的公告，或者财务数据中的某些指标显示这些活动。

例如，再融资可能导致股本增加（如增发）或负债增加（如债券发行），而并购重组可能导致资产的大幅变动。例如，筹资活动现金流量净额可能增加，或者投资活动现金流量净额可能减少（因为支付并购款项）。

但如果没有直接的字段，可能需要结合多个财务指标。例如：

- 再融资：筹资活动现金流量净额较高，或者总股本增加（排除送转股的影响）。
- 并购重组：投资活动现金流量净额较低，或者总资产显著增加。

但如何区分这些变化是否由再融资或并购导致？例如，总股本的增加可能来自送转股或增发。送转股的比例已经在数据中给出，所以可以计算因送转股导致的股本增加，然后看是否有额外的股本增加来自增发。

例如，总股本的变化 = 当前总股本 - 上期总股本。送转股导致的股本增加 = 原股本 * (送股比例 + 转增比例)/10。如果总股本的实际增加超过送转股导致的增加，则可能来自增发，即再融资。

但数据中的总股本是否是报告期末的总股本？例如，假设财务数据中的总股本已经是考虑了送转股后的数值？或者送转股是在公告日后实施的，所以报告期末的总股本尚未包含送转股的影响？

根据数据描述，每一行包含的是当时最新的财务数据和权益分派情况。例如，在公告日（如2020-09-17）的权益分派方案中的送转股可能尚未实施，所以报告期末（如2020-06-30）的总股本可能还未包含送转股的影响。因此，总股本的变化可能来自其他因素，如增发，这属于再融资。

因此，可以计算报告期内的总股本变化是否超过送转股的影响。例如，假设当前报告期的总股本为current_total_shares，上一期的总股本为prev_total_shares。送股比例和转增比例是每10股送n股和转m股，那么送转导致的股本增加为prev_total_shares * (n + m)/10。如果current_total_shares - prev_total_shares > prev_total_shares * (n + m)/10，则说明有额外的股本增加，可能来自增发，即再融资。

但需要获取上一期的总股本数据。在数据中，每一行对应的是某个报告期的财务数据，所以可能需要跨行比较。例如，对于当前行的财务数据日期，找到上一期的财务数据，比较总股本的变化。

但数据是日频的面板数据，每个公司可能有多个报告期的数据。例如，某公司可能有2020-03-31（Q1）、2020-06-30（H1）、2020-09-30（Q3）、2020-12-31（年报）等报告期。要计算当前报告期的总股本变化，需要找到同一公司上一个报告期的总股本。

这可能需要使用groupby和shift操作。例如，按公司分组，按财务数据日期排序，然后计算每个报告期的总股本变化。

但编写这样的代码可能比较复杂，尤其是在函数内部处理。例如，在函数中，可能需要为每个公司计算每个报告期的总股本变化，并判断是否有再融资导致的股本增加。

这可能是一个挑战，但根据任务要求，必须利用现有数据，所以需要尝试实现。

因此，处理condition的第二部分可能需要以下步骤：

1. 按公司分组，按财务数据日期排序。
2. 计算每个报告期的总股本变化（current_total_shares - previous_total_shares）。
3. 计算送转股导致的股本增加：previous_total_shares * (送股比例 + 转增比例)/10。
4. 如果总股本变化超过送转股导致的增加，则视为存在再融资（股本增加来自增发）。
5. 或者，如果有并购重组，可能总资产或净资产大幅变化，但需要其他指标。

这可能比较复杂，但如果没有其他字段，可能需要这样做。

此外，并购重组可能导致净资产的变化，例如，通过收购其他公司，导致净资产增加。这可能反映在净资产的大幅增长上。但如何区分这种增长是由于经营利润还是并购？

例如，如果净资产增长率较高，同时存在并购重组的公告，则可以认为导致净资产变化。

但如果没有并购的公告类型，可能需要依赖财务数据的变化。例如，净资产增长率是否显著高于历史水平，或者是否有其他指标如商誉的大幅增加，但数据中没有商誉字段。

综上，可能condition的第二部分需要满足以下任一条件：

- 存在再融资的公告（如增发、配股等）。
- 存在并购重组的公告。
- 总股本的变化超过送转股的影响，暗示增发。
- 净资产增长率较高，且存在其他指标暗示并购或再融资。

但如果没有直接的公告类型信息，可能需要依赖财务数据的变化。例如，筹资活动现金流量净额显著为正，可能暗示再融资；投资活动现金流量净额显著为负，可能暗示并购。

例如，可以检查筹资活动现金流量净额是否大于某个阈值（如大于总资产的一定比例），或者是否显著高于历史水平。但需要设定一个阈值，而MEU中没有给出，所以可能需要假设只要存在正值的筹资活动现金流量净额，就视为再融资。

这可能不太准确，但根据任务要求，必须利用现有数据。

现在，回到问题，MEU_18_2的condition是“披露高送转方案且在报告期内实施再融资、并购重组等导致净资产有较大变化”。因此，需要同时满足两个条件：高送转和再融资/并购导致净资产变化。

现在，处理高送转部分：

高送转定义为每10股送转合计≥5股。即送股比例（每10股送n股）加上转增比例（每10股转m股）的总和≥5。例如，送3股转2股，总和是5，满足条件。送2股转3股，总和5，也满足。因此，在代码中：

high_send = (df['送股比例'] + df['转增比例']) >= 5

但需要确认送股比例和转增比例的存储方式。根据附加信息，这两个字段是“每10股送n股”的格式，所以数值是整数，例如送3股则送股比例为3，转增4股则转增比例为4。因此，它们的和≥5即满足高送转。

接下来，处理再融资或并购重组导致净资产变化的条件：

假设可以通过公告类型判断，例如：

has_refinance_or_ma = df['公告类型'].str.contains('增发|配股|并购|重组', case=False, na=False)

或者，如果没有公告类型的信息，可能需要通过财务数据推断：

例如，计算净资产增长率是否较大，并且存在筹资活动或投资活动的显著变化。例如：

net_asset_growth = df['净资产增长率']  # 假设这是期末较期初的增长率

但如何确定这个增长率是否由再融资或并购导致？可能需要结合其他指标，如筹资活动现金流量净额或投资活动现金流量净额。

例如，如果筹资活动现金流量净额较大，可能表示再融资；如果投资活动现金流量净额较大负值，可能表示并购支出。因此：

has_refinance = df['筹资活动现金流量净额'] > threshold
has_ma = df['投资活动现金流量净额'] < -threshold

但threshold需要设定，但MEU中没有给出，所以可能需要假设只要存在正值或负值就视为满足，或者根据行业标准设定一个比例。例如，threshold可以是总资产的5%或其他。但数据中的单位是元，总资产可能很大，所以绝对值可能很高。例如，假设threshold为1e8（1亿元），但不同公司规模不同，这可能不适用。

这可能不可行，因此可能需要另一种方法。

或者，假设只要在报告期内，公司有再融资或并购重组的事件，无论金额大小，都视为导致净资产变化。例如，通过公告类型判断。

假设公告类型中有相关信息，那么可以构造条件：

has_event = df['公告类型'].str.contains('增发|配股|并购|重组', case=False, na=False)

这样，condition的第二部分就是has_event。

因此，整个condition的条件是：

valid_condition = high_send & has_event

但需要确认是否如此。

现在，假设可以这样处理，那么condition部分的条件就满足了。

接下来是constraint部分：每股送转股比例不得高于净资产增长率。

这里的每股送转股比例指的是每10股送转的总和，转换为每股的比例。例如，每10股送转5股，相当于每股送转0.5股。而净资产增长率是（期末净资产 - 期初净资产）/期初净资产。

因此，需要计算每股送转比例（每10股送转总和 /10），然后比较是否≤净资产增长率。

例如，送转总和为5股每10股，则每股送转0.5股。如果净资产增长率为0.3（30%），则0.5 >0.3，违反约束。

因此，约束条件为：

(send_ratio + transfer_ratio)/10 <= net_asset_growth

其中，send_ratio是送股比例，transfer_ratio是转增比例，net_asset_growth是净资产增长率。

因此，在代码中：

send_plus_transfer = df['送股比例'] + df['转增比例']
constraint_met = (send_plus_transfer / 10) <= df['净资产增长率']

但需要注意，如果净资产增长率为负，那么送转比例必须≤负数，这显然不可能，因此在这种情况下，任何送转都会违反约束。但根据法律，可能当净资产增长率为负时，不允许进行高送转？但MEU中的约束没有例外情况，所以必须严格按照公式判断。

因此，valid_constraint的条件是constraint_met为True。

现在，将这些步骤转化为代码：

首先，标记subject。因为subject是上市公司，所有行都满足，所以：

df['meu_18_2_subject'] = True

然后，处理condition：

high_send = (df['送股比例'] + df['转增比例']) >=5
has_event = df['公告类型'].str.contains('增发|配股|并购|重组', case=False, na=False)
valid_condition = high_send & has_event

但需要确认公告类型的匹配是否正确。例如，公告类型中的“并购重组”是否会被正则表达式捕获。例如，如果公告类型是“重大资产重组公告”，则会被包含。此外，可能还有其他类型的公告，如“非公开发行股票”（属于增发），“配股公告”等。

接下来，处理constraint：

send_plus_transfer = df['送股比例'] + df['转增比例']
constraint_ratio = send_plus_transfer / 10
valid_constraint = constraint_ratio <= df['净资产增长率']

但需要注意，如果净资产增长率为负，则constraint_ratio必须≤负数，这通常不可能，因此valid_constraint为False。

最后，整体合规性判断：当subject和condition都为True，但constraint为False时，视为违规。

因此，合规性列的计算：

df['meu_18_2_compliance'] = True  # 默认合规
violation = df['meu_18_2_subject'] & df['meu_18_2_condition'] & (~df['meu_18_2_constraint'])
df.loc[violation, 'meu_18_2_compliance'] = False

现在，将这些步骤整合到函数中。

但需要注意，可能存在数据中的某些情况，例如，没有进行高送转，或者没有相关事件，此时condition不满足，因此合规性可能为True（因为只有当condition和subject都满足时，才需要检查约束）。

此外，需要处理可能的NaN值。例如，如果某些行的送股比例或转增比例是NaN，或者净资产增长率是NaN，需要如何处理？例如，如果没有进行权益分派，送股和转增比例可能为0或NaN？根据数据描述，送股比例和转增比例是“每10股送n股”的格式，所以如果没有送转，可能为0。因此，在计算high_send时，如果送股和转增都是0，则和为0，不满足≥5的条件。

此外，关于报告期内的净资产增长率，是否指的是当前财务数据日期对应的报告期的期初到期末的增长率？例如，假设财务数据日期是2020-06-30，那么期初是2020-01-01（假设是半年报），或者上一报告期的期末（如2020-03-31）？这可能需要明确。

根据MEU中的描述，净资产增长率是“报告期末较之于期初”，这里的期初可能是指报告期初。例如，半年报的期初是年初（1月1日），期末是6月30日。或者，如果是季度报告，期初是上一季度的期末。这可能需要明确。

例如，假设财务数据中的“净资产”是报告期末的净资产，而期初的净资产需要从上一期的财务数据中获取。例如，对于当前行的财务数据日期，同一公司的上一报告期的净资产作为期初值。

因此，计算净资产增长率需要比较当前报告期的净资产和上一报告期的净资产。例如：

按公司分组，按财务数据日期排序，计算每个报告期的期初净资产（即上一期的期末净资产），然后计算增长率。

这可能需要使用groupby和shift操作。例如：

df['prev_净资产'] = df.groupby('公司简称')['净资产'].shift(1)
df['净资产增长率'] = (df['净资产'] - df['prev_净资产']) / df['prev_净资产']

但原数据中已经有“净资产增长率”列，所以可能不需要重新计算。根据附加信息，数据中的“净资产增长率”是单季的增长率。例如，每个季度的增长率。但MEU中的约束条件是否要求的是报告期内的增长率？例如，半年报的增长率是半年度的，而MEU中的条件可能要求的是该半年度的增长率。

假设数据中的“净资产增长率”已经是正确的报告期内的增长率，那么可以直接使用该列。否则，可能需要重新计算。

但根据附加信息，所有增长率都是单季的。例如，每个季度的增长率。而MEU中的条件可能涉及的报告期可能是一个季度、半年或一年。例如，如果公司披露的是半年报，那么报告期内的净资产增长率应该是半年度的，但数据中的“净资产增长率”是单季的，这可能不匹配。

这可能是一个问题。例如，如果MEU_18_2中的“报告期”指的是年报，而数据中的“净资产增长率”是单季的，那么需要重新计算整个报告期的增长率。

这可能意味着原数据中的“净资产增长率”列无法直接使用，需要重新计算报告期内的增长率。例如，对于半年报，需要计算从期初到期末的增长率，而不是单季的。

这可能比较复杂，但根据任务要求，必须利用现有数据，所以可能需要假设数据中的“净资产增长率”是正确的报告期内的增长率。或者，可能MEU中的“报告期”指的是单季度，因此数据中的增长率是正确的。

这可能需要进一步的信息，但根据问题描述，无法获得更多信息，因此只能假设数据中的“净资产增长率”是正确的。

综上，现在将代码整合：

函数的大致步骤：

1. 标记subject为True。
2. 计算高送转条件：送股+转增≥5。
3. 判断是否有再融资或并购重组事件：通过公告类型。
4. 计算condition是否满足：高送转且存在事件。
5. 计算约束条件：送转比例/10 ≤ 净资产增长率。
6. 标记各列。
7. 判断合规性：当subject和condition为True，但constraint为False时，违规。

代码：

import pandas as pd

def check_meu_18_2(df):
    '''
    检查MEU_18_2的合规性：
    subject: 上市公司
    condition: 披露高送转方案且在报告期内实施再融资、并购重组等导致净资产有较大变化
    constraint: 每股送转股比例不得高于上市公司报告期末净资产较之于期初净资产的增长率
    contextual_info: NaN
    '''
    # 初始化标记列
    df['meu_18_2_subject'] = True  # 所有行均为上市公司，满足subject
    df['meu_18_2_condition'] = False
    df['meu_18_2_constraint'] = False
    df['meu_18_2_compliance'] = True  # 默认合规，除非条件满足但约束不满足
    
    # 条件1：高送转（每10股送转合计≥5股）
    high_send = (df['送股比例'] + df['转增比例']) >= 5
    
    # 条件2：报告期内实施再融资、并购重组等导致净资产有较大变化（通过公告类型判断）
    # 假设公告类型中包含增发、配股、并购、重组等关键词
    has_event = df['公告类型'].str.contains(r'增发|配股|并购|重组', case=False, na=False)
    
    # 合并条件
    valid_condition = high_send & has_event
    df.loc[valid_condition, 'meu_18_2_condition'] = True
    
    # 约束：每股送转比例 ≤ 净资产增长率
    send_transfer_total = df['送股比例'] + df['转增比例']
    # 每股送转比例 = 总送转股数 / 10
    per_share_ratio = send_transfer_total / 10
    # 获取净资产增长率
    net_asset_growth = df['净资产增长率']
    # 检查约束
    valid_constraint = per_share_ratio <= net_asset_growth
    df.loc[valid_constraint, 'meu_18_2_constraint'] = True
    
    # 判断违规情况：满足subject和condition，但不满足constraint
    violation = df['meu_18_2_subject'] & df['meu_18_2_condition'] & (~df['meu_18_2_constraint'])
    df.loc[violation, 'meu_18_2_compliance'] = False
    
    return df

但需要注意以下几点：

1. 公告类型的匹配是否正确。例如，是否确实可以通过公告类型中的关键词判断再融资或并购事件。如果公告类型中没有这些关键词，或者有其他形式，可能需要调整正则表达式。

2. 净资产增长率的计算是否正确。例如，是否数据中的“净资产增长率”是报告期内的期初到期末的增长率，而不是单季的。如果数据中的该列是单季的，而报告期是半年或一年，则计算会错误。例如，半年报的增长率应该是半年度的，但数据中的该列是单季的，那么需要重新计算。例如，假设财务数据日期是半年报，那么需要计算半年度的增长率，而不是单季的。

这可能是一个潜在的问题。例如，如果数据中的“净资产增长率”是单季的，而报告期是半年报，那么正确的增长率应该是半年度的，即（当前净资产 - 半年前净资产） / 半年前净资产。但数据中的该列可能存储的是单季的增长率，例如Q2的增长率是相对于Q1的。这会导致计算错误。

因此，可能需要重新计算报告期内的净资产增长率。例如，对于每个财务数据日期，找到期初的净资产（即上一个报告期的期末净资产），然后计算增长率。

这需要按公司分组，并按财务数据日期排序，然后计算每个行的期初净资产：

df['prev_净资产'] = df.groupby('公司简称')['净资产'].shift(1)
df['净资产增长率_计算'] = (df['净资产'] - df['prev_净资产']) / df['prev_净资产']

然后，使用这个计算出的增长率代替原有的“净资产增长率”列。

这可能更准确，但需要修改代码。例如：

在函数中添加：

# 计算正确的报告期内的净资产增长率
df['prev_净资产'] = df.groupby('公司简称')['净资产'].shift(1)
df['净资产增长率_计算'] = (df['净资产'] - df['prev_净资产']) / df['prev_净资产']

然后，使用这个计算后的增长率：

net_asset_growth = df['净资产增长率_计算']

但需要注意，当prev_净资产为0或NaN时，会导致计算错误。需要处理这些情况，例如填充0或跳过。

此外，原数据中可能已经有“净资产增长率”列，但可能计算方式不符合MEU的要求。因此，可能需要重新计算。

因此，修改后的代码可能包括这部分：

def check_meu_18_2(df):
    # ... 其他部分同上
    
    # 重新计算报告期内的净资产增长率
    df_sorted = df.sort_values(by=['公司简称', '财务数据日期'])
    df_sorted['prev_净资产'] = df_sorted.groupby('公司简称')['净资产'].shift(1)
    df_sorted['净资产增长率_计算'] = (df_sorted['净资产'] - df_sorted['prev_净资产']) / df_sorted['prev_净资产']
    df = df_sorted
    
    # 在约束部分使用计算后的增长率
    net_asset_growth = df['净资产增长率_计算']
    valid_constraint = per_share_ratio <= net_asset_growth
    
    # ... 后续处理

但需要注意，排序可能会影响原始数据的顺序，因此需要谨慎处理。或者，在函数内部先按公司和财务数据日期排序，计算prev_净资产后再恢复原来的顺序。

这可能比较复杂，但为了正确计算增长率，可能需要这样做。

综上，最终的代码可能需要包括重新计算净资产增长率的步骤，以确保其正确性。
","CompletionUsage(completion_tokens=7418, prompt_tokens=2110, total_tokens=9528, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=6839, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 5. 计算整体的违约情况并标记在dataframe上(meu_n_k_compliance). 

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df['meu_4_2_subject'] = False  # 初始化subject列
    df['meu_4_2_condition'] = False  # 初始化condition列
    df['meu_4_2_constrain'] = False  # 初始化constrain列

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True

    # 判断违规情况：满足主体和条件但不满足约束
    is_violation = (
        valid_subject & 
        valid_condition & 
        (~valid_constraint)
    )

    # 标记违规行
    df.loc[is_violation, 'meu_4_1_compliance'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_13_5
法律的最小可执行单元内容: {""subject"": ""上市公司"", ""condition"": ""母公司资产负债表中未分配利润为负值但合并资产负债表中未分配利润为正值"", ""constraint"": ""应当在权益分派相关公告中披露上市公司控股子公司向母公司实施利润分配的情况"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '财务数据日期', '公告日期', '公告类型', '审计意见', '总资产', '总负债', '净资产', '资产负债率',
'交易性金融资产', '衍生金融资产', '债权投资', '其他债权投资', '其他权益工具投资', '其他非流动金融资产',
'其他流动资产', '金融资产总额', '总股本', '每股净资产', '合并报表未分配利润', '母公司报表未分配利润', '净利润',
'每股净利润', '母公司报表净利润', '经营活动现金流量净额', '投资活动现金流量净额', '筹资活动现金流量净额',
'现金及现金等价物净增加额', '净资产增长率', '净利润增长率', '资产负债率变化', '金融资产增长率',
'是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划', '现金分红金额', '送股比例', '转增比例', '是否进行权益分派', '权益分派方案文本', '公司简称']

## 其中: 
- 这是一个二维的面板数据, 根据['日期', '公司简称']可以定位到特定公司在特定日期的状态. 数据已经按照公司简称和日期排序. 
- 我们的'日期'并非连续的自然日或者交易日, 而是固定的季报/半年报/年报披露后三个月内的某一个自然日, 例如'2020-05-30', '2020-09-29', ...等, 我们假定公司在这一天发布了权益分派公告(或者决定了不进行权益分派). 每个季报/半年报/年报后只会跟随一个'日期'来决定是否进行权益分派, 如何进行分派. 
- 数据的每一行包含了两个部分的数据, 分别是当时最新的财务数据和当时最新的权益分派情况. 例如, '2020-09-17'这一行可能对应了公告日期为'2020-08-27'的截至'2020-06-30'的半年报财务报告['审计意见', '总资产', ..., '现金及现金等价物净增加额'], 以及在'2020-09-17'当天公告的权益分派信息['是否进行权益分派', ..., '现金分红金额', ...]
- 所有财务数据都是以单季度的形式记录的, 不需要考虑利润表科目在半年报和年报中逐渐累加的问题. 所有的增长率都是单季的. 
- 所有资产/价格的单位都是元而非万元, 千元或百万元; 所有的比例/比率都是小数而非百分数, 除了['送股比例', '转增比例']是""每10股送n股""的格式. 
- ['审计意见']的值有""无保留意见"", ""非标准无保留意见"", ""保留意见"". 
- 这些列为布尔值: ['是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划']

- 如果希望检查权益分派方案中是否披露了特定内容, 可以使用环境中会提供的函数`llm_content_check()`, 但非披露类的合规检查中禁止使用这个函数. 
    描述: 使用LLM检查公告中是否包含特定内容
        参数:
            announcement_text: 公告全文
            traget_content: 需要检查的内容描述
        返回:
            bool: 公告中是否包含特定内容
    调用示例: 
        ```python
        from utils.tool_for_agents import llm_content_check

        constraint_description = ""为增强投资者回报水平拟采取的措施"" # 请完整描述需要检查的内容, 不得简化
        df['meu_4_1_constraint'] = df['权益分派方案文本'].apply(
            lambda text: llm_content_check(text, constraint_description)
        )
        ```

note:
 - 理论上你撰写合规检验代码所需要的数据都可以从一致的数据中得到, 对于没有直接对应的数据你需要自己计算得到, 不要简单地认为无法完成. 
 - 除非材料提供, 否则不要主动进行简化的假设. 如果你认为所给的信息不足以判断案例的合规性, 可以在函数的结尾进行注释说明. 但这种情况应该很少出现. 

","

<CODE>
import pandas as pd
from utils.tool_for_agents import llm_content_check

def check_meu_13_5(df):
    '''
    检查MEU_13_5合规性：
    - subject: 上市公司（所有记录默认符合）
    - condition: 母公司未分配利润<0且合并报表未分配利润>0
    - constraint: 权益分派公告需披露子公司向母公司利润分配情况
    '''
    
    # 初始化合规标记列
    df['meu_13_5_subject'] = True  # 所有记录主体均为上市公司
    df['meu_13_5_condition'] = False
    df['meu_13_5_constraint'] = True  # 默认视为满足约束
    
    # 标记条件满足情况
    # 条件判断：母公司未分配利润为负且合并报表为正
    valid_condition = (df['母公司报表未分配利润'] < 0) & (df['合并报表未分配利润'] > 0)
    df['meu_13_5_condition'] = valid_condition
    
    # 约束条件处理
    target_description = ""上市公司控股子公司向母公司实施利润分配的情况""
    # 仅当同时满足以下情况需要检查：1.条件成立 2.实际进行权益分派
    need_check_mask = valid_condition & df['是否进行权益分派']
    
    # 使用LLM检查分派方案文本
    df.loc[need_check_mask, 'meu_13_5_constraint'] = df.loc[need_check_mask, '权益分派方案文本'].apply(
        lambda text: llm_content_check(text, target_description) if pd.notnull(text) else False
    )
    
    # 计算整体合规性（主体和条件成立时约束必须满足）
    df['meu_13_5_compliance'] = True
    violation_mask = df['meu_13_5_subject'] & df['meu_13_5_condition'] & (~df['meu_13_5_constraint'])
    df.loc[violation_mask, 'meu_13_5_compliance'] = False
    
    return df
</CODE>","好的，我现在需要为MEU_13_5编写一个合规性检查的函数。首先，我得仔细理解这个MEU的内容。根据描述，当母公司的资产负债表中的未分配利润为负，但合并资产负债表的未分配利润为正时，上市公司需要在权益分派公告中披露控股子公司向母公司分配利润的情况。

首先，我需要确定subject是“上市公司”，所以这一步应该比较简单，因为每一行数据都是针对上市公司的，所以可能所有行的subject都是有效的？不过可能需要确认是否有其他条件，但根据MEU的描述，subject就是上市公司，所以可能直接标记为True？或者可能要看公司类型？比如数据中的公司是否都是上市公司？假设数据中的公司都是上市公司，所以subject列可能全部为True。但可能需要检查是否有其他情况，比如是否有可能存在非上市公司的情况？根据附加信息中的dataframe列，有“公司简称”列，但没有公司类型的列。所以可能默认所有行都是上市公司，所以subject条件总是满足。这一步可能需要确认，但根据MEU的subject是“上市公司”，所以可能直接标记为True。

接下来是condition的条件：母公司的未分配利润为负，合并的未分配利润为正。对应的数据列应该是“母公司报表未分配利润”和“合并报表未分配利润”。所以需要检查这两个值是否符合条件。即，母公司报表未分配利润 < 0，而合并报表未分配利润 > 0。这时候，condition的条件就满足了。

然后是constraint的约束：应当在权益分派相关公告中披露子公司向母公司分配利润的情况。这里需要检查是否在权益分派公告中披露了这一情况。根据附加信息，可以使用llm_content_check函数来检查公告文本中的特定内容。所以，当condition满足时，需要检查权益分派方案文本是否包含“上市公司控股子公司向母公司实施利润分配的情况”的描述。这时候，如果公司进行了权益分派（即“是否进行权益分派”为True），并且需要披露的情况下，必须包含该内容。否则，如果未披露，则违反约束。

现在，我需要将这些步骤转化为代码。

首先，标记subject。因为subject是上市公司，而数据中的每一行都是针对上市公司的，所以可能直接设置meu_13_5_subject列为True。但可能需要确认是否有例外情况。比如，是否有可能存在非上市公司的数据？根据问题描述中的dataframe列，没有公司类型的信息，所以假设所有行都是上市公司。因此，subject列可以直接标记为True。

然后，condition的条件是：母公司报表未分配利润 < 0，且合并报表未分配利润 > 0。所以需要检查这两个列的值。对应的列名是“母公司报表未分配利润”和“合并报表未分配利润”。所以，valid_condition的条件是这两个条件同时满足。

接下来是constraint的检查。当condition满足时，如果公司进行了权益分派（即“是否进行权益分派”为True），则必须在其公告中披露相关内容。因此，需要检查两种情况：是否进行了权益分派，以及是否在公告中披露了相关信息。如果进行了权益分派，但没有披露，则constraint不满足。如果没有进行权益分派，可能不需要披露？或者是否需要披露？根据MEU的约束，当满足条件时，如果进行权益分派，必须披露。如果公司没有进行权益分派，可能不需要披露。所以，只有当condition满足且进行了权益分派时，才需要检查披露情况。因此，valid_constraint的条件是：如果condition满足且进行了权益分派，则必须通过llm_content_check检查公告文本是否包含相关内容。否则，如果未进行权益分派，则constraint自动满足？或者是否需要考虑其他情况？

这里可能需要更仔细的分析。MEU的约束是“应当在权益分派相关公告中披露”，所以只有当公司进行权益分派时，才需要披露。如果公司没有进行权益分派，那么可能不需要披露。因此，当condition满足时，如果公司进行了权益分派，则必须检查披露情况；如果未进行权益分派，则constraint自动满足？或者是否需要披露？

根据法律条文，可能只有当公司进行权益分派时，才需要披露。因此，当condition满足且公司进行了权益分派时，必须披露。否则，如果未进行权益分派，那么约束可能不适用。因此，在这种情况下，constraint是否满足取决于是否进行了权益分派，并在分派时是否披露。

因此，在代码中，当condition满足时，如果公司进行了权益分派，则必须检查公告文本是否包含披露内容。如果未进行分派，则constraint可能自动满足？或者是否需要处理这种情况？

例如，假设condition满足，但公司没有进行权益分派，那么是否需要披露？可能不需要，因为约束是针对权益分派相关公告的。因此，当condition满足但公司未进行权益分派时，约束条件可能不适用，因此视为满足？或者是否需要视为不适用？

这可能取决于具体的法律条文。根据MEU的约束，当条件满足时，如果公司进行权益分派，则必须披露。如果公司不进行权益分派，那么可能不需要披露。因此，在这种情况下，当condition满足时，如果公司进行了权益分派，则必须检查披露情况；如果未进行，则constraint视为满足？

或者，是否无论是否进行权益分派，只要condition满足，就需要在权益分派相关公告中披露？例如，如果公司决定不进行权益分派，那么是否需要披露？可能不需要，因为约束是针对权益分派公告的。因此，只有当公司进行权益分派时，才需要披露。

因此，在代码中，当condition满足时，如果公司进行了权益分派，则必须检查披露情况。否则，如果未进行分派，则constraint视为满足？

或者，是否当condition满足时，无论是否进行分派，都需要在公告中披露？例如，如果公司决定不进行分派，是否需要披露？这可能要看具体的法律条文。根据MEU的描述，约束是“应当在权益分派相关公告中披露”，所以只有当存在权益分派相关公告时，才需要披露。因此，如果公司没有进行权益分派，那么可能没有相关公告，因此不需要披露。因此，当condition满足但公司未进行权益分派时，约束条件可能不适用，因此视为满足？

或者，是否当condition满足时，无论是否进行分派，只要存在权益分派相关公告，就需要披露？例如，如果公司发布公告说明不进行分派，是否需要披露？这可能比较复杂。根据问题中的MEU，约束是“应当在权益分派相关公告中披露”，所以可能只有当公司进行权益分派时，才需要披露。因此，当condition满足且公司进行了权益分派时，必须披露；否则，如果未进行分派，则无需披露，因此约束条件视为满足？

因此，在代码中，当condition满足时，如果公司进行了权益分派，则必须检查公告是否包含披露内容。如果未进行分派，则constraint视为满足？

或者，是否当condition满足时，无论是否进行分派，只要存在权益分派相关公告（比如决定不进行分派的公告），就需要披露？这可能需要更详细的法律知识。但根据MEU的约束，可能只有当公司进行分派时，才需要披露。因此，在代码中，当condition满足时，如果公司进行了分派，则必须检查披露；否则，视为满足约束？

现在，我需要处理这些情况。假设当condition满足时，如果公司进行了权益分派，则必须披露；否则，无需披露，因此约束条件视为满足。因此，valid_constraint的条件是：

如果condition满足，并且公司进行了权益分派，则检查公告是否包含披露内容。如果未进行分派，则constraint满足。或者，当condition满足时，无论是否进行分派，只要存在权益分派相关公告，就需要披露？

例如，如果公司发布公告说不进行分派，但此时condition满足，是否需要披露？根据MEU的约束，可能不需要，因为约束是针对“权益分派相关公告”中的情况。因此，只有当公司实际进行分派时，才需要披露。因此，当condition满足且公司进行分派时，必须披露；否则，无需。

因此，在代码中，当condition满足时，如果公司进行了权益分派（即“是否进行权益分派”为True），则必须检查公告文本是否包含披露内容。如果公司未进行分派，则constraint视为满足。因此，valid_constraint的计算方式为：

valid_constraint = (condition满足) & (是否进行权益分派) → 需要检查披露内容。否则，如果未进行分派，则视为满足约束？

或者，当condition满足时，无论是否进行分派，只要存在权益分派相关公告，就需要披露。例如，如果公司发布公告说不进行分派，但此时condition满足，是否需要披露？这可能要看具体的法律条文。但根据MEU的约束，可能只有当公司进行分派时，才需要披露。因此，在代码中，当condition满足时，如果公司进行了分派，则必须披露；否则，无需，因此约束条件视为满足。

因此，valid_constraint的计算逻辑是：

当condition满足时：

- 如果公司进行了权益分派（即“是否进行权益分派”为True），则必须检查公告文本是否包含披露内容。此时，valid_constraint为True当且仅当公告中包含所需内容。

- 如果公司未进行权益分派，则无需披露，因此valid_constraint为True。

当condition不满足时，valid_constraint可能无关紧要，但根据框架，可能不需要处理，因为只有当subject和condition都满足时，才会检查constraint。

但根据框架中的步骤，需要标记valid的constraint，这可能意味着当subject和condition都满足时，才需要检查constraint是否满足。因此，在代码中，当subject和condition都满足时，才需要检查constraint是否满足。否则，constraint的标记可能无关紧要，但根据框架中的示例，可能所有行都会被标记为constraint的valid情况，而不仅仅是当subject和condition满足时。

例如，在示例中，valid_constraint的计算可能对所有行进行，但只有当subject和condition都满足时，才会影响最终的合规性判断。

因此，在代码中，valid_constraint的计算可能独立于subject和condition，但最终的合规性判断是当subject和condition都满足时，是否满足constraint。

现在，回到当前问题：

对于constraint的检查，当condition满足时（即母公司未分配利润为负，合并为正），并且公司进行了权益分派，那么必须披露。否则，如果未进行分派，则无需披露，因此constraint视为满足？

或者，是否当condition满足时，无论是否进行分派，都需要在权益分派相关公告中披露？例如，如果公司决定不进行分派，但存在相关公告，是否需要披露？

这可能取决于法律的具体要求。根据MEU的约束，约束是“应当在权益分派相关公告中披露”，所以只有当公司发布权益分派相关公告时，才需要披露。这可能包括决定进行分派或决定不进行分派的情况吗？例如，如果公司发布公告说明不进行分派，但此时condition满足，是否需要披露？

这可能比较复杂，但根据问题中的MEU描述，可能只有当公司进行权益分派时，才需要披露。因此，在代码中，当condition满足且公司进行了权益分派时，必须检查披露情况。否则，视为满足约束。

因此，valid_constraint的条件是：

当condition满足时，如果公司进行了权益分派，则检查公告是否包含披露内容。如果未进行分派，则视为满足约束。

因此，在代码中：

valid_constraint = (condition满足) & (是否进行权益分派) → 需要检查披露内容。否则，当condition满足但未进行分派时，视为满足约束？

或者，当condition满足时，无论是否进行分派，只要存在权益分派相关公告，就需要披露？

例如，如果公司发布公告说不进行分派，但此时condition满足，是否需要披露？这可能要看具体的法律条文。但根据MEU的约束，可能只有当公司进行分派时，才需要披露。因此，在代码中，当condition满足且公司进行分派时，必须披露；否则，无需。

因此，在代码中，当condition满足时：

如果公司进行了权益分派（即“是否进行权益分派”为True），则必须检查公告文本是否包含披露内容。此时，valid_constraint为True当且仅当公告中包含所需内容。

如果公司未进行权益分派（即“是否进行权益分派”为False），则无需披露，因此valid_constraint为True？

或者，当公司未进行分派时，是否不需要披露，因此constraint视为满足？

这可能取决于法律的具体要求。例如，如果公司未进行分派，那么可能没有权益分派相关公告，因此无需披露。或者，如果公司发布公告说明不进行分派，此时是否需要披露？

假设当公司未进行分派时，即使condition满足，也不需要披露，因此constraint视为满足。因此，在代码中，当condition满足时：

valid_constraint = (是否进行权益分派) → 如果为True，则检查披露内容；否则，视为True。

或者，当condition满足时，无论是否进行分派，只要存在权益分派相关公告（例如，决定不进行分派的公告），就需要披露？

这可能比较复杂，但根据问题中的描述，可能只有当公司进行分派时，才需要披露。因此，在代码中，当condition满足且公司进行分派时，必须检查披露内容。否则，视为满足约束。

因此，valid_constraint的计算步骤如下：

1. 对于每一行数据，首先判断是否满足condition（即母公司未分配利润为负，合并为正）。

2. 如果condition满足：

   a. 如果公司进行了权益分派（“是否进行权益分派”为True），则检查权益分派方案文本是否包含披露内容。此时，valid_constraint为True当且仅当公告中包含所需内容。

   b. 如果公司未进行权益分派，则valid_constraint为True（无需披露）。

3. 如果condition不满足，则valid_constraint可能无关紧要，但根据框架中的示例，可能所有行都会被标记，但只有当subject和condition都满足时，才会影响合规性。

现在，将这些步骤转化为代码：

首先，标记subject：

因为subject是“上市公司”，而数据中的每一行都是针对上市公司的，所以可能所有行的subject都满足。因此，df['meu_13_5_subject'] = True。

但需要确认是否有例外情况。例如，是否存在非上市公司的数据？根据问题中的dataframe列，没有公司类型的列，所以假设所有行都是上市公司。因此，subject列直接设为True。

接下来，condition的条件：

valid_condition = (df['母公司报表未分配利润'] < 0) & (df['合并报表未分配利润'] > 0)

然后，constraint的条件：

当condition满足时，如果公司进行了权益分派，则检查公告文本是否包含披露内容。否则，视为满足。

因此，在代码中：

# 初始化valid_constraint为True
df['meu_13_5_constraint'] = True

# 当condition满足且进行权益分派时，检查披露内容
mask = valid_condition & df['是否进行权益分派']
target_description = ""上市公司控股子公司向母公司实施利润分配的情况""
df.loc[mask, 'meu_13_5_constraint'] = df.loc[mask, '权益分派方案文本'].apply(
    lambda text: llm_content_check(text, target_description) if pd.notnull(text) else False
)

这里，假设如果权益分派方案文本为空（NaN），则视为未披露，因此返回False。例如，当公司进行分派但未在文本中提及相关内容时，视为违反约束。

现在，将这些步骤整合到函数中：

函数的大致结构如下：

def check_meu_13_5(df):
    # 初始化各列
    df['meu_13_5_subject'] = True  # 所有行都是上市公司
    df['meu_13_5_condition'] = False
    df['meu_13_5_constraint'] = False  # 初始化为False，后续根据条件调整

    # 计算valid_condition
    valid_condition = (df['母公司报表未分配利润'] < 0) & (df['合并报表未分配利润'] > 0)
    df['meu_13_5_condition'] = valid_condition

    # 计算valid_constraint
    # 先初始化为True（当condition不满足时，或者当condition满足但未进行分派时）
    df['meu_13_5_constraint'] = True

    # 当condition满足且进行分派时，检查披露内容
    mask = valid_condition & df['是否进行权益分派']
    target_description = ""上市公司控股子公司向母公司实施利润分配的情况""
    # 使用llm_content_check检查
    df.loc[mask, 'meu_13_5_constraint'] = df.loc[mask, '权益分派方案文本'].apply(
        lambda text: llm_content_check(text, target_description) if pd.notnull(text) else False
    )

    # 判断合规性：当subject和condition都满足时，必须满足constraint
    # 违规情况：subject和condition为True，但constraint为False
    df['meu_13_5_compliance'] = True  # 默认合规
    violation_mask = df['meu_13_5_subject'] & df['meu_13_5_condition'] & (~df['meu_13_5_constraint'])
    df.loc[violation_mask, 'meu_13_5_compliance'] = False

    return df

但需要注意，在初始化constraint列时，可能需要更精确的处理。例如，当condition不满足时，constraint的valid情况可能无关紧要，但根据示例，可能所有行都会被标记。例如，在示例中，valid_constraint的计算可能对所有行进行，而不仅仅是当subject和condition满足时。因此，在代码中，constraint的valid列可能被标记为True或False，无论其他条件如何。

但根据问题中的框架，需要分别标记subject、condition、constraint的valid情况，然后综合判断合规性。因此，在合规性判断时，只有当subject和condition都满足时，才需要检查constraint是否满足。如果其中任何一个不满足，则合规性可能为True？

或者，合规性判断是：当subject和condition都满足时，必须同时满足constraint，否则视为违规。否则，如果subject或condition不满足，则合规性为True？

例如，在示例中，合规性判断是：当subject和condition都满足，但constraint不满足时，视为违规。其他情况视为合规。

因此，在代码中，合规性列的计算是：

df['meu_13_5_compliance'] = ~(df['meu_13_5_subject'] & df['meu_13_5_condition'] & ~df['meu_13_5_constraint'])

或者，更明确地：

df['meu_13_5_compliance'] = True
violation = df['meu_13_5_subject'] & df['meu_13_5_condition'] & ~df['meu_13_5_constraint']
df.loc[violation, 'meu_13_5_compliance'] = False

这样，只有当subject和condition都满足，且constraint不满足时，才视为违规，标记为False。其他情况下，视为合规。

现在，将这些步骤整合到代码中：

另外，需要注意，当公司未进行权益分派时，是否需要进行披露？根据之前的分析，当condition满足但未进行分派时，视为满足约束，因此constraint为True。因此，在代码中，当condition满足且未进行分派时，constraint为True。

例如，当valid_condition为True，且“是否进行权益分派”为False时，constraint为True。

在代码中，这部分处理是通过初始化constraint列为True，然后仅对condition满足且进行分派的行进行检查。其他情况下，constraint保持为True。

现在，编写完整的代码：

import pandas as pd
from utils.tool_for_agents import llm_content_check

def check_meu_13_5(df):
    '''
    检查MEU_13_5的合规性：
    subject: 上市公司
    condition: 母公司未分配利润为负，合并未分配利润为正
    constraint: 在权益分派公告中披露子公司向母公司分配利润的情况
    '''

    # 初始化各列
    df['meu_13_5_subject'] = True  # 所有行都是上市公司
    df['meu_13_5_condition'] = False
    df['meu_13_5_constraint'] = True  # 默认视为满足，除非条件满足且需要检查

    # 标记condition的条件
    valid_condition = (df['母公司报表未分配利润'] < 0) & (df['合并报表未分配利润'] > 0)
    df['meu_13_5_condition'] = valid_condition

    # 处理constraint的条件
    # 当condition为True且公司进行权益分派时，需要检查披露
    mask = valid_condition & df['是否进行权益分派']
    target_description = ""上市公司控股子公司向母公司实施利润分配的情况""
    # 使用llm_content_check检查公告文本
    df.loc[mask, 'meu_13_5_constraint'] = df.loc[mask, '权益分派方案文本'].apply(
        lambda text: llm_content_check(text, target_description) if pd.notnull(text) else False
    )

    # 判断合规性：当subject和condition都满足时，必须满足constraint
    df['meu_13_5_compliance'] = True
    violation = df['meu_13_5_subject'] & df['meu_13_5_condition'] & (~df['meu_13_5_constraint'])
    df.loc[violation, 'meu_13_5_compliance'] = False

    return df

这样，代码的流程是：

1. 所有行的subject标记为True，因为都是上市公司。

2. condition的条件是母公司未分配利润为负且合并为正，标记在meu_13_5_condition列。

3. constraint的默认值为True。当condition满足且公司进行分派时，检查公告文本是否包含披露内容，否则保持为True。

4. 合规性判断：当subject和condition都为True，但constraint为False时，视为违规。

这样，当公司满足condition且进行分派但未披露时，合规性为False。其他情况下，合规性为True。

需要注意的是，当权益分派方案文本为空时，比如公司未进行分派，此时apply函数中的lambda表达式会返回False吗？例如，当mask为True（即condition满足且进行分派），但权益分派方案文本为NaN，此时pd.notnull(text)为False，所以返回False。因此，如果公司进行分派但未填写权益分派方案文本，则视为未披露，导致constraint为False，从而合规性为False。

这可能正确，因为如果公司进行分派，但未在公告中披露所需内容，则违规。

综上，这段代码应该能够正确标记各条件，并判断合规性。
","CompletionUsage(completion_tokens=5512, prompt_tokens=2016, total_tokens=7528, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=5034, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 5. 计算整体的违约情况并标记在dataframe上(meu_n_k_compliance). 

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df['meu_4_2_subject'] = False  # 初始化subject列
    df['meu_4_2_condition'] = False  # 初始化condition列
    df['meu_4_2_constrain'] = False  # 初始化constrain列

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True

    # 判断违规情况：满足主体和条件但不满足约束
    is_violation = (
        valid_subject & 
        valid_condition & 
        (~valid_constraint)
    )

    # 标记违规行
    df.loc[is_violation, 'meu_4_1_compliance'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_13_6
法律的最小可执行单元内容: {""subject"": ""上市公司"", ""condition"": ""母公司资产负债表中未分配利润为负值但合并资产负债表中未分配利润为正值"", ""constraint"": ""应当在权益分派相关公告中披露公司为增强投资者回报水平拟采取的措施"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '财务数据日期', '公告日期', '公告类型', '审计意见', '总资产', '总负债', '净资产', '资产负债率',
'交易性金融资产', '衍生金融资产', '债权投资', '其他债权投资', '其他权益工具投资', '其他非流动金融资产',
'其他流动资产', '金融资产总额', '总股本', '每股净资产', '合并报表未分配利润', '母公司报表未分配利润', '净利润',
'每股净利润', '母公司报表净利润', '经营活动现金流量净额', '投资活动现金流量净额', '筹资活动现金流量净额',
'现金及现金等价物净增加额', '净资产增长率', '净利润增长率', '资产负债率变化', '金融资产增长率',
'是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划', '现金分红金额', '送股比例', '转增比例', '是否进行权益分派', '权益分派方案文本', '公司简称']

## 其中: 
- 这是一个二维的面板数据, 根据['日期', '公司简称']可以定位到特定公司在特定日期的状态. 数据已经按照公司简称和日期排序. 
- 我们的'日期'并非连续的自然日或者交易日, 而是固定的季报/半年报/年报披露后三个月内的某一个自然日, 例如'2020-05-30', '2020-09-29', ...等, 我们假定公司在这一天发布了权益分派公告(或者决定了不进行权益分派). 每个季报/半年报/年报后只会跟随一个'日期'来决定是否进行权益分派, 如何进行分派. 
- 数据的每一行包含了两个部分的数据, 分别是当时最新的财务数据和当时最新的权益分派情况. 例如, '2020-09-17'这一行可能对应了公告日期为'2020-08-27'的截至'2020-06-30'的半年报财务报告['审计意见', '总资产', ..., '现金及现金等价物净增加额'], 以及在'2020-09-17'当天公告的权益分派信息['是否进行权益分派', ..., '现金分红金额', ...]
- 所有财务数据都是以单季度的形式记录的, 不需要考虑利润表科目在半年报和年报中逐渐累加的问题. 所有的增长率都是单季的. 
- 所有资产/价格的单位都是元而非万元, 千元或百万元; 所有的比例/比率都是小数而非百分数, 除了['送股比例', '转增比例']是""每10股送n股""的格式. 
- ['审计意见']的值有""无保留意见"", ""非标准无保留意见"", ""保留意见"". 
- 这些列为布尔值: ['是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划']

- 如果希望检查权益分派方案中是否披露了特定内容, 可以使用环境中会提供的函数`llm_content_check()`, 但非披露类的合规检查中禁止使用这个函数. 
    描述: 使用LLM检查公告中是否包含特定内容
        参数:
            announcement_text: 公告全文
            traget_content: 需要检查的内容描述
        返回:
            bool: 公告中是否包含特定内容
    调用示例: 
        ```python
        from utils.tool_for_agents import llm_content_check

        constraint_description = ""为增强投资者回报水平拟采取的措施"" # 请完整描述需要检查的内容, 不得简化
        df['meu_4_1_constraint'] = df['权益分派方案文本'].apply(
            lambda text: llm_content_check(text, constraint_description)
        )
        ```

note:
 - 理论上你撰写合规检验代码所需要的数据都可以从一致的数据中得到, 对于没有直接对应的数据你需要自己计算得到, 不要简单地认为无法完成. 
 - 除非材料提供, 否则不要主动进行简化的假设. 如果你认为所给的信息不足以判断案例的合规性, 可以在函数的结尾进行注释说明. 但这种情况应该很少出现. 

","

<CODE>
import pandas as pd
from utils.tool_for_agents import llm_content_check

def check_meu_13_6(df):
    '''
    验证上市公司在母公司未分配利润为负但合并报表为正时，是否披露增强回报措施
    
    ""subject"": ""上市公司"",
    ""condition"": ""母公司资产负债表中未分配利润为负值但合并资产负债表中未分配利润为正值"",
    ""constraint"": ""应当在权益分派相关公告中披露公司为增强投资者回报水平拟采取的措施""
    '''
    
    # 初始化所有标记列
    df['meu_13_6_subject'] = True  # 所有记录主体都是上市公司
    df['meu_13_6_condition'] = False
    df['meu_13_6_constraint'] = False
    df['meu_13_6_compliance'] = True  # 默认合规
    
    # 1. 验证condition条件
    parent_profit_negative = df['母公司报表未分配利润'] < 0
    consolidated_profit_positive = df['合并报表未分配利润'] > 0
    condition_met = parent_profit_negative & consolidated_profit_positive
    df.loc[condition_met, 'meu_13_6_condition'] = True
    
    # 2. 验证constraint约束（仅当condition满足时检查）
    if condition_met.any():
        # 获取需要检查的公告文本
        target_desc = ""为增强投资者回报水平拟采取的措施""
        
        # 对满足条件的行进行内容检查
        constrained_mask = condition_met & df['权益分派方案文本'].notna()
        df.loc[constrained_mask, 'meu_13_6_constraint'] = df.loc[constrained_mask, '权益分派方案文本'].apply(
            lambda text: llm_content_check(text, target_desc)
        )
        
        # 处理文本为空的情况（视为未披露）
        df.loc[condition_met & df['权益分派方案文本'].isna(), 'meu_13_6_constraint'] = False
    
    # 3. 计算整体合规性（主体有效且条件触发时约束必须满足）
    violation_mask = condition_met & (~df['meu_13_6_constraint'])
    df.loc[violation_mask, 'meu_13_6_compliance'] = False
    
    return df
</CODE>","好的，我现在需要为MEU_13_6编写一个合规性检查的函数。首先，我得仔细理解这个MEU的内容。根据提供的描述，MEU_13_6的subject是“上市公司”，condition是“母公司资产负债表中未分配利润为负值但合并资产负债表中未分配利润为正值”，而constraint是“应当在权益分派相关公告中披露公司为增强投资者回报水平拟采取的措施”。

接下来，我需要确定如何用给定的DataFrame中的列来验证这三个部分。首先处理subject部分。因为subject是上市公司本身，所以每一行对应的公司都是上市公司，所以可能不需要特别的筛选，但需要确认是否有标识列。不过根据提供的列，可能没有直接的“是否上市公司”列。但根据问题描述，数据中的公司都是上市公司，所以可能所有行的subject都是符合条件的。因此，可能所有行的subject标记都为True。不过需要确认是否有例外情况，但根据问题描述，可能不需要处理，直接标记为True。

接下来是condition部分。条件是母公司的未分配利润为负，而合并报表的未分配利润为正。在提供的列中，有“母公司报表未分配利润”和“合并报表未分配利润”这两列。因此，condition的条件应该是：母公司报表未分配利润 < 0，并且合并报表未分配利润 > 0。这时候需要检查这两个列的值是否满足这个条件。

然后是constraint部分。约束条件是当上述情况发生时，公司需要在权益分派公告中披露增强投资者回报的措施。这里需要检查的是，如果condition满足，那么对应的公告中是否包含该披露。根据附加信息，可以使用llm_content_check函数来检查“权益分派方案文本”是否包含“为增强投资者回报水平拟采取的措施”的描述。但需要注意，只有当公司进行了权益分派时，才需要检查这个披露。如果公司没有进行权益分派，可能不需要披露？或者不管是否分派，只要满足条件就需要披露？

根据MEU的constraint描述，不管是否进行权益分派，只要满足condition，就需要在权益分派相关公告中披露。但可能的情况是，如果公司没有进行权益分派，可能不需要发布相关公告，但根据数据中的列“是否进行权益分派”来判断。例如，如果公司进行了权益分派，那么必须披露；如果没有进行，可能不需要，但需要看法律的具体要求。但根据MEU的constraint描述，可能只要满足condition，不管是否分派，都需要在相关公告中披露。但这里的“相关公告”可能指的是权益分派的公告，或者即使不进行分派，也需要发布公告说明情况？

这个问题可能需要进一步分析。例如，如果公司满足condition（即母公司未分配利润为负但合并为正），那么无论是否进行分派，都需要在权益分派相关公告中披露措施。但可能当公司决定不进行分派时，是否需要发布公告？根据数据中的列，存在“是否进行权益分派”列，所以可能当公司进行分派时，必须发布公告，此时需要检查披露；如果公司不进行分派，可能不需要发布公告，因此可能不需要检查。或者，可能即使不进行分派，也需要在相关公告中披露？

这里可能存在法律细节的问题，但根据MEU的constraint描述，只要满足condition，就需要在权益分派相关公告中披露。因此，如果公司进行了权益分派（即“是否进行权益分派”为True），那么必须检查其公告是否包含所需内容。如果公司没有进行分派，可能不需要，因为可能没有相关公告。或者，可能即使不进行分派，也需要发布公告说明，此时也需要检查。但根据数据中的列，可能存在两种情况：当公司进行分派时，有权益分派方案文本；当不进行时，可能没有该文本，或者文本为空。因此，可能需要结合“是否进行权益分派”来判断是否需要检查披露。

因此，constraint的验证逻辑应该是：当condition满足时，如果公司进行了权益分派（即“是否进行权益分派”为True），则检查其权益分派方案文本是否包含所需内容；如果公司没有进行分派，可能不需要检查，或者可能也需要在公告中披露，但此时可能没有公告文本。因此，可能需要将约束条件分为两种情况：当condition满足时，必须进行披露，无论是否分派。但如果没有分派，可能没有相关公告，此时是否视为违规？

这个问题可能需要更仔细的分析。根据法律条文，可能当公司满足condition时，无论是否进行分派，只要存在权益分派相关公告（比如决定分派或者不进行分派的公告），都需要在公告中披露措施。例如，如果公司决定不进行分派，但满足condition，那么是否需要在公告中说明措施？这可能取决于具体的法律要求。但根据MEU的constraint描述，可能只要存在权益分派相关公告，就需要披露。因此，在数据中，当condition满足时，无论是否进行分派，只要存在公告（即“是否进行权益分派”为True或False，但存在公告），就需要检查公告文本是否包含所需内容。或者，可能只有当公司进行分派时，才需要披露？

这里可能需要假设，因为问题描述中没有明确说明。根据MEU的constraint描述，“应当在权益分派相关公告中披露”，这可能意味着只有当公司进行权益分派时，才需要披露。例如，如果公司不进行分派，可能不需要发布相关公告，或者即使发布公告，也不属于“权益分派相关公告”。因此，可能只有当“是否进行权益分派”为True时，才需要检查披露。或者，可能即使不进行分派，但存在相关公告（比如说明不进行分派的公告），也需要披露。但根据数据中的列，“是否进行权益分派”可能表示是否实际进行了分派，而不管是否发布公告。例如，公司可能发布公告说明不进行分派，此时“是否进行权益分派”为False，但存在公告文本。因此，在这种情况下，如果condition满足，即使不进行分派，也需要在公告中披露措施。

因此，constraint的验证逻辑应该是：当condition满足时，如果存在权益分派相关公告（即“是否进行权益分派”为True或False，但存在公告），则需要检查公告文本是否包含所需内容。但根据数据中的列，“是否进行权益分派”可能对应的是公司是否进行了分派，而不管是否发布公告。例如，如果公司没有进行分派，可能不会发布公告，或者可能发布公告说明不进行分派。此时，如果condition满足，但公司没有进行分派，并且没有发布公告，那么可能无法检查，但根据数据中的结构，每一行都对应一个公告日期，所以可能每一行都有对应的公告，无论是否进行分派。例如，每一行对应的是公司决定是否进行分派的公告，因此，无论是否进行分派，都会有一个公告。因此，在这种情况下，当condition满足时，无论是否进行分派，都需要在公告中披露措施。

因此，constraint的验证步骤应该是：当condition满足时，检查该行的“权益分派方案文本”是否包含所需的披露内容。这需要使用llm_content_check函数，传入公告文本和目标描述。

现在，总结各部分的处理：

1. subject：上市公司，所有行都满足，因此标记为True。
2. condition：母公司未分配利润 < 0 且合并未分配利润 > 0。
3. constraint：当condition满足时，检查公告文本是否包含披露内容。

然后，整体的合规性判断是：当subject和condition都满足时，必须满足constraint，否则违规。

现在，编写代码：

首先，初始化各列：

df['meu_13_6_subject'] = True，因为所有行都是上市公司。

然后，condition的判断：

valid_condition = (df['母公司报表未分配利润'] < 0) & (df['合并报表未分配利润'] > 0)

对于constraint，当condition满足时，检查公告文本：

需要应用llm_content_check函数。但需要注意，只有当condition满足时，才需要检查。因此，对于这些行，检查“权益分派方案文本”是否包含“为增强投资者回报水平拟采取的措施”。

因此，代码可能如下：

from utils.tool_for_agents import llm_content_check

def check_meu_13_6(df):
    # 初始化各列
    df['meu_13_6_subject'] = True  # 所有行都是上市公司
    df['meu_13_6_condition'] = False
    df['meu_13_6_constraint'] = False

    # 标记condition
    valid_condition = (df['母公司报表未分配利润'] < 0) & (df['合并报表未分配利润'] > 0)
    df.loc[valid_condition, 'meu_13_6_condition'] = True

    # 标记constraint：当condition满足时，检查公告是否包含措施
    # 获取满足condition的行的索引
    condition_met = valid_condition
    # 对于这些行，检查权益分派方案文本
    constraint_description = ""为增强投资者回报水平拟采取的措施""
    # 使用llm_content_check检查文本
    df.loc[condition_met, 'meu_13_6_constraint'] = df.loc[condition_met, '权益分派方案文本'].apply(
        lambda text: llm_content_check(text, constraint_description) if pd.notnull(text) else False
    )

    # 计算合规性：当subject和condition为True时，constraint必须为True，否则违规
    # 但subject始终为True，所以只需检查condition和constraint
    df['meu_13_6_compliance'] = True  # 默认合规
    # 违规情况：condition为True但constraint为False
    violation = (df['meu_13_6_condition']) & (~df['meu_13_6_constraint'])
    df.loc[violation, 'meu_13_6_compliance'] = False

    return df

但需要注意，可能当condition满足时，但公司没有进行权益分派，此时可能没有权益分派方案文本。例如，如果“是否进行权益分派”为False，那么“权益分派方案文本”可能为空或NaN。此时，应用llm_content_check可能会返回False，导致constraint标记为False，从而触发违规。但根据法律要求，是否在这种情况下也需要披露？

例如，如果公司满足condition（母公司未分配利润负，合并为正），但决定不进行权益分派，是否需要在其公告中披露措施？根据MEU的constraint描述，只要存在权益分派相关公告，就需要披露。如果公司不进行分派，但发布了相关公告（比如说明不进行分派的原因），那么该公告是否需要包含措施？

这可能取决于法律的具体要求。如果法律要求只要满足condition，无论是否分派，只要发布相关公告，就需要披露措施。那么在这种情况下，即使“是否进行权益分派”为False，只要存在公告文本，就需要检查。但如果公司没有发布任何公告（例如，没有进行分派也没有发布公告），则可能不需要。但根据数据中的结构，每一行都对应一个公告日期，所以可能每一行都有公告文本，无论是否进行分派。例如，公司可能发布公告说明不进行分派，此时“权益分派方案文本”可能包含相关内容，比如不进行分派的说明，但需要包含措施。

因此，在代码中，当condition满足时，无论是否进行分派，只要存在公告文本，就需要检查是否包含措施。如果公告文本为空（NaN），则视为未披露，导致constraint为False，从而违规。

因此，上述代码中的处理是正确的。在应用llm_content_check时，如果text是NaN，则返回False。例如，使用pd.notnull(text)来检查，否则返回False。

综上，代码应该如上述所示。
","CompletionUsage(completion_tokens=3050, prompt_tokens=2016, total_tokens=5066, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=2525, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 

# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 5. 计算整体的违约情况并标记在dataframe上(meu_n_k_compliance). 

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df['meu_4_2_subject'] = False  # 初始化subject列
    df['meu_4_2_condition'] = False  # 初始化condition列
    df['meu_4_2_constrain'] = False  # 初始化constrain列

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True

    # 判断违规情况：满足主体和条件但不满足约束
    is_violation = (
        valid_subject & 
        valid_condition & 
        (~valid_constraint)
    )

    # 标记违规行
    df.loc[is_violation, 'meu_4_1_compliance'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_18_3
法律的最小可执行单元内容: {""subject"": ""上市公司"", ""condition"": ""披露高送转方案且最近两年净利润持续增长且最近三年每股收益均不低于1元且上市公司认为确有必要且依据年度财务报表进行高送转"", ""constraint"": ""应当充分披露高送转的主要考虑及其合理性且送转股后每股收益不低于0.5元"", ""contextual_info"": NaN}
必要的额外信息: ""每股收益""简化为采用""每股净利润""

你被分配的MEU coding任务存在refer_to关系, 你需要参考下面这个MEU的必要内容来完成你被安排的任务, 但你不需要直接执行下面的MEU: 
【MEU_17_1】
subject: nan
condition: nan
constrain: nan
contextual_info: 本指引所称高送转，是指公司每十股送红股与公积金转增股本，合计达到或者超过五股


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '财务数据日期', '公告日期', '公告类型', '审计意见', '总资产', '总负债', '净资产', '资产负债率',
'交易性金融资产', '衍生金融资产', '债权投资', '其他债权投资', '其他权益工具投资', '其他非流动金融资产',
'其他流动资产', '金融资产总额', '总股本', '每股净资产', '合并报表未分配利润', '母公司报表未分配利润', '净利润',
'每股净利润', '母公司报表净利润', '经营活动现金流量净额', '投资活动现金流量净额', '筹资活动现金流量净额',
'现金及现金等价物净增加额', '净资产增长率', '净利润增长率', '资产负债率变化', '金融资产增长率',
'是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划', '现金分红金额', '送股比例', '转增比例', '是否进行权益分派', '权益分派方案文本', '公司简称']

## 其中: 
- 这是一个二维的面板数据, 根据['日期', '公司简称']可以定位到特定公司在特定日期的状态. 数据已经按照公司简称和日期排序. 
- 我们的'日期'并非连续的自然日或者交易日, 而是固定的季报/半年报/年报披露后三个月内的某一个自然日, 例如'2020-05-30', '2020-09-29', ...等, 我们假定公司在这一天发布了权益分派公告(或者决定了不进行权益分派). 每个季报/半年报/年报后只会跟随一个'日期'来决定是否进行权益分派, 如何进行分派. 
- 数据的每一行包含了两个部分的数据, 分别是当时最新的财务数据和当时最新的权益分派情况. 例如, '2020-09-17'这一行可能对应了公告日期为'2020-08-27'的截至'2020-06-30'的半年报财务报告['审计意见', '总资产', ..., '现金及现金等价物净增加额'], 以及在'2020-09-17'当天公告的权益分派信息['是否进行权益分派', ..., '现金分红金额', ...]
- 所有财务数据都是以单季度的形式记录的, 不需要考虑利润表科目在半年报和年报中逐渐累加的问题. 所有的增长率都是单季的. 
- 所有资产/价格的单位都是元而非万元, 千元或百万元; 所有的比例/比率都是小数而非百分数, 除了['送股比例', '转增比例']是""每10股送n股""的格式. 
- ['审计意见']的值有""无保留意见"", ""非标准无保留意见"", ""保留意见"". 
- 这些列为布尔值: ['是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划']

- 如果希望检查权益分派方案中是否披露了特定内容, 可以使用环境中会提供的函数`llm_content_check()`, 但非披露类的合规检查中禁止使用这个函数. 
    描述: 使用LLM检查公告中是否包含特定内容
        参数:
            announcement_text: 公告全文
            traget_content: 需要检查的内容描述
        返回:
            bool: 公告中是否包含特定内容
    调用示例: 
        ```python
        from utils.tool_for_agents import llm_content_check

        constraint_description = ""为增强投资者回报水平拟采取的措施"" # 请完整描述需要检查的内容, 不得简化
        df['meu_4_1_constraint'] = df['权益分派方案文本'].apply(
            lambda text: llm_content_check(text, constraint_description)
        )
        ```

note:
 - 理论上你撰写合规检验代码所需要的数据都可以从一致的数据中得到, 对于没有直接对应的数据你需要自己计算得到, 不要简单地认为无法完成. 
 - 除非材料提供, 否则不要主动进行简化的假设. 如果你认为所给的信息不足以判断案例的合规性, 可以在函数的结尾进行注释说明. 但这种情况应该很少出现. 

","

<CODE>
import pandas as pd
from utils.tool_for_agents import llm_content_check

def check_meu_18_3(df):
    '''
    验证上市公司高送转方案的合规性：
    ""subject"": ""上市公司"",
    ""condition"": ""披露高送转方案且最近两年净利润持续增长且最近三年每股收益均不低于1元且上市公司认为确有必要且依据年度财务报表进行高送转"",
    ""constraint"": ""应当充分披露高送转的主要考虑及其合理性且送转股后每股收益不低于0.5元""
    '''
    
    # 初始化合规标记列
    df['meu_18_3_subject'] = True  # 所有记录主体均为上市公司
    df['meu_18_3_condition'] = False
    df['meu_18_3_constraint'] = False
    df['meu_18_3_compliance'] = True

    # 转换财务数据日期格式
    df['财务数据日期'] = pd.to_datetime(df['财务数据日期'])
    
    # ======================
    # 条件验证部分
    # ======================
    
    # 1. 年度报表标识（假设12月为年报月份）
    is_annual_report = df['财务数据日期'].dt.month == 12
    
    # 2. 高送转方案验证（每10股送转≥5股）
    sz_ratio = df['送股比例'] + df['转增比例']
    high_sz = sz_ratio >= 5
    
    # 3. 净利润持续增长验证
    df['prev_year_net'] = df.groupby('公司简称')['净利润'].shift(1)
    df['prev_prev_year_net'] = df.groupby('公司简称')['净利润'].shift(2)
    net_growth = (df['净利润'] > df['prev_year_net']) & (df['prev_year_net'] > df['prev_prev_year_net'])
    
    # 4. 每股收益验证（三年EPS≥1）
    df['eps_prev1'] = df.groupby('公司简称')['每股净利润'].shift(1)
    df['eps_prev2'] = df.groupby('公司简称')['每股净利润'].shift(2)
    eps_valid = (df['每股净利润'] >= 1) & (df['eps_prev1'] >= 1) & (df['eps_prev2'] >= 1)
    
    # 5. 必要性验证（LLM内容检查）
    necessity_check = df['权益分派方案文本'].apply(
        lambda x: llm_content_check(x, ""上市公司认为确有必要实施高送转"") if pd.notnull(x) else False
    )
    
    # 6. 权益分派执行标记
    is_distributed = df['是否进行权益分派']
    
    # 综合条件判断
    condition_met = (
        is_annual_report &
        high_sz &
        net_growth &
        eps_valid &
        necessity_check &
        is_distributed
    )
    df.loc[condition_met, 'meu_18_3_condition'] = True
    
    # ======================
    # 约束验证部分
    # ======================
    
    # 1. 合理性披露检查
    disclosure_check = df['权益分派方案文本'].apply(
        lambda x: llm_content_check(x, ""高送转的主要考虑及其合理性"") if pd.notnull(x) else False
    )
    
    # 2. 送转后EPS计算
    expansion_ratio = sz_ratio / 10  # 转换为股本扩张比例
    post_eps = df['每股净利润'] / (1 + expansion_ratio)
    eps_constraint = post_eps >= 0.5
    
    # 综合约束判断
    constraint_met = disclosure_check & eps_constraint
    df.loc[constraint_met, 'meu_18_3_constraint'] = True
    
    # ======================
    # 最终合规性判断
    # ======================
    violation_mask = df['meu_18_3_subject'] & df['meu_18_3_condition'] & ~df['meu_18_3_constraint']
    df.loc[violation_mask, 'meu_18_3_compliance'] = False
    
    # 清理中间列
    df.drop(columns=['prev_year_net', 'prev_prev_year_net', 'eps_prev1', 'eps_prev2'], 
            inplace=True, errors='ignore')
    
    return df
</CODE>","好的，我现在需要处理这个MEU_18_3的合规性检查任务。首先，我得仔细理解这个MEU的具体内容。根据提供的JSON结构，MEU_18_3的subject是“上市公司”，condition是多个条件的组合，包括披露高送转方案、最近两年净利润持续增长、最近三年每股收益不低于1元、上市公司认为确有必要且依据年度财务报表进行高送转。而constraint则是需要充分披露高送转的主要考虑及合理性，并且送转股后每股收益不低于0.5元。contextual_info这里没有额外信息，但提到“每股收益”简化为“每股净利润”。

接下来，我需要根据给定的数据框的列来设计如何验证每个部分。首先，数据框中的每一行代表公司在某个日期的情况，包括财务数据和权益分派信息。我需要检查每个公司在该日期是否符合MEU_18_3的要求。

首先处理subject部分。MEU的subject是“上市公司”，而数据中的每一行都是针对上市公司的记录，所以理论上所有行的subject都是符合条件的。但可能需要确认是否有特殊情况，比如是否某些行可能代表非上市公司？但根据问题描述，数据框中的公司都是上市公司，所以可以直接标记subject为True。

接下来是condition部分。这里条件比较复杂，需要满足多个子条件：

1. 披露高送转方案：根据MEU_17_1的contextual_info，高送转是指每10股送红股与公积金转增股本合计达到或超过5股。所以需要检查送股比例和转增比例之和是否≥5。数据中的列有“送股比例”和“转增比例”，这两个列的值应该是每10股送多少股，比如送股比例是2表示每10股送2股。所以需要将这两个比例相加，判断是否≥5。

2. 最近两年净利润持续增长：需要检查最近两个年度的净利润是否逐年递增。但数据中的财务数据日期可能不是按年度的，需要确认如何确定“最近两年”。例如，当前行的财务数据日期如果是2023年的年报，那么需要检查2022和2023年的净利润是否增长，以及2021、2022、2023三年的每股净利润是否都≥1元。但数据中的财务数据日期可能是一个季度或半年报，这里可能需要假设财务数据日期是年度报告的情况？或者需要根据财务数据日期是否为年度报告来判断？

这里可能存在一个问题：MEU的条件中提到“依据年度财务报表进行高送转”，所以可能只有当财务数据日期对应的是年度报告时，才需要检查这些条件。例如，如果当前行的财务数据日期是某个季度的，可能不适用这个条件。但问题描述中提到，数据中的每一行对应的是季报/半年报/年报后的某个日期，但权益分派可能是在年报之后才会进行高送转。因此，可能需要先确定该行的财务数据是否是年度数据。例如，财务数据日期如果是3月31日，可能对应年报？或者需要根据财务数据的季度来判断是否为年度数据？

或者，可能假设所有的高送转都是基于年度财务报表进行的，因此只有当财务数据日期是年度报告时，才需要检查这些条件。例如，财务数据日期如果是12月31日，则视为年度报告。否则，可能不需要检查。但数据中的财务数据日期可能包含不同季度，所以需要处理这种情况。

另一个问题是，如何获取最近两年的净利润持续增长。例如，当前行的财务数据日期是2023-12-31，那么需要检查2022年和2023年的净利润是否增长。但数据中的每一行可能只包含当前财务数据日期的净利润，而没有历史数据。这时候可能需要通过groupby公司，然后按财务数据日期排序，获取前两年的数据进行比较。

同样，最近三年的每股净利润是否都不低于1元，需要检查当前年度及前两年的每股净利润是否≥1元。例如，当前行的财务数据日期是2023-12-31，那么需要检查2021、2022、2023三年的每股净利润是否≥1元。

第三个子条件是“上市公司认为确有必要”，这可能需要在权益分派方案文本中提到相关理由。根据附加信息中的说明，可以使用llm_content_check函数来检查公告文本是否包含相关内容。例如，检查方案文本中是否有“确有必要”的描述，或者是否有合理的解释。

第四个条件是“依据年度财务报表进行高送转”，这可能意味着高送转方案是基于年度财务报表的数据，所以需要财务数据日期对应的是年度报告。例如，财务数据日期是否为年度结束（如12月31日）。

接下来是constraint部分，需要满足两点：充分披露高送转的主要考虑及其合理性，以及送转股后每股收益不低于0.5元。对于第一点，同样需要使用llm_content_check函数检查权益分派方案文本是否包含相关披露。第二点需要计算送转股后的每股净利润是否≥0.5元。

现在，我需要逐步将这些条件转化为代码。

首先，处理subject部分。因为subject是上市公司，所有行都满足，所以可以直接标记为True。

然后是condition部分：

1. 披露高送转方案：检查送股比例和转增比例之和是否≥5。例如，送股比例是每10股送x股，转增比例是每10股转y股，所以x + y ≥5。数据中的列是“送股比例”和“转增比例”，所以需要将它们相加，判断是否≥5。注意，这两个列可能为0，如果公司没有进行送股或转增的话。

2. 最近两年净利润持续增长：需要当前年和上一年的净利润都增长。例如，当前财务数据日期是2023年，那么2023年的净利润增长率是否为正，且2022年的净利润是否比2021年高。但数据中的净利润是单季度的，可能需要累计年度的数据？或者这里的净利润是指年度净利润？

这里可能存在矛盾，因为MEU的条件中提到“依据年度财务报表进行高送转”，所以应该使用年度净利润数据。但数据中的财务数据日期可能对应不同的报告期，比如年报、半年报、季报。因此，只有当财务数据日期是年度报告时，才需要检查这些条件。例如，财务数据日期是否为年度结束日期（如12月31日）。

所以，首先需要确定当前行的财务数据是否是年度报告。例如，财务数据日期的月份是否为12月（假设年报在12月31日）。或者，可能有一个字段标识财务数据的类型（年报、季报等），但数据中没有这样的列。因此，可能需要根据财务数据日期的月份来判断是否为年度报告。例如，如果财务数据日期的月份是3、6、9、12中的一个，可能对应季报，而年报可能在12月。或者，可能无法直接判断，但MEU的条件明确要求依据年度财务报表，所以只有当财务数据日期对应年度报告时，才需要检查这些条件。因此，在代码中需要筛选出财务数据日期为年度的情况，例如，假设财务数据日期的月份是12月，并且是第四季度报告，即年报。

但数据中的财务数据日期可能包含不同季度，所以需要处理这种情况。例如，如果当前行的财务数据日期是2023-12-31，那么视为年度报告，否则不处理。因此，在代码中需要筛选出财务数据日期对应年度的情况。

接下来，对于这些年度报告的行，需要检查最近两年的净利润是否持续增长。例如，当前行的财务数据日期是2023-12-31，那么需要获取2022-12-31和2023-12-31的净利润，并确保2023年的净利润大于2022年，且2022年的净利润大于2021年。但数据中的每一行可能只包含当前年度的数据，所以需要跨行获取前两年的数据。这可能需要按公司分组，并按财务数据日期排序，然后比较前两年的数据。

同样，最近三年的每股净利润是否都不低于1元，需要当前年、前一年、前两年的每股净利润都≥1元。例如，当前年是2023年，需要2021、2022、2023年的每股净利润≥1元。

对于“上市公司认为确有必要”的条件，可能需要检查权益分派方案文本中是否有相关说明，例如是否提到“确有必要”或合理的理由。这需要使用llm_content_check函数。

关于“依据年度财务报表进行高送转”，需要确保当前行的财务数据日期是年度报告，并且高送转方案是基于该年度财务报表的。这可能已经在之前的条件中处理过，即只有当财务数据日期是年度时，才会进入后续的条件检查。

现在，处理这些条件的步骤可能如下：

1. 筛选出财务数据日期为年度报告的行（例如，财务数据日期的月份为12月）。

2. 对于这些行，检查是否披露了高送转方案（送股比例+转增比例≥5）。

3. 检查最近两年的净利润持续增长：需要当前年和上一年的净利润增长率是否为正？或者比较当前年与前一年的净利润是否增长，前一年与前前年是否增长？

例如，假设当前年是2023年，那么2023年的净利润应大于2022年，2022年的净利润应大于2021年。这需要三年的数据。

但数据中的每一行可能只包含当前年度的数据，所以需要按公司分组，获取前两年的数据。例如，对于每个公司，按财务数据日期排序，找到当前行对应的年度，然后获取前两年的净利润数据。

这可能比较复杂，需要使用groupby和shift操作。

例如，按公司分组，按财务数据日期排序，计算每个年度的净利润，然后比较连续两年的增长。

同样，对于每股净利润，需要最近三年（当前年、前一年、前前年）的数据都≥1元。

接下来，处理这些条件可能需要以下步骤：

对于每个公司的年度报告行：

- 计算最近两年的净利润是否持续增长：即当前年净利润 > 前一年净利润，且前一年净利润 > 前前年净利润。

- 最近三年的每股净利润是否都≥1元：当前年、前一年、前前年的每股净利润≥1。

这需要获取每个公司过去三年的数据，这可能通过shift操作来实现。

例如，按公司分组，按财务数据日期升序排列，然后创建列，如prev_year_net_profit，prev_prev_year_net_profit等。

但需要注意，如果数据中存在多个年度报告，例如同一公司有多个年度的数据，那么shift(1)将得到前一年的数据，shift(2)得到前前年的数据。

因此，在代码中可能需要：

- 筛选出财务数据日期为年度的行（例如，假设月份为12月）。

- 按公司分组，并按财务数据日期排序。

- 对于每个公司，计算每个年度的净利润和每股净利润，并检查是否满足条件。

但数据中的财务数据可能包含多个年份，例如同一公司可能有2021、2022、2023年的年报数据。因此，对于每个公司的每个年度报告行，需要检查该行对应的年度以及前两年的数据。

例如，对于2023年的年报行，需要检查2023、2022、2021年的数据。

这可能需要在数据框中为每个公司创建时间序列，并向前查找两年的数据。

这可能比较复杂，但可以通过groupby和rolling窗口来实现，或者使用shift函数。

例如，对于每个公司，按财务数据日期排序，然后计算净利润的增长率：

df['prev_year_net'] = df.groupby('公司简称')['净利润'].shift(1)
df['prev_year_net_growth'] = df['净利润'] > df['prev_year_net']

同样，再计算前前年的净利润：

df['prev_prev_year_net'] = df.groupby('公司简称')['净利润'].shift(2)
df['prev_prev_year_net_growth'] = df['prev_year_net'] > df['prev_prev_year_net']

然后，最近两年净利润持续增长的条件是当前年的净利润增长（即prev_year_net_growth为True）和上一年的增长（即prev_prev_year_net_growth为True）。

同样，对于每股净利润，需要当前年、前一年、前前年的每股净利润≥1：

df['eps_prev_year'] = df.groupby('公司简称')['每股净利润'].shift(1)
df['eps_prev_prev_year'] = df.groupby('公司简称')['每股净利润'].shift(2)

然后，条件为：

(current_eps >=1) & (eps_prev_year >=1) & (eps_prev_prev_year >=1)

接下来，“上市公司认为确有必要”可能需要检查权益分派方案文本中是否有相关说明，例如是否提到“确有必要”或合理的理由。这需要使用llm_content_check函数，传入方案文本和需要检查的内容描述。

最后，“依据年度财务报表进行高送转”可能已经在前面通过筛选年度报告行来处理，所以可能不需要额外检查，只要前面的条件是基于年度数据即可。

现在，处理constraint部分：

1. 充分披露高送转的主要考虑及其合理性：同样使用llm_content_check函数检查权益分派方案文本是否包含相关披露。

2. 送转股后每股收益不低于0.5元：需要计算送转股后的每股收益。假设送转股会导致总股本增加，从而稀释每股收益。例如，原来的每股净利润是EPS，送转股比例为每10股送x股和转y股，总送转比例为(x + y)/10。总股本变为原来的1 + (x + y)/10倍。因此，送转后的每股净利润为原EPS / (1 + (x + y)/10)。需要确保这个值≥0.5元。

例如，原每股净利润是EPS，送股比例是S（每10股送S股），转增比例是T（每10股转T股），总股本增加比例为（S+T)/10。总股本变为原来的1 + (S+T)/10倍。因此，送转后的每股净利润为 EPS / (1 + (S+T)/10 )

需要计算这个值是否≥0.5。

例如，如果原EPS是1.2元，送转比例是每10股送5股，则总股本变为1.5倍，送转后的EPS是1.2 / 1.5 = 0.8元，满足条件。

现在，将这些条件转化为代码：

首先，处理condition部分：

步骤：

1. 筛选出财务数据日期为年度报告的行。例如，假设财务数据日期的月份是12月：

df['财务数据日期'] = pd.to_datetime(df['财务数据日期'])
is_annual_report = df['财务数据日期'].dt.month == 12

或者，可能无法准确判断，但根据问题描述，MEU的条件是依据年度财务报表，所以必须确保当前行的财务数据是年度数据。因此，可能需要假设财务数据日期对应的是年度报告，例如，每个公司的年报日期可能是在每年的某个固定时间，如3月、4月发布年报，但财务数据日期可能对应的是报告期末，如12月31日。因此，判断财务数据日期是否为年末。

但数据中的财务数据日期可能格式为字符串，需要转换为datetime。

假设数据中的财务数据日期已经是datetime类型，或者需要转换：

df['财务数据日期'] = pd.to_datetime(df['财务数据日期'])

然后，is_annual_report = df['财务数据日期'].dt.month == 12  # 假设年报的财务数据日期是12月31日

这可能是一个合理的假设，但如果有其他情况可能需要调整。

2. 检查是否披露高送转方案：

送股比例 + 转增比例 >=5。注意，这两个列是每10股的数值，所以直接相加：

high_sz = (df['送股比例'] + df['转增比例']) >=5

3. 最近两年净利润持续增长：

需要当前年净利润 > 前一年净利润，且前一年净利润 > 前前年净利润。

这需要按公司分组，计算每个年度的净利润，并比较连续两年的增长。

例如：

df['prev_year_net'] = df.groupby('公司简称')['净利润'].shift(1)
df['prev_prev_year_net'] = df.groupby('公司简称')['净利润'].shift(2)

net_growth_last_year = (df['净利润'] > df['prev_year_net'])
net_growth_prev_year = (df['prev_year_net'] > df['prev_prev_year_net'])
net_growth_two_years = net_growth_last_year & net_growth_prev_year

但需要注意，只有当存在前两年数据时才能计算。否则，条件不满足。

4. 最近三年每股收益均不低于1元：

同样，按公司分组，获取前两年数据：

df['eps_prev_year'] = df.groupby('公司简称')['每股净利润'].shift(1)
df['eps_prev_prev_year'] = df.groupby('公司简称')['每股净利润'].shift(2)

eps_condition = (df['每股净利润'] >=1) & (df['eps_prev_year'] >=1) & (df['eps_prev_prev_year'] >=1)

同样，需要确保前两年数据存在。

5. 上市公司认为确有必要：

需要检查权益分派方案文本是否包含相关说明。例如，使用llm_content_check函数检查是否包含“确有必要”或合理理由的描述：

df['necessary_check'] = df['权益分派方案文本'].apply(lambda x: llm_content_check(x, ""上市公司认为确有必要进行高送转"") if pd.notnull(x) else False)

或者，可能更准确的描述是检查方案中是否说明了确有必要的原因，比如：

constraint_description = ""上市公司认为确有必要进行高送转的主要考虑及其合理性""
df['necessary_check'] = df['权益分派方案文本'].apply(
    lambda text: llm_content_check(text, constraint_description) if pd.notnull(text) else False
)

但根据MEU的condition中的描述，可能更准确的是“上市公司认为确有必要”，所以需要检查方案中是否有相关表述。

6. 依据年度财务报表进行高送转：

这已经在步骤1中处理，即只有年度报告的行才会被考虑。

综上，condition的条件组合为：

condition_met = (
    is_annual_report &
    high_sz &
    net_growth_two_years &
    eps_condition &
    df['necessary_check'] &
    (df['是否进行权益分派'] == True)  # 是否进行权益分派，可能也需要检查？
)

但MEU的condition中的“披露高送转方案”可能对应的是是否进行了高送转，即是否进行股票股利或转增股本。例如，送股比例和转增比例之和≥5，并且是否进行了权益分派（即“是否进行权益分派”列为True）。

所以，可能还需要检查“是否进行权益分派”为True，并且送股或转增的比例满足条件。

现在，处理constraint部分：

1. 充分披露高送转的主要考虑及其合理性：

同样使用llm_content_check函数检查方案文本：

df['disclosure_check'] = df['权益分派方案文本'].apply(
    lambda text: llm_content_check(text, ""高送转的主要考虑及其合理性"") if pd.notnull(text) else False
)

或者更准确的描述：

constraint_description = ""充分披露高送转的主要考虑及其合理性""
df['disclosure_check'] = df['权益分派方案文本'].apply(
    lambda text: llm_content_check(text, constraint_description) if pd.notnull(text) else False
)

2. 送转股后每股收益不低于0.5元：

计算送转后的每股净利润：

送转比例总和 = df['送股比例'] + df['转增比例']
total_sz_ratio = (送转比例总和) / 10  # 每10股送转的股数，转换为比例，例如5股送转，比例是0.5
new_eps = df['每股净利润'] / (1 + total_sz_ratio)
post_eps_condition = new_eps >= 0.5

注意，如果送股和转增的比例为0，则total_sz_ratio为0，此时new_eps等于原每股净利润。但这种情况可能不适用，因为高送转的条件已经要求送转比例≥5，所以此时total_sz_ratio≥0.5。

综上，constraint的条件是：

constraint_met = df['disclosure_check'] & post_eps_condition

现在，将这些条件组合到代码中：

首先，初始化各列：

df['meu_18_3_subject'] = True  # 所有行都是上市公司，所以直接为True

然后，处理condition的各部分：

需要标记meu_18_3_condition为True的条件：

condition_met = (
    is_annual_report &
    high_sz &
    net_growth_two_years &
    eps_condition &
    df['necessary_check'] &
    (df['是否进行权益分派'] == True)
)

但可能还需要确保高送转方案已经被披露，即送股和转增比例之和≥5，并且是否进行权益分派为True。

然后，处理constraint的条件：

constraint_met = df['disclosure_check'] & post_eps_condition

最后，整体合规性检查是：当subject和condition都为True时，是否constraint也为True。如果subject和condition为True但constraint不满足，则违规。

所以，合规性列meu_18_3_compliance为True当且仅当：

(df['meu_18_3_subject'] & df['meu_18_3_condition'] & df['meu_18_3_constraint']) 

否则为False。或者，当subject和condition为True时，如果constraint不满足，则合规性为False。

现在，将这些步骤转化为代码：

需要注意的是，在计算条件时，需要处理NaN的情况。例如，如果前两年的数据不存在，则条件不满足。

此外，对于每股净利润的计算，如果送股和转增比例都为0，那么总股本不变，此时送转后的每股净利润等于原值。但这种情况可能不适用，因为高送转的条件已经要求送转比例≥5。

现在，编写代码的大致步骤：

1. 初始化各列：

df['meu_18_3_subject'] = True

df['meu_18_3_condition'] = False
df['meu_18_3_constraint'] = False

2. 处理condition的条件：

a. 筛选年度报告：

is_annual_report = df['财务数据日期'].dt.month == 12

b. 高送转方案：

high_sz = (df['送股比例'] + df['转增比例']) >=5

c. 最近两年净利润持续增长：

按公司分组，计算前两年净利润：

df['prev_year_net'] = df.groupby('公司简称')['净利润'].shift(1)
df['prev_prev_year_net'] = df.groupby('公司简称')['净利润'].shift(2)

net_growth_last_year = df['净利润'] > df['prev_year_net']
net_growth_prev_year = df['prev_year_net'] > df['prev_prev_year_net']
net_growth_two_years = net_growth_last_year & net_growth_prev_year

d. 最近三年每股净利润≥1：

df['eps_prev_year'] = df.groupby('公司简称')['每股净利润'].shift(1)
df['eps_prev_prev_year'] = df.groupby('公司简称')['每股净利润'].shift(2)

eps_condition = (df['每股净利润'] >=1) & (df['eps_prev_year'] >=1) & (df['eps_prev_prev_year'] >=1)

e. 上市公司认为确有必要：

df['necessary_check'] = df['权益分派方案文本'].apply(
    lambda text: llm_content_check(text, ""上市公司认为确有必要进行高送转"") if pd.notnull(text) else False
)

或者更准确的描述：

df['necessary_check'] = df['权益分派方案文本'].apply(
    lambda text: llm_content_check(text, ""上市公司认为确有必要且依据年度财务报表进行高送转"") if pd.notnull(text) else False
)

f. 是否进行权益分派：

is_equity_distribution = df['是否进行权益分派'] == True

综上，condition的条件：

condition_met = (
    is_annual_report &
    high_sz &
    net_growth_two_years &
    eps_condition &
    df['necessary_check'] &
    is_equity_distribution
)

然后，将condition_met的值赋给df['meu_18_3_condition']

3. 处理constraint的条件：

a. 充分披露：

df['disclosure_check'] = df['权益分派方案文本'].apply(
    lambda text: llm_content_check(text, ""充分披露高送转的主要考虑及其合理性"") if pd.notnull(text) else False
)

b. 送转后每股收益≥0.5：

total_sz_ratio = (df['送股比例'] + df['转增比例']) / 10
new_eps = df['每股净利润'] / (1 + total_sz_ratio)
post_eps_condition = new_eps >= 0.5

constraint_met = df['disclosure_check'] & post_eps_condition

将constraint_met的值赋给df['meu_18_3_constraint']

4. 计算合规性：

df['meu_18_3_compliance'] = True  # 默认合规

# 当subject和condition为True，但constraint为False时，违规
violation = df['meu_18_3_subject'] & df['meu_18_3_condition'] & (~df['meu_18_3_constraint'])
df.loc[violation, 'meu_18_3_compliance'] = False

或者，更准确的是，合规性为True当且仅当subject、condition、constraint同时为True，或者当subject或condition为False时，不违规？

根据合规性检查的逻辑，只有当subject和condition都为True时，才需要满足constraint。否则，不需要检查constraint。因此，合规性为True的情况是：

- subject为False，或者condition为False，或者（subject和condition为True且constraint为True）

违规的情况是：subject和condition为True，但constraint为False。

因此，合规性列可以初始化为True，然后对于违规情况设置为False。

综上，代码的大致结构如下：

import pandas as pd
from utils.tool_for_agents import llm_content_check

def check_meu_18_3(df):
    # 初始化各列
    df['meu_18_3_subject'] = True  # 所有行都是上市公司
    
    df['meu_18_3_condition'] = False
    df['meu_18_3_constraint'] = False
    df['meu_18_3_compliance'] = True  # 默认合规
    
    # 转换财务数据日期为datetime
    df['财务数据日期'] = pd.to_datetime(df['财务数据日期'])
    
    # 条件1: 是否年度报告（假设财务数据日期为12月）
    is_annual_report = df['财务数据日期'].dt.month == 12
    
    # 条件2: 高送转方案（送股+转增≥5）
    high_sz = (df['送股比例'] + df['转增比例']) >= 5
    
    # 条件3: 最近两年净利润持续增长
    # 按公司分组，获取前两年的净利润
    df['prev_year_net'] = df.groupby('公司简称')['净利润'].shift(1)
    df['prev_prev_year_net'] = df.groupby('公司简称')['净利润'].shift(2)
    net_growth_last_year = df['净利润'] > df['prev_year_net']
    net_growth_prev_year = df['prev_year_net'] > df['prev_prev_year_net']
    net_growth_two_years = net_growth_last_year & net_growth_prev_year
    
    # 条件4: 最近三年每股净利润≥1
    df['eps_prev_year'] = df.groupby('公司简称')['每股净利润'].shift(1)
    df['eps_prev_prev_year'] = df.groupby('公司简称')['每股净利润'].shift(2)
    eps_condition = (df['每股净利润'] >= 1) & (df['eps_prev_year'] >= 1) & (df['eps_prev_prev_year'] >= 1)
    
    # 条件5: 上市公司认为确有必要
    df['necessary_check'] = df['权益分派方案文本'].apply(
        lambda text: llm_content_check(text, ""上市公司认为确有必要进行高送转且依据年度财务报表"") if pd.notnull(text) else False
    )
    
    # 条件6: 是否进行权益分派
    is_equity_distribution = df['是否进行权益分派'] == True
    
    # 组合condition条件
    condition_met = (
        is_annual_report &
        high_sz &
        net_growth_two_years &
        eps_condition &
        df['necessary_check'] &
        is_equity_distribution
    )
    df.loc[condition_met, 'meu_18_3_condition'] = True
    
    # 处理constraint
    # 充分披露
    df['disclosure_check'] = df['权益分派方案文本'].apply(
        lambda text: llm_content_check(text, ""充分披露高送转的主要考虑及其合理性"") if pd.notnull(text) else False
    )
    
    # 送转后每股收益≥0.5
    total_sz_ratio = (df['送股比例'] + df['转增比例']) / 10
    new_eps = df['每股净利润'] / (1 + total_sz_ratio)
    post_eps_condition = new_eps >= 0.5
    
    constraint_met = df['disclosure_check'] & post_eps_condition
    df.loc[constraint_met, 'meu_18_3_constraint'] = True
    
    # 计算合规性
    violation = df['meu_18_3_subject'] & df['meu_18_3_condition'] & (~df['meu_18_3_constraint'])
    df.loc[violation, 'meu_18_3_compliance'] = False
    
    # 清理临时列
    df.drop(columns=['prev_year_net', 'prev_prev_year_net', 'eps_prev_year', 'eps_prev_prev_year', 'necessary_check', 'disclosure_check'], inplace=True, errors='ignore')
    
    return df

需要注意的是，这里可能有一些潜在的问题：

1. 财务数据日期是否为年度报告的判断可能不准确，例如有些公司的财年结束日期可能不是12月。但根据问题描述，可能只能假设12月为年度报告。

2. 获取前两年的数据时，如果公司没有足够的历史数据（例如，刚上市两年），则条件不满足。例如，如果只有两年的数据，无法检查前两年的增长。

3. 使用shift函数时，需要确保数据按正确的顺序排列。假设数据框已经按公司简称和日期排序，这在问题描述中已经提到。

4. 在计算送转后的每股收益时，如果送股和转增比例为0，会导致除以1的情况，但此时高送转条件不满足，所以不会进入constraint的检查。

5. 使用llm_content_check函数时，需要确保传入正确的检查描述。例如，对于“上市公司认为确有必要”，可能需要更准确的描述，如“上市公司认为确有必要进行高送转的主要考虑及其合理性”。

此外，可能还需要处理NaN值的情况。例如，prev_year_net可能为NaN，此时net_growth_last_year会是False，因为NaN的比较结果为False。

综上，上述代码应该能够满足MEU_18_3的合规性检查要求。
","CompletionUsage(completion_tokens=7837, prompt_tokens=2136, total_tokens=9973, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=6835, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 

# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 5. 计算整体的违约情况并标记在dataframe上(meu_n_k_compliance). 

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df['meu_4_2_subject'] = False  # 初始化subject列
    df['meu_4_2_condition'] = False  # 初始化condition列
    df['meu_4_2_constrain'] = False  # 初始化constrain列

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True

    # 判断违规情况：满足主体和条件但不满足约束
    is_violation = (
        valid_subject & 
        valid_condition & 
        (~valid_constraint)
    )

    # 标记违规行
    df.loc[is_violation, 'meu_4_1_compliance'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_19_1
法律的最小可执行单元内容: {""subject"": ""上市公司"", ""condition"": ""报告期尚未产生收入"", ""constraint"": ""不得披露高送转方案"", ""contextual_info"": NaN}
必要的额外信息: nan

你被分配的MEU coding任务存在refer_to关系, 你需要参考下面这个MEU的必要内容来完成你被安排的任务, 但你不需要直接执行下面的MEU: 
【MEU_17_1】
subject: nan
condition: nan
constrain: nan
contextual_info: 本指引所称高送转，是指公司每十股送红股与公积金转增股本，合计达到或者超过五股


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '财务数据日期', '公告日期', '公告类型', '审计意见', '总资产', '总负债', '净资产', '资产负债率',
'交易性金融资产', '衍生金融资产', '债权投资', '其他债权投资', '其他权益工具投资', '其他非流动金融资产',
'其他流动资产', '金融资产总额', '总股本', '每股净资产', '合并报表未分配利润', '母公司报表未分配利润', '净利润',
'每股净利润', '母公司报表净利润', '经营活动现金流量净额', '投资活动现金流量净额', '筹资活动现金流量净额',
'现金及现金等价物净增加额', '净资产增长率', '净利润增长率', '资产负债率变化', '金融资产增长率',
'是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划', '现金分红金额', '送股比例', '转增比例', '是否进行权益分派', '权益分派方案文本', '公司简称']

## 其中: 
- 这是一个二维的面板数据, 根据['日期', '公司简称']可以定位到特定公司在特定日期的状态. 数据已经按照公司简称和日期排序. 
- 我们的'日期'并非连续的自然日或者交易日, 而是固定的季报/半年报/年报披露后三个月内的某一个自然日, 例如'2020-05-30', '2020-09-29', ...等, 我们假定公司在这一天发布了权益分派公告(或者决定了不进行权益分派). 每个季报/半年报/年报后只会跟随一个'日期'来决定是否进行权益分派, 如何进行分派. 
- 数据的每一行包含了两个部分的数据, 分别是当时最新的财务数据和当时最新的权益分派情况. 例如, '2020-09-17'这一行可能对应了公告日期为'2020-08-27'的截至'2020-06-30'的半年报财务报告['审计意见', '总资产', ..., '现金及现金等价物净增加额'], 以及在'2020-09-17'当天公告的权益分派信息['是否进行权益分派', ..., '现金分红金额', ...]
- 所有财务数据都是以单季度的形式记录的, 不需要考虑利润表科目在半年报和年报中逐渐累加的问题. 所有的增长率都是单季的. 
- 所有资产/价格的单位都是元而非万元, 千元或百万元; 所有的比例/比率都是小数而非百分数, 除了['送股比例', '转增比例']是""每10股送n股""的格式. 
- ['审计意见']的值有""无保留意见"", ""非标准无保留意见"", ""保留意见"". 
- 这些列为布尔值: ['是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划']

- 如果希望检查权益分派方案中是否披露了特定内容, 可以使用环境中会提供的函数`llm_content_check()`, 但非披露类的合规检查中禁止使用这个函数. 
    描述: 使用LLM检查公告中是否包含特定内容
        参数:
            announcement_text: 公告全文
            traget_content: 需要检查的内容描述
        返回:
            bool: 公告中是否包含特定内容
    调用示例: 
        ```python
        from utils.tool_for_agents import llm_content_check

        constraint_description = ""为增强投资者回报水平拟采取的措施"" # 请完整描述需要检查的内容, 不得简化
        df['meu_4_1_constraint'] = df['权益分派方案文本'].apply(
            lambda text: llm_content_check(text, constraint_description)
        )
        ```

note:
 - 理论上你撰写合规检验代码所需要的数据都可以从一致的数据中得到, 对于没有直接对应的数据你需要自己计算得到, 不要简单地认为无法完成. 
 - 除非材料提供, 否则不要主动进行简化的假设. 如果你认为所给的信息不足以判断案例的合规性, 可以在函数的结尾进行注释说明. 但这种情况应该很少出现. 

","

<CODE>
import pandas as pd

def check_meu_19_1(df):
    '''
    检查MEU_19_1合规性：
    - subject: 上市公司（所有记录默认满足）
    - condition: 报告期尚未产生收入（使用净利润<=0近似判断）
    - constraint: 未披露高送转方案（送转合计<5股）
    '''

    # 初始化标记列
    df['meu_19_1_subject'] = True  # 所有记录均为上市公司
    df['meu_19_1_condition'] = False
    df['meu_19_1_constraint'] = False
    df['meu_19_1_compliance'] = True  # 默认合规

    # 标记condition：报告期尚未产生收入（使用净利润<=0近似判断）
    # 注意：法律条文中的""产生收入""应指营业收入，但数据中无该字段，此处用净利润作为替代指标
    df['meu_19_1_condition'] = df['净利润'] <= 0

    # 标记constraint：未披露高送转方案
    # 计算送转合计（处理空值为0）
    total_distribution = df['送股比例'].fillna(0) + df['转增比例'].fillna(0)
    # 判断是否达到高送转标准（每10股送转≥5股）
    is_high_distribution = total_distribution >= 5
    # 约束成立条件：未进行权益分派 或 分派但未达高送转标准
    df['meu_19_1_constraint'] = ~(df['是否进行权益分派'] & is_high_distribution)

    # 判断整体合规性：同时满足主体+条件时需满足约束
    violation_mask = df['meu_19_1_subject'] & df['meu_19_1_condition'] & (~df['meu_19_1_constraint'])
    df.loc[violation_mask, 'meu_19_1_compliance'] = False

    return df
</CODE>","好的，我现在需要编写一个函数来检查MEU_19_1的合规性。根据MEU的内容，主体是上市公司，条件是报告期尚未产生收入，约束是不能披露高送转方案。同时，参考MEU_17_1中的高送转定义，即每10股送红股和公积金转增合计达到或超过5股。

首先，处理subject部分。MEU_19_1的subject是“上市公司”，所以所有行的subject都应该有效，因为数据中的每一行都是针对上市公司的。因此，meu_19_1_subject列可以直接设为True。

接下来是condition条件：“报告期尚未产生收入”。这里的收入应该是指营业收入，但数据中是否有相关字段呢？查看提供的列，发现可能有“净利润”这一项。但净利润可能为负，而收入可能为零。如果数据中没有直接的收入字段，可能需要用其他指标来推断。比如，如果净利润为零或负，并且其他财务指标如经营活动现金流量净额等也可能为零，但不确定。但根据问题描述，用户提供的列中没有营业收入，这可能是个问题。或者可能用“净利润”是否为零或负来判断？但原条件中的“尚未产生收入”可能更准确的是营业收入为零。这时候可能需要假设数据中存在某个字段，比如“营业收入”，但提供的列中没有。这可能是一个问题。但根据用户提供的列，可能无法直接判断。这时候可能需要用户说明，但根据问题中的附加信息，用户说“理论上你撰写合规检验代码所需要的数据都可以从一致的数据中得到”，所以可能我漏看了某个字段。再仔细看提供的列：有“净利润”、“母公司报表净利润”等，但没有营业收入。这可能意味着无法直接判断是否产生收入。这时候可能需要用户反馈，但根据问题要求，不能假设无法完成，必须找到解决办法。或者可能“报告期尚未产生收入”是否可以通过其他财务指标推断？比如，如果净利润为零或负，并且经营活动现金流量净额为零，可能说明没有收入？但这样可能不准确。或者可能用户提供的列中存在其他隐含的字段，比如“总资产”等，但无法直接对应。这时候可能需要用现有的字段来近似，比如净利润是否为零或负，但原条件中的“尚未产生收入”可能更严格，即收入为零。这时候可能无法准确判断，但根据问题要求，必须找到解决方案。或者可能用户提供的列中，虽然没有“营业收入”，但可能有其他字段，比如“财务数据日期”对应的季度报告中是否有收入数据？或者可能问题中的“报告期”指的是当前财务数据对应的期间，而“尚未产生收入”可能通过净利润是否为零或负来判断？或者可能“净利润”是否为零或负？但原条件中的“尚未产生收入”可能指的是营业收入为零，而净利润可能包括其他收益。这时候可能需要假设用户的数据中存在“营业收入”字段，但提供的列中没有。这可能是一个问题。这时候可能需要用户补充说明，但根据问题要求，必须用现有数据。这时候可能需要用其他字段来推断，比如如果净利润为零，并且经营活动现金流量净额为零，可能推断收入为零？或者可能用户的数据中，是否有一个字段如“营业收入”存在，但被遗漏在列描述中？或者可能问题中的“报告期尚未产生收入”是否可以通过其他方式判断？比如，如果净利润为零或负，并且没有现金分红，可能说明没有收入？但这样可能不准确。这时候可能需要用户指出如何处理，但根据问题要求，必须用现有数据。这时候可能需要假设“净利润”为零或负作为条件，但原条件中的“尚未产生收入”可能更严格。这时候可能需要用“净利润”是否小于等于零作为条件，但可能存在误差。或者可能问题中的“报告期尚未产生收入”是否可以通过其他指标组合来判断？比如，总资产为零？这显然不合理。或者可能用户提供的列中存在其他字段，比如“其他流动资产”等，但无法推断收入。这时候可能需要用户说明，但根据问题要求，必须继续。这时候可能需要假设“净利润”为零或负作为条件，但可能不符合实际法律要求。这时候可能需要注释说明，但根据问题要求，必须完成代码。这可能是一个难点。

假设这里的数据中存在一个字段，比如“营业收入”，但用户提供的列中没有列出。或者可能用户提供的列中有“财务数据日期”对应的季度报告中，是否包含该信息？或者可能问题中的“报告期”指的是当前行的财务数据对应的期间，而“尚未产生收入”可能通过该行的某些财务指标来判断。例如，如果净利润为零，并且经营活动现金流量净额为零，可能推断收入为零？但这样可能不准确。或者可能用户的数据中，是否有一个字段如“营业收入”存在，但未被列在提供的columns中？这时候可能需要用户确认，但根据问题要求，必须继续。这时候可能需要假设“净利润”是否为零或负作为条件，但原条件中的“尚未产生收入”可能更准确。这时候可能需要用其他方式，比如是否有现金分红？但现金分红可能与收入无关。或者可能问题中的“尚未产生收入”指的是营业收入为零，而净利润可能为负，比如成本过高导致亏损。这时候，如果数据中没有“营业收入”字段，可能无法准确判断。这时候可能需要用户补充说明，但根据问题要求，必须用现有数据。这时候可能需要用其他字段来推断，比如如果净利润为零或负，并且经营活动现金流量净额为负，可能推断收入不足，但无法确定是否为零。这时候可能需要假设存在一个字段，比如“营业收入”，但用户提供的列中没有，这可能是一个问题。这时候可能需要用户指出如何处理，但根据问题要求，必须继续。这时候可能需要用“净利润”是否小于等于零作为条件，但可能不符合法律条文中的“尚未产生收入”的实际含义。这时候可能需要注释说明，但根据问题要求，必须完成代码。这可能是一个问题，但暂时假设用户的数据中存在“营业收入”字段，或者可能问题中的“净利润”是否为零或负作为替代指标。或者可能用户提供的列中的“净利润”字段是否可以用来判断？例如，如果净利润为零或负，可能说明没有收入？但这样可能不正确，因为净利润可能包括其他收入和支出。这时候可能需要重新考虑。

或者可能问题中的“报告期尚未产生收入”中的“收入”指的是营业收入，而用户提供的列中没有该字段，这时候可能需要用其他字段来推断。例如，如果净利润为零或负，并且经营活动现金流量净额为零或负，可能推断营业收入为零。但这样可能不准确。这时候可能需要用户指出如何处理，但根据问题要求，必须继续。这时候可能需要假设用户的数据中存在“营业收入”字段，但被遗漏在列描述中。或者可能用户的数据中的“财务数据日期”对应的季度报告中，是否包含营业收入？例如，可能用户提供的列中的“净利润”字段可能不足以判断，但问题中的条件必须满足。这时候可能需要用户补充说明，但根据问题要求，必须用现有数据。这时候可能需要用其他方式，比如是否有其他指标的组合。例如，如果总资产为零，但显然不可能。或者可能用户的数据中的“是否实施现金分红”为False，可能说明没有收入？但这也可能不准确。这时候可能需要用户指出如何处理，但根据问题要求，必须继续。这时候可能需要假设用户的数据中存在“营业收入”字段，但未被列在提供的columns中，或者可能用户的数据中的“财务数据”部分包含该字段。例如，可能用户提供的columns中的某些字段如“其他流动资产”等可能被忽略，但实际数据中存在“营业收入”字段。这时候可能需要假设该字段存在，并编写代码。例如，假设数据中存在“营业收入”字段，那么条件就是该字段为零。但根据用户提供的columns列表，没有这个字段。这时候可能需要用户指出如何处理，但根据问题要求，必须继续。这时候可能需要用其他字段来替代，或者可能问题中的条件无法满足，导致函数无法正确编写。这时候可能需要注释说明，但根据问题要求，必须完成代码。这时候可能需要假设用户的数据中存在“营业收入”字段，或者可能用户的数据中的“净利润”字段是否为零或负作为替代。例如，如果净利润为零或负，可能认为尚未产生收入。但这样可能不符合法律条文中的实际要求。这时候可能需要做出这样的假设，并在代码中处理。

现在，假设用户的数据中存在“营业收入”字段，那么条件valid_condition就是该字段为零。但根据用户提供的columns列表，没有这个字段。这时候可能需要重新检查用户提供的columns列表。用户提供的columns包括：['日期', '财务数据日期', '公告日期', '公告类型', '审计意见', '总资产', '总负债', '净资产', '资产负债率', '交易性金融资产', '衍生金融资产', '债权投资', '其他债权投资', '其他权益工具投资', '其他非流动金融资产', '其他流动资产', '金融资产总额', '总股本', '每股净资产', '合并报表未分配利润', '母公司报表未分配利润', '净利润', '每股净利润', '母公司报表净利润', '经营活动现金流量净额', '投资活动现金流量净额', '筹资活动现金流量净额', '现金及现金等价物净增加额', '净资产增长率', '净利润增长率', '资产负债率变化', '金融资产增长率', '是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形', '相关股东后三个月存在减持计划', '现金分红金额', '送股比例', '转增比例', '是否进行权益分派', '权益分派方案文本', '公司简称']。确实没有“营业收入”字段。这时候可能需要用其他字段来推断。例如，如果净利润为零或负，可能认为没有收入，但这样可能不正确。或者可能用户的数据中的“净利润”字段是否为零或负作为条件。例如，如果净利润为零或负，可能认为报告期尚未产生收入。这时候，valid_condition = df['净利润'] <= 0。这可能是一个可能的解决方案，但可能不符合法律条文中的实际要求。这时候可能需要做出这样的假设，并在代码中处理。

接下来是约束条件：“不得披露高送转方案”。根据MEU_17_1的定义，高送转是指每10股送红股和公积金转增合计达到或超过5股。因此，需要检查权益分派方案中的送股比例和转增比例之和是否>=5。例如，送股比例是每10股送n股，转增比例是每10股转增m股，那么n + m >=5即为高送转。因此，约束条件valid_constraint应为：如果公司披露了高送转方案（即送股比例+转增比例>=5），则违反约束，因为约束是“不得披露”。因此，当公司披露了高送转方案时，约束条件不满足，即valid_constraint为False。或者，正确的逻辑是：当条件满足时（即报告期尚未产生收入），如果公司披露了高送转方案，则违规。因此，在约束条件中，valid_constraint应为是否没有披露高送转方案。即，valid_constraint = (送股比例 + 转增比例 <5) 或者 没有进行权益分派中的高送转。因此，需要检查是否在权益分派方案中存在高送转。例如，如果送股比例和转增比例之和>=5，则视为高送转，此时如果公司披露了这样的方案，则违反约束。因此，约束条件valid_constraint应为：没有高送转方案。即，当公司进行权益分派时，送股+转增比例之和<5，或者没有进行权益分派。因此，valid_constraint = ~((df['送股比例'] + df['转增比例']) >=5) | (~df['是否进行权益分派'])。或者，可能更准确的是，当公司进行权益分派时，是否包含高送转。因此，valid_constraint = ~( (df['是否进行权益分派']) & ( (df['送股比例'] + df['转增比例']) >=5 ) )

现在，将这些逻辑转化为代码：

首先，处理subject：所有行都是上市公司，所以meu_19_1_subject设为True。

条件condition：报告期尚未产生收入。假设这里用净利润<=0作为替代，或者是否有其他字段？例如，可能用户的数据中的“净利润”字段是否为零或负。或者可能用“合并报表未分配利润”是否为负？这可能不正确。或者可能用“净利润”是否为零或负。例如，如果净利润<=0，可能认为尚未产生收入。这可能是一个假设，但需要明确。例如，valid_condition = df['净利润'] <= 0。或者可能用“经营活动现金流量净额”是否为零或负？这可能也不准确。这时候可能需要用户指出如何处理，但根据问题要求，必须继续。假设这里使用净利润<=0作为条件，那么valid_condition = df['净利润'] <=0。但需要确认是否符合法律条文中的“尚未产生收入”的实际含义。这可能存在误差，但暂时这样处理。

约束constraint：不得披露高送转方案。即，如果公司披露了高送转方案，则违反约束。因此，valid_constraint应为：公司没有披露高送转方案。即，当公司进行权益分派时，送股比例+转增比例<5。或者，如果公司没有进行权益分派，则自然满足约束。因此，valid_constraint = ~( (df['是否进行权益分派']) & ( (df['送股比例'] + df['转增比例']) >=5 ) )

然后，整体合规性判断：当subject和condition都为True时，如果constraint为False（即公司披露了高送转），则违规。因此，is_violation = valid_subject & valid_condition & (~valid_constraint)

现在，将这些步骤转化为代码：

首先，初始化各列：

df['meu_19_1_subject'] = True

valid_condition = df['净利润'] <= 0  # 假设净利润<=0代表尚未产生收入，这可能不正确，但暂时这样处理

高送转的判断：

high_songzhuan = (df['送股比例'] + df['转增比例']) >=5
valid_constraint = ~( df['是否进行权益分派'] & high_songzhuan )

然后，标记各列：

df['meu_19_1_condition'] = valid_condition
df['meu_19_1_constraint'] = valid_constraint

合规性判断：

is_violation = df['meu_19_1_subject'] & df['meu_19_1_condition'] & (~df['meu_19_1_constraint'])
df['meu_19_1_compliance'] = ~is_violation

或者，可能更准确的是，合规性为True当且仅当满足subject和condition时，同时满足constraint。否则，当subject和condition都满足时，如果constraint不满足，则违规。因此，合规性列可以标记为是否满足所有三个条件中的约束。或者，合规性列应标记为是否违规。例如，合规性为True表示合规，False表示违规。因此：

df['meu_19_1_compliance'] = True  # 默认合规
df.loc[is_violation, 'meu_19_1_compliance'] = False

现在，将这些步骤整合到代码中：

需要注意的是，送股比例和转增比例可能为NaN，例如当公司没有进行权益分派时。因此，在计算high_songzhuan时，需要处理NaN的情况。例如，当公司没有进行权益分派时，送股比例和转增比例可能为0或NaN？根据用户提供的列描述，'是否进行权益分派'是布尔值，当为False时，可能送股比例和转增比例都为0或NaN。因此，在计算时，可能需要将NaN视为0。例如：

df['送股比例'] = df['送股比例'].fillna(0)
df['转增比例'] = df['转增比例'].fillna(0)

或者，在计算时，使用fillna(0)：

high_songzhuan = (df['送股比例'].fillna(0) + df['转增比例'].fillna(0)) >=5

这样，当公司没有进行权益分派时，送股和转增比例的总和为0，不会触发高送转。

因此，valid_constraint应为：

valid_constraint = ~( (df['是否进行权益分派']) & ( (df['送股比例'].fillna(0) + df['转增比例'].fillna(0)) >=5 ) )

或者，更简洁的方式：

valid_constraint = ~( df['是否进行权益分派'] & ( (df['送股比例'] + df['转增比例']).fillna(0) >=5 ) )

这样，当公司进行权益分派时，检查送股和转增比例之和是否>=5，否则视为不满足高送转条件。

现在，将这些步骤写入代码：

import pandas as pd

def check_meu_19_1(df):
    '''
    检查MEU_19_1的合规性：
    subject: 上市公司
    condition: 报告期尚未产生收入
    constraint: 不得披露高送转方案
    contextual_info: 高送转定义为每10股送转合计≥5股
    '''
    # 初始化标记列
    df['meu_19_1_subject'] = True  # 所有行均为上市公司
    df['meu_19_1_condition'] = False
    df['meu_19_1_constraint'] = False
    df['meu_19_1_compliance'] = True  # 默认合规
    
    # 标记condition：报告期尚未产生收入（假设用净利润<=0代替）
    # 注意：实际中应使用营业收入，但数据中可能无此字段，此处为假设
    valid_condition = df['净利润'] <= 0
    df['meu_19_1_condition'] = valid_condition
    
    # 标记constraint：未披露高送转方案
    # 计算送股和转增比例之和，处理NaN为0
    total_songzhuan = df['送股比例'].fillna(0) + df['转增比例'].fillna(0)
    is_high_songzhuan = total_songzhuan >= 5
    # 约束成立的条件：未进行权益分派 或 分派但未达到高送转
    valid_constraint = ~(df['是否进行权益分派'] & is_high_songzhuan)
    df['meu_19_1_constraint'] = valid_constraint
    
    # 判断违规：主体和条件满足但约束不满足
    is_violation = df['meu_19_1_subject'] & df['meu_19_1_condition'] & (~df['meu_19_1_constraint'])
    df.loc[is_violation, 'meu_19_1_compliance'] = False
    
    return df

需要注意的是，这里对condition的处理可能存在错误，因为净利润<=0并不等同于“尚未产生收入”。例如，公司可能有收入，但成本更高导致净利润为负。因此，这个假设可能导致误判。但根据用户提供的数据字段，无法直接获取营业收入，因此可能需要用户确认或补充数据。在代码中，可以添加注释说明这一点。

此外，高送转的判断是否正确？例如，送股比例和转增比例是否为每10股的数值。例如，如果送股比例是5，转增比例是0，则总为5，满足高送转。代码中的处理是正确的。

综上，编写上述代码，并在注释中说明假设条件。
","CompletionUsage(completion_tokens=4630, prompt_tokens=2083, total_tokens=6713, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=4166, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 

# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 5. 计算整体的违约情况并标记在dataframe上(meu_n_k_compliance). 

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df['meu_4_2_subject'] = False  # 初始化subject列
    df['meu_4_2_condition'] = False  # 初始化condition列
    df['meu_4_2_constrain'] = False  # 初始化constrain列

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True

    # 判断违规情况：满足主体和条件但不满足约束
    is_violation = (
        valid_subject & 
        valid_condition & 
        (~valid_constraint)
    )

    # 标记违规行
    df.loc[is_violation, 'meu_4_1_compliance'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_19_2
法律的最小可执行单元内容: {""subject"": ""上市公司"", ""condition"": ""净利润为负"", ""constraint"": ""不得披露高送转方案"", ""contextual_info"": NaN}
必要的额外信息: nan

你被分配的MEU coding任务存在refer_to关系, 你需要参考下面这个MEU的必要内容来完成你被安排的任务, 但你不需要直接执行下面的MEU: 
【MEU_17_1】
subject: nan
condition: nan
constrain: nan
contextual_info: 本指引所称高送转，是指公司每十股送红股与公积金转增股本，合计达到或者超过五股


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '财务数据日期', '公告日期', '公告类型', '审计意见', '总资产', '总负债', '净资产', '资产负债率',
'交易性金融资产', '衍生金融资产', '债权投资', '其他债权投资', '其他权益工具投资', '其他非流动金融资产',
'其他流动资产', '金融资产总额', '总股本', '每股净资产', '合并报表未分配利润', '母公司报表未分配利润', '净利润',
'每股净利润', '母公司报表净利润', '经营活动现金流量净额', '投资活动现金流量净额', '筹资活动现金流量净额',
'现金及现金等价物净增加额', '净资产增长率', '净利润增长率', '资产负债率变化', '金融资产增长率',
'是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划', '现金分红金额', '送股比例', '转增比例', '是否进行权益分派', '权益分派方案文本', '公司简称']

## 其中: 
- 这是一个二维的面板数据, 根据['日期', '公司简称']可以定位到特定公司在特定日期的状态. 数据已经按照公司简称和日期排序. 
- 我们的'日期'并非连续的自然日或者交易日, 而是固定的季报/半年报/年报披露后三个月内的某一个自然日, 例如'2020-05-30', '2020-09-29', ...等, 我们假定公司在这一天发布了权益分派公告(或者决定了不进行权益分派). 每个季报/半年报/年报后只会跟随一个'日期'来决定是否进行权益分派, 如何进行分派. 
- 数据的每一行包含了两个部分的数据, 分别是当时最新的财务数据和当时最新的权益分派情况. 例如, '2020-09-17'这一行可能对应了公告日期为'2020-08-27'的截至'2020-06-30'的半年报财务报告['审计意见', '总资产', ..., '现金及现金等价物净增加额'], 以及在'2020-09-17'当天公告的权益分派信息['是否进行权益分派', ..., '现金分红金额', ...]
- 所有财务数据都是以单季度的形式记录的, 不需要考虑利润表科目在半年报和年报中逐渐累加的问题. 所有的增长率都是单季的. 
- 所有资产/价格的单位都是元而非万元, 千元或百万元; 所有的比例/比率都是小数而非百分数, 除了['送股比例', '转增比例']是""每10股送n股""的格式. 
- ['审计意见']的值有""无保留意见"", ""非标准无保留意见"", ""保留意见"". 
- 这些列为布尔值: ['是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划']

- 如果希望检查权益分派方案中是否披露了特定内容, 可以使用环境中会提供的函数`llm_content_check()`, 但非披露类的合规检查中禁止使用这个函数. 
    描述: 使用LLM检查公告中是否包含特定内容
        参数:
            announcement_text: 公告全文
            traget_content: 需要检查的内容描述
        返回:
            bool: 公告中是否包含特定内容
    调用示例: 
        ```python
        from utils.tool_for_agents import llm_content_check

        constraint_description = ""为增强投资者回报水平拟采取的措施"" # 请完整描述需要检查的内容, 不得简化
        df['meu_4_1_constraint'] = df['权益分派方案文本'].apply(
            lambda text: llm_content_check(text, constraint_description)
        )
        ```

note:
 - 理论上你撰写合规检验代码所需要的数据都可以从一致的数据中得到, 对于没有直接对应的数据你需要自己计算得到, 不要简单地认为无法完成. 
 - 除非材料提供, 否则不要主动进行简化的假设. 如果你认为所给的信息不足以判断案例的合规性, 可以在函数的结尾进行注释说明. 但这种情况应该很少出现. 

","

<CODE>
import pandas as pd

def check_meu_19_2(df):
    '''
    检查MEU_19_2合规性：
    subject: 上市公司
    condition: 净利润为负
    constraint: 不得披露高送转方案
    contextual_info: 高送转定义参考MEU_17_1（每10股合计送转≥5股）
    '''
    # 初始化标记列
    df['meu_19_2_subject'] = True  # 数据主体均为上市公司
    df['meu_19_2_condition'] = False
    df['meu_19_2_constraint'] = False
    df['meu_19_2_compliance'] = True  # 默认合规

    # 标记条件满足情况 --------------------------------------------------------
    # 1.标记subject（所有行已默认True）
    
    # 2.标记condition（净利润为负）
    df['meu_19_2_condition'] = df['净利润'] < 0
    
    # 3.标记constraint（未披露高送转）
    # 计算高送转条件：进行权益分派且送转合计≥5股/10股
    high_send_condition = (
        df['是否进行权益分派'] & 
        ((df['送股比例'] + df['转增比例']) >= 5)
    )
    df['meu_19_2_constraint'] = ~high_send_condition  # 约束满足=未实施高送转
    
    # 判断违规情况 ----------------------------------------------------------
    # 当且仅当同时满足以下条件时违规：
    # a.主体有效（上市公司） 
    # b.条件成立（净利润为负）
    # c.约束不满足（实际存在高送转）
    violation_mask = (
        df['meu_19_2_subject'] & 
        df['meu_19_2_condition'] & 
        (~df['meu_19_2_constraint'])
    )
    df.loc[violation_mask, 'meu_19_2_compliance'] = False

    return df
</CODE>","好的，我现在需要处理这个MEU_19_2的合规性检查任务。首先，我得仔细理解这个MEU的内容。根据给定的信息，MEU_19_2的内容是：当上市公司净利润为负时，不得披露高送转方案。所以，我需要检查在数据中的每一行，即每个公司在特定日期的状态，是否符合这个规定。

首先，分解MEU的三个部分：subject、condition和constraint。Subject是“上市公司”，所以所有数据行中的公司都是subject，因为数据本身就是关于上市公司的。因此，subject的条件应该总是满足的，不需要额外的判断。不过可能需要确认数据中的公司是否都是上市公司，但根据问题描述，数据是上市公司的，所以这里可能直接标记为True。

接下来是condition：“净利润为负”。我需要检查该行的净利润是否小于零。数据中的净利润列是存在的，所以这一步应该可以直接用df['净利润'] < 0来判断。

然后是constraint：“不得披露高送转方案”。这里的高送转需要参考MEU_17_1中的定义，即每十股送红股与公积金转增股本合计达到或超过五股。所以，我需要检查该公司的权益分派方案是否属于高送转。数据中有送股比例和转增比例这两个列，它们的格式是“每10股送n股”或“每10股转增n股”。例如，送股比例如果是5，就是每10股送5股，转增比例如果是5，就是每10股转增5股。两者相加如果达到或超过5股，就属于高送转。

所以，计算高送转的条件应该是：(送股比例 + 转增比例) >= 5。但要注意，这两个比例可能都是每10股的情况。例如，送股比例是3，转增比例是2，合计5，就满足条件。这时候，如果公司披露了这样的方案，就属于高送转，此时如果净利润为负，就违反了约束条件。

现在，我需要将这些逻辑转化为代码。

首先，处理subject部分。因为数据中的每一行都是上市公司，所以meu_19_2_subject列应该全部为True。但可能需要确认是否有例外情况，但根据问题描述，数据中的公司都是上市公司，所以直接标记为True。

然后，condition部分：净利润为负。即df['净利润'] < 0。这里需要注意净利润的数据类型是否为数值型，但问题描述中提到所有数据都是正确的格式，所以可以直接比较。

接下来是constraint部分：不得披露高送转方案。也就是说，当condition满足时（净利润为负），如果公司披露了高送转方案，则违反约束。因此，需要检查是否在此时存在高送转。高送转的条件是送股比例和转增比例之和>=5。数据中的送股比例和转增比例是每10股的数值，所以直接相加即可。例如，送股比例是3，转增比例是2，总和是5，满足条件。因此，高送转的条件是：(df['送股比例'] + df['转增比例']) >=5。同时，公司是否进行了权益分派中的高送转，可能要看是否实施了股票股利或公积金转增股本。但根据MEU_17_1的定义，只要方案中存在高送转，无论是否实施，可能都需要检查。但问题中的constraint是“不得披露”，所以只要在权益分派方案中披露了高送转，就违反约束。因此，需要检查是否在权益分派方案中存在高送转的情况。

数据中的相关列包括：是否进行权益分派、送股比例、转增比例。如果公司进行了权益分派，并且送股比例+转增比例>=5，那么属于高送转。因此，判断高送转的条件是：(df['送股比例'] + df['转增比例']) >=5，并且可能同时需要检查是否进行了股票股利或公积金转增。但根据MEU_17_1的定义，只要方案中的送股和转增合计达到或超过5股，就属于高送转。因此，不管是否实施，只要方案中存在这样的比例，就属于高送转。但问题中的约束是“不得披露”，所以如果公司披露了这样的方案，就违反约束。因此，需要检查是否在权益分派方案中存在高送转的情况。

因此，constraint的valid条件是：当净利润为负时，没有披露高送转方案。即，如果净利润为负，那么高送转方案不存在。因此，在代码中，当condition满足时（净利润为负），如果存在高送转方案（即送股+转增>=5），则constraint不满足，即valid_constraint为False。反之，如果净利润为负，但高送转方案不存在，则constraint满足，valid_constraint为True。或者，当净利润为负时，如果公司没有高送转方案，则符合约束；如果有，则不符合。

所以，constraint的valid条件应该是：当condition满足时，高送转方案不存在。即，valid_constraint = ~((送股比例 + 转增比例) >=5) 或者 没有进行权益分派中的高送转。或者，是否进行权益分派中的高送转可能由是否实施股票股利或公积金转增股本决定？例如，如果公司没有进行股票股利或公积金转增，那么即使送股比例和转增比例是0，那么高送转不存在。或者，是否在权益分派方案中包含了高送转，不管是否实施？

这里可能需要更仔细的分析。根据MEU_19_2的约束，是“不得披露高送转方案”，即如果公司披露了高送转方案，就违规。因此，只要在权益分派方案中存在高送转的提议，无论是否实施，都算违规。例如，公司可能在公告中提出高送转方案，但可能还未实施。但根据数据中的列，可能要看是否在公告中存在这样的方案。

数据中的列包括：是否进行权益分派、送股比例、转增比例。如果公司进行了权益分派，并且送股比例和转增比例之和>=5，那么属于高送转。或者，是否进行权益分派可能表示是否实际执行，而送股比例和转增比例是方案中的数值。例如，如果公司公告了权益分派方案，其中包含送股和转增，那么即使还未实施，只要方案中存在高送转，就属于披露了高送转方案，此时如果净利润为负，就违规。

因此，判断是否披露高送转方案的条件是：是否进行权益分派（即'是否进行权益分派'为True），并且送股比例+转增比例>=5。或者，可能即使没有进行权益分派，但方案中存在高送转的情况？比如，公司可能公告了方案但最终未实施。但根据数据中的列，可能'是否进行权益分派'表示是否实际执行，而送股比例和转增比例是方案中的数值。或者，可能这些比例是在权益分派方案中的数值，不管是否实施。例如，公司可能公告了一个高送转方案，但之后取消，但此时在公告日已经披露了，所以仍然算违规。

因此，正确的判断应该是：只要在权益分派方案中（即公告中）存在高送转，无论是否实施，都算作披露了高送转方案。因此，需要检查送股比例和转增比例的总和是否>=5，并且是否进行了权益分派。或者，是否进行权益分派可能表示是否在公告中提出了方案。例如，'是否进行权益分派'为True表示公司在该日期公告了权益分派方案，而送股比例和转增比例是该方案的内容。因此，当'是否进行权益分派'为True，并且送股比例+转增比例>=5时，属于披露了高送转方案。

因此，判断高送转的条件是：df['是否进行权益分派'] & ((df['送股比例'] + df['转增比例']) >=5)。这可能更准确，因为如果公司没有进行权益分派，那么即使送股和转增的比例很高，也不存在披露的问题。例如，如果公司没有进行权益分派，那么送股比例和转增比例可能为0或者NaN，或者未被记录。因此，只有当公司进行了权益分派，并且方案中的送股和转增比例之和>=5时，才算作披露了高送转方案。

综上，constraint的valid条件是：当净利润为负时，没有进行高送转方案的披露。即，当condition（净利润<0）为True时，如果高送转方案存在（即是否进行权益分派为True，并且送股+转增>=5），则constraint不满足（valid_constraint为False）；否则，constraint满足（valid_constraint为True）。

现在，将这些逻辑转化为代码：

首先，标记subject。因为所有行都是上市公司，所以meu_19_2_subject列全部设为True。

然后，condition是净利润<0，所以valid_condition = df['净利润'] < 0。

接下来，constraint的判断：当condition为True时，是否没有高送转方案。高送转方案的条件是是否进行权益分派，并且送股+转增>=5。所以，高送转存在的情况是：df['是否进行权益分派'] & (df['送股比例'] + df['转增比例'] >=5)。因此，当condition为True时，如果高送转存在，则constraint不满足；否则满足。因此，valid_constraint应该是：当condition为True时，高送转不存在。即：

valid_constraint = ~(df['是否进行权益分派'] & (df['送股比例'] + df['转增比例'] >=5))

但需要将valid_constraint的初始值设为True，只有当condition为True时，才检查是否满足约束。或者，只有当condition和subject都满足时，才需要检查constraint。或者，valid_constraint的条件是：当subject和condition都满足时，是否满足约束。

不过根据框架，需要分别标记subject、condition、constraint的valid情况，然后整体合规性是当subject和condition都满足时，constraint是否满足。如果subject和condition都满足，但constraint不满足，则违规。

所以，在代码中：

1. 初始化各列为False。
2. 标记subject为True（所有行）。
3. 标记condition为净利润<0。
4. 标记constraint为：当公司没有进行高送转方案（即不满足高送转的条件）。
   即，constraint的valid条件是：没有进行高送转。所以，valid_constraint = ~(是否进行权益分派且送股+转增>=5)。
   因此，只要公司没有进行高送转，无论condition是否满足，constraint的valid都是True。但根据MEU的约束，只有当subject和condition都满足时，才需要满足constraint。因此，在标记constraint的valid时，可能应该考虑是否在condition满足的情况下，是否满足约束。或者，constraint的valid条件是否独立于condition？

这里可能需要更仔细的分析。根据MEU的结构，constraint的valid应该是在subject和condition都满足的情况下，是否满足约束。因此，在代码中，当subject和condition都满足时，必须满足constraint，否则违规。因此，在标记constraint的valid时，可能应该单独判断是否满足约束条件，而不考虑condition是否满足。例如，constraint的valid是：无论condition是否满足，只要没有高送转，就标记为True。但只有当subject和condition都满足时，才需要检查constraint是否满足，从而决定是否违规。

或者，根据框架中的例子，constraint的valid标记是独立于condition的，即不管condition是否满足，只要满足约束条件，就标记为True。例如，在例子中，valid_constraint的条件是交易日差>=15且存在减持计划，这可能与condition是否满足无关。然后，在判断违规时，只有当subject和condition都满足，但constraint不满足时，才违规。

因此，在代码中，constraint的valid标记应该独立于condition，即只要满足约束条件，就标记为True。例如，在例子中，valid_constraint是交易日差>=15且存在减持计划，不管是否满足condition。然后，当subject和condition都满足时，如果constraint不满足，则违规。

因此，在本任务中，constraint的valid条件是：没有进行高送转。即，只要公司没有进行高送转，无论其净利润是否为负，constraint的valid都是True。而当公司进行了高送转，则constraint的valid是False。然后，当subject和condition都满足时（即公司是上市公司且净利润为负），如果此时constraint的valid是False（即进行了高送转），则违规。

因此，在代码中：

valid_subject = True（所有行）
valid_condition = df['净利润'] < 0
valid_constraint = ~ (df['是否进行权益分派'] & (df['送股比例'] + df['转增比例'] >=5))

然后，违规情况是：valid_subject & valid_condition & (~valid_constraint)

现在，将这些逻辑转化为代码：

首先，初始化各列：

df['meu_19_2_subject'] = True  # 所有行都是上市公司

df['meu_19_2_condition'] = (df['净利润'] < 0)

高送转的条件是：是否进行权益分派，并且送股比例+转增比例>=5
high_send = df['是否进行权益分派'] & (df['送股比例'] + df['转增比例'] >=5)
df['meu_19_2_constraint'] = ~high_send

然后，违规情况是当subject和condition都满足，但constraint不满足：

is_violation = df['meu_19_2_subject'] & df['meu_19_2_condition'] & (~df['meu_19_2_constraint'])

然后，将合规情况标记为True或False。例如，合规的情况是当不违规，即：

df['meu_19_2_compliance'] = ~is_violation

或者，可能合规列应该标记为True表示合规，False表示违规。所以：

df['meu_19_2_compliance'] = True  # 默认合规
df.loc[is_violation, 'meu_19_2_compliance'] = False

或者，根据例子中的处理方式，直接根据是否违规来设置compliance列：

df['meu_19_2_compliance'] = True
df.loc[is_violation, 'meu_19_2_compliance'] = False

或者，例子中的代码是：

is_violation = valid_subject & valid_condition & (~valid_constraint)
df.loc[is_violation, 'meu_4_1_compliance'] = False

但可能还需要处理其他情况，比如当subject或condition不满足时，compliance可能为True或者不需要标记。例如，当subject不满足，或者condition不满足，那么该行不涉及该MEU的约束，因此合规性可能为True，或者不需要标记。但根据合规性的定义，只有当subject和condition都满足时，才需要满足约束，否则视为不适用，因此合规性可能为True。或者，可能合规性列应该标记为True，除非存在违规情况。

例如，在例子中，只有当满足subject和condition，但constraint不满足时，才标记为False，其他情况标记为True。因此，在代码中：

df['meu_19_2_compliance'] = True
df.loc[is_violation, 'meu_19_2_compliance'] = False

这样处理。

现在，将这些步骤整合到代码中：

import pandas as pd

def check_meu_19_2(df):
    '''
    检查MEU_19_2的合规性：
    subject: 上市公司
    condition: 净利润为负
    constraint: 不得披露高送转方案
    contextual_info: NaN
    '''
    # 初始化各列
    df['meu_19_2_subject'] = True  # 所有行都是上市公司
    df['meu_19_2_condition'] = df['净利润'] < 0
    # 计算高送转条件：是否进行权益分派且送股+转增>=5股
    high_send = df['是否进行权益分派'] & (df['送股比例'] + df['转增比例'] >= 5)
    df['meu_19_2_constraint'] = ~high_send
    # 判断违规情况：主体和条件满足但约束不满足
    is_violation = df['meu_19_2_subject'] & df['meu_19_2_condition'] & (~df['meu_19_2_constraint'])
    # 标记合规性
    df['meu_19_2_compliance'] = True
    df.loc[is_violation, 'meu_19_2_compliance'] = False
    return df

但需要确认是否正确处理了所有情况。例如，当公司是上市公司（subject为True），净利润为负（condition为True），并且进行了高送转（constraint为False），则违规。此时，compliance为False。其他情况下，compliance为True。

另外，关于送股比例和转增比例的数值是否正确。例如，如果送股比例是5，转增比例是0，那么总和是5，满足高送转条件。如果送股比例是3，转增比例是2，总和5，也满足。如果总和是4，则不满足。

此外，是否进行权益分派是布尔值，所以当该列为True时，才考虑送股和转增的比例。如果该列为False，那么即使送股和转增比例很高，也不属于高送转，因为公司没有进行权益分派。

因此，代码中的high_send计算是正确的。

综上，这个函数应该能够正确标记各条件，并判断合规性。
","CompletionUsage(completion_tokens=4348, prompt_tokens=2081, total_tokens=6429, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=3880, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 5. 计算整体的违约情况并标记在dataframe上(meu_n_k_compliance). 

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df['meu_4_2_subject'] = False  # 初始化subject列
    df['meu_4_2_condition'] = False  # 初始化condition列
    df['meu_4_2_constrain'] = False  # 初始化constrain列

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True

    # 判断违规情况：满足主体和条件但不满足约束
    is_violation = (
        valid_subject & 
        valid_condition & 
        (~valid_constraint)
    )

    # 标记违规行
    df.loc[is_violation, 'meu_4_1_compliance'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_15_1
法律的最小可执行单元内容: {""subject"": ""上市公司"", ""condition"": ""权益分派方案中现金分红的金额达到或者超过当期净利润的100%且达到或者超过当期末未分配利润的50%"", ""constraint"": ""应当同时披露是否影响偿债能力、过去十二个月内是否使用过募集资金补充流动资金以及未来十二个月内是否计划使用募集资金补充流动资金等内容"", ""contextual_info"": NaN}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '财务数据日期', '公告日期', '公告类型', '审计意见', '总资产', '总负债', '净资产', '资产负债率',
'交易性金融资产', '衍生金融资产', '债权投资', '其他债权投资', '其他权益工具投资', '其他非流动金融资产',
'其他流动资产', '金融资产总额', '总股本', '每股净资产', '合并报表未分配利润', '母公司报表未分配利润', '净利润',
'每股净利润', '母公司报表净利润', '经营活动现金流量净额', '投资活动现金流量净额', '筹资活动现金流量净额',
'现金及现金等价物净增加额', '净资产增长率', '净利润增长率', '资产负债率变化', '金融资产增长率',
'是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划', '现金分红金额', '送股比例', '转增比例', '是否进行权益分派', '权益分派方案文本', '公司简称']

## 其中: 
- 这是一个二维的面板数据, 根据['日期', '公司简称']可以定位到特定公司在特定日期的状态. 数据已经按照公司简称和日期排序. 
- 我们的'日期'并非连续的自然日或者交易日, 而是固定的季报/半年报/年报披露后三个月内的某一个自然日, 例如'2020-05-30', '2020-09-29', ...等, 我们假定公司在这一天发布了权益分派公告(或者决定了不进行权益分派). 每个季报/半年报/年报后只会跟随一个'日期'来决定是否进行权益分派, 如何进行分派. 
- 数据的每一行包含了两个部分的数据, 分别是当时最新的财务数据和当时最新的权益分派情况. 例如, '2020-09-17'这一行可能对应了公告日期为'2020-08-27'的截至'2020-06-30'的半年报财务报告['审计意见', '总资产', ..., '现金及现金等价物净增加额'], 以及在'2020-09-17'当天公告的权益分派信息['是否进行权益分派', ..., '现金分红金额', ...]
- 所有财务数据都是以单季度的形式记录的, 不需要考虑利润表科目在半年报和年报中逐渐累加的问题. 所有的增长率都是单季的. 
- 所有资产/价格的单位都是元而非万元, 千元或百万元; 所有的比例/比率都是小数而非百分数, 除了['送股比例', '转增比例']是""每10股送n股""的格式. 
- ['审计意见']的值有""无保留意见"", ""非标准无保留意见"", ""保留意见"". 
- 这些列为布尔值: ['是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划']

- 如果希望检查权益分派方案中是否披露了特定内容, 可以使用环境中会提供的函数`llm_content_check()`, 但非披露类的合规检查中禁止使用这个函数. 
    描述: 使用LLM检查公告中是否包含特定内容
        参数:
            announcement_text: 公告全文
            traget_content: 需要检查的内容描述
        返回:
            bool: 公告中是否包含特定内容
    调用示例: 
        ```python
        from utils.tool_for_agents import llm_content_check

        constraint_description = ""为增强投资者回报水平拟采取的措施"" # 请完整描述需要检查的内容, 不得简化
        df['meu_4_1_constraint'] = df['权益分派方案文本'].apply(
            lambda text: llm_content_check(text, constraint_description)
        )
        ```

note:
 - 理论上你撰写合规检验代码所需要的数据都可以从一致的数据中得到, 对于没有直接对应的数据你需要自己计算得到, 不要简单地认为无法完成. 
 - 除非材料提供, 否则不要主动进行简化的假设. 如果你认为所给的信息不足以判断案例的合规性, 可以在函数的结尾进行注释说明. 但这种情况应该很少出现. 

","

<CODE>
import pandas as pd
from utils.tool_for_agents import llm_content_check

def check_meu_15_1(df):
    '''
    验证上市公司在超高比例分红时的信息披露合规性
    subject: 上市公司
    condition: 现金分红≥净利润100%且≥未分配利润50%
    constraint: 需披露偿债影响、募集资金使用情况
    '''
    
    # 初始化合规标记列
    df['meu_15_1_subject'] = True  # 所有记录主体均为上市公司
    df['meu_15_1_condition'] = False
    df['meu_15_1_constraint'] = False
    df['meu_15_1_compliance'] = True  # 默认合规
    
    # 条件验证：现金分红达标
    cash_condition = (
        (df['现金分红金额'] >= df['净利润']) & 
        (df['现金分红金额'] >= df['合并报表未分配利润'] * 0.5)
    )
    df.loc[cash_condition, 'meu_15_1_condition'] = True
    
    # 约束验证：信息披露完整性
    def check_disclosure(text):
        if pd.isna(text):
            return False
        return (
            llm_content_check(text, ""是否影响偿债能力"") &
            llm_content_check(text, ""过去十二个月内是否使用过募集资金补充流动资金"") &
            llm_content_check(text, ""未来十二个月内是否计划使用募集资金补充流动资金"")
        )
    
    df.loc[cash_condition, 'meu_15_1_constraint'] = df['权益分派方案文本'].apply(check_disclosure)
    
    # 违规判定：条件触发但约束未满足
    violation_mask = (
        df['meu_15_1_subject'] & 
        df['meu_15_1_condition'] & 
        (~df['meu_15_1_constraint'])
    )
    df.loc[violation_mask, 'meu_15_1_compliance'] = False
    
    return df
</CODE>","好的，我现在需要处理这个MEU_15_1的合规性检查。首先，我得仔细理解这个MEU的内容。根据描述，主体是上市公司，条件是当权益分派方案中的现金分红金额达到或超过当期净利润的100%，并且达到或超过当期末未分配利润的50%。约束是必须同时披露是否影响偿债能力、过去十二个月是否使用募集资金补充流动资金，以及未来十二个月是否有计划使用募集资金补充流动资金。

接下来，我需要考虑如何将这些条件转化为代码。首先，处理subject部分。这里的主体是上市公司，所以每一行的数据都是针对上市公司的，可能不需要特别的判断，因为数据本身已经是针对上市公司的。但可能需要确认是否存在某些例外情况，比如是否某些行可能不是上市公司的情况？根据提供的dataframe列，似乎没有公司类型的列，所以可能默认所有行都是上市公司。因此，subject的条件可能总是满足，所以meu_15_1_subject列可能全为True。但需要确认MEU中的subject是否还有其他条件，比如是否存在某些情况下上市公司被排除的情况？比如，如果公司被ST处理？但根据现有数据，可能无法判断，所以暂时认为所有行的subject都是有效的。

接下来是condition部分。需要满足两个条件：现金分红金额 >= 当期净利润的100%，并且现金分红金额 >= 当期末未分配利润的50%。这里的当期净利润应该是指最近一期的净利润，而期末未分配利润可能是合并报表或母公司报表中的数值？需要看数据中的列。根据提供的列，有'净利润'和'合并报表未分配利润'、'母公司报表未分配利润'。这里可能需要明确MEU中的“当期末未分配利润”是指合并报表还是母公司报表。通常，权益分派可能基于母公司报表的未分配利润，但需要确认。假设这里指的是合并报表的未分配利润，或者需要同时满足两者？或者可能要看公司实际使用的是哪一个？例如，如果公司使用的是母公司报表的未分配利润进行分派，那么应该用母公司报表的数据。但MEU中的描述没有明确说明，可能需要根据实际情况处理。或者，可能MEU中的条件是两个条件中的任何一个？或者两个都必须满足？

根据MEU的描述，条件是两个条件同时满足：现金分红金额 >= 净利润的100%，并且 >= 未分配利润的50%。所以需要同时满足这两个条件。因此，在代码中需要计算这两个条件。

假设净利润是当期的净利润，比如当前行的净利润。现金分红金额是当前行的现金分红金额。未分配利润是当期末的合并报表未分配利润或者母公司报表的？可能需要进一步确认。例如，如果权益分派是基于母公司未分配利润，那么应该用母公司报表的数值。但MEU中的条件可能要求的是合并报表的未分配利润。或者，可能两种情况都需要考虑？例如，如果公司使用的是母公司报表的未分配利润，那么是否要检查母公司的数值？

这里可能需要根据实际情况处理。例如，假设当期末未分配利润指的是合并报表的，那么使用'合并报表未分配利润'列。或者，可能要看公司的分派依据，但数据中没有相关字段。这种情况下，可能需要假设使用合并报表的数据。或者，可能MEU中的条件同时要求两个未分配利润的情况？这可能需要进一步分析。

假设MEU中的条件中的未分配利润指的是合并报表的，那么条件为：

现金分红金额 >= 净利润（当期的）的100%，并且现金分红金额 >= 合并报表未分配利润的50%。

接下来，处理constraint部分。约束是必须披露三个内容：是否影响偿债能力、过去十二个月是否使用过募集资金补充流动资金、未来十二个月是否计划使用募集资金补充流动资金。这些信息需要从权益分派方案文本中提取。这时候，需要使用提供的llm_content_check函数来检查公告文本是否包含这三个内容。

所以，对于每个满足subject和condition的行，必须检查这三个披露内容是否存在。如果这三个内容都被披露了，那么constraint满足，否则不满足。

现在，分步骤处理：

1. 标记subject：所有行的subject都是上市公司，所以meu_15_1_subject列设为True。但需要确认是否存在例外情况。例如，如果某行对应的公司不是上市公司？但根据问题描述，数据中的公司都是上市公司，所以这里可能直接设为True。

2. 标记condition：计算现金分红金额是否满足两个条件。即：

condition_met = (现金分红金额 >= 净利润) & (现金分红金额 >= 合并报表未分配利润 * 0.5)

或者，可能当期的净利润可能是指母公司报表的净利润？例如，净利润列是合并报表的净利润吗？根据提供的列，有'净利润'和'母公司报表净利润'。所以需要明确MEU中的“当期净利润”指的是合并还是母公司的。例如，权益分派可能基于母公司的净利润，但MEU中的条件可能要求的是合并报表的净利润。或者，可能两种情况都需要满足？

这里可能需要根据法律条文的具体要求来判断。例如，如果权益分派方案中的现金分红金额超过母公司净利润的100%，或者合并报表的？但MEU中的条件可能指的是合并报表的净利润，因为通常财务报表以合并报表为准。或者，可能要看分红的来源。例如，分红只能来自母公司报表的未分配利润，所以净利润可能指的是母公司的净利润？

这个问题可能需要进一步分析。例如，假设MEU中的“当期净利润”指的是合并报表的净利润，那么使用'净利润'列。否则，如果是母公司的，则使用'母公司报表净利润'列。但MEU中的描述没有明确说明，所以可能需要根据常规做法处理。例如，合并报表的净利润可能更常用，所以这里使用'净利润'列。

同样，未分配利润可能指的是合并报表的，所以使用'合并报表未分配利润'列。或者，可能要看公司实际分红的来源，但数据中没有相关字段。因此，可能需要假设使用合并报表的数据。

所以，condition的条件是：

cash_dividend >= df['净利润'] 并且 cash_dividend >= df['合并报表未分配利润'] * 0.5

但需要注意，如果净利润为负怎么办？例如，如果净利润是负数，那么现金分红金额超过净利润的100%可能意味着分红金额超过一个负数，这在现实中不可能。但根据MEU的条件，只有当现金分红金额达到或超过净利润的100%时才会触发约束。如果净利润为负，那么现金分红金额不可能超过净利润的100%（因为净利润是负的，100%的净利润是更小的负数，而现金分红是正数）。所以在这种情况下，条件中的第一个条件（现金分红 >= 净利润的100%）可能自动不满足，因此整个条件不会被触发。

因此，在代码中，需要处理这种情况。例如，当净利润为负时，现金分红金额 >= 净利润的100%这个条件自动为False，所以整个条件不会被满足。

接下来，处理constraint部分。需要检查权益分派方案文本中是否同时披露了三个内容：是否影响偿债能力、过去十二个月是否使用募集资金补充流动资金、未来十二个月是否计划使用募集资金补充流动资金。因此，需要调用llm_content_check函数三次，分别检查这三个内容是否存在，并且三个结果都为True时，constraint才满足。

例如：

disclosure1 = llm_content_check(text, ""是否影响偿债能力"")
disclosure2 = llm_content_check(text, ""过去十二个月内是否使用过募集资金补充流动资金"")
disclosure3 = llm_content_check(text, ""未来十二个月内是否计划使用募集资金补充流动资金"")

valid_constraint = disclosure1 & disclosure2 & disclosure3

但需要注意，这三个内容是否在同一个描述中，或者需要分别检查。例如，可能需要三个独立的检查。

现在，将这些步骤转化为代码：

首先，处理subject：

df['meu_15_1_subject'] = True  # 因为所有行都是上市公司

然后，处理condition：

condition1 = df['现金分红金额'] >= df['净利润']
condition2 = df['现金分红金额'] >= df['合并报表未分配利润'] * 0.5
valid_condition = condition1 & condition2

但需要注意，当净利润为负时，condition1会是False，所以valid_condition自动为False。

接下来，处理constraint：

需要检查三个披露内容是否都存在。因此，对于每一行的权益分派方案文本，需要检查这三个内容是否都被包含。

这里可能需要使用三次llm_content_check调用，并将结果相与。

例如：

df['disclosure1'] = df['权益分派方案文本'].apply(lambda x: llm_content_check(x, ""是否影响偿债能力""))
df['disclosure2'] = df['权益分派方案文本'].apply(lambda x: llm_content_check(x, ""过去十二个月内是否使用过募集资金补充流动资金""))
df['disclosure3'] = df['权益分派方案文本'].apply(lambda x: llm_content_check(x, ""未来十二个月内是否计划使用募集资金补充流动资金""))

valid_constraint = df['disclosure1'] & df['disclosure2'] & df['disclosure3']

然后，将valid_constraint赋值给meu_15_1_constraint列。

最后，判断合规性：当subject和condition都为True，但constraint为False时，视为违规。即：

is_violation = (df['meu_15_1_subject'] == True) & (df['meu_15_1_condition'] == True) & (df['meu_15_1_constraint'] == False)

然后，将合规性标记为False在这些情况下，否则为True？

或者，合规性列应该标记是否满足所有条件。即，当subject和condition都满足时，必须满足constraint，否则违规。所以，合规性为True的情况是：当subject和condition都为True时，constraint也为True。否则，如果subject和condition都为True而constraint为False，则合规性为False。其他情况下，可能合规性为True或者不适用？

例如，合规性列可以这样计算：

df['meu_15_1_compliance'] = True  # 默认合规

# 当subject和condition都满足，但constraint不满足时，违规
df.loc[ (df['meu_15_1_subject'] & df['meu_15_1_condition']) & (~df['meu_15_1_constraint']), 'meu_15_1_compliance'] = False

或者，可能合规性列应该标记为True只有当所有条件都满足，否则False？或者，只有当subject和condition满足时，才需要检查constraint，否则合规性可能为N/A？

根据示例中的处理方式，示例中的合规性判断是当满足subject和condition但不满足constraint时，标记为违规。其他情况可能不标记或者视为合规？

例如，在示例代码中：

is_violation = valid_subject & valid_condition & (~valid_constraint)

然后，将meu_4_1_compliance标记为False在这些行，其他可能为True？

或者，可能合规性列是True表示合规，False表示违规，其他情况可能为NaN？或者，是否所有行都需要标记合规性？

根据示例中的处理，合规性列可能被初始化为True，然后违规的行被标记为False。或者，可能合规性列初始化为NaN，然后根据条件填充。

在示例中，代码中的合规性处理是：

df.loc[is_violation, 'meu_4_1_compliance'] = False

这可能意味着，只有违规的行被标记为False，其他行可能保持原来的值。但原示例中的代码可能没有初始化该列为True，所以需要先初始化。

例如，在示例代码中，可能先初始化meu_4_1_compliance为True，然后将违规的行设为False。或者，可能初始化为True，然后根据条件修改。

但根据示例中的代码，可能没有初始化该列，而是直接对违规的行赋值False，其他行可能保持NaN或者未被处理。这可能存在问题，所以需要正确的初始化。

因此，正确的步骤应该是：

初始化meu_15_1_compliance列为True（假设合规），然后对于违规的情况标记为False。

或者，可能合规性只有在满足subject和condition的情况下才需要检查，否则视为不适用，所以合规性列可能为NaN或者True？

这可能需要更仔细的处理。例如，合规性只有当subject和condition都满足时，才需要满足constraint。否则，合规性可能不适用，所以可以标记为True或者不处理。

根据法律合规的逻辑，只有当主体和条件都满足时，才需要遵守约束。因此，如果主体或条件不满足，那么该MEU不适用，合规性可能视为不适用，或者不需要标记。但根据示例中的处理方式，合规性列可能被标记为False只有当主体和条件满足但约束不满足时，其他情况可能保持为True或者未标记。

例如，在示例中，合规性列可能被初始化为True，然后违规的行被设为False。或者，初始化为True，然后对于满足subject和condition的行，如果约束满足则保持True，否则设为False。其他行可能保持True，但可能这并不正确，因为当subject或条件不满足时，该MEU不适用，所以合规性可能应为True（因为没有触发条件）或者不适用（即不需要检查）。

但根据示例中的代码，合规性列可能被标记为False仅当违规，其他情况可能保持原值。例如，在示例中：

df.loc[is_violation, 'meu_4_1_compliance'] = False

这可能意味着，其他行的合规性未被设置，可能保持NaN或者之前的值。这可能存在问题，所以正确的做法应该是初始化合规性列为True，然后将违规的行设为False。或者，初始化为True，然后对于满足subject和condition的行，检查约束是否满足，否则设为False。

或者，可能合规性列应该为True当且仅当：如果subject和condition都满足，那么constraint也必须满足。否则，如果subject或condition不满足，则合规性为True（因为不需要遵守约束）。

例如，合规性可以这样计算：

df['meu_15_1_compliance'] = ~(valid_subject & valid_condition & ~valid_constraint)

或者，更准确地说：

df['meu_15_1_compliance'] = True  # 默认合规

# 当subject和condition都满足，但constraint不满足时，违规
df.loc[valid_subject & valid_condition & (~valid_constraint), 'meu_15_1_compliance'] = False

这样，其他情况下，合规性为True。

现在，将这些步骤整合到代码中：

首先，初始化各列：

df['meu_15_1_subject'] = True  # 所有行都是上市公司

然后，计算condition的条件：

condition1 = df['现金分红金额'] >= df['净利润']
condition2 = df['现金分红金额'] >= df['合并报表未分配利润'] * 0.5
valid_condition = condition1 & condition2

df['meu_15_1_condition'] = valid_condition

接下来，处理constraint：

需要检查三个披露内容是否都存在。因此，使用llm_content_check三次：

targets = [
    ""是否影响偿债能力"",
    ""过去十二个月内是否使用过募集资金补充流动资金"",
    ""未来十二个月内是否计划使用募集资金补充流动资金""
]

# 初始化三个临时列
for i, target in enumerate(targets, 1):
    df[f'disclosure_{i}'] = df['权益分派方案文本'].apply(
        lambda text: llm_content_check(text, target) if pd.notnull(text) else False
    )

valid_constraint = df['disclosure_1'] & df['disclosure_2'] & df['disclosure_3']

df['meu_15_1_constraint'] = valid_constraint

然后，计算合规性：

df['meu_15_1_compliance'] = True  # 默认合规

# 当subject和condition都满足，但constraint不满足时，设为False
violation_mask = df['meu_15_1_subject'] & df['meu_15_1_condition'] & (~df['meu_15_1_constraint'])
df.loc[violation_mask, 'meu_15_1_compliance'] = False

最后，可能需要删除临时列disclosure_1, disclosure_2, disclosure_3。

但根据示例中的代码，可能不需要保留这些临时列，所以可以在计算完valid_constraint后删除它们。

或者，在代码中不创建这些临时列，而是直接计算：

valid_constraint = (
    df['权益分派方案文本'].apply(lambda x: llm_content_check(x, targets[0])) &
    df['权益分派方案文本'].apply(lambda x: llm_content_check(x, targets[1])) &
    df['权益分派方案文本'].apply(lambda x: llm_content_check(x, targets[2]))
)

但这样可能需要三次调用llm_content_check，可能效率较低。不过，在示例中，可能必须这样做。

现在，将这些步骤写入代码：

import pandas as pd
from utils.tool_for_agents import llm_content_check

def check_meu_15_1(df):
    # 初始化各列
    df['meu_15_1_subject'] = True  # 所有行都是上市公司
    
    # 处理condition
    # 现金分红金额 >= 净利润的100% 且 >= 当期末未分配利润的50%
    # 当期末未分配利润使用合并报表的数据
    condition1 = df['现金分红金额'] >= df['净利润']
    condition2 = df['现金分红金额'] >= df['合并报表未分配利润'] * 0.5
    valid_condition = condition1 & condition2
    df['meu_15_1_condition'] = valid_condition
    
    # 处理constraint
    # 需要检查三个披露内容
    targets = [
        ""是否影响偿债能力"",
        ""过去十二个月内是否使用过募集资金补充流动资金"",
        ""未来十二个月内是否计划使用募集资金补充流动资金""
    ]
    
    # 检查每个目标内容是否存在
    disclosures = []
    for target in targets:
        disclosure = df['权益分派方案文本'].apply(
            lambda text: llm_content_check(text, target) if pd.notnull(text) else False
        )
        disclosures.append(disclosure)
    
    # 所有三个披露必须存在
    valid_constraint = disclosures[0] & disclosures[1] & disclosures[2]
    df['meu_15_1_constraint'] = valid_constraint
    
    # 计算合规性
    # 默认合规
    df['meu_15_1_compliance'] = True
    
    # 当主体和条件满足但约束不满足时，违规
    violation_mask = (
        df['meu_15_1_subject'] & 
        df['meu_15_1_condition'] & 
        (~df['meu_15_1_constraint'])
    )
    df.loc[violation_mask, 'meu_15_1_compliance'] = False
    
    return df

但需要注意，当权益分派方案文本为空时，比如公司没有进行权益分派，那么现金分红金额可能为0，此时condition可能不满足，所以不会触发约束检查。但根据数据中的列，'是否进行权益分派'可能为True或False。例如，如果公司没有进行权益分派，那么现金分红金额可能为0，此时condition的两个条件可能不满足，所以valid_condition为False，因此不会触发约束检查。因此，在这种情况下，合规性不会被标记为False，因为主体和条件未同时满足。

另外，当净利润为负时，condition1自动为False，所以valid_condition为False，不会触发约束检查。

此外，当合并报表未分配利润为负时，condition2中的现金分红金额 >= 负数*0.5，这总是成立，因为现金分红金额是正数。例如，如果未分配利润为-1000元，那么50%是-500元，现金分红金额只要>= -500元就满足条件。但现金分红金额是正数，所以此时condition2自动为True。但此时，如果净利润是正数，并且现金分红金额 >= 净利润，那么condition1为True，所以valid_condition为True。这可能是一个问题，因为如果未分配利润为负，公司可能无法进行分红。但根据MEU的条件，只要现金分红金额满足这两个条件，不管未分配利润是否为负，都需要触发约束。这可能与实际法律要求不符，但根据MEU的描述，条件仅基于数值比较，而不考虑未分配利润是否为负。因此，代码需要按照MEU的条件严格处理，不管实际情况是否合理。

例如，如果公司净利润为100元，未分配利润为-200元，现金分红金额为100元。此时，condition1为True（100 >= 100），condition2为True（100 >= (-200)*0.5 → 100 >= -100，成立）。所以valid_condition为True，触发约束检查。此时，如果公司未披露三个内容，则合规性为False。这可能与实际法律冲突，但根据MEU的条件，必须这样处理。

因此，代码中的条件判断是正确的。

最后，关于未分配利润的选择，假设MEU中的当期末未分配利润指的是合并报表的，所以使用'合并报表未分配利润'列。如果实际中应该使用母公司报表的，那么需要调整代码，但根据现有数据，无法确定，所以按照MEU的描述处理。

综上，代码应该如上述所示。
","CompletionUsage(completion_tokens=5042, prompt_tokens=2041, total_tokens=7083, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=4587, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
"
# 身份
你是一个精通法律的程序员. 擅长编写代码以检验特定案例对于特定法律要求的合规性. 

## MEU概念简述
MEU (Minimum Executable Unit) 是法律条文拆解出的最小合规单元，包含：
- MEU_id: MEU的编号, 通常为""MEU_n_k"", 其中n是其所属的法条的编号, k是其在法条内部的编号
- subject: 责任主体（如""控股股东"") 
- condition: 触发条件（如""减持股份"")  
- constraint: 约束内容（如""提前15日公告"") 
- contextual_info: 补充说明（如价格计算方式）


# 任务
你现在面临一个编写代码以检验某法律事件的合规性的任务, 你需要编写一个函数, 这个函数的输入是一个日频的pandas dataframe, 每一行是在某个交易日内公司的情况和股东的情况, 这个函数会检验该dataframe的每一行在某一个给定的法律最小可执行单元上的合规性, 标注在特定的列上, 并返回标注后的dataframe. 


# 更多要求
 - 你可以进行任意长度的思考, 然后用<CODE></CODE>包裹你的代码. 
 - 你需要按照下面这个框架编写代码: 1. 标记valid的subject(meu_n_k_subject); 2. 标记valid的condition(meu_n_k_condition); 3. 标记valid的constrain(meu_n_k_constrain); 4. 在dataframe中记录subject, condition和constrain的valid情况; 5. 计算整体的违约情况并标记在dataframe上(meu_n_k_compliance). 

# example
下面是一个例子:

## 输入
法律的最小可执行单元编号: MEU_4_1
法律的最小可执行单元内容: {""subject"": ""上市公司大股东 | 董监高"", ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", ""contextual_info"": NaN}
必要的额外信息: NaN

## 输出
<CODE>
import pandas a pd

def check_meu_4_1(df):
    '''
    代码的注释要清晰, 展示你分别验证subject, condition和constrain的过程.
    ""subject"": ""上市公司大股东 | 董监高"", 
    ""condition"": ""计划通过本所集中竞价或大宗交易减持股份"", 
    ""constraint"": ""应当及时通知公司，并在首次卖出的15个交易日前向本所报告并预先披露减持计划"", 
    ""contextual_info"": NaN
    '''

    df['meu_4_2_subject'] = False  # 初始化subject列
    df['meu_4_2_condition'] = False  # 初始化condition列
    df['meu_4_2_constrain'] = False  # 初始化constrain列

    # 标记valid的subject
    is_major_shareholder = (
        df['股东身份'].isin(['控股股东', '实际控制人', '持股5%以上股东']) |
        (df['持股比例'] >= 0.05)
    )
    is_director = df['股东身份'].isin(['董监高'])
    valid_subject = is_major_shareholder | is_director

    # 标记valid的condition
    valid_condition = df['减持方式'].isin(['竞价交易', '大宗交易'])

    # 标记valid的constrain
    df['交易日差'] = (df['计划开始日'] - df['计划披露日']).dt.days
    has_plan = df['存在减持计划']
    valid_constraint = df['交易日差'] >= 15 & df['存在减持计划']

    # 标记各条件满足情况
    df.loc[valid_subject, 'meu_4_1_subject'] = True
    df.loc[valid_condition, 'meu_4_1_condition'] = True
    df.loc[valid_constraint, 'meu_4_1_constraint'] = True

    # 判断违规情况：满足主体和条件但不满足约束
    is_violation = (
        valid_subject & 
        valid_condition & 
        (~valid_constraint)
    )

    # 标记违规行
    df.loc[is_violation, 'meu_4_1_compliance'] = False

    return df

</CODE>

# 下面轮到你来完成这个任务
法律的最小可执行单元编号: MEU_14_1
法律的最小可执行单元内容: {""subject"": ""上市公司"", ""condition"": ""合并资产负债表、母公司资产负债表中本年末未分配利润均为正值且报告期内盈利，且最近连续两个会计年度经审计的下列财务报表项目金额合计占总资产的50%以上：交易性金融资产、衍生金融资产（套期保值工具除外）、债权投资、其他债权投资、其他权益工具投资、其他非流动金融资产、其他流动资产（待抵扣增值税、预缴税费、合同取得成本等与经营活动相关的资产除外），且未进行现金分红或者现金分红总额低于当年净利润50%"", ""constraint"": ""应当在权益分派方案中结合前述财务报表列报项目的具体情况说明现金分红方案确定的依据及未来增强投资者回报的规划"", ""contextual_info"": ""财务报表项目具体范围包含：交易性金融资产、衍生金融资产（套期保值工具除外）、债权投资、其他债权投资、其他权益工具投资、其他非流动金融资产、其他流动资产（待抵扣增值税、预缴税费、合同取得成本等与经营活动相关的资产除外）""}
必要的额外信息: nan


# 附加信息
## 你可以操作的dataframe的columns: 
['日期', '财务数据日期', '公告日期', '公告类型', '审计意见', '总资产', '总负债', '净资产', '资产负债率',
'交易性金融资产', '衍生金融资产', '债权投资', '其他债权投资', '其他权益工具投资', '其他非流动金融资产',
'其他流动资产', '金融资产总额', '总股本', '每股净资产', '合并报表未分配利润', '母公司报表未分配利润', '净利润',
'每股净利润', '母公司报表净利润', '经营活动现金流量净额', '投资活动现金流量净额', '筹资活动现金流量净额',
'现金及现金等价物净增加额', '净资产增长率', '净利润增长率', '资产负债率变化', '金融资产增长率',
'是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划', '现金分红金额', '送股比例', '转增比例', '是否进行权益分派', '权益分派方案文本', '公司简称']

## 其中: 
- 这是一个二维的面板数据, 根据['日期', '公司简称']可以定位到特定公司在特定日期的状态. 数据已经按照公司简称和日期排序. 
- 我们的'日期'并非连续的自然日或者交易日, 而是固定的季报/半年报/年报披露后三个月内的某一个自然日, 例如'2020-05-30', '2020-09-29', ...等, 我们假定公司在这一天发布了权益分派公告(或者决定了不进行权益分派). 每个季报/半年报/年报后只会跟随一个'日期'来决定是否进行权益分派, 如何进行分派. 
- 数据的每一行包含了两个部分的数据, 分别是当时最新的财务数据和当时最新的权益分派情况. 例如, '2020-09-17'这一行可能对应了公告日期为'2020-08-27'的截至'2020-06-30'的半年报财务报告['审计意见', '总资产', ..., '现金及现金等价物净增加额'], 以及在'2020-09-17'当天公告的权益分派信息['是否进行权益分派', ..., '现金分红金额', ...]
- 所有财务数据都是以单季度的形式记录的, 不需要考虑利润表科目在半年报和年报中逐渐累加的问题. 所有的增长率都是单季的. 
- 所有资产/价格的单位都是元而非万元, 千元或百万元; 所有的比例/比率都是小数而非百分数, 除了['送股比例', '转增比例']是""每10股送n股""的格式. 
- ['审计意见']的值有""无保留意见"", ""非标准无保留意见"", ""保留意见"". 
- 这些列为布尔值: ['是否实施现金分红', '是否实施股票股利', '是否公积金转增股本', '相关股东前三个月内存在减持情形',
'相关股东后三个月存在减持计划']

- 如果希望检查权益分派方案中是否披露了特定内容, 可以使用环境中会提供的函数`llm_content_check()`, 但非披露类的合规检查中禁止使用这个函数. 
    描述: 使用LLM检查公告中是否包含特定内容
        参数:
            announcement_text: 公告全文
            traget_content: 需要检查的内容描述
        返回:
            bool: 公告中是否包含特定内容
    调用示例: 
        ```python
        from utils.tool_for_agents import llm_content_check

        constraint_description = ""为增强投资者回报水平拟采取的措施"" # 请完整描述需要检查的内容, 不得简化
        df['meu_4_1_constraint'] = df['权益分派方案文本'].apply(
            lambda text: llm_content_check(text, constraint_description)
        )
        ```

note:
 - 理论上你撰写合规检验代码所需要的数据都可以从一致的数据中得到, 对于没有直接对应的数据你需要自己计算得到, 不要简单地认为无法完成. 
 - 除非材料提供, 否则不要主动进行简化的假设. 如果你认为所给的信息不足以判断案例的合规性, 可以在函数的结尾进行注释说明. 但这种情况应该很少出现. 

","

<CODE>
import pandas as pd
from utils.tool_for_agents import llm_content_check

def check_meu_14_1(df):
    '''
    验证上市公司在特定财务条件下的现金分红方案披露合规性
    ""subject"": ""上市公司"", 
    ""condition"": ""合并及母公司未分配利润为正+连续两年金融资产占比超50%+现金分红不足净利润50%"", 
    ""constraint"": ""需在权益分派方案中说明依据及回报规划"", 
    ""contextual_info"": ""金融资产范围包含交易性金融资产等7项（特定项目除外）""
    '''
    # 初始化标记列
    df['meu_14_1_subject'] = True  # 所有行均为上市公司
    df['meu_14_1_condition'] = False
    df['meu_14_1_constraint'] = True
    df['meu_14_1_compliance'] = True

    # 预处理：按公司分组并计算历史数据
    df_sorted = df.sort_values(['公司简称', '财务数据日期'])
    grouped = df_sorted.groupby('公司简称')

    # 计算前一年度财务指标
    financial_columns = ['总资产', '交易性金融资产', '衍生金融资产', '债权投资', '其他债权投资',
                        '其他权益工具投资', '其他非流动金融资产', '其他流动资产']
    for col in financial_columns:
        df_sorted[f'prev_{col}'] = grouped[col].shift(1)

    # 合并回原始索引顺序
    df = df_sorted.reset_index(drop=True).reindex(df.index)

    # 条件验证逻辑
    # 1. 基础财务条件
    is_annual = df['财务数据日期'].dt.month == 12
    profit_condition = (
        (df['合并报表未分配利润'] > 0) &
        (df['母公司报表未分配利润'] > 0) &
        (df['净利润'] > 0)
    )

    # 2. 金融资产占比条件
    current_fa = (
        df['交易性金融资产'] + 
        df['衍生金融资产'] +  # 假设已排除套期工具
        df['债权投资'] +
        df['其他债权投资'] +
        df['其他权益工具投资'] +
        df['其他非流动金融资产'] +
        df['其他流动资产']  # 假设已排除特定项目
    )
    prev_fa = (
        df['prev_交易性金融资产'] + 
        df['prev_衍生金融资产'] +
        df['prev_债权投资'] +
        df['prev_其他债权投资'] +
        df['prev_其他权益工具投资'] +
        df['prev_其他非流动金融资产'] +
        df['prev_其他流动资产']
    )
    fa_ratio_condition = (
        (current_fa / df['总资产'] >= 0.5) &
        (prev_fa / df['prev_总资产'] >= 0.5) &
        df['prev_总资产'].notna()
    )

    # 3. 现金分红条件
    dividend_condition = (
        ~df['是否实施现金分红'] | 
        (df['现金分红金额'] < df['净利润'] * 0.5)
    )

    # 综合条件判断
    valid_condition = (
        is_annual &
        profit_condition &
        fa_ratio_condition &
        dividend_condition
    )
    df['meu_14_1_condition'] = valid_condition

    # 约束条件验证
    constraint_desc = ""结合前述财务报表列报项目的具体情况说明现金分红方案确定的依据及未来增强投资者回报的规划""
    need_check = valid_condition & df['是否进行权益分派']
    df.loc[need_check, 'meu_14_1_constraint'] = df.loc[need_check, '权益分派方案文本'].apply(
        lambda x: llm_content_check(x, constraint_desc) if pd.notnull(x) else False
    )

    # 合规性判定
    violation_mask = df['meu_14_1_subject'] & df['meu_14_1_condition'] & ~df['meu_14_1_constraint']
    df.loc[violation_mask, 'meu_14_1_compliance'] = False

    return df
</CODE>","好的，我现在需要处理这个MEU_14_1的合规性检查。首先，我得仔细理解这个MEU的内容。根据提供的JSON，主体是上市公司，条件有几个部分，约束是要求权益分派方案中说明依据和规划。

首先，处理subject部分。MEU的subject是“上市公司”，所以所有行的subject都应该有效，因为数据中的每一行都是针对上市公司的。所以这里可能不需要特别的判断，直接标记为True。不过可能需要确认数据中的公司是否都是上市公司，但根据问题描述，数据中的公司简称应该都是上市公司，所以这一步可能直接设为True。

接下来是condition部分。条件分为几个部分：

1. 合并资产负债表和母公司资产负债表中本年末未分配利润均为正值，且报告期内盈利。这需要检查合并报表未分配利润和母公司报表未分配利润是否都大于0，同时净利润是否为正。可能还要看审计意见是否为无保留意见？不过MEU的条件里没有提到审计意见，所以可能不需要考虑。但需要确认“报告期内盈利”是否指净利润为正。是的，所以需要净利润>0。

2. 最近连续两个会计年度经审计的财务报表项目金额合计占总资产的50%以上。这些项目包括交易性金融资产、衍生金融资产（套期保值工具除外）等。需要计算这些项目的总和，然后看是否占总资产的50%以上。这里需要注意的是，是否是两个连续年度的数据？比如当前年度和上一年度的数据？但数据中的财务数据日期可能是一个季度或年度报告的数据。可能需要确认如何获取连续两个会计年度的数据。但根据数据中的列，可能每个行的财务数据日期对应的是最近的两个年度？或者需要跨行比较？这可能比较复杂。例如，当前行的财务数据日期是2023年的年报，那么需要检查2023和2022年的数据。但数据中的每一行可能对应不同的财务报告期，所以可能需要跨行找到前一年的数据来计算总和。这可能比较困难，因为数据是按日期和公司简称排列的，但每个日期对应的是某个报告期的数据。例如，某一行是2023-05-30，对应的财务数据日期是2023-03-31（一季报），而另一行可能是2023-08-30对应的半年报。但MEU的条件是连续两个会计年度，所以可能需要年报的数据。因此，可能需要确保财务数据日期是年度报告，并且连续两年的数据满足条件。但数据中的财务数据日期可能包含季度数据，这可能需要处理。例如，如何确定当前行是否是年报的数据？或者是否所有行都是年报的数据？根据附加信息中的说明，每个季报/年报后三个月内有一个日期来决定权益分派。所以可能每个公司的行对应的是年报、半年报、季报后的日期。但MEU的条件是连续两个会计年度，所以可能需要两年的年报数据。例如，当前行的财务数据日期是2022年的年报，那么需要前一年（2021年）的年报数据。但如何获取前一年的数据呢？这可能需要在数据框中按公司分组，然后对于每一行，找到前一年的年报数据来计算总和。这可能比较复杂，因为需要跨行查找。例如，对于某公司当前行的财务数据日期是2022-12-31（年报），那么需要找到同一公司前一年的年报数据，即2021-12-31的数据。如果存在这样的数据，那么计算这两个年度的相关项目的总和，然后除以总资产的总和是否超过50%。这可能涉及到对每个公司的数据按时间排序，并找到前一年的数据。这可能比较复杂，但根据问题描述，数据已经按公司简称和日期排序，所以可能需要使用groupby和shift等方法。例如，对于每个公司，按财务数据日期排序，然后计算当前年和上一年的总和。但需要注意，财务数据日期可能不是年度数据，比如季报的数据可能不符合条件。因此，可能需要先筛选出年报的数据行，或者假设每个权益分派决策都是基于年报的数据。这可能是一个问题，因为MEU的条件是“最近连续两个会计年度”，所以必须使用年报的数据。因此，可能需要检查当前行的财务数据是否是年报的数据。例如，财务数据日期的月份是否为12月（年报通常是在12月结束）。例如，如果财务数据日期是2022-12-31，则是年报；如果是2022-06-30，则是半年报。但MEU的条件是会计年度，所以可能半年报的数据不适用。因此，可能需要过滤出年报的数据行，否则无法满足条件。这可能意味着，对于非年报的数据行，条件部分自动不满足。或者，可能数据中的每一行都是年报后的权益分派决策，所以财务数据日期都是年报的。但问题描述中提到，数据中的日期是季报/半年报/年报披露后的三个月内的日期，所以可能存在不同报告期的数据。因此，可能需要处理这种情况，即只有当财务数据日期对应的报告期是年报时，才进行条件判断，否则条件不满足。或者，可能MEU的条件中的“最近连续两个会计年度”指的是最近两个完整的会计年度，无论当前报告期是什么。例如，如果当前是2023年半年报，那么最近两个会计年度是2022和2021年的年报数据。但如何获取这些数据呢？这可能需要跨行查找同一公司的年报数据。这可能比较复杂，但根据问题描述，数据中的每一行可能包含当时的财务数据，所以可能需要遍历每个公司的历史数据。例如，对于当前行，财务数据日期是2023-06-30（半年报），那么需要找到该公司2022-12-31和2021-12-31的年报数据中的相关项目。如果这些数据存在，则计算总和。否则，条件不满足。这可能非常复杂，因为需要跨行获取数据。但问题描述中提到，数据已经按公司简称和日期排序，所以可能可以通过分组和滚动窗口来处理。例如，对于每个公司，按财务数据日期排序，然后找到前两个年报的数据。这可能涉及到识别哪些财务数据日期是年报的（比如月份是12月的），然后取最近的两个。例如，对于某公司，当前行的财务数据日期是2023-06-30，那么最近的两个年报可能是2022-12-31和2021-12-31。需要检查这两个年报的数据是否存在，并计算它们的相关项目总和。如果存在，则计算总和占总资产的比例。否则，条件不满足。这可能比较复杂，但可能需要这样做。或者，可能问题中的条件中的“最近连续两个会计年度”指的是当前财务数据日期所在的会计年度和前一个会计年度，而不管当前报告期是年报还是其他。例如，如果当前行的财务数据日期是2023-06-30（半年报），那么会计年度是2023年，前一个是2022年。需要这两个会计年度的年报数据中的相关项目。但如何获取这些数据呢？可能无法直接获取，因为当前行可能只有半年报的数据。因此，可能只有当当前行的财务数据日期是年报时，才能满足条件。否则，条件不满足。这可能是一个合理的假设，因为只有年报的数据才能完整反映整个会计年度的情况。因此，在代码中可能需要首先检查财务数据日期是否是年报（即月份是否为12月），否则条件不满足。这可能是一个关键点。例如，如果财务数据日期不是12月31日，则条件中的“最近连续两个会计年度”无法满足，因此条件部分自动为False。这可能是一个合理的处理方式。因此，在代码中，首先需要确定当前行的财务数据是否是年报数据。如果是，则继续处理；否则，条件不满足。这可能是一个必要的步骤。例如，在代码中，可以提取财务数据日期的月份是否为12月，并且是否为年度报告（比如，如果是年报，可能财务数据日期是12月31日）。因此，在代码中，可以添加一个条件：财务数据日期是否为年末（如月份为12月）。如果是，则继续处理；否则，条件不满足。这可能是一个关键点。例如，在代码中：

is_annual_report = (df['财务数据日期'].dt.month == 12) & (df['财务数据日期'].dt.day == 31)

然后，只有满足is_annual_report的行，才继续处理条件中的其他部分。否则，条件部分为False。

接下来，处理条件中的第一部分：合并和母公司未分配利润均为正值，且报告期内盈利。即：

合并报表未分配利润 > 0，且母公司报表未分配利润 > 0，且净利润 > 0。

所以这部分的条件是：

condition_part1 = (df['合并报表未分配利润'] > 0) & (df['母公司报表未分配利润'] > 0) & (df['净利润'] > 0)

但需要注意，净利润可能指的是合并报表的净利润，还是母公司的？根据MEU的条件中的描述，“报告期内盈利”可能指的是合并报表的净利润，或者母公司报表的净利润？根据条件中的描述，“合并资产负债表、母公司资产负债表中本年末未分配利润均为正值且报告期内盈利”，这里的“报告期内盈利”可能指的是合并报表和母公司报表的净利润均为正？或者只是合并报表的净利润？需要仔细看条件。原条件中的描述是：“合并资产负债表、母公司资产负债表中本年末未分配利润均为正值且报告期内盈利”，这里的“报告期内盈利”可能指的是合并报表和母公司报表各自的净利润均为正。或者可能指的是整个公司报告期内盈利，即合并报表的净利润为正。这可能需要进一步分析。例如，原条件中的结构是：

合并资产负债表和母公司资产负债表中本年末未分配利润均为正值，并且报告期内盈利。这里的“报告期内盈利”可能是指合并报表的净利润为正。或者可能是指两个报表的净利润均为正？这可能需要更仔细的理解。例如，原条件中的“且报告期内盈利”可能是指整个公司（合并报表）在报告期内盈利。因此，可能只需要合并报表的净利润>0。或者，可能同时需要母公司报表的净利润>0？这可能需要根据法律条文的具体要求来判断。但根据MEU的条件描述，可能这里的“报告期内盈利”指的是合并报表的净利润为正。因此，条件的第一部分应为：

合并报表未分配利润 > 0，母公司报表未分配利润 > 0，且合并报表的净利润 > 0。或者，可能母公司报表的净利润也需要>0？这可能需要更仔细的分析。例如，原条件中的“合并资产负债表、母公司资产负债表中本年末未分配利润均为正值且报告期内盈利”可能意味着：

- 合并资产负债表的未分配利润正值；
- 母公司资产负债表的未分配利润正值；
- 报告期内（合并报表）盈利；
或者，可能报告期内盈利指的是合并和母公司都盈利？

这可能需要根据法律条文的理解。例如，如果原条件中的“报告期内盈利”指的是合并报表的净利润为正，那么条件的第一部分应为：

(合并未分配利润 >0) & (母公司未分配利润 >0) & (净利润 >0)

其中，净利润是合并报表的净利润。或者，如果母公司报表的净利润也需要为正，那么可能还需要检查母公司报表的净利润。但根据数据中的列，有“母公司报表净利润”这一列。因此，可能需要同时满足合并和母公司报表的净利润为正。例如：

condition_part1 = (df['合并报表未分配利润'] > 0) & (df['母公司报表未分配利润'] > 0) & (df['净利润'] > 0) & (df['母公司报表净利润'] > 0)

这可能更符合条件中的描述。但原条件中的“报告期内盈利”是否指的是合并和母公司都盈利？或者只是合并？这可能需要进一步确认。例如，原条件中的“报告期内盈利”可能指的是公司整体盈利，即合并报表的净利润为正。因此，可能只需要合并报表的净利润>0。但原条件中的结构是“合并资产负债表、母公司资产负债表中本年末未分配利润均为正值且报告期内盈利”，这里的“且”可能连接的是两个条件：未分配利润均为正值，并且报告期内盈利。这里的“报告期内盈利”可能指的是整个公司（合并报表）的净利润为正。因此，条件的第一部分应为：

(合并未分配利润 >0) & (母公司未分配利润 >0) & (净利润 >0)

其中，净利润是合并报表的净利润。这可能更合理。

接下来，条件的第二部分是最近连续两个会计年度经审计的财务报表项目金额合计占总资产的50%以上。这里的财务报表项目包括交易性金融资产、衍生金融资产（套期保值工具除外）、债权投资、其他债权投资、其他权益工具投资、其他非流动金融资产、其他流动资产（扣除特定项目）。需要计算这些项目的总和，然后看是否占总资产的50%以上。并且是最近连续两个会计年度的总和。例如，当前会计年度和上一个会计年度的总和。但如何计算这两个年度的总和？

假设当前行的财务数据日期是2022-12-31（年报），那么需要计算2022年和2021年的相关项目的总和，然后除以这两个年度的总资产之和是否超过50%。或者，是否是每个年度的项目金额占总资产的比例均超过50%？或者两个年度的总和占总资产的比例？原条件中的描述是“最近连续两个会计年度经审计的下列财务报表项目金额合计占总资产的50%以上”，这里的“合计”可能指的是两个会计年度的项目金额之和占总资产之和的50%以上。或者，每个会计年度的项目金额占该年度总资产的50%以上？这需要明确。例如，原条件中的“金额合计”可能是指每个会计年度的金额合计占总资产的比例，并且连续两个会计年度均满足。或者，两个会计年度的金额合计之和占总资产之和的50%以上。这需要仔细分析。例如，原条件中的描述是“最近连续两个会计年度经审计的下列财务报表项目金额合计占总资产的50%以上”，这里的“合计”可能是指每个会计年度的金额合计占该年度总资产的50%以上，并且这两个会计年度都满足。或者，两个会计年度的金额总和占两个会计年度总资产总和的50%以上。例如，假设2021年的项目金额是A1，总资产是B1；2022年的项目金额是A2，总资产是B2。那么条件是否要求（A1 + A2）/(B1 + B2) >= 0.5？或者，每个年度的A/B >=0.5？

根据原条件中的描述，“金额合计占总资产的50%以上”，这里的“合计”可能是指每个会计年度的金额合计占该会计年度总资产的50%以上。因此，需要每个会计年度都满足该条件。例如，连续两个会计年度中，每个年度的相关项目金额占该年度总资产的50%以上。这可能更符合法律条文的要求。因此，需要检查最近两个会计年度的每个年度的相关项目金额是否占该年度总资产的50%以上。例如，对于当前行对应的会计年度（比如2022年），需要检查2022年和2021年的每个年度的相关项目金额是否占各自总资产的50%以上。这可能更合理。因此，在代码中，需要获取当前会计年度和前一个会计年度的数据，并分别计算每个年度的比例是否>=0.5。

但如何获取前一个会计年度的数据呢？例如，当前行的财务数据日期是2022-12-31，那么前一个会计年度是2021-12-31。需要找到同一公司的该年度的数据行。这可能涉及到对数据框进行分组和排序，然后使用shift操作来获取前一年的数据。例如，按公司分组，按财务数据日期排序，然后对于每个公司的每一行，找到前一年的数据。如果存在，则计算两个年度的比例是否都>=0.5。否则，条件不满足。

这可能比较复杂，但可以尝试以下步骤：

1. 筛选出年报数据行：财务数据日期为年末（如12月31日）。
2. 对每个公司，按财务数据日期排序。
3. 对于每个公司的每一行，检查是否存在前一年的年报数据。
4. 如果存在，则计算当前年和前一年的相关项目金额占总资产的比例是否都>=0.5。
5. 如果两个年度的比例都>=0.5，则满足条件的第二部分。

例如，在代码中：

# 筛选年报数据
is_annual = df['财务数据日期'].dt.month == 12
df_annual = df[is_annual].copy()

# 按公司和财务数据日期排序
df_sorted = df_annual.sort_values(['公司简称', '财务数据日期'])

# 计算每个公司的前一年财务数据
# 使用shift(1)来获取前一年的数据
# 但需要确保同一公司内的数据按年份递增排列
df_sorted['prev_总资产'] = df_sorted.groupby('公司简称')['总资产'].shift(1)
df_sorted['prev_交易性金融资产'] = df_sorted.groupby('公司简称')['交易性金融资产'].shift(1)
# 同理处理其他相关项目...

这可能比较繁琐，因为需要为每个相关项目创建前一年的列。或者，可以合并当前年和前一年的数据，然后进行计算。

或者，可以对于每一行，找到同一公司前一年的年报数据，并计算相关项目的比例。例如：

对于当前行，公司为A，财务数据日期为2022-12-31，那么找到公司A在2021-12-31的数据行。如果存在，则计算当前年和前一年的比例。

这可能通过合并同一公司的不同年份的数据来实现。例如，为每个公司生成一个包含当前年和前一年数据的DataFrame。

但考虑到数据可能很大，这种方法可能效率不高。因此，可能需要使用groupby和shift来获取前一年的数据。

例如，在代码中：

# 按公司分组，并按财务数据日期升序排列
grouped = df.sort_values(['公司简称', '财务数据日期']).groupby('公司简称')

# 对于每个公司，计算前一年的相关字段
df['prev_总资产'] = grouped['总资产'].shift(1)
df['prev_交易性金融资产'] = grouped['交易性金融资产'].shift(1)
# 同理处理其他相关项目...

然后，对于当前行，如果存在prev_总资产（即前一年的数据存在），则计算当前年和前一年的相关项目金额占总资产的比例是否都>=0.5。

例如：

current_year_ratio = (交易性金融资产 + 衍生金融资产（套期保值工具除外） + ... ) / 总资产 >= 0.5
prev_year_ratio = (prev_交易性金融资产 + prev_衍生金融资产（套期保值工具除外） + ... ) / prev_总资产 >= 0.5

condition_part2 = current_year_ratio & prev_year_ratio

但需要注意，衍生金融资产需要排除套期保值工具。但数据中的“衍生金融资产”是否已经排除了套期保值工具？根据数据列的描述，可能“衍生金融资产”列已经排除了套期保值工具，或者需要另外处理。例如，原条件中的“衍生金融资产（套期保值工具除外）”可能需要从衍生金融资产中减去套期保值工具的部分。但数据中是否有这个信息？根据提供的列，可能没有单独的套期保值工具数据，因此可能无法准确计算。这可能是一个问题。例如，数据中的“衍生金融资产”列是否已经扣除了套期保值工具？如果无法确定，可能需要假设该列已经正确排除了套期保值工具，或者无法满足条件。因此，在代码中，可能需要直接使用“衍生金融资产”列的值，因为无法进一步拆分。这可能是一个限制，但根据问题描述，可能需要这样处理。

因此，相关项目的总和计算如下：

current_year_sum = (df['交易性金融资产'] 
                    + df['衍生金融资产']  # 假设已经排除了套期保值工具
                    + df['债权投资']
                    + df['其他债权投资']
                    + df['其他权益工具投资']
                    + df['其他非流动金融资产']
                    + (df['其他流动资产'] - 扣除项)) 

但扣除项如待抵扣增值税、预缴税费、合同取得成本等与经营活动相关的资产，这部分如何计算？数据中的“其他流动资产”是否已经扣除了这些项目？或者是否有其他列可以获取这些扣除项？根据提供的列，可能没有这些扣除项的数据，因此无法准确计算。这可能是一个问题。例如，原条件中的其他流动资产需要扣除这些项目，但数据中没有这些具体项目的列，因此无法计算。这可能意味着，无法准确判断这一部分的条件，因此可能需要在代码中注释说明，或者假设其他流动资产全部属于需要计算的类别，或者无法满足条件。这可能是一个需要处理的问题。

根据问题描述中的note：“理论上你撰写合规检验代码所需要的数据都可以从一致的数据中得到，对于没有直接对应的数据你需要自己计算得到，不要简单地认为无法完成。” 因此，可能需要找到替代的方法。例如，可能数据中的“其他流动资产”列已经排除了这些扣除项，或者这些扣除项的数据不存在，因此无法处理。这可能意味着，该条件无法完全准确判断，但根据问题描述，必须编写代码，因此可能需要假设其他流动资产全部属于需要计算的类别，或者忽略扣除项，直接使用其他流动资产的值。这可能不符合法律条文的要求，但根据现有数据，只能这样处理。因此，在代码中，其他流动资产的值直接使用，不进行扣除。这可能是一个错误，但根据现有数据，无法处理扣除项，因此只能这样处理。或者，可能问题中的“其他流动资产”列已经排除了这些扣除项，因此可以直接使用。例如，可能数据中的“其他流动资产”已经排除了待抵扣增值税、预缴税费、合同取得成本等与经营活动相关的资产。因此，在代码中，可以直接使用该列的值。因此，相关项目的总和计算为：

current_year_sum = (df['交易性金融资产'] 
                    + df['衍生金融资产'] 
                    + df['债权投资']
                    + df['其他债权投资']
                    + df['其他权益工具投资']
                    + df['其他非流动金融资产']
                    + df['其他流动资产'])

然后，current_year_ratio = current_year_sum / df['总资产'] >= 0.5

同理，前一年的总和：

prev_year_sum = (df['prev_交易性金融资产'] 
                + df['prev_衍生金融资产'] 
                + df['prev_债权投资']
                + df['prev_其他债权投资']
                + df['prev_其他权益工具投资']
                + df['prev_其他非流动金融资产']
                + df['prev_其他流动资产'])

prev_year_ratio = prev_year_sum / df['prev_总资产'] >= 0.5

然后，condition_part2 = current_year_ratio & prev_year_ratio

但需要确保前一年的数据存在。例如，如果prev_总资产是NaN，则prev_year_ratio为False。

接下来，条件的第三部分是未进行现金分红或者现金分红总额低于当年净利润的50%。即：

现金分红金额 < 净利润 * 0.5 或者 是否实施现金分红为False。

所以，这部分的条件是：

condition_part3 = (~df['是否实施现金分红']) | (df['现金分红金额'] < df['净利润'] * 0.5)

综合以上三个部分，整个条件部分的条件是：

valid_condition = condition_part1 & condition_part2 & condition_part3

但需要注意，只有年报的数据行才会进行这些条件的判断。否则，条件部分自动为False。例如，如果当前行的财务数据日期不是年报，则条件不满足。

接下来是约束部分。约束是“应当在权益分派方案中结合前述财务报表列报项目的具体情况说明现金分红方案确定的依据及未来增强投资者回报的规划”。这需要检查权益分派方案文本中是否包含这些说明。根据附加信息中的说明，可以使用llm_content_check函数。因此，在约束部分，需要调用该函数来检查权益分派方案文本是否包含所需内容。

因此，约束的有效性取决于：

1. 是否进行了权益分派（即“是否进行权益分派”为True）。
2. 如果进行了权益分派，则检查方案文本是否包含所需内容。

或者，无论是否进行权益分派，只要满足条件，就需要在方案中说明。例如，如果公司满足条件，但未进行权益分派，是否需要说明？根据约束的描述，“应当在权益分派方案中结合前述情况说明...”，所以只有当公司进行权益分派时，才需要说明。如果公司未进行权益分派，可能不需要说明。或者，可能无论是否进行分派，只要满足条件，就需要在方案中说明。例如，如果公司决定不进行分派，但满足条件，是否需要说明？这可能需要更仔细的理解。原约束的描述是“应当在权益分派方案中结合前述财务报表列报项目的具体情况说明现金分红方案确定的依据及未来增强投资者回报的规划”。因此，只有当公司有权益分派方案时（即“是否进行权益分派”为True），才需要满足该约束。如果公司不进行权益分派，则约束可能不适用。因此，约束的有效性判断可能分为两种情况：

- 如果公司进行了权益分派（“是否进行权益分派”为True），则需要检查方案文本是否包含所需内容。
- 如果公司未进行权益分派，则约束自动满足（或者不需要检查）。

但根据法律条文，可能即使公司未进行权益分派，但满足条件，也需要在方案中说明。例如，公司决定不进行现金分红，但满足条件，因此需要在权益分派方案中说明原因和规划。因此，无论是否进行分派，只要满足条件，就需要在方案中说明。因此，约束的有效性判断是：当条件满足时，必须检查方案文本是否包含所需内容。否则，约束不适用。

因此，在代码中，约束的有效性判断是：

如果条件满足（即valid_condition为True），则需要检查权益分派方案文本是否包含所需内容。否则，约束自动满足（或者不适用）。

因此，约束的有效性为：

valid_constraint = True  # 默认情况

# 当条件满足时，检查方案文本
mask = valid_condition & df['是否进行权益分派']
constraint_description = ""结合前述财务报表列报项目的具体情况说明现金分红方案确定的依据及未来增强投资者回报的规划""
df.loc[mask, 'meu_14_1_constraint'] = df.loc[mask, '权益分派方案文本'].apply(
    lambda text: llm_content_check(text, constraint_description) if pd.notnull(text) else False
)

# 如果条件满足但未进行权益分派，是否需要处理？例如，是否需要说明？
这可能取决于法律条文的具体要求。例如，如果公司满足条件但未进行权益分派，是否需要说明？原约束的描述是“应当在权益分派方案中...”，所以如果公司没有权益分派方案（即未进行分派），则可能不需要说明。因此，只有当公司进行权益分派时，才需要检查约束。因此，在代码中，只有当valid_condition为True且公司进行了权益分派时，才需要检查约束。否则，约束自动满足（例如，当公司未进行分派时，约束不适用，因此视为满足）。

综上，约束的有效性判断为：

valid_constraint = True  # 默认情况下为True，除非条件满足且进行了分派但未满足内容检查

但需要具体处理：

对于所有行，初始时设置meu_14_1_constraint为True。

然后，对于满足条件的行（valid_condition为True）且进行了权益分派的行，检查方案文本是否包含所需内容。如果包含，则constraint为True；否则为False。

对于其他情况（如未进行分派或条件不满足），constraint为True（视为满足约束）。

或者，可能当条件满足时，无论是否进行分派，都需要在方案中说明。例如，如果公司满足条件但未进行分派，是否需要在方案中说明？这可能取决于法律条文。例如，原约束的描述是“应当在权益分派方案中...”，所以如果公司没有权益分派方案（即未进行分派），则可能不需要说明。因此，只有当公司进行分派时，才需要检查约束。因此，在代码中：

valid_constraint = True  # 默认情况下为True

mask = valid_condition & df['是否进行权益分派']
df.loc[mask, 'meu_14_1_constraint'] = df.loc[mask, '权益分派方案文本'].apply(
    lambda text: llm_content_check(text, constraint_description) if pd.notnull(text) else False
)

对于mask为True的行，如果方案文本检查通过，则constraint为True，否则为False。其他情况下，constraint为True。

这可能更合理。

现在，将各部分整合到代码中：

首先，处理subject：

因为subject是“上市公司”，而数据中的每一行都是上市公司，所以meu_14_1_subject列全部为True。

然后，处理condition：

需要满足三个部分的条件，并且是年报数据。

处理constraint：

当条件满足且进行了权益分派时，检查方案文本。

最后，整体的合规性判断是：当subject、condition为True，但constraint为False时，视为违规。

因此，合规性列的计算是：

df['meu_14_1_compliance'] = True  # 默认合规

# 违规情况：满足subject和condition，但constraint不满足
is_violation = (df['meu_14_1_subject'] == True) & (df['meu_14_1_condition'] == True) & (df['meu_14_1_constraint'] == False)
df.loc[is_violation, 'meu_14_1_compliance'] = False

现在，编写代码：

首先，初始化各列：

df['meu_14_1_subject'] = True  # 所有行都是上市公司

然后，处理condition：

valid_condition = False

步骤：

1. 检查是否为年报数据：
is_annual = df['财务数据日期'].dt.month == 12

2. 检查条件第一部分：
condition_part1 = (df['合并报表未分配利润'] > 0) & (df['母公司报表未分配利润'] > 0) & (df['净利润'] > 0)

3. 处理条件第二部分：需要连续两个会计年度的数据

这部分比较复杂，需要获取前一年的数据。例如，按公司分组，获取前一年的相关字段：

# 按公司分组，并按财务数据日期排序
df_sorted = df.sort_values(['公司简称', '财务数据日期'])
grouped = df_sorted.groupby('公司简称')

# 计算前一年的各字段
prev_cols = ['总资产', '交易性金融资产', '衍生金融资产', '债权投资', '其他债权投资', '其他权益工具投资', '其他非流动金融资产', '其他流动资产']
for col in prev_cols:
    df_sorted[f'prev_{col}'] = grouped[col].shift(1)

# 计算当前年和前一年的总和
current_sum = (df_sorted['交易性金融资产'] + df_sorted['衍生金融资产'] + df_sorted['债权投资'] 
               + df_sorted['其他债权投资'] + df_sorted['其他权益工具投资'] + df_sorted['其他非流动金融资产'] 
               + df_sorted['其他流动资产'])
prev_sum = (df_sorted['prev_交易性金融资产'] + df_sorted['prev_衍生金融资产'] + df_sorted['prev_债权投资'] 
            + df_sorted['prev_其他债权投资'] + df_sorted['prev_其他权益工具投资'] + df_sorted['prev_其他非流动金融资产'] 
            + df_sorted['prev_其他流动资产'])

current_ratio = current_sum / df_sorted['总资产']
prev_ratio = prev_sum / df_sorted['prev_总资产']

condition_part2 = (current_ratio >= 0.5) & (prev_ratio >= 0.5)

但需要确保前一年的数据存在，即prev_总资产不为NaN。例如：

condition_part2 = (current_ratio >= 0.5) & (prev_ratio >= 0.5) & (~df_sorted['prev_总资产'].isna())

然后，条件第三部分：

condition_part3 = (~df_sorted['是否实施现金分红']) | (df_sorted['现金分红金额'] < df_sorted['净利润'] * 0.5)

综合条件：

valid_condition = is_annual & condition_part1 & condition_part2 & condition_part3

但需要将df_sorted的索引与原始df对齐，这可能存在问题，因为df_sorted是排序后的数据。因此，可能需要将处理后的结果合并回原始df。或者，直接在原始df上进行处理。这可能比较复杂，因为shift操作在分组后可能索引顺序不同。

这可能是一个难点。例如，原始df的索引可能不是按公司简称和财务数据日期排序的，因此在处理时可能需要先排序，处理后再恢复原始顺序。或者，假设数据已经按公司简称和日期排序，因此可以直接使用shift。

或者，直接在原始df上进行分组和shift：

# 按公司分组，并按财务数据日期排序
df['prev_总资产'] = df.groupby('公司简称')['总资产'].shift(1)
# 同理处理其他prev_字段

然后，计算current_sum和prev_sum：

current_sum = (df['交易性金融资产'] + df['衍生金融资产'] + df['债权投资'] 
               + df['其他债权投资'] + df['其他权益工具投资'] + df['其他非流动金融资产'] 
               + df['其他流动资产'])
prev_sum = (df['prev_交易性金融资产'] + df['prev_衍生金融资产'] + df['prev_债权投资'] 
            + df['prev_其他债权投资'] + df['prev_其他权益工具投资'] + df['prev_其他非流动金融资产'] 
            + df['prev_其他流动资产'])

current_ratio = current_sum / df['总资产']
prev_ratio = prev_sum / df['prev_总资产']

condition_part2 = (current_ratio >= 0.5) & (prev_ratio >= 0.5) & (~df['prev_总资产'].isna())

然后，条件部分：

valid_condition = (
    (df['财务数据日期'].dt.month == 12) &  # 年报数据
    (df['合并报表未分配利润'] > 0) & 
    (df['母公司报表未分配利润'] > 0) & 
    (df['净利润'] > 0) & 
    condition_part2 & 
    (~df['是否实施现金分红'] | (df['现金分红金额'] < df['净利润'] * 0.5))
)

然后，标记condition列：

df['meu_14_1_condition'] = valid_condition

接下来处理constraint：

constraint_description = ""结合前述财务报表列报项目的具体情况说明现金分红方案确定的依据及未来增强投资者回报的规划""

# 初始化为True
df['meu_14_1_constraint'] = True

# 当条件满足且进行权益分派时，检查方案文本
mask = valid_condition & df['是否进行权益分派']
df.loc[mask, 'meu_14_1_constraint'] = df.loc[mask, '权益分派方案文本'].apply(
    lambda text: llm_content_check(text, constraint_description) if pd.notnull(text) else False
)

最后，计算合规性：

df['meu_14_1_compliance'] = True
is_violation = df['meu_14_1_subject'] & df['meu_14_1_condition'] & (~df['meu_14_1_constraint'])
df.loc[is_violation, 'meu_14_1_compliance'] = False

综上，整合代码：

需要注意的是，在计算prev_字段时，必须确保按公司分组并按财务数据日期排序，否则shift(1)可能获取不到正确的前一年数据。因此，在代码中，可能需要先对数据进行排序，处理后再恢复原始顺序。例如：

def check_meu_14_1(df):
    # 复制df以避免修改原数据
    df = df.copy()
    
    # 初始化各列
    df['meu_14_1_subject'] = True  # 所有行都是上市公司
    df['meu_14_1_condition'] = False
    df['meu_14_1_constraint'] = True
    df['meu_14_1_compliance'] = True
    
    # 处理条件部分
    # 1. 检查是否为年报数据
    is_annual = df['财务数据日期'].dt.month == 12
    
    # 2. 条件第一部分：未分配利润和盈利
    condition_part1 = (
        (df['合并报表未分配利润'] > 0) & 
        (df['母公司报表未分配利润'] > 0) & 
        (df['净利润'] > 0)
    )
    
    # 3. 条件第二部分：连续两年相关项目占比
    # 按公司分组并按财务数据日期排序
    df_sorted = df.sort_values(['公司简称', '财务数据日期'])
    grouped = df_sorted.groupby('公司简称')
    
    # 计算前一年的相关字段
    prev_cols = ['总资产', '交易性金融资产', '衍生金融资产', '债权投资', '其他债权投资', 
                 '其他权益工具投资', '其他非流动金融资产', '其他流动资产']
    for col in prev_cols:
        df_sorted[f'prev_{col}'] = grouped[col].shift(1)
    
    # 计算当前年和前一年的总和
    current_sum = (
        df_sorted['交易性金融资产'] + 
        df_sorted['衍生金融资产'] + 
        df_sorted['债权投资'] + 
        df_sorted['其他债权投资'] + 
        df_sorted['其他权益工具投资'] + 
        df_sorted['其他非流动金融资产'] + 
        df_sorted['其他流动资产']
    )
    prev_sum = (
        df_sorted['prev_交易性金融资产'] + 
        df_sorted['prev_衍生金融资产'] + 
        df_sorted['prev_债权投资'] + 
        df_sorted['prev_其他债权投资'] + 
        df_sorted['prev_其他权益工具投资'] + 
        df_sorted['prev_其他非流动_金融资产'] +  # 注意列名是否正确，原数据中的列名可能不同
        df_sorted['prev_其他流动资产']
    )
    
    # 计算比例
    current_ratio = current_sum / df_sorted['总资产']
    prev_ratio = prev_sum / df_sorted['prev_总资产']
    
    # 检查前一年的数据是否存在
    has_prev_year = ~df_sorted['prev_总资产'].isna()
    
    condition_part2 = (current_ratio >= 0.5) & (prev_ratio >= 0.5) & has_prev_year
    
    # 将条件部分合并回原始df
    # 由于df_sorted的索引可能与原始df不同，需要将condition_part2合并回去
    # 这里假设df_sorted的索引是原始df的索引，或者需要重新索引
    # 这里可能需要更复杂的处理，例如将df_sorted的索引保存，然后合并回原始df
    # 但为了简化，假设排序后的df_sorted的索引与原始df相同，或者直接使用条件_part2的Series
    # 这里可能需要重新索引
    # 例如，将condition_part2的索引与原始df对齐
    condition_part2 = condition_part2.reindex(df.index, fill_value=False)
    
    # 3. 条件第三部分：现金分红
    condition_part3 = (
        ~df_sorted['是否实施现金分红'] | 
        (df_sorted['现金分红金额'] < df_sorted['净利润'] * 0.5)
    )
    condition_part3 = condition_part3.reindex(df.index, fill_value=False)
    
    # 综合条件
    valid_condition = (
        is_annual & 
        condition_part1 & 
        condition_part2 & 
        condition_part3
    )
    
    df['meu_14_1_condition'] = valid_condition
    
    # 处理约束部分
    constraint_description = ""结合前述财务报表列报项目的具体情况说明现金分红方案确定的依据及未来增强投资者回报的规划""
    mask = valid_condition & df['是否进行权益分派']
    df.loc[mask, 'meu_14_1_constraint'] = df.loc[mask, '权益分派方案文本'].apply(
        lambda text: llm_content_check(text, constraint_description) if pd.notnull(text) else False
    )
    
    # 计算合规性
    is_violation = df['meu_14_1_subject'] & df['meu_14_1_condition'] & (~df['meu_14_1_constraint'])
    df.loc[is_violation, 'meu_14_1_compliance'] = False
    
    return df

但这里可能存在几个问题：

1. 在计算prev_字段时，df_sorted是排序后的数据，但处理后的条件_part2需要与原始df的索引对齐。例如，如果原始df的索引不是连续的或排序后的顺序不同，那么condition_part2的索引可能与原始df不匹配，导致错误。因此，需要确保将条件_part2的索引与原始df对齐。

2. 列名是否正确，例如“其他非流动金融资产”是否与数据中的列名一致。根据提供的列，列名是“其他非流动金融资产”，所以在代码中应使用正确的列名。

3. 在计算prev_sum时，是否有拼写错误，例如prev_其他非流动_金融资产可能应为prev_其他非流动金融资产。

4. 在计算condition_part3时，是否使用了正确的列，例如是否实施现金分红是布尔列，现金分红金额是否正确。

此外，可能还需要处理财务数据日期是否为年报的问题，例如，是否只处理12月31日的数据。例如，is_annual的条件是否正确。

综上，可能需要调整代码中的列名和处理步骤，确保所有字段正确对应。

例如，在计算prev_sum时，正确的列名应为：

prev_其他非流动金融资产 = df_sorted['prev_其他非流动金融资产']

因此，在代码中：

prev_sum = (
    df_sorted['prev_交易性金融资产'] + 
    df_sorted['prev_衍生金融资产'] + 
    df_sorted['prev_债权投资'] + 
    df_sorted['prev_其他债权投资'] + 
    df_sorted['prev_其他权益工具投资'] + 
    df_sorted['prev_其他非流动金融资产'] + 
    df_sorted['prev_其他流动资产']
)

此外，在将condition_part2合并回原始df时，可能需要使用reindex或merge操作，以确保索引正确。例如，在排序后的df_sorted中处理完条件后，将结果合并回原始df：

# 在df_sorted中计算condition_part2
condition_part2 = (current_ratio >= 0.5) & (prev_ratio >= 0.5) & has_prev_year

# 将condition_part2保存到原始df中
df['condition_part2'] = condition_part2.reindex(df.index, fill_value=False)

但这种方法可能更可靠。

综上，最终的代码可能如下：
","CompletionUsage(completion_tokens=10263, prompt_tokens=2173, total_tokens=12436, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=None, audio_tokens=None, reasoning_tokens=9302, rejected_prediction_tokens=None), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0))"
